

# python
#Stable 13APR24

# Part 1


import pygame
import random
import math
import sys
import time
import pickle
import os
import datetime
import itertools
from itertools import permutations, product
from collections import Counter

# --- GADDAG Node Definition (Add this to Scrabble Game.py) ---
class GaddagNode:
    """Represents a node in the GADDAG."""
    __slots__ = ['children', 'is_terminal'] # Memory optimization

    def __init__(self):
        self.children = {}  # Dictionary mapping letter -> GaddagNode
        self.is_terminal = False # True if a path ending here is a valid word/subword

# --- GADDAG Class Definition (Add this to Scrabble Game.py) ---
class Gaddag:
    """
    Represents the GADDAG data structure.
    This class definition is needed to correctly unpickle the object.
    The actual building happens in gaddag_builder.py.
    """
    SEPARATOR = '>' # Special character used in GADDAG paths

    def __init__(self):
        # The root node will be populated when loading from pickle
        self.root = GaddagNode()

    # No insert method needed here, as we load a pre-built structure.

# Initialize Pygame
pygame.init()
main_called = False # Flag to track if main() has been entered

# Constants
GADDAG_STRUCTURE = None
GRID_SIZE = 15
SQUARE_SIZE = 40
BOARD_SIZE = GRID_SIZE * SQUARE_SIZE
FONT_SIZE = SQUARE_SIZE // 2
TILE_WIDTH = 35
TILE_HEIGHT = 35
TILE_GAP = 5
BUTTON_WIDTH = 100
BUTTON_HEIGHT = 30
BUTTON_GAP = 10
CENTER_SQUARE = (7, 7)
OPTIONS_WIDTH = 100
OPTIONS_HEIGHT = 30
DROPDOWN_HEIGHT = 90
OPTIONS_Y = BOARD_SIZE + 60  # Adjusted from +40 to align with shifted UI
DOUBLE_CLICK_TIME = 300
SECOND_CLICK_TIME = 500  # Time window for second click
ALL_WORDS_DIALOG_WIDTH = 750
ALL_WORDS_DIALOG_HEIGHT = 600
SCROLL_SPEED = 20

EXCHANGE_PREFERENCE_THRESHOLD = 5.0
LOW_SCORE_THRESHOLD = 10
POOL_QUALITY_FACTOR = 1.5
POOL_TILE_VALUES = {' ': 5, 'S': 3, 'Z': 1, 'X': 1, 'Q': -3, 'J': -2, 'V': -2, 'W': -2, 'U': -2, 'I': -1}

# Dialog dimensions for game over dialog
DIALOG_WIDTH = 480
DIALOG_HEIGHT = 250
LETTERS = "ABCDEFGHIJKLMNO"  # For column labels

# Get screen resolution
display_info = pygame.display.Info()
# Set window size to fit within screen resolution (with padding for borders)
WINDOW_WIDTH = min(1400, display_info.current_w - 50)  # 50 pixels padding
WINDOW_HEIGHT = min(900, display_info.current_h - 50)  # 50 pixels padding

# Colors
WHITE = (255, 255, 255)
BLACK = (0, 0, 0)
RED = (255, 100, 100)
PINK = (255, 182, 193)
BLUE = (0, 102, 204)  # Darkened from (173, 216, 230) for TL
LIGHT_BLUE = (135, 206, 250)
HIGHLIGHT_BLUE = (191, 238, 255)
YELLOW = (255, 255, 153)
GRAY = (200, 200, 200)
GREEN = (144, 238, 144)
DARK_GREEN = (100, 200, 100)
PALE_YELLOW = (255, 255, 200)
BUTTON_COLOR = (180, 180, 180)
BUTTON_HOVER = (220, 220, 220)
TURN_INDICATOR_COLOR = (255, 215, 0)
DIALOG_COLOR = (150, 150, 150)
DROPDOWN_COLOR = (200, 200, 200)
SELECTED_TILE_COLOR = (255, 165, 0)
GRAYED_OUT_COLOR = (100, 100, 100)
ARROW_COLOR = (0, 0, 255)
HINT_NORMAL_COLOR = (220, 220, 220)
HINT_SELECTED_COLOR = (180, 180, 255)

# Setup display and font
screen = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))
pygame.display.set_caption("Scrabble Game")
font = pygame.font.SysFont("Arial", FONT_SIZE, bold=True)
ui_font = pygame.font.SysFont("Arial", 20)
button_font = pygame.font.SysFont("Arial", 16)
tile_count_font = pygame.font.SysFont("Arial", 14)
dialog_font = pygame.font.SysFont("Arial", 24)

# Tile bag and values (moved up to be defined before trie)
TILE_DISTRIBUTION = {
    'A': (9, 1), 'B': (2, 3), 'C': (2, 3), 'D': (4, 2), 'E': (12, 1), 'F': (2, 4),
    'G': (3, 2), 'H': (2, 4), 'I': (9, 1), 'J': (1, 8), 'K': (1, 5), 'L': (4, 1),
    'M': (2, 3), 'N': (6, 1), 'O': (8, 1), 'P': (2, 3), 'Q': (1, 10), 'R': (6, 1),
    'S': (4, 1), 'T': (6, 1), 'U': (4, 1), 'V': (2, 4), 'W': (2, 4), 'X': (1, 8),
    'Y': (2, 4), 'Z': (1, 10), ' ': (2, 0)
}
# Global bag - initialized properly in main() or practice setup
bag = []

POWER_TILES = {'J', 'Q', 'X', 'Z'}

# Global game state variables (will be initialized/reset in main)
board = None
tiles = None
racks = None
blanks = None
scores = None
turn = 1
first_play = True
game_mode = None
is_ai = None
practice_mode = None # Added to track practice modes like "eight_letter", "power_tiles"
move_history = []
replay_mode = False
current_replay_turn = 0
last_word = ""
last_score = 0
last_start = None
last_direction = None

def draw_checkbox(screen, x, y, checked):
    pygame.draw.rect(screen, BLACK, (x, y, 20, 20), 1)
    if checked:
        pygame.draw.line(screen, BLACK, (x+2, y+2), (x+18, y+18), 2)
        pygame.draw.line(screen, BLACK, (x+18, y+2), (x+2, y+18), 2)


# --- GCG Handling ---
def save_game_to_gcg(player_names, move_history, initial_racks, final_scores):
    """Save the game to GCG format using move_history directly."""
    gcg_lines = [
        "#",
        f"#player1 {player_names[0]}",
        f"#player2 {player_names[1]}"
    ]
    cumulative_scores = [0, 0]

    for move in move_history:
        player = move['player'] - 1  # 0-based index
        rack = ''.join(sorted(tile if tile != ' ' else '?' for tile in move['rack']))

        if move['move_type'] == 'place':
            # Use the stored full word with blanks
            word_with_blanks = move.get('word_with_blanks', move.get('word','').upper()) # Use getter for safety
            score = move['score']
            cumulative_scores[player] += score
            gcg_lines.append(
                f">{player_names[player]}: {rack} {move['coord']} {word_with_blanks} +{score} {cumulative_scores[player]}"
            )
        elif move['move_type'] == 'exchange':
            exchanged = ''.join(sorted(tile if tile != ' ' else '?' for tile in move.get('exchanged_tiles',[]))) # Use getter
            gcg_lines.append(
                f">{player_names[player]}: {rack} ({exchanged}) +0 {cumulative_scores[player]}"
            )
        elif move['move_type'] == 'pass':
            gcg_lines.append(
                f">{player_names[player]}: {rack} -- +0 {cumulative_scores[player]}"
            )

    gcg_lines.append(f"Final score: {player_names[0]} {final_scores[0]}, {player_names[1]} {final_scores[1]}")

    return '\n'.join(gcg_lines)



def load_game_from_gcg(filename):
    """Load a game from a GCG file, returning data to enter replay mode."""
    move_history = []
    player_names = ["Player1", "Player2"]
    final_scores = [0, 0]
    line_num = 0

    try:
        with open(filename, "r") as f:
            for line in f:
                line_num += 1
                line = line.strip()
                if not line or line.startswith("#"): # Skip empty/comments
                    if line.startswith("#player1"):
                        try: player_names[0] = line.split(maxsplit=1)[1]
                        except IndexError: print(f"GCG Load Warning (Line {line_num}): Malformed #player1 line.")
                    elif line.startswith("#player2"):
                        try: player_names[1] = line.split(maxsplit=1)[1]
                        except IndexError: print(f"GCG Load Warning (Line {line_num}): Malformed #player2 line.")
                    continue

                if line.startswith("Final score:"):
                    try:
                        parts = line.split();
                        if len(parts) >= 6: final_scores[0] = int(parts[3].strip(',')); final_scores[1] = int(parts[5])
                        else: raise ValueError("Incorrect number of parts for Final score line")
                    except (IndexError, ValueError) as e: print(f"GCG Load Warning (Line {line_num}): Error parsing final score line: {e}")
                    continue

                if line.startswith(">"):
                    try:
                        parts = line.split() # Split by whitespace
                        if len(parts) < 5: # Minimum parts: >Name: Rack -- +Score CumScore
                            raise ValueError(f"Insufficient parts on move line ({len(parts)})")

                        # --- Robust Parsing Logic ---
                        # 1. Identify parts from the end
                        cumulative_score_str = parts[-1]
                        score_str = parts[-2]
                        # Part before score could be Word, (Exchange), or --
                        third_last_part = parts[-3]

                        # 2. Safely parse scores first
                        try: score = int(score_str[1:]) # Remove initial '+' or '-'
                        except (ValueError, IndexError): raise ValueError(f"Invalid score format '{score_str}'")
                        try: cumulative_score = int(cumulative_score_str)
                        except ValueError: raise ValueError(f"Invalid cumulative score format '{cumulative_score_str}'")

                        # 3. Determine Move Type based on third_last_part
                        move_type = None
                        player_name_parts = []
                        rack_str = ""
                        exchanged_list = []
                        position_str = ""
                        word_played_gcg = ""

                        if third_last_part == "--": # Pass
                            move_type = 'pass'
                            # Structure: > Name(s) : Rack -- +Score CumScore
                            if len(parts) < 5: raise ValueError("Incorrect part count for Pass")
                            rack_str = parts[-4] # Part before -- is Rack
                            player_name_parts = parts[:-4] # All parts before Rack
                        elif third_last_part.startswith("(") and third_last_part.endswith(")"): # Exchange
                            move_type = 'exchange'
                            # Structure: > Name(s) : Rack (Exch) +Score CumScore
                            if len(parts) < 5: raise ValueError("Incorrect part count for Exchange")
                            rack_str = parts[-4] # Part before (Exch) is Rack
                            player_name_parts = parts[:-4] # All parts before Rack
                            exchanged_gcg = third_last_part[1:-1]
                            exchanged_list = [(' ' if char == '?' else char.upper()) for char in exchanged_gcg]
                        else: # Place
                            move_type = 'place'
                            # Structure: > Name(s) : Rack Coord Word +Score CumScore
                            if len(parts) < 6: raise ValueError("Incorrect part count for Place")
                            word_played_gcg = third_last_part # Part before score is Word
                            position_str = parts[-4] # Part before Word is Coord
                            rack_str = parts[-5] # Part before Coord is Rack
                            player_name_parts = parts[:-5] # All parts before Rack

                        # 4. Reconstruct Player Name
                        if not player_name_parts or not player_name_parts[0].startswith(">") or not player_name_parts[-1].endswith(":"):
                            raise ValueError(f"Could not reconstruct player name from parts: {player_name_parts}")
                        player_name_full = " ".join(player_name_parts)
                        player_name = player_name_full[1:-1] # Remove '>' and ':'
                        player = 1 if player_name == player_names[0] else 2
                        # --- End Robust Parsing Logic ---

                        # Append to move_history based on type
                        if move_type == 'pass':
                            move_history.append({
                                'player': player, 'move_type': 'pass', 'score': score,
                                'word': '', 'coord': ''
                            })
                        elif move_type == 'exchange':
                            move_history.append({
                                'player': player, 'move_type': 'exchange', 'exchanged_tiles': exchanged_list,
                                'score': score, 'word': '', 'coord': ''
                            })
                        elif move_type == 'place':
                            # Parse coordinate
                            coord_parse_result = parse_coord(position_str)
                            if coord_parse_result is None or coord_parse_result[0] is None:
                                raise ValueError(f"Invalid coordinate format '{position_str}'")
                            (row, col), direction = coord_parse_result

                            # Reconstruct positions and blanks from the GCG word
                            positions = []; blanks = set()
                            current_r_gcg, current_c_gcg = row, col
                            for i, letter_gcg in enumerate(word_played_gcg):
                                r_place = current_r_gcg if direction == "right" else current_r_gcg + i
                                c_place = current_c_gcg + i if direction == "right" else current_c_gcg
                                if not (0 <= r_place < GRID_SIZE and 0 <= c_place < GRID_SIZE):
                                    raise ValueError(f"Word placement out of bounds: '{word_played_gcg}' at {position_str}")
                                letter_upper = letter_gcg.upper()
                                positions.append((r_place, c_place, letter_upper))
                                if letter_gcg.islower(): blanks.add((r_place, c_place))

                            move_history.append({
                                'player': player, 'move_type': 'place', 'positions': positions,
                                'blanks': blanks, 'score': score, 'word': word_played_gcg.upper(),
                                'start': (row, col), 'direction': direction, 'coord': position_str
                            })

                    except Exception as e:
                        print(f"GCG Load Error (Line {line_num}): Failed to parse move line.")
                        print(f"  Line content: '{line}'")
                        print(f"  Error details: {type(e).__name__}: {e}")
                        raise ValueError(f"Error parsing GCG line {line_num}: {e}") from e

                else:
                    print(f"GCG Load Warning (Line {line_num}): Skipping unrecognized line format: '{line}'")

    except FileNotFoundError:
        print(f"GCG Load Error: File not found '{filename}'")
        raise
    except Exception as e:
        print(f"GCG Load Error: An unexpected error occurred reading file '{filename}' near line {line_num}.")
        print(f"  Error details: {type(e).__name__}: {e}")
        raise

    return player_names, move_history, final_scores



# New helper function to create a standard Scrabble bag
def create_standard_bag():
    """Creates and returns a standard Scrabble tile bag list."""
    bag = [letter for letter, (count, _) in TILE_DISTRIBUTION.items() for _ in range(count)]
    return bag

# New function to simulate game state for replay from GCG history
def simulate_game_up_to(target_turn_idx, move_history_loaded, initial_shuffled_bag):
    """
    Simulates a game turn-by-turn up to a target index using loaded move history
    (which lacks 'drawn' info) and an initial shuffled bag state. Handles initial draws.

    Args:
        target_turn_idx (int): The 0-based index of the turn *after* which the state is needed
                               (e.g., 0 for initial state, 1 for state after move 0).
        move_history_loaded (list): The move history loaded from GCG (lacks 'drawn').
        initial_shuffled_bag (list): A list representing the shuffled bag at the very start of the game.

    Returns:
        tuple: (tiles_state, blanks_state, scores_state, racks_state) representing the
               game state after target_turn_idx-1 moves have been applied.
               Racks are sorted alphabetically before returning for display.
    """
    # Initialize game state variables
    tiles_state = [['' for _ in range(GRID_SIZE)] for _ in range(GRID_SIZE)]
    blanks_state = set()
    scores_state = [0, 0]
    racks_state = [[], []]
    # IMPORTANT: Use a copy of the initial bag for the simulation run to avoid modifying the original
    bag_state = initial_shuffled_bag[:]

    # --- Simulate Drawing Initial Racks ---
    # GCG doesn't store initial racks, so simulate drawing them from the shuffled bag.
    try:
        for _ in range(7):
            if bag_state: racks_state[0].append(bag_state.pop())
            else: raise IndexError("Bag empty during initial draw for P1")
        for _ in range(7):
            if bag_state: racks_state[1].append(bag_state.pop())
            else: raise IndexError("Bag empty during initial draw for P2")
    except IndexError as e:
        print(f"Replay Simulation Error: {e}")
        # Return initial empty state as fallback if bag runs out unexpectedly
        return tiles_state, blanks_state, scores_state, racks_state

    # Apply moves sequentially up to the target turn index (0 to target_turn_idx-1)
    for i in range(target_turn_idx):
        if i >= len(move_history_loaded):
            # Target turn index is beyond the loaded history length
            print(f"Replay Sim Info: Reached end of available history at move index {i} before target index {target_turn_idx}.")
            break

        move = move_history_loaded[i]
        player_idx = move.get('player')
        if player_idx not in [1, 2]:
            print(f"Replay Sim Warning: Invalid player index {player_idx} in loaded move {i}. Skipping move.")
            continue
        player_idx -= 1 # Convert to 0-based index

        # Get a copy of the current rack state for modification
        rack_after_move = racks_state[player_idx][:]

        tiles_removed_count = 0 # Track tiles removed in this turn to know how many to draw

        move_type = move.get('move_type')

        if move_type == 'place':
            # Retrieve necessary info from the loaded move dictionary
            positions = move.get('positions', []) # These are the primary word tiles from GCG
            blanks_in_move = move.get('blanks', set()) # Blanks placed in *this* specific move

            # Identify newly placed tiles on the board based on GCG positions vs current board state
            for r, c, letter in positions:
                 # Check if the square was empty *before* this simulated move
                 is_newly_placed_sim = (0 <= r < GRID_SIZE and 0 <= c < GRID_SIZE and not tiles_state[r][c])

                 # Place tile on simulated board state
                 if 0 <= r < GRID_SIZE and 0 <= c < GRID_SIZE:
                     tiles_state[r][c] = letter
                     if (r, c) in blanks_in_move:
                         blanks_state.add((r, c))
                 else:
                     # Log warning but continue simulation if possible
                     print(f"Replay Sim Warning: Invalid position ({r},{c}) in loaded move {i}")
                     continue

                 # If it was newly placed in this simulation step, remove from simulated rack
                 if is_newly_placed_sim:
                     tiles_removed_count += 1
                     if (r,c) in blanks_in_move: # If this placement used a blank
                         if ' ' in rack_after_move:
                             rack_after_move.remove(' ')
                         else:
                             # Log warning if blank wasn't found (state inconsistency)
                             print(f"Replay Sim Warning: Tried to remove blank from simulated rack for move {i} ({r},{c}), but not found.")
                     else: # If this placement used a regular tile
                         if letter in rack_after_move:
                             rack_after_move.remove(letter)
                         else:
                             # Log warning if tile wasn't found (state inconsistency)
                             print(f"Replay Sim Warning: Tried to remove tile '{letter}' from simulated rack for move {i} ({r},{c}), but not found.")

            # Update score based on the score recorded in the GCG move
            scores_state[player_idx] += move.get('score', 0)

        elif move_type == 'exchange':
            exchanged_gcg = move.get('exchanged_tiles', []) # Tiles recorded in GCG (using '?')
            for tile_gcg in exchanged_gcg:
                 if tile_gcg == '?': # GCG standard for blank
                      tile_to_remove = ' '
                 else:
                      tile_to_remove = tile_gcg.upper() # Ensure consistency

                 if tile_to_remove in rack_after_move:
                      rack_after_move.remove(tile_to_remove)
                      tiles_removed_count += 1
                 else:
                      # Log warning if tile/blank wasn't found (state inconsistency)
                      print(f"Replay Sim Warning: Tried to remove exchanged GCG tile '{tile_gcg}' (as '{tile_to_remove}') from simulated rack for move {i}, but not found.")
            # Score doesn't change for exchange

        elif move_type == 'pass':
            # No change to board, score, or rack content needed for simulation state
            tiles_removed_count = 0
            # Score doesn't change for pass

        else:
             print(f"Replay Sim Warning: Unknown move_type '{move_type}' in loaded move {i}. Skipping state update for move.")
             continue # Skip draw calculation if move type is unknown

        # --- Simulate Drawing New Tiles ---
        # Draw tiles from the simulated bag based on how many were removed/exchanged
        num_to_draw = tiles_removed_count
        drawn_simulated = []
        for _ in range(num_to_draw):
             if bag_state: # Check if bag is not empty
                 drawn_simulated.append(bag_state.pop())
             else:
                 # Bag ran out during simulated draw
                 print(f"Replay Sim Info: Simulated bag ran out while drawing for move {i}.")
                 break # Stop drawing if bag runs out
        rack_after_move.extend(drawn_simulated) # Add the simulated drawn tiles
        racks_state[player_idx] = rack_after_move # Update the persistent rack state

    # Sort final racks alphabetically before returning for display consistency
    for rack in racks_state:
        rack.sort()

    # Return the simulated state *after* target_turn_idx-1 moves have been applied
    return tiles_state, blanks_state, scores_state, racks_state


# --- Trie/DAWG Setup ---
class TrieNode: # Keeping simple Trie for now, can replace with minimized DAWG later
    def __init__(self):
        self.children = {}
        self.is_end = False

class Dawg: # Renaming our existing Trie to Dawg for conceptual clarity
    def __init__(self):
        self.root = TrieNode()

    def insert(self, word):
        node = self.root
        for char in word:
            if char not in node.children:
                node.children[char] = TrieNode()
            node = node.children[char]
        node.is_end = True

    def search(self, word):
        """Check if a word exists in the DAWG."""
        node = self.root
        for char in word:
            if char not in node.children:
                return False
            node = node.children[char]
        return node.is_end

# Load the DAWG with words from "All Words 2023.txt"
DAWG = Dawg()
try:
    # Ensure the path is correct or adjust as needed
    with open("All Words 2023.txt", "r") as f:
        for word in (w.strip().upper() for w in f):
            if len(word) > 1: # Optionally filter out single-letter words if not needed
                DAWG.insert(word)
    print("DAWG loaded successfully.")
except FileNotFoundError:
    print("Error: 'All Words 2023.txt' not found. Word validation will not work.")


# --- Mode Selection Constants ---
MODE_HVH = "Human vs Human"
MODE_HVA = "Human vs AI"
MODE_AVA = "AI vs AI"

# --- Replay Button Positions ---
REPLAY_BUTTON_Y = OPTIONS_Y + OPTIONS_HEIGHT + 10
REPLAY_BUTTON_WIDTH = 50
REPLAY_BUTTON_HEIGHT = 30
REPLAY_BUTTON_GAP = 10
replay_start_rect = pygame.Rect(10, REPLAY_BUTTON_Y, REPLAY_BUTTON_WIDTH, REPLAY_BUTTON_HEIGHT)
replay_prev_rect = pygame.Rect(10 + REPLAY_BUTTON_WIDTH + REPLAY_BUTTON_GAP, REPLAY_BUTTON_Y, REPLAY_BUTTON_WIDTH, REPLAY_BUTTON_HEIGHT)
replay_next_rect = pygame.Rect(10 + 2 * (REPLAY_BUTTON_WIDTH + REPLAY_BUTTON_GAP), REPLAY_BUTTON_Y, REPLAY_BUTTON_WIDTH, REPLAY_BUTTON_HEIGHT)
replay_end_rect = pygame.Rect(10 + 3 * (REPLAY_BUTTON_WIDTH + REPLAY_BUTTON_GAP), REPLAY_BUTTON_Y, REPLAY_BUTTON_WIDTH, REPLAY_BUTTON_HEIGHT)


# --- Coordinate Handling ---
def get_coord(start, direction):
    row, col = start
    if direction == "right":
        return f"{row + 1}{LETTERS[col]}"
    else:  # "down"
        return f"{LETTERS[col]}{row + 1}"

def parse_coord(coord):
    """Parse a GCG coordinate (e.g., '8H' or 'H8') into (row, col) and direction."""
    if not coord: return None, None # Handle empty coord
    if coord[0].isalpha():  # Vertical: e.g., H8 or H10
        col_char = coord[0]
        row_str = coord[1:]
        if col_char not in LETTERS or not row_str.isdigit(): return None, None
        col = LETTERS.index(col_char)
        row = int(row_str) - 1
        direction = "down"
    else:  # Horizontal: e.g., 8H or 10A
        i = 0
        while i < len(coord) and coord[i].isdigit(): i += 1
        row_str = coord[:i]
        col_char = coord[i:]
        if not row_str.isdigit() or len(col_char) != 1 or col_char not in LETTERS: return None, None
        row = int(row_str) - 1
        col = LETTERS.index(col_char)
        direction = "right"

    if not (0 <= row < GRID_SIZE and 0 <= col < GRID_SIZE): return None, None # Bounds check
    return (row, col), direction

# --- Board Creation ---
def create_board():
    """Initialize the Scrabble board with special squares and labels."""
    board = [[WHITE for _ in range(GRID_SIZE)] for _ in range(GRID_SIZE)]
    labels = [['' for _ in range(GRID_SIZE)] for _ in range(GRID_SIZE)]
    tiles = [['' for _ in range(GRID_SIZE)] for _ in range(GRID_SIZE)]

    tw = [(0, 0), (0, 7), (0, 14), (7, 0), (7, 14), (14, 0), (14, 7), (14, 14)]
    dw = [(1, 1), (2, 2), (3, 3), (4, 4), (10, 10), (11, 11), (12, 12), (13, 13),
          (1, 13), (2, 12), (3, 11), (4, 10), (10, 4), (11, 3), (12, 2), (13, 1)]
    tl = [(1, 5), (1, 9), (5, 1), (5, 5), (5, 9), (5, 13), (9, 1), (9, 5),
          (9, 9), (9, 13), (13, 5), (13, 9)]
    dl = [(0, 3), (0, 11), (2, 6), (2, 8), (3, 0), (3, 7), (3, 14), (6, 2),
          (6, 6), (6, 8), (6, 12), (7, 3), (7, 11), (8, 2), (8, 6), (8, 8),
          (8, 12), (11, 0), (11, 7), (11, 14), (12, 6), (12, 8), (14, 3), (14, 11)]

    for r, c in tw: board[r][c] = RED
    for r, c in dw: board[r][c] = PINK
    for r, c in tl: board[r][c] = BLUE
    for r, c in dl: board[r][c] = LIGHT_BLUE
    board[7][7] = PINK # Center square

    return board, labels, tiles

# --- Drawing Functions ---
def draw_rack(player, rack, scores, turn, player_names, dragged_tile=None, drag_pos=None, display_scores=None):
    """Draw a player's rack with tiles, scores, and buttons."""
    global practice_mode # Access global practice_mode
    if not rack: return None, None
    if display_scores is None: display_scores = scores
    if practice_mode == "eight_letter" and player == 2: return None, None # Don't draw P2 rack

    rack_width = 7 * (TILE_WIDTH + TILE_GAP) - TILE_GAP
    # Calculate the rightmost extent of the replay buttons area
    # Replay buttons start at x=10, width=50, gap=10. 4 buttons total.
    replay_area_end_x = 10 + 4 * (REPLAY_BUTTON_WIDTH + REPLAY_BUTTON_GAP) # 10 + 4*(50+10) = 250
    # Minimum start x for the rack, considering replay buttons and star indicator offset (star is at start_x - 20)
    min_rack_start_x = replay_area_end_x + BUTTON_GAP + 20 # 250 + 10 + 20 = 280
    # Try to center the rack, but ensure it starts after the minimum x to avoid overlap
    start_x = max(min_rack_start_x, (BOARD_SIZE - rack_width) // 2)

    rack_y = BOARD_SIZE + 80 if player == 1 else BOARD_SIZE + 150

    if turn == player and (practice_mode != "eight_letter" or player == 1): # Draw turn indicator
        # Star indicator position depends on the calculated start_x
        center_x = start_x - 20; center_y = rack_y + TILE_HEIGHT // 2; radius = 10; points = []
        for i in range(10): angle = i * math.pi / 5; r = radius if i % 2 == 0 else radius / 2; x = center_x + r * math.cos(angle); y = center_y + r * math.sin(angle); points.append((x, y))
        pygame.draw.polygon(screen, TURN_INDICATOR_COLOR, points)

    for i, tile in enumerate(rack): # Draw tiles
        tile_x = start_x + i * (TILE_WIDTH + TILE_GAP)
        if dragged_tile == (player, i) and drag_pos: continue
        if tile == ' ':
            center = (tile_x + TILE_WIDTH // 2, rack_y + TILE_HEIGHT // 2); radius = TILE_WIDTH // 2 - 2
            pygame.draw.circle(screen, BLACK, center, radius); text = font.render('?', True, WHITE)
            text_rect = text.get_rect(center=center); screen.blit(text, text_rect)
        else:
            pygame.draw.rect(screen, GREEN, (tile_x, rack_y, TILE_WIDTH, TILE_HEIGHT)); text = font.render(tile, True, BLACK)
            screen.blit(text, (tile_x + 5, rack_y + 5))

    if dragged_tile and dragged_tile[0] == player and drag_pos: # Draw dragged tile
        tile_x, tile_y = drag_pos
        if 0 <= dragged_tile[1] < len(rack):
            tile = rack[dragged_tile[1]]
            if tile == ' ':
                center = (tile_x, tile_y); radius = TILE_WIDTH // 2 - 2; pygame.draw.circle(screen, BLACK, center, radius)
                text = font.render('?', True, WHITE); text_rect = text.get_rect(center=center); screen.blit(text, text_rect)
            else:
                pygame.draw.rect(screen, GREEN, (tile_x - TILE_WIDTH // 2, tile_y - TILE_HEIGHT // 2, TILE_WIDTH, TILE_HEIGHT))
                text = font.render(tile, True, BLACK); screen.blit(text, (tile_x - TILE_WIDTH // 2 + 5, tile_y - TILE_HEIGHT // 2 + 5))

    button_x = start_x + rack_width + BUTTON_GAP # Draw buttons
    alpha_button_rect = pygame.draw.rect(screen, BUTTON_COLOR, (button_x, rack_y, BUTTON_WIDTH, BUTTON_HEIGHT))
    rand_button_rect = pygame.draw.rect(screen, BUTTON_COLOR, (button_x + BUTTON_WIDTH + BUTTON_GAP, rack_y, BUTTON_WIDTH, BUTTON_HEIGHT))
    alpha_text = button_font.render("Alphabetize", True, BLACK); alpha_rect = alpha_text.get_rect(center=alpha_button_rect.center); screen.blit(alpha_text, alpha_rect)
    rand_text = button_font.render("Randomize", True, BLACK); rand_rect = rand_text.get_rect(center=rand_button_rect.center); screen.blit(rand_text, rand_rect)

    player_idx = player - 1 # Draw score
    if 0 <= player_idx < len(player_names) and 0 <= player_idx < len(display_scores):
        player_name_display = player_names[player_idx] if player_names[player_idx] else f"Player {player}"
        score_text = ui_font.render(f"{player_name_display} Score: {display_scores[player_idx]}", True, BLACK)
        screen.blit(score_text, (start_x, rack_y - 20))
    else: print(f"Warning: Invalid player index {player} for score display.")
    return alpha_button_rect, rand_button_rect

def draw_replay_icon(screen, rect, icon_type):
    """Draw centered replay control icons (arrows) on the buttons."""
    center_x, center_y = rect.center; arrow_size = 8
    if icon_type == "start": pygame.draw.polygon(screen, BLACK, [(center_x + 6, center_y - arrow_size), (center_x - 2, center_y), (center_x + 6, center_y + arrow_size)]); pygame.draw.polygon(screen, BLACK, [(center_x - 2, center_y - arrow_size), (center_x - 10, center_y), (center_x - 2, center_y + arrow_size)])
    elif icon_type == "prev": pygame.draw.polygon(screen, BLACK, [(center_x + 6, center_y - arrow_size), (center_x - 6, center_y), (center_x + 6, center_y + arrow_size)])
    elif icon_type == "next": pygame.draw.polygon(screen, BLACK, [(center_x - 6, center_y - arrow_size), (center_x + 6, center_y), (center_x - 6, center_y + arrow_size)])
    elif icon_type == "end": pygame.draw.polygon(screen, BLACK, [(center_x - 6, center_y - arrow_size), (center_x + 2, center_y), (center_x - 6, center_y + arrow_size)]); pygame.draw.polygon(screen, BLACK, [(center_x + 2, center_y - arrow_size), (center_x + 10, center_y), (center_x + 2, center_y + arrow_size)])

def draw_scoreboard(screen, move_history, scroll_offset, scores, is_ai, final_scores=None, game_over_state=False):
    """Draws the scrollable scoreboard."""
    scoreboard_x = BOARD_SIZE + 275; scoreboard_y = 40; scoreboard_width = max(200, WINDOW_WIDTH - BOARD_SIZE - 20); scoreboard_height = WINDOW_HEIGHT - 80
    if scoreboard_x + scoreboard_width > WINDOW_WIDTH - 10: scoreboard_width = WINDOW_WIDTH - scoreboard_x - 10
    if scoreboard_width < 200: scoreboard_x = WINDOW_WIDTH - 210; scoreboard_width = 200
    scoreboard_surface = pygame.Surface((scoreboard_width, scoreboard_height)); scoreboard_surface.fill(WHITE)
    running_scores = [0, 0]; y_pos = 10 - scroll_offset
    for i, move in enumerate(move_history):
        player_idx = move['player'] - 1; running_scores[player_idx] += move['score']
        player_label = "AI" if 0 <= player_idx < len(is_ai) and is_ai[player_idx] else f"P{move['player']}"
        display_score = running_scores[player_idx]
        if move['move_type'] == 'place': word = move.get('word', 'N/A'); coord = move.get('coord', 'N/A'); text = f"{i+1}: {player_label} - {word} at {coord} (+{move['score']}) Total: {display_score}"
        elif move['move_type'] == 'pass': text = f"{i+1}: {player_label} - Pass (+0) Total: {display_score}"
        elif move['move_type'] == 'exchange': text = f"{i+1}: {player_label} - Exchange (+0) Total: {display_score}"
        else: text = f"{i+1}: {player_label} - Unknown Move Type"
        text_surface = ui_font.render(text, True, BLACK)
        if y_pos < scoreboard_height and y_pos + 20 > 0:
            if (i // 2) % 2 == 0: rect_width = 10 + text_surface.get_width() + 10; highlight_rect = pygame.Rect(0, y_pos, rect_width, 20); pygame.draw.rect(scoreboard_surface, HIGHLIGHT_BLUE, highlight_rect)
            scoreboard_surface.blit(text_surface, (10, y_pos))
        y_pos += 20
    if game_over_state and final_scores is not None:
        y_pos += 20; final_text = f"Final Scores: P1: {final_scores[0]}, P2: {final_scores[1]}"; final_surface = ui_font.render(final_text, True, BLACK)
        if y_pos < scoreboard_height and y_pos + 20 > 0: scoreboard_surface.blit(final_surface, (10, y_pos))
    screen.blit(scoreboard_surface, (scoreboard_x, scoreboard_y))

# End of Part 1 (Includes basic drawing functions)

# Part 2 (Includes word finding, scoring, practice setup, mode selection, options menu)
# find_main_word, find_cross_word, find_all_words_formed (Unchanged from Part 2 provided previously)
def find_main_word(new_tiles, tiles):
    """Finds the primary word formed by newly placed tiles."""
    if not new_tiles: return [], None
    rows = set(r for r, c, _ in new_tiles); cols = set(c for r, c, _ in new_tiles)
    if len(rows) == 1: # Potential horizontal word
        orientation = "horizontal"; row = rows.pop(); min_col = min(c for r, c, _ in new_tiles if r == row); max_col = max(c for r, c, _ in new_tiles if r == row)
        while min_col > 0 and tiles[row][min_col - 1]: min_col -= 1
        while max_col < GRID_SIZE - 1 and tiles[row][max_col + 1]: max_col += 1
        main_word = [(row, c, tiles[row][c]) for c in range(min_col, max_col + 1) if tiles[row][c]]
        return (main_word, orientation) if len(main_word) > 1 else ([], None)
    elif len(cols) == 1: # Potential vertical word
        orientation = "vertical"; col = cols.pop(); min_row = min(r for r, c, _ in new_tiles if c == col); max_row = max(r for r, c, _ in new_tiles if c == col)
        while min_row > 0 and tiles[min_row - 1][col]: min_row -= 1
        while max_row < GRID_SIZE - 1 and tiles[max_row + 1][col]: max_row += 1
        main_word = [(r, col, tiles[r][col]) for r in range(min_row, max_row + 1) if tiles[r][col]]
        return (main_word, orientation) if len(main_word) > 1 else ([], None)
    else: return [], None

def find_cross_word(tile, tiles, main_orientation):
    """Finds a cross word formed by a single tile perpendicular to the main word."""
    r, c, _ = tile; cross_word = []
    if main_orientation == "horizontal": # Check vertically
        min_row = r;
        while min_row > 0 and tiles[min_row - 1][c]: min_row -= 1
        max_row = r;
        while max_row < GRID_SIZE - 1 and tiles[max_row + 1][c]: max_row += 1
        if max_row > min_row: cross_word = [(rr, c, tiles[rr][c]) for rr in range(min_row, max_row + 1) if tiles[rr][c]]
    elif main_orientation == "vertical": # Check horizontally
        min_col = c;
        while min_col > 0 and tiles[r][min_col - 1]: min_col -= 1
        max_col = c;
        while max_col < GRID_SIZE - 1 and tiles[r][max_col + 1]: max_col += 1
        if max_col > min_col: cross_word = [(r, cc, tiles[r][cc]) for cc in range(min_col, max_col + 1) if tiles[r][cc]]
    return cross_word if len(cross_word) > 1 else []

def find_all_words_formed(new_tiles, tiles):
    """Finds all words (main and cross) formed by a play."""
    words = [];
    if not new_tiles: return words
    new_positions_set = set((r, c) for r, c, _ in new_tiles)
    main_word_tiles, orientation = find_main_word(new_tiles, tiles)
    if main_word_tiles:
        words.append(main_word_tiles)
        for tile in new_tiles:
            if (tile[0], tile[1]) in new_positions_set:
                cross_word = find_cross_word(tile, tiles, orientation)
                if cross_word: words.append(cross_word)
    elif len(new_tiles) == 1: # Single tile placement check
        tile = new_tiles[0]
        cross_h = find_cross_word(tile, tiles, "vertical");   # Check H
        if cross_h: words.append(cross_h)
        cross_v = find_cross_word(tile, tiles, "horizontal"); # Check V
        if cross_v: words.append(cross_v)
    unique_word_tile_lists = []; seen_signatures = set()
    for word_tile_list in words:
        signature = tuple(sorted((r, c, l) for r, c, l in word_tile_list))
        if signature not in seen_signatures: unique_word_tile_lists.append(word_tile_list); seen_signatures.add(signature)
    return unique_word_tile_lists

# calculate_score (Unchanged from Part 2 provided previously)
def calculate_score(new_tiles, board, tiles, blanks):
    """Calculates the score for a play based on newly placed tiles."""
    total_score = 0; new_positions = set((r, c) for r, c, _ in new_tiles)
    words_formed_details = find_all_words_formed(new_tiles, tiles)
    for word_tiles in words_formed_details:
        word_score = 0; word_multiplier = 1
        for r, c, letter in word_tiles:
            if letter not in TILE_DISTRIBUTION: print(f"Warning: Invalid letter '{letter}' found in word during scoring at ({r},{c}). Skipping."); continue
            is_blank = (r, c) in blanks; letter_value = 0 if is_blank else TILE_DISTRIBUTION[letter][1]; letter_multiplier = 1
            if (r, c) in new_positions:
                square_color = board[r][c]
                if square_color == LIGHT_BLUE: letter_multiplier = 2 # DL
                elif square_color == BLUE: letter_multiplier = 3 # TL
                elif square_color == PINK: word_multiplier *= 2 # DW (Center is also Pink)
                elif square_color == RED: word_multiplier *= 3 # TW
            word_score += letter_value * letter_multiplier
        total_score += word_score * word_multiplier
    if len(new_tiles) == 7: total_score += 50 # Bingo bonus
    return total_score

# select_seven_letter_word, eight_letter_practice, mode_selection_screen, draw_options_menu (Unchanged from Part 2 provided previously)
def select_seven_letter_word(removed_letter, seven_letter_words):
    """Selects a random 7-letter word containing the removed letter."""
    candidates = [word for word in seven_letter_words if removed_letter in word]
    if not candidates: print(f"Warning: No 7-letter words contain '{removed_letter}'. Choosing random 7-letter word."); return random.choice(seven_letter_words) if seven_letter_words else None
    return random.choice(candidates)

def eight_letter_practice():
    """Handles the setup dialog and initialization for 8-Letter Bingo practice."""
    try:
        with open("7-letter-list.txt", "r") as seven_file, open("8-letter-list.txt", "r") as eight_file:
            seven_letter_words = [line.strip().upper() for line in seven_file.readlines()]; eight_letter_words = [line.strip().upper() for line in eight_file.readlines()]
    except FileNotFoundError: print("Error: Could not find 7-letter-list.txt or 8-letter-list.txt"); return False, None, None, None, None, None
    if not seven_letter_words or not eight_letter_words: print("Error: Word list files are empty."); return False, None, None, None, None, None
    dialog_width, dialog_height = 300, 150; dialog_x = (WINDOW_WIDTH - dialog_width) // 2; dialog_y = (WINDOW_HEIGHT - dialog_height) // 2
    proceed = False; text_box_active = False; probability_input = ""
    while True: # Dialog loop
        screen.fill(WHITE); pygame.draw.rect(screen, DIALOG_COLOR, (dialog_x, dialog_y, dialog_width, dialog_height)); pygame.draw.rect(screen, BLACK, (dialog_x, dialog_y, dialog_width, dialog_height), 2)
        title_text = dialog_font.render("8-Letter Bingo Options", True, BLACK); screen.blit(title_text, (dialog_x + 10, dialog_y + 10))
        prob_text = ui_font.render("Probability", True, BLACK); screen.blit(prob_text, (dialog_x + 20, dialog_y + 50))
        text_box_rect = pygame.Rect(dialog_x + 120, dialog_y + 45, 150, 30); pygame.draw.rect(screen, WHITE, text_box_rect); pygame.draw.rect(screen, BLACK, text_box_rect, 1)
        input_text = ui_font.render(probability_input, True, BLACK); screen.blit(input_text, (text_box_rect.x + 5, text_box_rect.y + 5))
        go_rect = pygame.Rect(dialog_x + 50, dialog_y + 100, 100, 30); cancel_rect = pygame.Rect(dialog_x + 160, dialog_y + 100, 100, 30)
        pygame.draw.rect(screen, BUTTON_COLOR, go_rect); pygame.draw.rect(screen, BUTTON_COLOR, cancel_rect)
        go_text = button_font.render("Go", True, BLACK); cancel_text = button_font.render("Cancel", True, BLACK)
        screen.blit(go_text, go_text.get_rect(center=go_rect.center)); screen.blit(cancel_text, cancel_text.get_rect(center=cancel_rect.center))
        for event in pygame.event.get():
            if event.type == pygame.QUIT: pygame.quit(); sys.exit()
            elif event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
                x, y = event.pos; text_box_active = text_box_rect.collidepoint(x, y)
                if go_rect.collidepoint(x, y):
                    max_index = len(eight_letter_words);
                    if probability_input.isdigit(): prob_val = int(probability_input); max_index = min(max(1, prob_val), len(eight_letter_words))
                    selected_eight = random.choice(eight_letter_words[:max_index]); print("Selected 8-letter word:", selected_eight)
                    remove_idx = random.randint(0, 7); removed_letter = selected_eight[remove_idx]; removed_eight = selected_eight[:remove_idx] + selected_eight[remove_idx + 1:]
                    print("Player 1 rack (7 letters):", removed_eight); print("Removed letter:", removed_letter)
                    selected_seven = select_seven_letter_word(removed_letter, seven_letter_words)
                    if selected_seven is None: print("Error: Could not find a suitable 7-letter word."); return False, None, None, None, None, None
                    print("Selected 7-letter word for board:", selected_seven)
                    board, _, tiles = create_board(); local_racks = [[], []]; local_blanks = set(); local_racks[0] = sorted(list(removed_eight)); local_racks[1] = []
                    center_r, center_c = CENTER_SQUARE; word_len = len(selected_seven); start_offset = word_len // 2; place_horizontally = random.choice([True, False]); placement_successful = False
                    if place_horizontally:
                        start_c_place = center_c - start_offset
                        if 0 <= start_c_place and start_c_place + word_len <= GRID_SIZE:
                            for i, letter in enumerate(selected_seven): tiles[center_r][start_c_place + i] = letter
                            placement_successful = True; print(f"Placed '{selected_seven}' horizontally at ({center_r},{start_c_place})")
                    if not placement_successful: # Try vertically
                        start_r_place = center_r - start_offset
                        if 0 <= start_r_place and start_r_place + word_len <= GRID_SIZE:
                            for i, letter in enumerate(selected_seven): tiles[start_r_place + i][center_c] = letter
                            placement_successful = True; print(f"Placed '{selected_seven}' vertically at ({start_r_place},{center_c})")
                    if not placement_successful: print("Error: Could not place 7-letter word centered H or V."); return False, None, None, None, None, None
                    local_bag = []; return True, board, tiles, local_racks, local_blanks, local_bag
                elif cancel_rect.collidepoint(x, y): return False, None, None, None, None, None
            elif event.type == pygame.KEYDOWN and text_box_active:
                if event.key == pygame.K_BACKSPACE: probability_input = probability_input[:-1]
                elif event.unicode.isdigit(): probability_input += event.unicode
        pygame.display.flip()
    return False, None, None, None, None, None # Should not be reached








def mode_selection_screen():
    """Display and handle the game mode selection screen, including Load Game via text input."""
    print("--- mode_selection_screen() entered ---")
    global main_called
    try:
        print("--- mode_selection_screen(): Attempting to load background image... ---")
        image = pygame.image.load("Scrabble_S.png").convert_alpha(); content_width = WINDOW_WIDTH - 200; image = pygame.transform.scale(image, (content_width, WINDOW_HEIGHT)); image.set_alpha(128); content_left = (WINDOW_WIDTH - content_width) // 2
        print("--- mode_selection_screen(): Background image loaded and processed. ---")
    except pygame.error as e:
        print(f"--- mode_selection_screen(): WARNING - Could not load background image 'Scrabble_S.png': {e} ---")
        image = None; content_width = WINDOW_WIDTH; content_left = 0

    modes = [MODE_HVH, MODE_HVA, MODE_AVA]; selected_mode = None; player_names = ["Player 1", "Player 2"]; human_player = 1; input_active = [False, False]; current_input = 0
    practice_mode = None; dropdown_open = False; showing_power_tiles_dialog = False; letter_checks = [True, True, True, True]; number_checks = [True, True, True, True, False, False]; practice_state = None
    loaded_game_data = None

    # State for Load Game Text Input
    showing_load_input = False; load_filename_input = ""; load_input_active = False
    load_confirm_button_rect = None; load_input_rect = None; load_cancel_button_rect = None

    print("--- mode_selection_screen(): Entering main loop (while selected_mode is None:)... ---")
    loop_count = 0
    while selected_mode is None:
        loop_count += 1
        if loop_count % 15000 == 0: print(f"--- mode_selection_screen(): Loop iteration {loop_count} ---")

        pygame.event.pump()

        # --- Define positions INSIDE the loop ---
        option_rects = []
        name_rect_x = content_left + (content_width - 200) // 2
        p2_y_pos = 300 + 60

        # Button Positions
        play_later_rect = pygame.Rect(WINDOW_WIDTH - BUTTON_WIDTH - 10, WINDOW_HEIGHT - BUTTON_HEIGHT - 10, BUTTON_WIDTH, BUTTON_HEIGHT)
        load_game_button_rect = pygame.Rect(play_later_rect.left - BUTTON_GAP - BUTTON_WIDTH, play_later_rect.top, BUTTON_WIDTH, BUTTON_HEIGHT)

        # Calculate Load Input Field/Button Positions unconditionally
        load_input_width = 300; load_input_x = load_game_button_rect.left; load_input_y = load_game_button_rect.top - BUTTON_GAP - BUTTON_HEIGHT
        load_input_rect = pygame.Rect(load_input_x, load_input_y, load_input_width, BUTTON_HEIGHT)
        load_confirm_button_rect = pygame.Rect(load_input_x + load_input_width + BUTTON_GAP, load_input_y, BUTTON_WIDTH, BUTTON_HEIGHT)
        load_cancel_button_rect = pygame.Rect(load_confirm_button_rect.right + BUTTON_GAP, load_input_y, BUTTON_WIDTH, BUTTON_HEIGHT)

        # --- MOVED: Calculate HVA button rects unconditionally ---
        hva_button_row_y = p2_y_pos + BUTTON_HEIGHT + 10
        hva_buttons_total_width = (BUTTON_WIDTH * 2 + 20)
        hva_buttons_start_x = content_left + (content_width - hva_buttons_total_width) // 2
        p1_rect_hva = pygame.Rect(hva_buttons_start_x, hva_button_row_y, BUTTON_WIDTH, BUTTON_HEIGHT)
        p2_rect_hva = pygame.Rect(hva_buttons_start_x + BUTTON_WIDTH + 20, hva_button_row_y, BUTTON_WIDTH, BUTTON_HEIGHT)
        # --- END MOVED ---

        # Dropdown positioning
        if modes[current_input] == MODE_HVH and dropdown_open:
            dropdown_x = name_rect_x; dropdown_button_y = p2_y_pos + BUTTON_HEIGHT + 10; dropdown_y = dropdown_button_y + 30
            options = ["Power Tiles", "8-Letter Bingos", "End Game"]
            for i, option in enumerate(options): option_rect = pygame.Rect(dropdown_x, dropdown_y + 30 * i, 200, 30); option_rects.append(option_rect)


        # --- Event Handling ---
        for event in pygame.event.get():
            if event.type == pygame.QUIT: pygame.quit(); sys.exit()

            # Handle Load Game Input FIRST if active
            if showing_load_input:
                if event.type == pygame.MOUSEBUTTONDOWN:
                    x, y = event.pos
                    if load_input_rect.collidepoint(x, y): load_input_active = True
                    else: load_input_active = False
                    if load_confirm_button_rect.collidepoint(x, y): # Load Confirm ...
                        filepath = load_filename_input.strip()
                        if filepath:
                             print(f"--- mode_selection_screen(): Attempting to load typed file: {filepath} ---")
                             try:
                                 loaded_p_names, loaded_hist, loaded_f_scores = load_game_from_gcg(filepath)
                                 print(f"--- mode_selection_screen(): GCG loaded successfully. Moves: {len(loaded_hist)} ---")
                                 selected_mode = "LOADED_GAME"; loaded_game_data = (loaded_p_names, loaded_hist, loaded_f_scores)
                                 showing_load_input = False; load_input_active = False; break
                             except FileNotFoundError: print(f"--- mode_selection_screen(): Error: File not found '{filepath}' ---"); show_message_dialog(f"Error: File not found:\n{filepath}", "Load Error"); load_input_active = True
                             except Exception as e: print(f"--- mode_selection_screen(): Error loading GCG file '{filepath}': {e} ---"); show_message_dialog(f"Error loading file:\n{e}", "Load Error"); load_input_active = True
                        else: show_message_dialog("Please enter a filename.", "Load Error"); load_input_active = True
                    elif load_cancel_button_rect.collidepoint(x,y): # Load Cancel ...
                         showing_load_input = False; load_input_active = False; load_filename_input = ""
                    if not load_input_rect.collidepoint(x,y): input_active = [False, False] # Deactivate name input too
                elif event.type == pygame.KEYDOWN and load_input_active: # Load Input Typing ...
                    if event.key == pygame.K_RETURN or event.key == pygame.K_KP_ENTER:
                         if load_confirm_button_rect: pygame.event.post(pygame.event.Event(pygame.MOUSEBUTTONDOWN, {'pos': load_confirm_button_rect.center, 'button': 1}))
                    elif event.key == pygame.K_BACKSPACE: load_filename_input = load_filename_input[:-1]
                    elif event.unicode.isprintable(): load_filename_input += event.unicode
                continue # Skip rest of event handling

            # Handle other events if load input wasn't active
            elif event.type == pygame.MOUSEBUTTONDOWN:
                x, y = event.pos
                if showing_power_tiles_dialog: # Power Tiles Dialog ...
                    dialog_x = (WINDOW_WIDTH - 300) // 2; dialog_y = (WINDOW_HEIGHT - 250) // 2; letter_rects = [pygame.Rect(dialog_x + 20, dialog_y + 40 + i*30, 20, 20) for i in range(4)]; number_rects = [pygame.Rect(dialog_x + 150, dialog_y + 40 + i*30, 20, 20) for i in range(6)]
                    go_rect = pygame.Rect(dialog_x + 50, dialog_y + 220, 100, 30); cancel_rect = pygame.Rect(dialog_x + 160, dialog_y + 220, 100, 30)
                    for i, rect in enumerate(letter_rects):
                        if rect.collidepoint(x, y): letter_checks[i] = not letter_checks[i]
                    for i, rect in enumerate(number_rects):
                        if rect.collidepoint(x, y): number_checks[i] = not number_checks[i]
                    if go_rect.collidepoint(x, y): practice_mode = "power_tiles"; selected_mode = MODE_AVA; showing_power_tiles_dialog = False; print(f"--- mode_selection_screen(): Mode selected via Power Tiles Go: {selected_mode} ---"); break
                    elif cancel_rect.collidepoint(x, y): showing_power_tiles_dialog = False
                else: # Main Selection Screen ...
                    # Must define mode_rects before checking collision
                    mode_rects = []
                    for i, mode in enumerate(modes):
                        y_pos = 100 + i * 60; rect = pygame.Rect(content_left + (content_width - (BUTTON_WIDTH * 2 + 20)) // 2, y_pos, BUTTON_WIDTH * 2 + 20, BUTTON_HEIGHT); mode_rects.append(rect)
                    # Check mode buttons
                    for i, rect in enumerate(mode_rects):
                        if rect.collidepoint(x, y):
                            current_input = i; dropdown_open = False
                            if i == 0: player_names = ["Player 1", "Player 2"]; input_active = [False, False]
                            elif i == 1: player_names = ["Player 1", "AI"] if human_player == 1 else ["AI", "Player 2"]; input_active = [True, False] if human_player == 1 else [False, True] # Set initial HVA state
                            elif i == 2: player_names = ["AI 1", "AI 2"]; input_active = [False, False]
                            # Select mode immediately ONLY for HVH and AVA
                            if modes[current_input] in [MODE_HVH, MODE_AVA]:
                                selected_mode = modes[current_input]; print(f"--- mode_selection_screen(): Mode selected via click: {selected_mode} ---"); break
                    if selected_mode: break # Exit if HVH or AVA selected

                    # Check Load Game Button
                    if load_game_button_rect.collidepoint(x, y):
                        print("--- mode_selection_screen(): Load Game button clicked, showing input ---")
                        showing_load_input = True; load_input_active = True; load_filename_input = ""
                        continue # Skip rest

                    # Check Other Buttons
                    if play_later_rect.collidepoint(x, y): print("--- mode_selection_screen(): Play Later clicked. Exiting. ---"); pygame.quit(); sys.exit()
                    clicked_name_input = False
                    p1_name_rect = pygame.Rect(name_rect_x, 300, 200, BUTTON_HEIGHT)
                    p2_name_rect = pygame.Rect(name_rect_x, p2_y_pos, 200, BUTTON_HEIGHT) if modes[current_input] == MODE_HVH else None
                    if modes[current_input] == MODE_HVH: # HVH Name Input ...
                        if p1_name_rect.collidepoint(x, y): input_active = [True, False]; clicked_name_input = True
                        elif p2_name_rect and p2_name_rect.collidepoint(x, y): input_active = [False, True]; clicked_name_input = True
                    elif modes[current_input] == MODE_HVA: # HVA Name Input / Play As ...
                        # Check name input click
                        if human_player == 1 and p1_name_rect.collidepoint(x, y): input_active = [True, False]; clicked_name_input = True
                        elif human_player == 2:
                            p2_name_rect_hva = pygame.Rect(name_rect_x, p2_y_pos, 200, BUTTON_HEIGHT)
                            if p2_name_rect_hva.collidepoint(x,y): input_active = [False, True]; clicked_name_input = True
                        # --- Check HVA Play As buttons using pre-calculated rects ---
                        if p1_rect_hva.collidepoint(x, y):
                            human_player = 1; player_names = ["Player 1", "AI"]; input_active = [True, False]
                            selected_mode = MODE_HVA; print(f"--- mode_selection_screen(): Mode selected via click: {selected_mode} (Play as P1) ---"); break
                        elif p2_rect_hva.collidepoint(x, y):
                            human_player = 2; player_names = ["AI", "Player 2"]; input_active = [False, True]
                            selected_mode = MODE_HVA; print(f"--- mode_selection_screen(): Mode selected via click: {selected_mode} (Play as P2) ---"); break
                        # --- End Check ---
                    if modes[current_input] == MODE_HVH: # Practice Dropdown ...
                        dropdown_button_y = p2_y_pos + BUTTON_HEIGHT + 10; dropdown_rect = pygame.Rect(name_rect_x, dropdown_button_y, 200, 30)
                        if dropdown_rect.collidepoint(x, y): dropdown_open = not dropdown_open
                        elif dropdown_open:
                            clicked_option = False
                            for i, option_rect in enumerate(option_rects):
                                if option_rect.collidepoint(x, y):
                                    clicked_option = True; dropdown_open = False
                                    if i == 0: showing_power_tiles_dialog = True
                                    elif i == 1: # 8-Letter Bingos
                                        print("--- mode_selection_screen(): 8-Letter Bingo practice selected. Calling eight_letter_practice()... ---")
                                        proceed, p_board, p_tiles, p_racks, p_blanks, p_bag = eight_letter_practice()
                                        if proceed:
                                            practice_mode = "eight_letter"; selected_mode = MODE_HVH; player_names = ["Player 1", ""]; human_player = 1
                                            practice_state = {"board": p_board, "tiles": p_tiles, "racks": p_racks, "blanks": p_blanks, "bag": p_bag, "first_play": False, "scores": [0, 0], "turn": 1}
                                            print(f"--- mode_selection_screen(): 8-Letter practice setup successful. Selected mode: {selected_mode} ---"); break
                                        else: print("--- mode_selection_screen(): 8-Letter practice setup cancelled or failed. ---")
                                    elif i == 2: print("End Game practice selected - Not implemented yet")
                                    break # Exit options loop
                            if not clicked_option and not dropdown_rect.collidepoint(x,y): dropdown_open = False
                        elif not dropdown_rect.collidepoint(x,y): dropdown_open = False
                    if selected_mode: break
                    # Deactivate name input if clicking elsewhere
                    dropdown_button_y = p2_y_pos + BUTTON_HEIGHT + 10; dropdown_rect_check = pygame.Rect(name_rect_x, dropdown_button_y, 200, 30) if modes[current_input] == MODE_HVH else None
                    if not clicked_name_input and not (dropdown_open and any(r.collidepoint(x,y) for r in option_rects)) and not p1_name_rect.collidepoint(x,y) and not (p2_name_rect and p2_name_rect.collidepoint(x,y)) and not (dropdown_rect_check and dropdown_rect_check.collidepoint(x,y)): input_active = [False, False]

            elif event.type == pygame.KEYDOWN: # Keyboard Input (Names only now)
                if not showing_load_input: # Only handle name input if load input isn't showing
                     active_idx = -1
                     if input_active[0]: active_idx = 0
                     elif input_active[1] and modes[current_input] == MODE_HVH: active_idx = 1
                     elif input_active[1] and modes[current_input] == MODE_HVA and human_player == 2: active_idx = 1
                     if active_idx != -1:
                        if event.key == pygame.K_BACKSPACE: player_names[active_idx] = player_names[active_idx][:-1]
                        elif event.key == pygame.K_RETURN: input_active[active_idx] = False
                        elif event.unicode.isalnum() or event.unicode == ' ':
                            if len(player_names[active_idx]) < 15: player_names[active_idx] += event.unicode

        # --- Drawing Logic ---
        screen.fill(WHITE);
        if image: screen.blit(image, (content_left, 0))
        title_text = dialog_font.render("Select Game Mode", True, BLACK); title_x = content_left + (content_width - title_text.get_width()) // 2; screen.blit(title_text, (title_x, 50))
        mode_rects = [] # Draw Mode Buttons ...
        for i, mode in enumerate(modes):
            y_pos = 100 + i * 60; rect = pygame.Rect(content_left + (content_width - (BUTTON_WIDTH * 2 + 20)) // 2, y_pos, BUTTON_WIDTH * 2 + 20, BUTTON_HEIGHT); hover = rect.collidepoint(pygame.mouse.get_pos())
            color = BUTTON_HOVER if i == current_input or hover else BUTTON_COLOR; pygame.draw.rect(screen, color, rect)
            if i == current_input: pygame.draw.rect(screen, BLACK, rect, 2)
            text = button_font.render(mode, True, BLACK); text_rect = text.get_rect(center=rect.center); screen.blit(text, text_rect); mode_rects.append(rect)

        # Draw Play Later Button ...
        hover = play_later_rect.collidepoint(pygame.mouse.get_pos()); color = BUTTON_HOVER if hover else BUTTON_COLOR; pygame.draw.rect(screen, color, play_later_rect)
        play_later_text = button_font.render("Play Later", True, BLACK); play_later_text_rect = play_later_text.get_rect(center=play_later_rect.center); screen.blit(play_later_text, play_later_text_rect)

        # Draw Load Game Button ...
        hover = load_game_button_rect.collidepoint(pygame.mouse.get_pos()); color = BUTTON_HOVER if hover else BUTTON_COLOR; pygame.draw.rect(screen, color, load_game_button_rect)
        load_game_text = button_font.render("Load Game", True, BLACK); load_game_text_rect = load_game_text.get_rect(center=load_game_button_rect.center); screen.blit(load_game_text, load_game_text_rect)

        # Draw Load Game Input Field (if active)
        if showing_load_input:
             pygame.draw.rect(screen, WHITE, load_input_rect); pygame.draw.rect(screen, BLACK, load_input_rect, 1 if not load_input_active else 2)
             input_surf = ui_font.render(load_filename_input, True, BLACK); screen.blit(input_surf, (load_input_rect.x + 5, load_input_rect.y + 5))
             if load_input_active and int(time.time() * 2) % 2 == 0: # Blinking cursor
                  cursor_x = load_input_rect.x + 5 + input_surf.get_width(); cursor_y1 = load_input_rect.y + 5; cursor_y2 = load_input_rect.y + load_input_rect.height - 5
                  pygame.draw.line(screen, BLACK, (cursor_x, cursor_y1), (cursor_x, cursor_y2), 1)
             hover = load_confirm_button_rect.collidepoint(pygame.mouse.get_pos()); color = BUTTON_HOVER if hover else BUTTON_COLOR # Confirm Button
             pygame.draw.rect(screen, color, load_confirm_button_rect); text = button_font.render("Load File", True, BLACK); text_rect = text.get_rect(center=load_confirm_button_rect.center); screen.blit(text, text_rect)
             hover = load_cancel_button_rect.collidepoint(pygame.mouse.get_pos()); color = BUTTON_HOVER if hover else BUTTON_COLOR # Cancel Button
             pygame.draw.rect(screen, color, load_cancel_button_rect); text = button_font.render("Cancel", True, BLACK); text_rect = text.get_rect(center=load_cancel_button_rect.center); screen.blit(text, text_rect)

        # Name Input / Practice Dropdown / HVA Selection Drawing ...
        name_y_start = 300; name_rect_width = 200; p1_y_pos = name_y_start; p1_label_text = "Player 1 Name:"; p1_label = ui_font.render(p1_label_text, True, BLACK);
        p1_name_rect = pygame.Rect(name_rect_x, p1_y_pos, name_rect_width, BUTTON_HEIGHT) # Define for drawing
        p1_label_x = name_rect_x - p1_label.get_width() - 10; screen.blit(p1_label, (p1_label_x, p1_y_pos + 5)); p1_bg_color = LIGHT_BLUE if input_active[0] else (GRAY if modes[current_input] == MODE_AVA else WHITE); pygame.draw.rect(screen, p1_bg_color, p1_name_rect); pygame.draw.rect(screen, BLACK, p1_name_rect, 1)
        p1_name_text = ui_font.render(player_names[0], True, BLACK); screen.blit(p1_name_text, (p1_name_rect.x + 5, p1_name_rect.y + 5))
        if modes[current_input] == MODE_HVH:
            p2_label_text = "Player 2 Name:"; p2_label = ui_font.render(p2_label_text, True, BLACK); p2_name_rect = pygame.Rect(name_rect_x, p2_y_pos, name_rect_width, BUTTON_HEIGHT) # Define for drawing
            p2_label_x = name_rect_x - p2_label.get_width() - 10; screen.blit(p2_label, (p2_label_x, p2_y_pos + 5))
            pygame.draw.rect(screen, WHITE if not input_active[1] else LIGHT_BLUE, p2_name_rect); pygame.draw.rect(screen, BLACK, p2_name_rect, 1); p2_name_text = ui_font.render(player_names[1], True, BLACK); screen.blit(p2_name_text, (p2_name_rect.x + 5, p2_name_rect.y + 5))
            dropdown_button_y = p2_y_pos + BUTTON_HEIGHT + 10; dropdown_rect = pygame.Rect(name_rect_x, dropdown_button_y, 200, 30); hover = dropdown_rect.collidepoint(pygame.mouse.get_pos()); color = BUTTON_HOVER if hover else BUTTON_COLOR; pygame.draw.rect(screen, color, dropdown_rect)
            text = button_font.render("Practice", True, BLACK); text_rect = text.get_rect(center=dropdown_rect.center); screen.blit(text, text_rect)
            if dropdown_open:
                for i, option_rect in enumerate(option_rects): hover = option_rect.collidepoint(pygame.mouse.get_pos()); color = BUTTON_HOVER if hover else DROPDOWN_COLOR; pygame.draw.rect(screen, color, option_rect); text = button_font.render(options[i], True, BLACK); text_rect = text.get_rect(center=option_rect.center); screen.blit(text, text_rect)
        elif modes[current_input] == MODE_HVA:
            p2_label_text = "AI Name:"; p2_label = ui_font.render(p2_label_text, True, BLACK); p2_name_rect = pygame.Rect(name_rect_x, p2_y_pos, name_rect_width, BUTTON_HEIGHT) # Define for drawing
            p2_label_x = name_rect_x - p2_label.get_width() - 10; screen.blit(p2_label, (p2_label_x, p2_y_pos + 5))
            pygame.draw.rect(screen, GRAY, p2_name_rect); pygame.draw.rect(screen, BLACK, p2_name_rect, 1); p2_name_text = ui_font.render(player_names[1], True, BLACK); screen.blit(p2_name_text, (p2_name_rect.x + 5, p2_name_rect.y + 5))
            # Draw HVA Play As buttons using pre-calculated rects
            p1_hover = p1_rect_hva.collidepoint(pygame.mouse.get_pos()); p2_hover = p2_rect_hva.collidepoint(pygame.mouse.get_pos()); pygame.draw.rect(screen, BUTTON_HOVER if p1_hover else BUTTON_COLOR, p1_rect_hva);
            if human_player == 1: pygame.draw.rect(screen, BLACK, p1_rect_hva, 2)
            pygame.draw.rect(screen, BUTTON_HOVER if p2_hover else BUTTON_COLOR, p2_rect_hva);
            if human_player == 2: pygame.draw.rect(screen, BLACK, p2_rect_hva, 2)
            p1_text = button_font.render("Play as P1", True, BLACK); p2_text = button_font.render("Play as P2", True, BLACK); p1_text_rect = p1_text.get_rect(center=p1_rect_hva.center); p2_text_rect = p2_text.get_rect(center=p2_rect_hva.center); screen.blit(p1_text, p1_text_rect); screen.blit(p2_text, p2_text_rect)
        elif modes[current_input] == MODE_AVA:
            p2_label_text = "AI 2 Name:"; p2_label = ui_font.render(p2_label_text, True, BLACK); p2_name_rect = pygame.Rect(name_rect_x, p2_y_pos, name_rect_width, BUTTON_HEIGHT) # Define for drawing
            p2_label_x = name_rect_x - p2_label.get_width() - 10; screen.blit(p2_label, (p2_label_x, p2_y_pos + 5))
            pygame.draw.rect(screen, GRAY, p2_name_rect); pygame.draw.rect(screen, BLACK, p2_name_rect, 1); p2_name_text = ui_font.render(player_names[1], True, BLACK); screen.blit(p2_name_text, (p2_name_rect.x + 5, p2_name_rect.y + 5))
            pygame.draw.rect(screen, GRAY, p1_name_rect); pygame.draw.rect(screen, BLACK, p1_name_rect, 1); p1_name_text = ui_font.render(player_names[0], True, BLACK); screen.blit(p1_name_text, (p1_name_rect.x + 5, p1_name_rect.y + 5))

        # Draw Power Tiles Dialog if active ...
        if showing_power_tiles_dialog:
             # (No changes needed here)
            dialog_width, dialog_height = 300, 250; dialog_x = (WINDOW_WIDTH - dialog_width) // 2; dialog_y = (WINDOW_HEIGHT - dialog_height) // 2; pygame.draw.rect(screen, DIALOG_COLOR, (dialog_x, dialog_y, dialog_width, dialog_height)); pygame.draw.rect(screen, BLACK, (dialog_x, dialog_y, dialog_width, dialog_height), 2)
            title_text = dialog_font.render("Power Tiles Options", True, BLACK); screen.blit(title_text, (dialog_x + 10, dialog_y + 10)); letters = ['J', 'Q', 'X', 'Z']
            for i, letter in enumerate(letters): draw_checkbox(screen, dialog_x + 20, dialog_y + 40 + i*30, letter_checks[i]); text = ui_font.render(letter, True, BLACK); screen.blit(text, (dialog_x + 50, dialog_y + 40 + i*30))
            numbers = ['2', '3', '4', '5', '6', '7+']
            for i, num in enumerate(numbers): draw_checkbox(screen, dialog_x + 150, dialog_y + 40 + i*30, number_checks[i]); text = ui_font.render(num, True, BLACK); screen.blit(text, (dialog_x + 180, dialog_y + 40 + i*30))
            go_rect = pygame.Rect(dialog_x + 50, dialog_y + 220, 100, 30); cancel_rect = pygame.Rect(dialog_x + 160, dialog_y + 220, 100, 30); pygame.draw.rect(screen, BUTTON_COLOR, go_rect); pygame.draw.rect(screen, BUTTON_COLOR, cancel_rect)
            go_text = button_font.render("Go", True, BLACK); cancel_text = button_font.render("Cancel", True, BLACK); screen.blit(go_text, go_text.get_rect(center=go_rect.center)); screen.blit(cancel_text, cancel_text.get_rect(center=cancel_rect.center))


        # --- Display Update ---
        pygame.display.flip()

        # --- Exit Condition Check ---
        if selected_mode: break

    print(f"--- mode_selection_screen(): Exiting loop. Returning mode={selected_mode} ---")
    # Return loaded game data or new game setup data
    if selected_mode == "LOADED_GAME":
        return selected_mode, loaded_game_data
    else:
        return selected_mode, (player_names, human_player, practice_mode, letter_checks, practice_state)



def draw_options_menu(turn, dropdown_open, bag_count):
    """Draw the options menu with dropdown functionality."""
    global practice_mode # Access practice_mode
    options_x = 10; options_rect = pygame.Rect(options_x, OPTIONS_Y, OPTIONS_WIDTH, OPTIONS_HEIGHT)
    hover = options_rect.collidepoint(pygame.mouse.get_pos()); color = BUTTON_HOVER if hover else BUTTON_COLOR; pygame.draw.rect(screen, color, options_rect)
    options_text = button_font.render("Options", True, BLACK); options_text_rect = options_text.get_rect(center=(options_x + OPTIONS_WIDTH // 2, OPTIONS_Y + OPTIONS_HEIGHT // 2)); screen.blit(options_text, options_text_rect)
    dropdown_rects = []
    if dropdown_open:
        dropdown_y = OPTIONS_Y + OPTIONS_HEIGHT
        if practice_mode == "eight_letter": options = ["Give Up", "Main", "Quit"]
        else: options = ["Pass", "Exchange", "Main", "Quit"]
        for i, option in enumerate(options):
            rect = pygame.Rect(options_x, dropdown_y + i * OPTIONS_HEIGHT, OPTIONS_WIDTH, OPTIONS_HEIGHT)
            is_disabled = (practice_mode != "eight_letter" and option == "Exchange" and bag_count < 7)
            if is_disabled: pygame.draw.rect(screen, GRAYED_OUT_COLOR, rect); text = button_font.render(option, True, BLACK); dropdown_rects.append(None)
            else: hover = rect.collidepoint(pygame.mouse.get_pos()); color = BUTTON_HOVER if hover else DROPDOWN_COLOR; pygame.draw.rect(screen, color, rect); text = button_font.render(option, True, BLACK); dropdown_rects.append(rect)
            text_rect = text.get_rect(center=(options_x + OPTIONS_WIDTH // 2, dropdown_y + i * OPTIONS_HEIGHT + OPTIONS_HEIGHT // 2)); screen.blit(text, text_rect)
    return options_rect, dropdown_rects

# End of Part 2

# Part 3 (Includes dialogs, stats, message boxes)
# draw_suggest_button, draw_exchange_dialog, confirm_quit, draw_game_over_dialog, draw_score_row, calculate_moves_per_player, calculate_bingos_per_player, calculate_bingo_avg_per_player, draw_moves_row, draw_avg_score_row, draw_bingos_row, draw_bingo_avg_row, calculate_blanks_per_player, draw_blanks_row, draw_stats_dialog, show_message_dialog, draw_practice_end_dialog (Unchanged from Part 3 provided previously)
def draw_suggest_button():
    """Draw the suggest button."""
    suggest_x = 10 + OPTIONS_WIDTH + BUTTON_GAP; suggest_rect = pygame.Rect(suggest_x, OPTIONS_Y, OPTIONS_WIDTH, OPTIONS_HEIGHT)
    hover = suggest_rect.collidepoint(pygame.mouse.get_pos()); color = BUTTON_HOVER if hover else BUTTON_COLOR; pygame.draw.rect(screen, color, suggest_rect)
    suggest_text = button_font.render("Suggest", True, BLACK); suggest_text_rect = suggest_text.get_rect(center=(suggest_x + OPTIONS_WIDTH // 2, OPTIONS_Y + OPTIONS_HEIGHT // 2)); screen.blit(suggest_text, suggest_text_rect)
    return suggest_rect

def draw_exchange_dialog(rack, selected_tiles):
    """Draw the tile exchange dialog."""
    dialog_width, dialog_height = 400, 200; dialog_x = (WINDOW_WIDTH - dialog_width) // 2; dialog_y = (WINDOW_HEIGHT - dialog_height) // 2
    pygame.draw.rect(screen, DIALOG_COLOR, (dialog_x, dialog_y, dialog_width, dialog_height)); pygame.draw.rect(screen, BLACK, (dialog_x, dialog_y, dialog_width, dialog_height), 2)
    prompt_text = dialog_font.render("Select tiles to exchange:", True, BLACK); screen.blit(prompt_text, (dialog_x + 10, dialog_y + 10))
    tile_rects = []; rack_display_width = len(rack) * (TILE_WIDTH + TILE_GAP) - TILE_GAP; start_tile_x = dialog_x + (dialog_width - rack_display_width) // 2
    for i, tile in enumerate(rack):
        tile_x = start_tile_x + i * (TILE_WIDTH + TILE_GAP); tile_y = dialog_y + 50; rect = pygame.Rect(tile_x, tile_y, TILE_WIDTH, TILE_HEIGHT); tile_rects.append(rect)
        if tile == ' ':
            center = rect.center; radius = TILE_WIDTH // 2 - 2; pygame.draw.circle(screen, BLACK, center, radius)
            if i in selected_tiles: pygame.draw.circle(screen, SELECTED_TILE_COLOR, center, radius + 2, 2)
            text = font.render('?', True, WHITE); text_rect = text.get_rect(center=center); screen.blit(text, text_rect)
        else: color = SELECTED_TILE_COLOR if i in selected_tiles else GREEN; pygame.draw.rect(screen, color, rect); text = font.render(tile, True, BLACK); screen.blit(text, (tile_x + 5, tile_y + 5))
    total_button_width = BUTTON_WIDTH * 2 + BUTTON_GAP; button_start_x = dialog_x + (dialog_width - total_button_width) // 2; button_y = dialog_y + dialog_height - BUTTON_HEIGHT - 10
    exchange_button_rect = pygame.Rect(button_start_x, button_y, BUTTON_WIDTH, BUTTON_HEIGHT); cancel_button_rect = pygame.Rect(button_start_x + BUTTON_WIDTH + BUTTON_GAP, button_y, BUTTON_WIDTH, BUTTON_HEIGHT)
    hover = exchange_button_rect.collidepoint(pygame.mouse.get_pos()); color = BUTTON_HOVER if hover else BUTTON_COLOR; pygame.draw.rect(screen, color, exchange_button_rect)
    exchange_text = button_font.render("Exchange", True, BLACK); exchange_text_rect = exchange_text.get_rect(center=exchange_button_rect.center); screen.blit(exchange_text, exchange_text_rect)
    hover = cancel_button_rect.collidepoint(pygame.mouse.get_pos()); color = BUTTON_HOVER if hover else BUTTON_COLOR; pygame.draw.rect(screen, color, cancel_button_rect)
    cancel_text = button_font.render("Cancel", True, BLACK); cancel_text_rect = cancel_text.get_rect(center=cancel_button_rect.center); screen.blit(cancel_text, cancel_text_rect)
    return tile_rects, exchange_button_rect, cancel_button_rect

def confirm_quit():
    """Prompt the user to confirm quitting the game."""
    dialog_width, dialog_height = 300, 100; dialog_x = (WINDOW_WIDTH - dialog_width) // 2; dialog_y = (WINDOW_HEIGHT - dialog_height) // 2
    pygame.draw.rect(screen, DIALOG_COLOR, (dialog_x, dialog_y, dialog_width, dialog_height)); pygame.draw.rect(screen, BLACK, (dialog_x, dialog_y, dialog_width, dialog_height), 2)
    prompt_text = dialog_font.render("Quit game? (Y/N)", True, BLACK); screen.blit(prompt_text, (dialog_x + (dialog_width - prompt_text.get_width()) // 2, dialog_y + 30)); pygame.display.flip()
    while True:
        for event in pygame.event.get():
            if event.type == pygame.QUIT: pygame.quit(); sys.exit()
            elif event.type == pygame.KEYDOWN:
                if event.key == pygame.K_y: return True
                elif event.key == pygame.K_n: return False

def draw_game_over_dialog(dialog_x, dialog_y, final_scores, reason, player_names):
    """Draw the game over dialog and return button rectangles."""
    pygame.draw.rect(screen, DIALOG_COLOR, (dialog_x, dialog_y, DIALOG_WIDTH, DIALOG_HEIGHT)); pygame.draw.rect(screen, BLACK, (dialog_x, dialog_y, DIALOG_WIDTH, DIALOG_HEIGHT), 2)
    title_text = dialog_font.render(f"Game Over - {reason}", True, BLACK); p1_score_text = ui_font.render(f"{player_names[0]} Score: {final_scores[0]}", True, BLACK)
    p2_name_display = player_names[1] if player_names[1] else "Player 2"; p2_score_text = ui_font.render(f"{p2_name_display} Score: {final_scores[1]}", True, BLACK)
    save_text = button_font.render("Save (S)", True, BLACK); quit_text = button_font.render("Quit (Q)", True, BLACK); replay_text = button_font.render("Replay (R)", True, BLACK); play_again_text = button_font.render("Play Again (P)", True, BLACK); stats_text = button_font.render("Statistics", True, BLACK)
    screen.blit(title_text, (dialog_x + 10, dialog_y + 20)); screen.blit(p1_score_text, (dialog_x + 10, dialog_y + 60)); screen.blit(p2_score_text, (dialog_x + 10, dialog_y + 90))
    first_row_width = 3 * BUTTON_WIDTH + 2 * BUTTON_GAP; first_row_start_x = dialog_x + (DIALOG_WIDTH - first_row_width) // 2; second_row_width = 2 * BUTTON_WIDTH + BUTTON_GAP; second_row_start_x = dialog_x + (DIALOG_WIDTH - second_row_width) // 2
    save_rect = pygame.Rect(first_row_start_x, dialog_y + 150, BUTTON_WIDTH, BUTTON_HEIGHT); quit_rect = pygame.Rect(first_row_start_x + BUTTON_WIDTH + BUTTON_GAP, dialog_y + 150, BUTTON_WIDTH, BUTTON_HEIGHT); replay_rect = pygame.Rect(first_row_start_x + 2 * (BUTTON_WIDTH + BUTTON_GAP), dialog_y + 150, BUTTON_WIDTH, BUTTON_HEIGHT)
    play_again_rect = pygame.Rect(second_row_start_x, dialog_y + 190, BUTTON_WIDTH, BUTTON_HEIGHT); stats_rect = pygame.Rect(second_row_start_x + BUTTON_WIDTH + BUTTON_GAP, dialog_y + 190, BUTTON_WIDTH, BUTTON_HEIGHT)
    pygame.draw.rect(screen, BUTTON_COLOR, save_rect); pygame.draw.rect(screen, BUTTON_COLOR, quit_rect); pygame.draw.rect(screen, BUTTON_COLOR, replay_rect); pygame.draw.rect(screen, BUTTON_COLOR, play_again_rect); pygame.draw.rect(screen, BUTTON_COLOR, stats_rect)
    screen.blit(save_text, save_text.get_rect(center=save_rect.center)); screen.blit(quit_text, quit_text.get_rect(center=quit_rect.center)); screen.blit(replay_text, replay_text.get_rect(center=replay_rect.center)); screen.blit(play_again_text, play_again_text.get_rect(center=play_again_rect.center)); screen.blit(stats_text, stats_text.get_rect(center=stats_rect.center))
    return save_rect, quit_rect, replay_rect, play_again_rect, stats_rect

def draw_score_row(screen, dialog_x, y_pos, final_scores):
    """Draw the score row for the statistics dialog."""
    score_label = ui_font.render("Score:", True, BLACK); p1_score_text = ui_font.render(str(final_scores[0]), True, BLACK); p2_score_text = ui_font.render(str(final_scores[1]), True, BLACK)
    screen.blit(score_label, (dialog_x + 10, y_pos)); screen.blit(p1_score_text, (dialog_x + 120, y_pos)); screen.blit(p2_score_text, (dialog_x + 230, y_pos))

def calculate_moves_per_player(move_history):
    """Calculate the number of moves made by each player from move_history."""
    moves_count = {1: 0, 2: 0}
    for move in move_history:
        player = move['player']
        # --- CORRECTED INDENTATION START ---
        if move['move_type'] in ['place', 'pass', 'exchange']:
            moves_count[player] += 1
        # --- CORRECTED INDENTATION END ---
    return moves_count[1], moves_count[2]

def calculate_bingos_per_player(move_history):
    """Calculate the number of bingos played by each player."""
    bingo_count = {1: 0, 2: 0}
    for move in move_history:
        if move['move_type'] == 'place' and move.get('is_bingo', False): player = move['player']; bingo_count[player] += 1
    return bingo_count[1], bingo_count[2]

def calculate_bingo_avg_per_player(move_history):
    """Calculate the average score of bingos for each player."""
    bingo_scores = {1: [], 2: []}
    for move in move_history:
        if move['move_type'] == 'place' and move.get('is_bingo', False): player = move['player']; bingo_scores[player].append(move['score'])
    avg_p1 = sum(bingo_scores[1]) / len(bingo_scores[1]) if bingo_scores[1] else 0.0; avg_p2 = sum(bingo_scores[2]) / len(bingo_scores[2]) if bingo_scores[2] else 0.0
    return avg_p1, avg_p2

def draw_moves_row(screen, dialog_x, y_pos, moves_p1, moves_p2):
    """Draw the moves row for the statistics dialog."""
    moves_label = ui_font.render("Moves:", True, BLACK); p1_moves_text = ui_font.render(str(moves_p1), True, BLACK); p2_moves_text = ui_font.render(str(moves_p2), True, BLACK)
    screen.blit(moves_label, (dialog_x + 10, y_pos)); screen.blit(p1_moves_text, (dialog_x + 120, y_pos)); screen.blit(p2_moves_text, (dialog_x + 230, y_pos))

def draw_avg_score_row(screen, dialog_x, y_pos, avg_p1, avg_p2):
    """Draw the average score per move row for the statistics dialog."""
    avg_label = ui_font.render("Avg Score:", True, BLACK); p1_avg_text = ui_font.render(f"{avg_p1:.2f}", True, BLACK); p2_avg_text = ui_font.render(f"{avg_p2:.2f}", True, BLACK)
    screen.blit(avg_label, (dialog_x + 10, y_pos)); screen.blit(p1_avg_text, (dialog_x + 120, y_pos)); screen.blit(p2_avg_text, (dialog_x + 230, y_pos))

def draw_bingos_row(screen, dialog_x, y_pos, bingos_p1, bingos_p2):
    """Draw the bingos row for the statistics dialog."""
    bingos_label = ui_font.render("Bingos:", True, BLACK); p1_bingos_text = ui_font.render(str(bingos_p1), True, BLACK); p2_bingos_text = ui_font.render(str(bingos_p2), True, BLACK)
    screen.blit(bingos_label, (dialog_x + 10, y_pos)); screen.blit(p1_bingos_text, (dialog_x + 120, y_pos)); screen.blit(p2_bingos_text, (dialog_x + 230, y_pos))

def draw_bingo_avg_row(screen, dialog_x, y_pos, bingo_avg_p1, bingo_avg_p2, bingos_p1, bingos_p2):
    """Draw the average bingo score row."""
    bingo_avg_label = ui_font.render("Bingo Avg:", True, BLACK); p1_text = "N/A" if bingos_p1 == 0 else f"{bingo_avg_p1:.2f}"; p2_text = "N/A" if bingos_p2 == 0 else f"{bingo_avg_p2:.2f}"
    p1_bingo_avg_text = ui_font.render(p1_text, True, BLACK); p2_bingo_avg_text = ui_font.render(p2_text, True, BLACK)
    screen.blit(bingo_avg_label, (dialog_x + 10, y_pos)); screen.blit(p1_bingo_avg_text, (dialog_x + 120, y_pos)); screen.blit(p2_bingo_avg_text, (dialog_x + 230, y_pos))

def calculate_blanks_per_player(move_history):
    """Calculate the number of blanks played by each player."""
    blanks_p1 = 0; blanks_p2 = 0
    for move in move_history:
        if move['move_type'] == 'place': player = move['player']; blanks_count = len(move.get('blanks', set()))
        if player == 1: blanks_p1 += blanks_count
        elif player == 2: blanks_p2 += blanks_count
    return blanks_p1, blanks_p2

def draw_blanks_row(screen, dialog_x, y_pos, blanks_p1, blanks_p2):
    """Draw the blanks played row."""
    blanks_label = ui_font.render("Blanks:", True, BLACK); p1_blanks_text = ui_font.render(str(blanks_p1), True, BLACK); p2_blanks_text = ui_font.render(str(blanks_p2), True, BLACK)
    screen.blit(blanks_label, (dialog_x + 10, y_pos)); screen.blit(p1_blanks_text, (dialog_x + 120, y_pos)); screen.blit(p2_blanks_text, (dialog_x + 230, y_pos))

def draw_stats_dialog(dialog_x, dialog_y, player_names, final_scores, tiles):
    """Draw the complete statistics dialog."""
    stats_dialog_width, stats_dialog_height = 400, 360
    pygame.draw.rect(screen, DIALOG_COLOR, (dialog_x, dialog_y, stats_dialog_width, stats_dialog_height))
    pygame.draw.rect(screen, BLACK, (dialog_x, dialog_y, stats_dialog_width, stats_dialog_height), 2)

    title_text = dialog_font.render("Game Statistics", True, BLACK)
    screen.blit(title_text, (dialog_x + 10, dialog_y + 10))

    # Player Names Header
    p1_name_display = player_names[0] if player_names[0] else "Player 1"
    p2_name_display = player_names[1] if player_names[1] else "Player 2"
    p1_name_text = ui_font.render(p1_name_display, True, BLACK)
    p2_name_text = ui_font.render(p2_name_display, True, BLACK)
    screen.blit(p1_name_text, (dialog_x + 120, dialog_y + 40))
    screen.blit(p2_name_text, (dialog_x + 230, dialog_y + 40))

    # Calculate Stats
    moves_p1, moves_p2 = calculate_moves_per_player(move_history)
    avg_p1 = final_scores[0] / moves_p1 if moves_p1 > 0 else 0.00
    avg_p2 = final_scores[1] / moves_p2 if moves_p2 > 0 else 0.00
    bingos_p1, bingos_p2 = calculate_bingos_per_player(move_history)
    bingo_avg_p1, bingo_avg_p2 = calculate_bingo_avg_per_player(move_history)
    blanks_p1, blanks_p2 = calculate_blanks_per_player(move_history)

    # Draw Rows
    y = dialog_y + 70
    draw_score_row(screen, dialog_x, y, final_scores)
    y += 30
    draw_moves_row(screen, dialog_x, y, moves_p1, moves_p2)
    y += 30
    draw_avg_score_row(screen, dialog_x, y, avg_p1, avg_p2)
    y += 30
    draw_bingos_row(screen, dialog_x, y, bingos_p1, bingos_p2)
    y += 30
    draw_bingo_avg_row(screen, dialog_x, y, bingo_avg_p1, bingo_avg_p2, bingos_p1, bingos_p2)
    y += 30
    draw_blanks_row(screen, dialog_x, y, blanks_p1, blanks_p2)
    y += 30

    # OK Button
    ok_button_rect = pygame.Rect(dialog_x + stats_dialog_width - BUTTON_WIDTH - 10, dialog_y + stats_dialog_height - BUTTON_HEIGHT - 10, BUTTON_WIDTH, BUTTON_HEIGHT)
    hover = ok_button_rect.collidepoint(pygame.mouse.get_pos())
    color = BUTTON_HOVER if hover else BUTTON_COLOR
    pygame.draw.rect(screen, color, ok_button_rect)
    ok_text = button_font.render("OK", True, BLACK)
    ok_text_rect = ok_text.get_rect(center=ok_button_rect.center)
    screen.blit(ok_text, ok_text_rect)

    return ok_button_rect

def show_message_dialog(message, title="Message"):
    """Display a general message dialog with an OK button, wrapping text."""
    dialog_width, dialog_height = 400, 150; dialog_x = (WINDOW_WIDTH - dialog_width) // 2; dialog_y = (WINDOW_HEIGHT - dialog_height) // 2
    words = message.split(' '); lines = []; current_line = ''; max_line_width = dialog_width - 20
    for word in words: test_line = current_line + word + ' ';
    if ui_font.size(test_line)[0] < max_line_width: current_line = test_line
    else: lines.append(current_line.strip()); current_line = word + ' '
    if current_line: lines.append(current_line.strip())
    pygame.draw.rect(screen, DIALOG_COLOR, (dialog_x, dialog_y, dialog_width, dialog_height)); pygame.draw.rect(screen, BLACK, (dialog_x, dialog_y, dialog_width, dialog_height), 2)
    title_surf = dialog_font.render(title, True, BLACK); screen.blit(title_surf, (dialog_x + 10, dialog_y + 5))
    y_offset = 10 + dialog_font.get_linesize()
    for line in lines: text = ui_font.render(line, True, BLACK); screen.blit(text, (dialog_x + 10, dialog_y + y_offset)); y_offset += ui_font.get_linesize()
    ok_button_rect = pygame.Rect(dialog_x + dialog_width - BUTTON_WIDTH - 10, dialog_y + dialog_height - BUTTON_HEIGHT - 10, BUTTON_WIDTH, BUTTON_HEIGHT)
    hover = ok_button_rect.collidepoint(pygame.mouse.get_pos()); color = BUTTON_HOVER if hover else BUTTON_COLOR; pygame.draw.rect(screen, color, ok_button_rect)
    ok_text = button_font.render("OK", True, BLACK); ok_text_rect = ok_text.get_rect(center=ok_button_rect.center); screen.blit(ok_text, ok_text_rect)
    pygame.display.flip()
    dialog_running = True
    while dialog_running:
        for event in pygame.event.get():
            if event.type == pygame.QUIT: pygame.quit(); sys.exit()
            elif event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
                 if ok_button_rect.collidepoint(event.pos): return
            elif event.type == pygame.KEYDOWN:
                 if event.key == pygame.K_RETURN or event.key == pygame.K_KP_ENTER: return

def draw_practice_end_dialog(message):
    """Draw the dialog shown at the end of a practice puzzle."""
    dialog_width, dialog_height = 400, 180; dialog_x = (WINDOW_WIDTH - dialog_width) // 2; dialog_y = (WINDOW_HEIGHT - dialog_height) // 2
    pygame.draw.rect(screen, DIALOG_COLOR, (dialog_x, dialog_y, dialog_width, dialog_height)); pygame.draw.rect(screen, BLACK, (dialog_x, dialog_y, dialog_width, dialog_height), 2)
    words = message.split(' '); lines = []; current_line = ''; max_line_width = dialog_width - 20
    for word in words: test_line = current_line + word + ' ';
    if ui_font.size(test_line)[0] < max_line_width: current_line = test_line
    else: lines.append(current_line.strip()); current_line = word + ' '
    if current_line: lines.append(current_line.strip())
    y_offset = 15
    for line in lines: text_surf = ui_font.render(line, True, BLACK); screen.blit(text_surf, (dialog_x + 10, dialog_y + y_offset)); y_offset += ui_font.get_linesize()
    button_y = dialog_y + dialog_height - BUTTON_HEIGHT - 15; total_button_width = 3 * BUTTON_WIDTH + 2 * BUTTON_GAP; button_start_x = dialog_x + (dialog_width - total_button_width) // 2
    play_again_rect = pygame.Rect(button_start_x, button_y, BUTTON_WIDTH, BUTTON_HEIGHT); main_menu_rect = pygame.Rect(button_start_x + BUTTON_WIDTH + BUTTON_GAP, button_y, BUTTON_WIDTH, BUTTON_HEIGHT); quit_rect = pygame.Rect(button_start_x + 2 * (BUTTON_WIDTH + BUTTON_GAP), button_y, BUTTON_WIDTH, BUTTON_HEIGHT)
    pygame.draw.rect(screen, BUTTON_COLOR, play_again_rect); pygame.draw.rect(screen, BUTTON_COLOR, main_menu_rect); pygame.draw.rect(screen, BUTTON_COLOR, quit_rect)
    play_again_text = button_font.render("Play Again", True, BLACK); main_menu_text = button_font.render("Main Menu", True, BLACK); quit_text = button_font.render("Quit", True, BLACK)
    screen.blit(play_again_text, play_again_text.get_rect(center=play_again_rect.center)); screen.blit(main_menu_text, main_menu_text.get_rect(center=main_menu_rect.center)); screen.blit(quit_text, quit_text.get_rect(center=quit_rect.center))
    return play_again_rect, main_menu_rect, quit_rect

# End of Part 3

# Part 4 (Includes game logic helpers: get_words_played, remaining tiles, validation, anchors)
# get_words_played, get_remaining_tiles, draw_remaining_tiles, draw_arrow, is_valid_play, get_anchor_points (Unchanged from Part 4 provided previously)
def get_words_played(word_positions, tiles):
    """Get all word strings formed by a play based on tile positions."""
    if not word_positions: return []
    words_found = set(); rows_involved_list = []; cols_involved_list = []; valid_positions = True
    for item in word_positions:
        if isinstance(item, tuple) and len(item) >= 3: rows_involved_list.append(item[0]); cols_involved_list.append(item[1])
        else: print(f"Error in get_words_played: Invalid item format: {item}"); valid_positions = False; break
    if not valid_positions: return []
    rows_involved = set(rows_involved_list); cols_involved = set(cols_involved_list)
    if len(rows_involved) == 1: # Horizontal Check
        r = rows_involved.pop(); min_c = min(cols_involved_list); max_c = max(cols_involved_list)
        while min_c > 0 and tiles[r][min_c - 1]: min_c -= 1
        while max_c < GRID_SIZE - 1 and tiles[r][max_c + 1]: max_c += 1
        word_h = "".join(tiles[r][c] for c in range(min_c, max_c + 1) if tiles[r][c])
        if len(word_h) > 1: words_found.add(word_h)
    if len(cols_involved) == 1: # Vertical Check
        c = cols_involved.pop(); min_r = min(rows_involved_list); max_r = max(rows_involved_list)
        while min_r > 0 and tiles[min_r - 1][c]: min_r -= 1
        while max_r < GRID_SIZE - 1 and tiles[max_r + 1][c]: max_r += 1
        word_v = "".join(tiles[r][c] for r in range(min_r, max_r + 1) if tiles[r][c])
        if len(word_v) > 1: words_found.add(word_v)
    for r_new, c_new, _ in word_positions: # Cross Checks
        if len(rows_involved) == 1: # Vertical Cross
            min_r_cross = r_new; max_r_cross = r_new;
            while min_r_cross > 0 and tiles[min_r_cross - 1][c_new]: min_r_cross -= 1;
            while max_r_cross < GRID_SIZE - 1 and tiles[max_r_cross + 1][c_new]: max_r_cross += 1
            if max_r_cross > min_r_cross: cross_word_v = "".join(tiles[r][c_new] for r in range(min_r_cross, max_r_cross + 1) if tiles[r][c_new]);
            if len(cross_word_v) > 1: words_found.add(cross_word_v)
        if len(cols_involved) == 1: # Horizontal Cross
            min_c_cross = c_new; max_c_cross = c_new;
            while min_c_cross > 0 and tiles[r_new][min_c_cross - 1]: min_c_cross -= 1;
            while max_c_cross < GRID_SIZE - 1 and tiles[r_new][max_c_cross + 1]: max_c_cross += 1
            if max_c_cross > min_c_cross: cross_word_h = "".join(tiles[r_new][c] for c in range(min_c_cross, max_c_cross + 1) if tiles[r_new][c]);
            if len(cross_word_h) > 1: words_found.add(cross_word_h)
    return list(words_found)

def get_remaining_tiles(rack, tiles, blanks):
    """Calculate the remaining tiles (excluding those on board and current player's rack)."""
    remaining = {letter: count for letter, (count, _) in TILE_DISTRIBUTION.items()}
    rack_counter = Counter(rack)
    for tile, count in rack_counter.items():
        if tile in remaining: remaining[tile] -= count
    for r in range(GRID_SIZE):
        for c in range(GRID_SIZE):
            if tiles[r][c]:
                if (r, c) in blanks:
                    if ' ' in remaining: remaining[' '] -= 1
                else:
                    letter = tiles[r][c]
                    if letter in remaining: remaining[letter] -= 1
    for letter in remaining: remaining[letter] = max(0, remaining[letter])
    return remaining

def draw_remaining_tiles(remaining, turn):
    """Draw the list of remaining tiles."""
    global practice_mode
    if practice_mode == "eight_letter": return # Don't draw remaining tiles in this mode
    remaining_x = min(BOARD_SIZE + 70, WINDOW_WIDTH - 200);
    if remaining_x < BOARD_SIZE + 10: remaining_x = BOARD_SIZE + 10
    title_text = ui_font.render(f"P{turn}'s Unseen Tiles:", True, BLACK); screen.blit(title_text, (remaining_x, 10))
    y_pos = 40; col_width = 60; max_y = WINDOW_HEIGHT - 100; sorted_letters = sorted(remaining.keys()); current_col_x = remaining_x; items_in_col = 0; max_items_per_col = (max_y - y_pos) // 20
    if max_items_per_col <= 0: max_items_per_col = 1
    last_drawn_y = 40 # Initialize with starting y_pos in case list is empty
    last_drawn_col_x = remaining_x # Track the column x of the last item

    for letter in sorted_letters:
        count = remaining.get(letter, 0)
        if count > 0:
            display_letter = "?" if letter == " " else letter; text_str = f"{display_letter}: {count}"; text = tile_count_font.render(text_str, True, BLACK)
            if items_in_col >= max_items_per_col:
                y_pos = 40 # Reset y_pos for the new column
                current_col_x += col_width
                items_in_col = 0
            screen.blit(text, (current_col_x, y_pos))
            last_drawn_y = y_pos # Update the last drawn y position in the current column
            last_drawn_col_x = current_col_x # Update the column x
            y_pos += 20; items_in_col += 1

    # Calculate summary position directly below the last drawn item's position
    # Add the height of one line (20) to get the position below it, plus a small gap (e.g., 5)
    summary_y_start = last_drawn_y + 20 + 5
    # Ensure it doesn't go off screen
    summary_y_start = min(summary_y_start, max_y + 40) # Use max_y for clamping

    total_tiles = sum(remaining.values()); vowels = sum(remaining.get(letter, 0) for letter in 'AEIOU'); consonants = sum(remaining.get(letter, 0) for letter in remaining if letter.isalpha() and letter not in 'AEIOU '); blanks_rem = remaining.get(' ', 0)
    text1 = tile_count_font.render(f"Tiles remaining: {total_tiles}", True, BLACK); text2 = tile_count_font.render(f"V: {vowels}  C: {consonants}  B: {blanks_rem}", True, BLACK)

    # Align summary text x-coordinate with the start of the list columns
    summary_x = remaining_x
    screen.blit(text1, (summary_x, summary_y_start));
    screen.blit(text2, (summary_x, summary_y_start + 20)) # Draw second line below first

def draw_arrow(row, col, direction):
    """Draw an arrow indicating play direction."""
    center_x = 40 + col * SQUARE_SIZE + SQUARE_SIZE // 2; center_y = 40 + row * SQUARE_SIZE + SQUARE_SIZE // 2; arrow_length = SQUARE_SIZE * 0.4; arrow_width = SQUARE_SIZE * 0.2
    if direction == "right": pygame.draw.line(screen, ARROW_COLOR, (center_x - arrow_length / 2, center_y), (center_x + arrow_length / 2, center_y), 3); pygame.draw.polygon(screen, ARROW_COLOR, [(center_x + arrow_length / 2, center_y - arrow_width / 2), (center_x + arrow_length / 2, center_y + arrow_width / 2), (center_x + arrow_length / 2 + arrow_width, center_y)])
    elif direction == "down": pygame.draw.line(screen, ARROW_COLOR, (center_x, center_y - arrow_length / 2), (center_x, center_y + arrow_length / 2), 3); pygame.draw.polygon(screen, ARROW_COLOR, [(center_x - arrow_width / 2, center_y + arrow_length / 2), (center_x + arrow_width / 2, center_y + arrow_length / 2), (center_x, center_y + arrow_length / 2 + arrow_width)])

def is_valid_play(word_positions, tiles, is_first_play, initial_rack_size, original_tiles, rack):
    """Validate a potential play against game rules and dictionary."""
    # word_positions here is the list of newly placed tiles: [(r, c, letter), ...]
    if not word_positions:
        # print("DEBUG is_valid_play: No word_positions provided.")
        return False, False

    newly_placed_positions_coords = set((r, c) for r, c, _ in word_positions)
    if not newly_placed_positions_coords:
        # print("DEBUG is_valid_play: No new tiles identified.")
        return False, False # No new tiles placed

    # --- Alignment and Gap Checks (remain the same) ---
    rows = sorted(list(set(r for r, _, _ in word_positions))); cols = sorted(list(set(c for _, c, _ in word_positions)))
    is_horizontal = len(rows) == 1; is_vertical = len(cols) == 1
    if not (is_horizontal or is_vertical):
        # print(f"DEBUG is_valid_play: Not aligned. Rows: {rows}, Cols: {cols}")
        return False, False # Not aligned

    # Check for gaps within the main line of play
    if is_horizontal:
        r = rows[0]; min_col = min(cols); max_col = max(cols)
        # Extend bounds to include adjacent existing tiles
        temp_min_col = min_col; temp_max_col = max_col
        while temp_min_col > 0 and tiles[r][temp_min_col - 1]: temp_min_col -= 1
        while temp_max_col < GRID_SIZE - 1 and tiles[r][temp_max_col + 1]: temp_max_col += 1
        # Check for empty squares within these bounds
        for c in range(temp_min_col, temp_max_col + 1):
            if not tiles[r][c]:
                # print(f"DEBUG is_valid_play: Gap found horizontally at ({r},{c})")
                return False, False # Gap found
    elif is_vertical:
        c = cols[0]; min_row = min(rows); max_row = max(rows)
        # Extend bounds
        temp_min_row = min_row; temp_max_row = max_row
        while temp_min_row > 0 and tiles[temp_min_row - 1][c]: temp_min_row -= 1
        while temp_max_row < GRID_SIZE - 1 and tiles[temp_max_row + 1][c]: temp_max_row += 1
        # Check for gaps
        for r in range(temp_min_row, temp_max_row + 1):
            if not tiles[r][c]:
                # print(f"DEBUG is_valid_play: Gap found vertically at ({r},{c})")
                return False, False # Gap found

    # --- Word Validity Check (Use find_all_words_formed) ---
    # Use the more robust function to find all words based on the newly placed tiles
    # It correctly handles single-tile placements forming cross-words.
    all_words_details = find_all_words_formed(word_positions, tiles)

    if not all_words_details:
         # This might happen if only a single letter was placed and it didn't connect
         # to form any word of length 2+ (already checked by connection rule below)
         # Or if find_all_words_formed has a bug.
         # Let's assume connection rule handles the first case.
         # If this triggers otherwise, it indicates an issue.
         # print(f"DEBUG is_valid_play: find_all_words_formed returned empty list for {word_positions}")
         # We might need a connection check *before* this word check?
         pass # Continue to connection check

    formed_word_strings = ["".join(tile[2] for tile in word_detail) for word_detail in all_words_details]

    if not formed_word_strings and len(word_positions) > 1: # If multiple tiles placed but no words formed -> invalid
         # print(f"DEBUG is_valid_play: Multiple tiles placed but no words formed: {word_positions}")
         return False, False

    # Check each formed word string against the DAWG
    for word in formed_word_strings:
        if not DAWG.search(word):
            # print(f"DEBUG is_valid_play: Word '{word}' not in DAWG.")
            return False, False # Word not in dictionary

    # --- Connection Rules Check (remain the same) ---
    if is_first_play:
        if CENTER_SQUARE not in newly_placed_positions_coords:
            # print("DEBUG is_valid_play: First play not on center square.")
            return False, False
    else:
        connects = False
        for r, c in newly_placed_positions_coords:
            for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < GRID_SIZE and 0 <= nc < GRID_SIZE and original_tiles[nr][nc]:
                    connects = True; break
            if connects: break
        if not connects:
            # print("DEBUG is_valid_play: Play does not connect to existing tiles.")
            return False, False

    # --- Bingo Check (remains the same) ---
    tiles_played_from_rack = len(newly_placed_positions_coords)
    is_bingo = (initial_rack_size == 7 and tiles_played_from_rack == 7)

    # If all checks passed
    return True, is_bingo

def get_anchor_points(tiles, is_first_play):
    """Get anchor points (empty squares adjacent to existing tiles) for valid moves."""
    anchors = set()
    if is_first_play: anchors.add(CENTER_SQUARE); return anchors
    has_tiles = False
    for r in range(GRID_SIZE):
        for c in range(GRID_SIZE):
            if tiles[r][c]: has_tiles = True # Check if board has any tiles
            if not tiles[r][c]: # Must be an empty square
                 is_anchor = False
                 for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
                     nr, nc = r + dr, c + dc
                     if 0 <= nr < GRID_SIZE and 0 <= nc < GRID_SIZE and tiles[nr][nc]: is_anchor = True; break
                 if is_anchor: anchors.add((r, c))
    if not has_tiles and not is_first_play: anchors.add(CENTER_SQUARE) # Fallback if board empty but not first play
    return anchors

# End of Part 4

# python
# MODIFIED: 01APR24 - Implementing 8-Letter Bingo Practice Mode Fixes (Part 5 - Corrected Attribute Name)

# Part 5

# --- NEW Move Generation (Based on kamilmielnik/scrabble-solver principles) ---
# --- NEW Move Generation (Based on kamilmielnik/scrabble-solver principles - REVISED) ---

# --- GADDAG-Based Move Generation (Replaces generate_valid_moves_new) ---

# --- GADDAG-Based Move Generation (Replaces generate_valid_moves_new and its helpers) ---

# --- GADDAG-Based Move Generation (Replaces generate_valid_moves_new and its helpers) ---

# --- GADDAG-Based Move Generation (Replaces generate_valid_moves_new and its helpers) ---

# Function to Modify: _gaddag_traverse (Refined post-separator logic)

def _gaddag_traverse(
    anchor_pos, rack_counts, tiles, board, blanks, cross_check_sets, gaddag_node,
    current_word_tiles, is_reversed, current_axis, all_found_moves, unique_move_signatures,
    original_tiles_state, is_first_play, full_rack_size, max_len=GRID_SIZE,
    depth=0
):
    """ Recursive helper with refined post-separator logic """
    # Limit recursion depth for safety and logging
    if depth > 20: return

    # --- Base Cases and Pruning ---
    if not current_word_tiles: return
    if len(current_word_tiles) > max_len: return

    # Get the last tile added for step calculation (but might need anchor later)
    r_last, c_last, _, _, _ = current_word_tiles[-1]

    # --- Check if current path forms a valid move ---
    # (Validation logic remains the same as previous version with diagnostic prints)
    if gaddag_node.is_terminal and not is_reversed:
        # ... (validation code identical to previous response) ...
        # Find newly placed tiles
        newly_placed_list_details = [(r, c, l) for r, c, l, _, is_new in current_word_tiles if is_new]
        if newly_placed_list_details:
            new_tiles_sig = tuple(sorted(newly_placed_list_details))
            if new_tiles_sig not in unique_move_signatures:
                # Simulate placement for validation
                temp_tiles = [row[:] for row in original_tiles_state]
                temp_blanks = set(blanks); move_blanks_coords = set(); newly_placed_coords = set()
                for r, c, letter, is_blank, is_new in current_word_tiles:
                    if is_new:
                        if 0 <= r < GRID_SIZE and 0 <= c < GRID_SIZE:
                            temp_tiles[r][c] = letter; newly_placed_coords.add((r, c))
                            if is_blank: temp_blanks.add((r, c)); move_blanks_coords.add((r, c))

                # Use the ORIGINAL is_valid_play now (remove diagnostic version)
                is_valid, is_bingo = is_valid_play(newly_placed_list_details, temp_tiles, is_first_play, full_rack_size, original_tiles_state, rack_counts) # Pass original_tiles_state

                if is_valid:
                    unique_move_signatures.add(new_tiles_sig) # Mark as found
                    score = calculate_score(newly_placed_list_details, board, temp_tiles, temp_blanks)
                    all_words_formed_details = find_all_words_formed(newly_placed_list_details, temp_tiles)
                    # ... (rest of move detail extraction identical to previous response) ...
                    primary_word_tiles = []; primary_word_str = ""; start_pos = (0, 0); orientation = current_axis
                    if all_words_formed_details:
                        # ... (primary word finding logic) ...
                         found_primary = False
                         for word_detail in all_words_formed_details:
                             is_along_axis = False
                             if orientation == 'H' and len(set(r for r,c,l in word_detail)) == 1: is_along_axis = True
                             elif orientation == 'V' and len(set(c for r,c,l in word_detail)) == 1: is_along_axis = True
                             if is_along_axis and any((t[0], t[1]) in newly_placed_coords for t in word_detail):
                                 primary_word_tiles = word_detail; found_primary = True; break
                         if not found_primary: # Fallback
                              for word_detail in all_words_formed_details:
                                  if any((t[0], t[1]) in newly_placed_coords for t in word_detail):
                                       primary_word_tiles = word_detail
                                       if len(set(r for r,c,l in primary_word_tiles)) == 1: orientation = 'H'
                                       elif len(set(c for r,c,l in primary_word_tiles)) == 1: orientation = 'V'
                                       break
                         if not primary_word_tiles and all_words_formed_details: # Extreme fallback
                              primary_word_tiles = all_words_formed_details[0]
                              if len(set(r for r,c,l in primary_word_tiles)) == 1: orientation = 'H'
                              elif len(set(c for r,c,l in primary_word_tiles)) == 1: orientation = 'V'

                         if primary_word_tiles: # Check added
                             primary_word_str = "".join(t[2] for t in primary_word_tiles)
                             start_pos = (primary_word_tiles[0][0], primary_word_tiles[0][1])
                    # ... (word_with_blanks formatting) ...
                    word_with_blanks_list = []
                    for wr, wc, w_letter in primary_word_tiles:
                        is_blank_in_word = (wr, wc) in newly_placed_coords and (wr, wc) in move_blanks_coords
                        word_with_blanks_list.append(w_letter.lower() if is_blank_in_word else w_letter.upper())
                    word_with_blanks = "".join(word_with_blanks_list)
                    leave = list(rack_counts.elements()) # Current rack count is the leave
                    # ... (store move details) ...
                    move_details_dict = {
                        'positions': [(t[0], t[1], t[2]) for t in primary_word_tiles], 'blanks': move_blanks_coords,
                        'word': primary_word_str, 'score': score, 'start': start_pos, 'direction': orientation,
                        'leave': leave, 'is_bingo': is_bingo, 'word_with_blanks': word_with_blanks,
                        'newly_placed': newly_placed_list_details
                    }
                    all_found_moves.append(move_details_dict)


    # --- Explore Next Steps ---
    for letter, next_node in gaddag_node.children.items():
        if letter == Gaddag.SEPARATOR:
            if is_reversed:
                # When crossing the separator, the *anchor position* becomes the reference
                # for the next step calculation in the forward direction.
                # We pass the anchor_pos implicitly; the logic needs to use it.
                # We pass current_word_tiles as is, because it contains the history.
                _gaddag_traverse(
                    anchor_pos, rack_counts, tiles, board, blanks, cross_check_sets,
                    next_node, current_word_tiles, False, current_axis, # Switch is_reversed
                    all_found_moves, unique_move_signatures, original_tiles_state,
                    is_first_play, full_rack_size, max_len, depth + 1
                )
            continue # Move to next child

        # Determine next coordinates
        next_r, next_c = -1, -1
        if is_reversed:
             # Moving backward from the last placed tile (r_last, c_last)
            if current_axis == 'H': next_r, next_c = r_last, c_last - 1 # Left
            else:                   next_r, next_c = r_last - 1, c_last # Up
        else: # Moving forward
            # **** CORRECTED LOGIC ****
            # If current_word_tiles only contains the anchor tile (or tiles placed *before* it),
            # the first step *forward* must be relative to the anchor_pos.
            # Otherwise, step forward from the last placed tile (r_last, c_last).

            # Check if the anchor position is the last element added *or* if all tiles were placed before anchor
            # A simple check: is the anchor position the first tile in our list (and maybe the only one)?
            # A better check: find the tile actually placed *on* the anchor square.
            anchor_r, anchor_c = anchor_pos
            tile_on_anchor = None
            for t_r, t_c, t_l, t_b, t_n in current_word_tiles:
                 if t_r == anchor_r and t_c == anchor_c:
                      tile_on_anchor = (t_r, t_c)
                      break

            # If we haven't placed anything *after* the anchor yet, step from the anchor
            # This happens immediately after crossing the separator.
            # How to detect this? If the last tile added IS the tile_on_anchor
            # or if all tiles were added when is_reversed was True?
            # Let's use the anchor_pos directly as the reference point
            # for the first step in the forward direction.

            # Heuristic: If the last tile's coordinates are the same as the anchor,
            # then the next step must be the first step *away* from the anchor.
            # What if multiple tiles were placed reversed? The last tile isn't the anchor.
            # --> Need a robust way to know if we are taking the *first* step forward.

            # Let's track if we JUST crossed the separator. A simple way is if the last tile
            # added was before or at the anchor point based on axis and anchor coords.
            just_crossed_separator = False
            if len(current_word_tiles) > 0:
                if current_axis == 'H':
                    if c_last <= anchor_c: just_crossed_separator = True
                else: # Vertical
                    if r_last <= anchor_r: just_crossed_separator = True

            # Use anchor as reference ONLY if we just crossed separator, otherwise use last tile
            ref_r, ref_c = (anchor_r, anchor_c) if just_crossed_separator else (r_last, c_last)

            if current_axis == 'H': next_r, next_c = ref_r, ref_c + 1 # Move right
            else:                   next_r, next_c = ref_r + 1, ref_c # Move down
            # **** END CORRECTED LOGIC ****


        # Bounds check
        if not (0 <= next_r < GRID_SIZE and 0 <= next_c < GRID_SIZE): continue

        next_pos = (next_r, next_c)
        existing_tile = tiles[next_r][next_c]

        # Case 1: Square is empty
        # (Rest of logic for placing rack/blank or using existing tile remains the same)
        if not existing_tile:
            cross_axis = 'V' if current_axis == 'H' else 'H'
            allowed_letters = cross_check_sets.get(next_pos, {}).get(cross_axis, set())
            # Option 1a: Use regular tile
            if rack_counts[letter] > 0 and letter in allowed_letters:
                new_rack_counts = rack_counts.copy(); new_rack_counts[letter] -= 1
                if new_rack_counts[letter] == 0: del new_rack_counts[letter]
                _gaddag_traverse(
                    anchor_pos, new_rack_counts, tiles, board, blanks, cross_check_sets,
                    next_node, current_word_tiles + [(next_r, next_c, letter, False, True)],
                    is_reversed, current_axis, all_found_moves, unique_move_signatures,
                    original_tiles_state, is_first_play, full_rack_size, max_len, depth + 1
                )
            # Option 1b: Use blank tile
            if rack_counts[' '] > 0 and ' ' in allowed_letters:
                new_rack_counts = rack_counts.copy(); new_rack_counts[' '] -= 1
                if new_rack_counts[' '] == 0: del new_rack_counts[' ']
                _gaddag_traverse(
                    anchor_pos, new_rack_counts, tiles, board, blanks, cross_check_sets,
                    next_node, current_word_tiles + [(next_r, next_c, letter, True, True)],
                    is_reversed, current_axis, all_found_moves, unique_move_signatures,
                    original_tiles_state, is_first_play, full_rack_size, max_len, depth + 1
                )
        # Case 2: Square has matching existing tile
        elif existing_tile == letter:
            _gaddag_traverse(
                anchor_pos, rack_counts, tiles, board, blanks, cross_check_sets,
                next_node, current_word_tiles + [(next_r, next_c, letter, False, False)],
                is_reversed, current_axis, all_found_moves, unique_move_signatures,
                original_tiles_state, is_first_play, full_rack_size, max_len, depth + 1
            )

# Function to Replace: generate_all_moves_gaddag
# REASON: Includes corrected initiation logic for Strategy 2 (essential for general cases)
#         and reviewed logic for Strategy 1 (intended to handle first play).

def generate_all_moves_gaddag(rack, tiles, board, blanks, gaddag_root):
    """
    Generates ALL valid Scrabble moves using GADDAG traversal.
    Initiates the traversal from anchor points and adjacent existing tiles.
    Includes corrected Strategy 2 initiation.
    """
    print(f"--- generate_all_moves_gaddag called. Rack: {''.join(sorted(rack))} ---") # Sort rack for consistent logging
    if not gaddag_root:
        print("ERROR: GADDAG structure not loaded.")
        return []

    all_found_moves = []
    unique_move_signatures = set() # Tracks signatures (new_r, new_c, new_l) to avoid adding identical plays
    rack_counts = Counter(rack)
    is_first_play = sum(1 for row in tiles for t in row if t) == 0
    anchors = get_anchor_points(tiles, is_first_play)
    print(f"--- generate_all_moves_gaddag: Found anchors: {anchors} ---")
    original_tiles_state = [row[:] for row in tiles] # Keep a safe copy
    full_rack_size = len(rack) # Needed for bingo check

    # --- Precompute Cross-Check Sets ---
    print("--- generate_all_moves_gaddag: Generating cross-check sets... ---")
    cross_check_sets = {}
    for r in range(GRID_SIZE):
        for c in range(GRID_SIZE):
            if not tiles[r][c]: # Only needed for empty squares
                # Check Vertical context
                up_word = ""; rr = r - 1
                while rr >= 0 and tiles[rr][c]: up_word = tiles[rr][c] + up_word; rr -= 1
                down_word = ""; rr = r + 1
                while rr < GRID_SIZE and tiles[rr][c]: down_word += tiles[rr][c]; rr += 1
                allowed_letters_v = set()
                if not up_word and not down_word: allowed_letters_v = set('ABCDEFGHIJKLMNOPQRSTUVWXYZ ')
                else:
                    for letter in 'ABCDEFGHIJKLMNOPQRSTUVWXYZ':
                        if DAWG.search(up_word + letter + down_word): allowed_letters_v.add(letter)
                    if allowed_letters_v: allowed_letters_v.add(' ')

                # Check Horizontal context
                left_word = ""; cc = c - 1
                while cc >= 0 and tiles[r][cc]: left_word = tiles[r][cc] + left_word; cc -= 1
                right_word = ""; cc = c + 1
                while cc < GRID_SIZE and tiles[r][cc]: right_word += tiles[r][cc]; cc += 1
                allowed_letters_h = set()
                if not left_word and not right_word: allowed_letters_h = set('ABCDEFGHIJKLMNOPQRSTUVWXYZ ')
                else:
                    for letter in 'ABCDEFGHIJKLMNOPQRSTUVWXYZ':
                        if DAWG.search(left_word + letter + right_word): allowed_letters_h.add(letter)
                    if allowed_letters_h: allowed_letters_h.add(' ')

                cross_check_sets[(r, c)] = {'V': allowed_letters_v, 'H': allowed_letters_h}
    print("--- generate_all_moves_gaddag: Cross-check sets generated. ---")

    # --- Initiate Traversal from Each Anchor ---
    print("--- generate_all_moves_gaddag: Starting traversal... ---")
    processed_adjacent_starts = set() # Prevent redundant starts *from the same adjacent tile* for different anchors

    for r_anchor, c_anchor in anchors:
        anchor_pos = (r_anchor, c_anchor)

        # --- Strategy 1: Place the first letter *on* the anchor square itself ---
        # This is the primary strategy for the first move of the game.
        allowed_h = cross_check_sets.get(anchor_pos, {}).get('H', set())
        allowed_v = cross_check_sets.get(anchor_pos, {}).get('V', set())
        # Try placing regular tiles from rack onto the anchor
        for tile_letter, count in list(rack_counts.items()):
            if count > 0 and tile_letter != ' ':
                if tile_letter in gaddag_root.children:
                    next_node = gaddag_root.children[tile_letter]
                    # Create a fresh copy for each starting path
                    new_rack_counts = rack_counts.copy(); new_rack_counts[tile_letter] -= 1
                    if new_rack_counts[tile_letter] == 0: del new_rack_counts[tile_letter]
                    initial_tiles = [(r_anchor, c_anchor, tile_letter, False, True)]
                    # Initiate HORIZONTAL exploration (checks Vertical cross-check)
                    if tile_letter in allowed_v:
                         # Pass a copy of the rack counter
                         _gaddag_traverse(anchor_pos, new_rack_counts.copy(), tiles, board, blanks, cross_check_sets, next_node, initial_tiles, True, 'H', all_found_moves, unique_move_signatures, original_tiles_state, is_first_play, full_rack_size)
                    # Initiate VERTICAL exploration (checks Horizontal cross-check)
                    if tile_letter in allowed_h:
                         # Pass a copy of the rack counter
                         _gaddag_traverse(anchor_pos, new_rack_counts.copy(), tiles, board, blanks, cross_check_sets, next_node, initial_tiles, True, 'V', all_found_moves, unique_move_signatures, original_tiles_state, is_first_play, full_rack_size)
        # Try placing a blank tile from rack onto the anchor
        if rack_counts[' '] > 0:
            if ' ' in allowed_h and ' ' in allowed_v:
                # Create a base rack count with blank removed
                new_rack_counts_blank_base = rack_counts.copy(); new_rack_counts_blank_base[' '] -= 1
                if new_rack_counts_blank_base[' '] == 0: del new_rack_counts_blank_base[' ']

                for assigned_letter in 'ABCDEFGHIJKLMNOPQRSTUVWXYZ':
                    if assigned_letter in gaddag_root.children:
                        next_node = gaddag_root.children[assigned_letter]
                        initial_tiles = [(r_anchor, c_anchor, assigned_letter, True, True)]
                        # Initiate HORIZONTAL exploration
                        # Pass a copy for this branch
                        _gaddag_traverse(anchor_pos, new_rack_counts_blank_base.copy(), tiles, board, blanks, cross_check_sets, next_node, initial_tiles, True, 'H', all_found_moves, unique_move_signatures, original_tiles_state, is_first_play, full_rack_size)
                        # Initiate VERTICAL exploration
                        # Pass a copy for this branch
                        _gaddag_traverse(anchor_pos, new_rack_counts_blank_base.copy(), tiles, board, blanks, cross_check_sets, next_node, initial_tiles, True, 'V', all_found_moves, unique_move_signatures, original_tiles_state, is_first_play, full_rack_size)


        # --- Strategy 2: Start traversal from an *existing* tile adjacent to the anchor ---
        # This strategy only applies if not the first play (anchors != {(7,7)})
        if not is_first_play:
            for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]: # Check N, S, W, E neighbors
                nr, nc = r_anchor + dr, c_anchor + dc
                adj_pos = (nr, nc) # Position of the adjacent tile

                if 0 <= nr < GRID_SIZE and 0 <= nc < GRID_SIZE:
                    existing_tile_letter = tiles[nr][nc]
                    # Check if it's an existing tile AND we haven't already started traversals from this specific tile position
                    if existing_tile_letter and adj_pos not in processed_adjacent_starts:
                         # Mark this adjacent tile as processed FOR THIS generate_all_moves call
                         # to avoid redundant work if it's adjacent to multiple anchors.
                         processed_adjacent_starts.add(adj_pos)

                         if existing_tile_letter in gaddag_root.children:
                            next_node = gaddag_root.children[existing_tile_letter]
                            initial_tiles = [(nr, nc, existing_tile_letter, False, False)] # Existing tile is not blank, not new

                            # Determine the axis based on the direction *from* the existing tile *to* the anchor
                            start_axis = None
                            if dr != 0: start_axis = 'V' # Moved vertically to anchor, so word axis is Vertical
                            else:       start_axis = 'H' # Moved horizontally to anchor, so word axis is Horizontal

                            # **** Explore both directions from the adjacent tile ****
                            # Explore FORWARDS (away from existing tile, past the anchor)
                            _gaddag_traverse(
                                anchor_pos, rack_counts.copy(), tiles, board, blanks, cross_check_sets, # Pass copy of rack_counts
                                next_node, initial_tiles[:], False, start_axis, # is_reversed = False
                                all_found_moves, unique_move_signatures, original_tiles_state,
                                is_first_play, full_rack_size
                            )
                            # Explore BACKWARDS (towards where the existing tile came from - effectively extending the other way)
                            _gaddag_traverse(
                                anchor_pos, rack_counts.copy(), tiles, board, blanks, cross_check_sets, # Pass copy of rack_counts
                                next_node, initial_tiles[:], True, start_axis, # is_reversed = True
                                all_found_moves, unique_move_signatures, original_tiles_state,
                                is_first_play, full_rack_size
                            )


    print(f"--- generate_all_moves_gaddag: Traversal complete. Found {len(all_found_moves)} potential moves before sorting/final check. ---")

    # --- Post-processing ---
    all_found_moves.sort(key=lambda m: m['score'], reverse=True)
    final_unique_moves = []
    seen_final_signatures = set()
    for move in all_found_moves:
        # Signature includes sorted new tiles tuple + score
        sig_tuple = tuple(sorted(move['newly_placed'])) + (move['score'],)
        if sig_tuple not in seen_final_signatures:
            final_unique_moves.append(move)
            seen_final_signatures.add(sig_tuple)

    print(f"--- generate_all_moves_gaddag: Returning {len(final_unique_moves)} unique moves. ---")
    return final_unique_moves


# Corrected snippet for Part 5 - draw_hint_dialog

# --- Hint Dialog ---
def draw_hint_dialog(moves, selected_index):
    """Draw the hint dialog showing top 5 moves."""
    dialog_width, dialog_height = 400, 250
    dialog_x = (WINDOW_WIDTH - dialog_width) // 2
    dialog_y = (WINDOW_HEIGHT - dialog_height) // 2

    pygame.draw.rect(screen, DIALOG_COLOR, (dialog_x, dialog_y, dialog_width, dialog_height))
    pygame.draw.rect(screen, BLACK, (dialog_x, dialog_y, dialog_width, dialog_height), 2)

    title_text = dialog_font.render("Top 5 Moves" if moves else "No Moves Available", True, BLACK)
    screen.blit(title_text, (dialog_x + 10, dialog_y + 10))

    hint_rects = []
    y_pos = dialog_y + 40
    for i, move in enumerate(moves[:5]):
        color = HINT_SELECTED_COLOR if i == selected_index else HINT_NORMAL_COLOR
        rect = pygame.Rect(dialog_x + 10, y_pos, dialog_width - 20, 30)
        pygame.draw.rect(screen, color, rect)

        word = move.get('word', 'N/A')
        score = move.get('score', 0)
        start_pos = move.get('start', (0,0))
        direction = move.get('direction', 'right')
        leave = move.get('leave', [])
        word_display = move.get('word_with_blanks', word.upper()) # Use formatted word
        coord = get_coord(start_pos, direction)
        leave_str = ''.join(sorted(l if l != ' ' else '?' for l in leave))

        text_str = f"{i+1}. {word_display} ({score} pts) at {coord} ({leave_str})"
        text = ui_font.render(text_str, True, BLACK)

        # Truncate text if too wide
        max_text_width = rect.width - 10
        if text.get_width() > max_text_width:
             avg_char_width = text.get_width() / len(text_str) if len(text_str) > 0 else 10
             # Ensure avg_char_width is not zero to avoid division error
             if avg_char_width > 0:
                 max_chars = int(max_text_width / avg_char_width) - 3 # Calculate max_chars
                 # --- CORRECTED INDENTATION START ---
                 if max_chars < 5: # Check if max_chars is too small
                     max_chars = 5
                 text_str = text_str[:max_chars] + "..." # Truncate and add ellipsis
                 text = ui_font.render(text_str, True, BLACK) # Re-render the truncated text
                 # --- CORRECTED INDENTATION END ---
             # else: # Handle case where avg_char_width is 0 (e.g., empty text_str) - text won't be truncated anyway
             #    pass

        screen.blit(text, (dialog_x + 15, y_pos + 5))
        hint_rects.append(rect)
        y_pos += 30

    # Buttons
    button_y = dialog_y + dialog_height - BUTTON_HEIGHT - 10
    total_button_width = 3 * BUTTON_WIDTH + 2 * BUTTON_GAP
    button_start_x = dialog_x + (dialog_width - total_button_width) // 2

    play_button_rect = pygame.Rect(button_start_x, button_y, BUTTON_WIDTH, BUTTON_HEIGHT)
    all_words_button_rect = pygame.Rect(button_start_x + BUTTON_WIDTH + BUTTON_GAP, button_y, BUTTON_WIDTH, BUTTON_HEIGHT)
    ok_button_rect = pygame.Rect(button_start_x + 2 * (BUTTON_WIDTH + BUTTON_GAP), button_y, BUTTON_WIDTH, BUTTON_HEIGHT)

    # Draw buttons
    pygame.draw.rect(screen, BUTTON_COLOR, play_button_rect)
    pygame.draw.rect(screen, BUTTON_COLOR, all_words_button_rect)
    pygame.draw.rect(screen, BUTTON_COLOR, ok_button_rect)

    play_text = button_font.render("Play", True, BLACK)
    all_words_text = button_font.render("All Words", True, BLACK)
    ok_text = button_font.render("OK", True, BLACK)

    screen.blit(play_text, play_text.get_rect(center=play_button_rect.center))
    screen.blit(all_words_text, all_words_text.get_rect(center=all_words_button_rect.center))
    screen.blit(ok_text, ok_text.get_rect(center=ok_button_rect.center))

    return hint_rects, play_button_rect, ok_button_rect, all_words_button_rect

# End of Part 5

# python
# MODIFIED: 01APR24 - Implementing 8-Letter Bingo Practice Mode Fixes (Part 6)

# python
# MODIFIED: 01APR24 - Implementing 8-Letter Bingo Practice Mode Fixes (Part 6 - Corrected Function Call)

# Part 6

def draw_all_words_dialog(moves, selected_index, scroll_offset):
    """Draw the dialog showing all valid moves with scrolling."""
    dialog_x = (WINDOW_WIDTH - ALL_WORDS_DIALOG_WIDTH) // 2; dialog_y = (WINDOW_HEIGHT - ALL_WORDS_DIALOG_HEIGHT) // 2
    pygame.draw.rect(screen, DIALOG_COLOR, (dialog_x, dialog_y, ALL_WORDS_DIALOG_WIDTH, ALL_WORDS_DIALOG_HEIGHT)); pygame.draw.rect(screen, BLACK, (dialog_x, dialog_y, ALL_WORDS_DIALOG_WIDTH, ALL_WORDS_DIALOG_HEIGHT), 2)
    header_height = 40; unique_words_count = len(set(move.get('word', '') for move in moves if move.get('word'))); title_text = dialog_font.render(f"All Valid Moves ({unique_words_count} unique words, {len(moves)} plays)", True, BLACK); screen.blit(title_text, (dialog_x + 10, dialog_y + 10))
    content_area_y = dialog_y + header_height; button_area_height = BUTTON_HEIGHT + 30; content_area_height = ALL_WORDS_DIALOG_HEIGHT - header_height - button_area_height; content_area_rect = pygame.Rect(dialog_x, content_area_y, ALL_WORDS_DIALOG_WIDTH, content_area_height)
    content_height = len(moves) * 30; content_surface_width = max(1, ALL_WORDS_DIALOG_WIDTH - 20); content_surface = pygame.Surface((content_surface_width, content_height)); content_surface.fill(DIALOG_COLOR)
    all_words_rects = []; item_height = 30
    for i, move in enumerate(moves):
        y_pos_on_surface = i * item_height
        if y_pos_on_surface >= scroll_offset - item_height and y_pos_on_surface < scroll_offset + content_area_height:
            color = HINT_SELECTED_COLOR if i == selected_index else HINT_NORMAL_COLOR; rect_on_surface = pygame.Rect(10, y_pos_on_surface, content_surface_width - 20, item_height); pygame.draw.rect(content_surface, color, rect_on_surface)
            word = move.get('word', 'N/A'); score = move.get('score', 0); start_pos = move.get('start', (0,0)); direction = move.get('direction', 'right'); leave = move.get('leave', []); word_display = move.get('word_with_blanks', word.upper())
            coord = get_coord(start_pos, direction); leave_str = ''.join(sorted(l if l != ' ' else '?' for l in leave)); text_str = f"{i+1}. {word_display} ({score} pts) at {coord} ({leave_str})"; text = ui_font.render(text_str, True, BLACK)
            max_text_width = rect_on_surface.width - 10 # Truncate text

            # --- CORRECTED INDENTATION BLOCK START ---
            if text.get_width() > max_text_width:
                avg_char_width = text.get_width() / len(text_str) if len(text_str) > 0 else 10
                if avg_char_width > 0:
                    max_chars = int(max_text_width / avg_char_width) - 3
                    if max_chars < 5: max_chars = 5 # Ensure at least a few chars show
                    text_str = text_str[:max_chars] + "..."
                    text = ui_font.render(text_str, True, BLACK) # Re-render truncated text
                # else: # Handle case where avg_char_width is 0 (e.g., empty text_str) - text won't be truncated anyway
                #    pass
            # --- CORRECTED INDENTATION BLOCK END ---

            content_surface.blit(text, (15, y_pos_on_surface + 5))
            screen_y = content_area_y + y_pos_on_surface - scroll_offset; screen_rect = pygame.Rect(dialog_x + 10, screen_y, content_surface_width - 20, item_height)
            visible_top = content_area_y; visible_bottom = content_area_y + content_area_height; clipped_top = max(visible_top, screen_rect.top); clipped_bottom = min(visible_bottom, screen_rect.bottom)
            if clipped_bottom > clipped_top: clipped_rect = pygame.Rect(screen_rect.left, clipped_top, screen_rect.width, clipped_bottom - clipped_top); all_words_rects.append((clipped_rect, i))

    visible_area_on_surface = pygame.Rect(0, scroll_offset, content_surface_width, content_area_height); screen.blit(content_surface, (dialog_x + 10, content_area_y), visible_area_on_surface)
    pygame.draw.rect(screen, BLACK, (dialog_x + 10, content_area_y, content_surface_width, content_area_height), 1) # Optional border
    total_button_width = 2 * BUTTON_WIDTH + BUTTON_GAP; buttons_x = dialog_x + (ALL_WORDS_DIALOG_WIDTH - total_button_width) // 2; button_y = dialog_y + ALL_WORDS_DIALOG_HEIGHT - BUTTON_HEIGHT - 20
    play_button_rect = pygame.Rect(buttons_x, button_y, BUTTON_WIDTH, BUTTON_HEIGHT); ok_button_rect = pygame.Rect(buttons_x + BUTTON_WIDTH + BUTTON_GAP, button_y, BUTTON_WIDTH, BUTTON_HEIGHT)
    pygame.draw.rect(screen, BUTTON_COLOR, play_button_rect); pygame.draw.rect(screen, BUTTON_COLOR, ok_button_rect)
    play_text = button_font.render("Play", True, BLACK); ok_text = button_font.render("OK", True, BLACK)
    screen.blit(play_text, play_text.get_rect(center=play_button_rect.center)); screen.blit(ok_text, ok_text.get_rect(center=ok_button_rect.center))
    return all_words_rects, play_button_rect, ok_button_rect

# --- Mouse/Tile Interaction Helpers ---
# get_tile_under_mouse, get_insertion_index, count_consecutive_existing (Unchanged from Part 6 provided previously)
def get_tile_under_mouse(x, y, rack_start_x, rack_y, rack_len):
    """Determine which tile index (0 to rack_len-1) is under the mouse cursor."""
    # Iterate through each potential tile position on the rack
    for i in range(rack_len):
        # Calculate the x-coordinate for the current tile
        tile_x = rack_start_x + i * (TILE_WIDTH + TILE_GAP)
        # Create the rectangle for the current tile *inside* the loop
        tile_rect = pygame.Rect(tile_x, rack_y, TILE_WIDTH, TILE_HEIGHT)
        # Check if the mouse coordinates collide with this specific tile's rectangle *inside* the loop
        if tile_rect.collidepoint(x, y):
            return i # Return the index of the collided tile immediately
    # If the loop finishes without finding any collision (or if rack_len was 0), return None
    return None

def get_insertion_index(x, rack_start_x, rack_len):
    """Determine the insertion index (0 to rack_len) based on mouse x-position."""
    if x < rack_start_x + TILE_WIDTH // 2: return 0
    for i in range(rack_len): tile_left = rack_start_x + i * (TILE_WIDTH + TILE_GAP); gap_center = tile_left + TILE_WIDTH + TILE_GAP // 2;
    if x < gap_center: return i + 1
    return rack_len

def count_consecutive_existing(row, col, direction, tiles):
    """Count consecutive existing tiles in a direction (unused currently)."""
    count = 0
    if direction == "right": c = col;
    while c < GRID_SIZE and tiles[row][c]: count += 1; c += 1
    else: r = row;
    while r < GRID_SIZE and tiles[r][col]: count += 1; r += 1
    return count

# New function to handle end-of-game score adjustments
def calculate_final_scores(current_scores, racks, bag):
    """
    Calculates the final scores based on game end conditions and remaining tiles.

    Args:
        current_scores (list): List containing the scores of [Player1, Player2] before adjustments.
        racks (list): List containing the tile lists for [Player1's rack, Player2's rack].
        bag (list): The list representing the tile bag.

    Returns:
        list: A new list containing the final adjusted scores for [Player1, Player2].
    """
    final_scores = list(current_scores) # Start with a copy of current scores
    rack_values = [0, 0]

    # Calculate the value of tiles left on each rack (blanks count as 0)
    for i in range(2):
        if i < len(racks) and racks[i]: # Check if rack exists and is not None
             rack_values[i] = sum(TILE_DISTRIBUTION[tile][1] for tile in racks[i] if tile != ' ')
        # else: rack_values[i] remains 0

    # Determine if a player went out (must have empty rack AND bag must be empty)
    p1_out = (not racks[0]) and (not bag)
    p2_out = (not racks[1]) and (not bag)

    if p1_out:
        print("Final Score Adjust: P1 went out.")
        # Player 1 went out: Add double Player 2's remaining tile value to P1's score. P2 score unchanged.
        adjustment = 2 * rack_values[1]
        final_scores[0] += adjustment
        # final_scores[1] remains unchanged
        print(f"  P2 tiles value: {rack_values[1]}, P1 adjustment: +{adjustment}")
    elif p2_out:
        print("Final Score Adjust: P2 went out.")
        # Player 2 went out: Add double Player 1's remaining tile value to P2's score. P1 score unchanged.
        adjustment = 2 * rack_values[0]
        final_scores[1] += adjustment
        # final_scores[0] remains unchanged
        print(f"  P1 tiles value: {rack_values[0]}, P2 adjustment: +{adjustment}")
    else:
        # Neither player went out: Subtract each player's own remaining tile value from their score.
        print("Final Score Adjust: Neither player went out.")
        final_scores[0] -= rack_values[0]
        final_scores[1] -= rack_values[1]
        print(f"  P1 adjustment: -{rack_values[0]}, P2 adjustment: -{rack_values[1]}")

    print(f"  Scores before: {current_scores}, Scores after: {final_scores}")
    return final_scores


# --- Playing Moves ---
# Function to Modify: play_hint_move
# REASON: Added sorting of the rack *after* drawing new tiles.

# Function to Modify: play_hint_move
# REASON: Re-added sorting of the rack *after* drawing new tiles for human players.

# Function to Modify: play_hint_move
# REASON: Added sorting of the rack *after* drawing new tiles for human players.

def play_hint_move(move, tiles, racks, blanks, scores, turn, bag, board):
    """Plays a move (usually from hint/AI), updates state. Handles practice mode. Sorts human rack."""
    global practice_mode, is_ai # Need is_ai to check if player is human

    player_idx = turn - 1
    if not (0 <= player_idx < len(racks)):
        print(f"Error: Invalid player index {player_idx} in play_hint_move.")
        return turn, [], []

    current_rack = racks[player_idx]
    move_positions = move.get('positions', [])
    move_blanks_coords = move.get('blanks', set())
    newly_placed_details = move.get('newly_placed', [])

    # --- Verification ---
    needed_tiles = Counter()
    blanks_needed_count = 0
    for r, c, letter in newly_placed_details:
        if (r, c) in move_blanks_coords: blanks_needed_count += 1
        else: needed_tiles[letter] += 1
    rack_counter = Counter(current_rack)
    if blanks_needed_count > rack_counter.get(' ', 0):
        print(f"Error playing move: Needs {blanks_needed_count} blanks, only {rack_counter.get(' ', 0)} available.")
        return turn, [], []
    for letter, count in needed_tiles.items():
        if rack_counter.get(letter, 0) < count:
            print(f"Error playing move: Needs {count} '{letter}', only {rack_counter.get(letter, 0)} available.")
            return turn, [], []
    # --- End Verification ---

    # Place tiles & update rack
    rack_after_play = current_rack[:] # Work with a copy
    for r, c, letter in newly_placed_details:
        tiles[r][c] = letter
        if (r, c) in move_blanks_coords:
            if ' ' in rack_after_play: rack_after_play.remove(' '); blanks.add((r, c))
            else: print("Error: Tried to play blank but none in rack_after_play!")
        else:
            if letter in rack_after_play: rack_after_play.remove(letter)
            else: print(f"Error: Tried to play '{letter}' but not in rack_after_play!")

    score = move.get('score', 0)
    scores[player_idx] += score # Update score

    # Draw new tiles (Skip in 8-letter practice)
    drawn_tiles = []
    if practice_mode != "eight_letter":
        num_to_draw = len(newly_placed_details)
        drawn_tiles = [bag.pop() for _ in range(num_to_draw) if bag]
        rack_after_play.extend(drawn_tiles)

    # --- ADDED SORTING ---
    # Sort the rack alphabetically if the player is human
    if not is_ai[player_idx]:
        rack_after_play.sort()
    # --- END ADDED SORTING ---

    racks[player_idx] = rack_after_play # Update main rack AFTER potential sort

    next_turn = turn if practice_mode == "eight_letter" else 3 - turn # Determine next turn
    return next_turn, drawn_tiles, newly_placed_details



# --- AI Logic ---

# --- AI Strategy Helper Functions ---

# --- Static Leave Values & Constants (Assumed to be defined elsewhere in the full code) ---
GOOD_LEAVE_BONUS = {' ': 25.6, 'S': 8.0, 'Z': 5.1, 'X': 3.3, 'E': 0.3, 'A': 0.6, 'R': 1.1, 'N': 0.2,'H': 1.1, 'C': 0.9, 'M': 0.6, 'D': 0.5}
BAD_LEAVE_PENALTY = {'T': -0.1, 'I': -2.1, 'L': -0.2, 'Q': -6.8, 'J': -1.5, 'V': -5.5, 'W': -3.8, 'K': -0.5, 'F': -2.2, 'Y': -0.6, 'U': -5.1, 'B': -2.0, 'G': -2.9, 'P': -0.5, 'O': -2.5}
DUPLICATE_PENALTY = -4.2 # Applied for each duplicate beyond the first
VOWELS = "AEIOU"
BALANCE_PENALTY_FACTOR = -4.0 # Penalty per vowel count away from ideal range
# --- END Constants ---


def evaluate_leave(rack, verbose=False):
    """
    Calculates a score adjustment based on static tile values, duplicate penalties,
    and V/C balance deviation (with special handling for 1 and 2-tile leaves).
    Includes verbose debug printing. Higher scores are better leaves.

    Args:
        rack (list): A list of characters representing the tiles left.
        verbose (bool): If True, print detailed calculation steps.

    Returns:
        int: A score adjustment (positive or negative), rounded from float.
    """
    if not rack:
        return 0

    leave_score = 0.0 # Use float for calculations
    rack_str = "".join(sorted(rack))
    if verbose: print(f"--- Evaluating Leave (Verbose): '{rack_str}' ---")

    rack_counts = Counter(rack)
    num_tiles = len(rack)
    vowel_count = 0

    # 1. Apply Static Bonuses/Penalties for each tile present
    if verbose: print("  Static Tile Values:")
    current_tile_value_score = 0.0
    for tile, count in rack_counts.items():
        if tile in VOWELS: vowel_count += count # Count vowels
        bonus = GOOD_LEAVE_BONUS.get(tile, 0.0)
        penalty = BAD_LEAVE_PENALTY.get(tile, 0.0)
        tile_value = (bonus + penalty) * count

        if verbose:
            if bonus != 0.0: print(f"    - Tile '{tile}' (x{count}): Bonus per tile = {bonus:.1f}, Total = {bonus*count:.1f}")
            if penalty != 0.0: print(f"    - Tile '{tile}' (x{count}): Penalty per tile = {penalty:.1f}, Total = {penalty*count:.1f}")
            if bonus == 0.0 and penalty == 0.0: print(f"    - Tile '{tile}' (x{count}): Neutral value = 0.0")

        current_tile_value_score += tile_value
    if verbose: print(f"    Subtotal (Tile Values): {current_tile_value_score:.1f}")
    leave_score += current_tile_value_score

    # 2. Apply Duplicate Penalties
    if verbose: print("  Duplicate Penalties:")
    current_duplicate_penalty = 0.0
    has_duplicates = False
    for tile, count in rack_counts.items():
        if count > 1:
            has_duplicates = True
            penalty_applied = DUPLICATE_PENALTY * (count - 1)
            if verbose: print(f"    - Tile '{tile}' (x{count}): Penalty for {count-1} duplicate(s) = {penalty_applied:.1f}")
            current_duplicate_penalty += penalty_applied
    if verbose:
        if current_duplicate_penalty == 0.0: print("    None")
        print(f"    Subtotal (Duplicates): {current_duplicate_penalty:.1f}")
    leave_score += current_duplicate_penalty

    # --- MODIFIED: Apply V/C Balance Deviation Penalty (with refined 1/2 tile exceptions) ---
    if verbose: print("  V/C Balance Deviation Penalty:")
    current_balance_penalty = 0.0

    # Determine if the V/C balance check should be skipped
    skip_balance_check = False
    if num_tiles == 1:
        if verbose: print("    (Leave has 1 tile, skipping V/C balance check)")
        skip_balance_check = True
    elif num_tiles == 2 and not has_duplicates:
        # Skip only if it's a balanced V+C pair
        if vowel_count == 1:
             if verbose: print("    (Leave has 2 non-duplicate tiles: 1 Vowel, 1 Consonant - skipping V/C balance check)")
             skip_balance_check = True
        else:
             # It's 2 non-duplicates, but both V or both C - DO NOT SKIP
             if verbose: print("    (Leave has 2 non-duplicate tiles: Both Vowels or Both Consonants - applying V/C balance check)")
             skip_balance_check = False # Explicitly ensure it's not skipped
    elif num_tiles == 0: # Should be caught by initial check, but safe
        skip_balance_check = True

    # Proceed with balance calculation only if not skipped
    if not skip_balance_check:
        consonant_count = num_tiles - vowel_count

        # Calculate ideal range for *this* number of tiles
        # For 2 tiles, the ideal range logic might seem odd, but the deviation calculation works:
        # - If 2V (vowel_count=2), ideal_min=1, ideal_max=1. Deviation = 2-1 = 1. Penalty applied.
        # - If 2C (vowel_count=0), ideal_min=1, ideal_max=1. Deviation = 1-0 = 1. Penalty applied.
        ideal_min = max(1, math.floor(num_tiles / 3))
        ideal_max = max(ideal_min, math.floor(num_tiles * 0.45))

        if verbose: print(f"    Tiles: {num_tiles}, Vowels: {vowel_count}, Consonants: {consonant_count}, Ideal Vowel Range: [{ideal_min}-{ideal_max}]")

        deviation = 0
        if vowel_count < ideal_min:
            deviation = ideal_min - vowel_count
            if verbose: print(f"    Deviation: Too few vowels (deviation {deviation})")
        elif vowel_count > ideal_max:
            deviation = vowel_count - ideal_max
            if verbose: print(f"    Deviation: Too many vowels (deviation {deviation})")

        if deviation > 0:
            current_balance_penalty = BALANCE_PENALTY_FACTOR * deviation
            if verbose: print(f"    Penalty Applied: {current_balance_penalty:.1f}")
        elif verbose:
             # Only print "Balance OK" if we actually performed the check and found no deviation
             print("    Balance OK (No deviation penalty).")

    elif verbose and num_tiles > 0: # Print reason if skipped and rack wasn't empty
        pass # Message already printed above when setting skip_balance_check

    if verbose: print(f"    Subtotal (Balance): {current_balance_penalty:.1f}")
    leave_score += current_balance_penalty
    # --- END MODIFIED ---

    final_adjustment = int(round(leave_score)) # Round float score to nearest int
    if verbose: print(f"--- Final Leave Adjustment for '{rack_str}': {final_adjustment} (Raw Score: {leave_score:.1f}) ---")
    return final_adjustment


def evaluate_single_move(move_dict, leave_evaluation_func):
    """
    Combines the immediate score of a move with the evaluated score of its leave.

    Args:
        move_dict (dict): The dictionary representing the move (must contain 'score' and 'leave').
        leave_evaluation_func (function): The function to use for evaluating the leave (e.g., evaluate_leave).

    Returns:
        float: The combined evaluation score for the move.
               Using float allows for potential future weighting.
    """
    immediate_score = move_dict.get('score', 0)
    leave = move_dict.get('leave', [])
    leave_score_adjustment = leave_evaluation_func(leave)

    # Simple combination for now: add leave adjustment to immediate score
    # Future difficulty levels could apply weights here:
    # e.g., weight_score * immediate_score + weight_leave * leave_score_adjustment
    combined_score = float(immediate_score + leave_score_adjustment)

    return combined_score


def analyze_unseen_pool(remaining_tiles_dict):
    """
    Analyzes the quality of the unseen tile pool (bag + opponent rack).
    NOTE: In reality, we only know the bag for sure. This uses the combined pool.

    Args:
        remaining_tiles_dict (dict): Dictionary mapping letters to counts of unseen tiles.

    Returns:
        dict: Analysis containing counts and a quality score.
              {'total': int, 'vowels': int, 'consonants': int, 'blanks': int,
               's_count': int, 'power_tiles': int, 'bad_tiles': int, 'quality_score': float}
    """
    analysis = {
        'total': 0, 'vowels': 0, 'consonants': 0, 'blanks': 0,
        's_count': 0, 'power_tiles': 0, 'bad_tiles': 0, 'quality_score': 0.0
    }
    if not remaining_tiles_dict:
        return analysis

    vowel_letters = "AEIOU"
    power_letters = "SZJQX" # Tiles often opening up bingos or high scores
    bad_letters = "VWUQKI" # Tiles often considered difficult or less valuable

    raw_quality_sum = 0.0

    for tile, count in remaining_tiles_dict.items():
        if count <= 0: continue # Skip tiles with zero or negative count

        analysis['total'] += count

        if tile == ' ':
            analysis['blanks'] += count
        elif tile in vowel_letters:
            analysis['vowels'] += count
        else:
            analysis['consonants'] += count

        if tile == 'S':
            analysis['s_count'] += count
        if tile in power_letters:
            analysis['power_tiles'] += count
        if tile in bad_letters:
            analysis['bad_tiles'] += count

        # Add to raw quality score based on predefined values
        raw_quality_sum += POOL_TILE_VALUES.get(tile, 0) * count

    # Normalize quality score slightly based on pool size (average value per tile)
    if analysis['total'] > 0:
        analysis['quality_score'] = raw_quality_sum / analysis['total']
    else:
        analysis['quality_score'] = 0.0

    # print(f"DEBUG analyze_unseen_pool: Pool: {remaining_tiles_dict}, Analysis: {analysis}") # Optional debug
    return analysis

def estimate_draw_value(num_to_draw, pool_analysis):
    """
    Provides a simple heuristic estimate of the value gained by drawing tiles.

    Args:
        num_to_draw (int): The number of tiles to be drawn.
        pool_analysis (dict): The result from analyze_unseen_pool.

    Returns:
        float: An estimated score adjustment based on pool quality.
    """
    # Simple heuristic: base value is proportional to pool quality score and number drawn
    # Positive quality score means pool is generally good, negative means generally bad
    estimated_value = pool_analysis.get('quality_score', 0.0) * num_to_draw * POOL_QUALITY_FACTOR
    # print(f"DEBUG estimate_draw_value: Draw {num_to_draw}, Quality {pool_analysis.get('quality_score', 0.0):.2f}, Estimated Value: {estimated_value:.1f}") # Optional debug
    return estimated_value


def find_best_exchange_option(rack, remaining_tiles_dict, bag_count):
    """
    Determines the best set of tiles to exchange to maximize the
    evaluated score of the *remaining* tiles, plus an estimated draw value.

    Args:
        rack (list): The AI's current rack.
        remaining_tiles_dict (dict): Dictionary of unseen tiles (bag + opponent).
        bag_count (int): Number of tiles currently in the bag.

    Returns:
        tuple: (list_of_tiles_to_exchange, best_estimated_value)
               Returns ([], -float('inf')) if no valid exchange is possible or beneficial.
    """
    best_overall_exchange_tiles = []
    best_overall_estimated_value = -float('inf') # Keep track of the best value found across all numbers of tiles exchanged

    if not rack:
        return [], -float('inf')

    pool_analysis = analyze_unseen_pool(remaining_tiles_dict)

    # Iterate through exchanging k=1 to min(7, len(rack)) tiles
    for k in range(1, min(len(rack), 7) + 1):
        # Check if there are enough tiles in the bag to perform this exchange
        if bag_count < k:
            continue # Cannot exchange k tiles if fewer than k are in the bag

        best_leave_for_k = []
        best_leave_score_for_k = -float('inf')
        current_exchange_tiles_for_k = []

        # Find the combination of k tiles to *remove* that leaves the best rack
        # This is equivalent to finding the best combination of (len(rack) - k) tiles to *keep*
        num_to_keep = len(rack) - k
        if num_to_keep < 0: continue # Should not happen, but safety check

        if num_to_keep == 0: # Exchanging all tiles
             leave_score = 0 # No leave value if keeping zero tiles
             kept_tiles = []
             exchanged_tiles = rack[:]
        else:
            best_kept_subset = []
            # Iterate through all combinations of tiles to KEEP
            for kept_subset_tuple in itertools.combinations(rack, num_to_keep):
                kept_subset_list = list(kept_subset_tuple)
                current_leave_score = evaluate_leave(kept_subset_list) # Evaluate the potential leave

                if current_leave_score > best_leave_score_for_k:
                    best_leave_score_for_k = current_leave_score
                    best_kept_subset = kept_subset_list

            # Determine which tiles were exchanged to achieve this best leave
            temp_rack_counts = Counter(rack)
            temp_kept_counts = Counter(best_kept_subset)
            temp_rack_counts.subtract(temp_kept_counts)
            exchanged_tiles = list(temp_rack_counts.elements())
            kept_tiles = best_kept_subset
            leave_score = best_leave_score_for_k # The score of the best leave found for keeping num_to_keep tiles

        # Calculate the total estimated value for exchanging these 'k' tiles
        estimated_value_of_draw = estimate_draw_value(k, pool_analysis)
        total_estimated_value = leave_score + estimated_value_of_draw

        # print(f"DEBUG Exchange Option (k={k}): Exchanging {exchanged_tiles}, Keeping {kept_tiles}, Leave Score: {leave_score}, Draw Est: {estimated_value_of_draw:.1f}, Total Est: {total_estimated_value:.1f}") # Optional debug

        # Update the overall best exchange found so far
        if total_estimated_value > best_overall_estimated_value:
            best_overall_estimated_value = total_estimated_value
            best_overall_exchange_tiles = exchanged_tiles

    # print(f"DEBUG Best Exchange Found: Tiles={best_overall_exchange_tiles}, Est Value={best_overall_estimated_value:.1f}") # Optional debug
    return best_overall_exchange_tiles, best_overall_estimated_value





# --- End AI Strategy Helper Functions ---







def ai_turn(turn, racks, tiles, board, blanks, scores, bag, first_play, pass_count, exchange_count, consecutive_zero_point_turns, player_names, dropdown_open=False, hinting=False, showing_all_words=False, letter_checks=None):
    """
    Handles the AI's turn, selecting moves based on score and leave evaluation,
    and incorporating the new exchange strategy.
    """
    global last_word, last_score, last_start, last_direction, move_history, current_replay_turn, practice_mode, GADDAG_STRUCTURE, last_played_highlight_coords

    # Skip AI turn entirely in 8-letter practice mode
    if practice_mode == "eight_letter":
        return turn, first_play, pass_count, exchange_count, consecutive_zero_point_turns, [], dropdown_open, hinting, showing_all_words, False, None

    player_idx = turn - 1
    current_rack = racks[player_idx][:] # Use a copy for analysis
    bag_count = len(bag)
    print(f"AI Player {turn} turn started. Rack: {''.join(sorted(current_rack))}, Bag: {bag_count}") # Log sorted rack
    paused_for_power_tile = False
    current_power_tile = None
    all_moves = []

    # Generate moves using GADDAG
    if GADDAG_STRUCTURE:
        # Pass the original rack state to the generator
        all_moves = generate_all_moves_gaddag(racks[player_idx], tiles, board, blanks, GADDAG_STRUCTURE.root)
    else:
        print("ERROR: AI cannot generate moves, GADDAG not loaded.")
        all_moves = []

    if all_moves is None: all_moves = []
    print(f"AI Player {turn} generated {len(all_moves)} moves.")

    # --- Power Tile Practice Pause Check (remains the same) ---
    if practice_mode == "power_tiles" and letter_checks:
        checked_power_tiles = {letter for i, letter in enumerate(['J', 'Q', 'X', 'Z']) if letter_checks[i]}
        power_tiles_on_rack = sorted([tile for tile in current_rack if tile in checked_power_tiles])
        if power_tiles_on_rack:
            current_power_tile = power_tiles_on_rack[0]
            paused_for_power_tile = True
            print(f"AI turn paused for power tile practice. Target: {current_power_tile}")
            # Return the generated moves so the human can see them if needed
            return turn, first_play, pass_count, exchange_count, consecutive_zero_point_turns, all_moves, dropdown_open, hinting, showing_all_words, paused_for_power_tile, current_power_tile

    # --- AI Action Decision Logic ---
    move_rack_before = racks[player_idx][:] # Record rack state before action
    exchanged_tiles_for_history = []
    action_chosen = 'pass' # Default action
    best_play_move = None
    best_play_evaluation = -float('inf')
    best_exchange_tiles = []
    best_exchange_evaluation = -float('inf')

    can_play = bool(all_moves)
    # Standard rule: proactive exchange considered only if bag has enough tiles
    can_exchange_proactively = bag_count >= 7

    # 1. Evaluate Best Play (if any moves exist)
    if can_play:
        print(f"AI {turn} evaluating {len(all_moves)} plays...")
        current_top_raw_score = -float('inf')
        top_raw_score_move = None # Keep track for logging

        for move in all_moves:
            # Evaluate silently first to find the best
            # Ensure evaluate_single_move uses the correct leave evaluation function
            evaluated_score = evaluate_single_move(move, evaluate_leave) # Pass the function itself
            immediate_score = move.get('score', 0)

            if evaluated_score > best_play_evaluation:
                best_play_evaluation = evaluated_score
                best_play_move = move
            if immediate_score > current_top_raw_score:
                 current_top_raw_score = immediate_score
                 top_raw_score_move = move

        # --- Debug Prints for Play Evaluation ---
        print("-" * 20)
        print(f"AI {turn} Play Evaluation Complete:")
        if top_raw_score_move:
            print(f"  Top Raw Score Move : '{top_raw_score_move.get('word','N/A')}' ({top_raw_score_move.get('score',0)} pts)")
        else:
            print("  Top Raw Score Move : None Found")

        if best_play_move:
            chosen_score = best_play_move.get('score', 0)
            chosen_leave = best_play_move.get('leave', [])
            chosen_leave_str = ''.join(sorted(chosen_leave))
            print(f"  Best Evaluated Play: '{best_play_move.get('word','N/A')}' (Raw Score: {chosen_score})")
            print(f"    Leave Tiles: '{chosen_leave_str}'")
            # Call again with verbose=True ONLY for the chosen move's leave
            leave_adjust = evaluate_leave(chosen_leave, verbose=True) # Call with verbose=True
            print(f"    --------------------") # Separator after verbose output
            print(f"    Final Play Eval Score: {chosen_score + leave_adjust:.2f} (Raw: {chosen_score}, Leave Adj: {leave_adjust})")
        else:
            print("  Best Evaluated Play: None Found")
        print("-" * 20)
        # --- END Debug Prints ---

    # 2. Evaluate Best Exchange Option
    # Only evaluate if mandatory (no plays) or if proactive exchange is possible
    if not can_play or can_exchange_proactively:
        print(f"AI {turn} evaluating exchange options...")
        # Need the current state of unseen tiles
        # Use the *actual* current rack (racks[player_idx]) and board state (tiles, blanks)
        remaining_tiles_dict = get_remaining_tiles(racks[player_idx], tiles, blanks)
        best_exchange_tiles, best_exchange_evaluation = find_best_exchange_option(
            racks[player_idx], remaining_tiles_dict, bag_count
        )
        if best_exchange_tiles:
             print(f"  Best Exchange Option Found: Exchange {len(best_exchange_tiles)} tiles ({''.join(sorted(best_exchange_tiles))}), Est Value: {best_exchange_evaluation:.1f}")
        else:
             print("  No beneficial exchange option found.")


    # 3. Make the Decision
    if can_play:
        action_chosen = 'play' # Default if playing is possible

        # Check conditions for proactive exchange
        if can_exchange_proactively and best_exchange_tiles:
            is_low_score_play = best_play_move and best_play_move.get('score', 0) < LOW_SCORE_THRESHOLD
            is_exchange_significantly_better = best_exchange_evaluation > best_play_evaluation + EXCHANGE_PREFERENCE_THRESHOLD

            if is_low_score_play and is_exchange_significantly_better:
                print(f"AI {turn}: DECISION -> Proactive Exchange (Low score play '{best_play_move.get('word','N/A')}' ({best_play_move.get('score',0)}) and Exchange eval {best_exchange_evaluation:.1f} > Play eval {best_play_evaluation:.1f} + {EXCHANGE_PREFERENCE_THRESHOLD})")
                action_chosen = 'exchange'
            elif not is_low_score_play and is_exchange_significantly_better:
                 # Also consider exchanging even if score isn't "low", if exchange is clearly better
                 print(f"AI {turn}: DECISION -> Proactive Exchange (Exchange eval {best_exchange_evaluation:.1f} > Play eval {best_play_evaluation:.1f} + {EXCHANGE_PREFERENCE_THRESHOLD})")
                 action_chosen = 'exchange'
            else:
                 print(f"AI {turn}: DECISION -> Play ('{best_play_move.get('word','N/A')}') (Exchange not sufficiently better or play score not low)")

    elif best_exchange_tiles: # Cannot play, but found a valid exchange option
        # find_best_exchange_option already checked bag size for the returned option
        print(f"AI {turn}: DECISION -> Mandatory Exchange (No plays possible)")
        action_chosen = 'exchange'
    else: # Cannot play, and no valid/beneficial exchange found
        print(f"AI {turn}: DECISION -> Pass (No plays, no viable exchange)")
        action_chosen = 'pass'

    # --- Execute Action ---
    next_turn = turn # Default, might change
    drawn_tiles = []
    newly_placed = []
    move_type = ''
    score = 0
    word = ''
    positions = []
    blanks_used = set()
    coord = ''
    word_with_blanks = ''
    is_bingo = False

    if action_chosen == 'play':
        if best_play_move:
            print(f"AI {turn} playing move: '{best_play_move.get('word', 'N/A')}'")
            # Use the existing play_hint_move function to execute the move
            # It handles placing tiles, updating score, drawing, and returns the next turn
            next_turn, drawn_tiles, newly_placed = play_hint_move(best_play_move, tiles, racks, blanks, scores, turn, bag, board)

            # Extract details for history
            move_type = 'place'
            score = best_play_move.get('score', 0)
            word = best_play_move.get('word', 'N/A')
            positions = best_play_move.get('positions', []) # Use positions from the move dict
            blanks_used = best_play_move.get('blanks', set())
            start = best_play_move.get('start', (0,0))
            direction = best_play_move.get('direction', 'right')
            coord = get_coord(start, direction)
            word_with_blanks = best_play_move.get('word_with_blanks', '')
            is_bingo = best_play_move.get('is_bingo', False)

            first_play = False
            consecutive_zero_point_turns = 0
            pass_count = 0
            exchange_count = 0
            last_played_highlight_coords = set((pos[0], pos[1]) for pos in positions) # Update highlight

        else:
            print(f"AI {turn} Error: Action was 'play' but best_play_move is None. Passing.")
            action_chosen = 'pass' # Fallback to passing

    if action_chosen == 'exchange':
        if best_exchange_tiles:
            print(f"AI {turn} exchanging {len(best_exchange_tiles)} tiles: {''.join(sorted(best_exchange_tiles))}")
            exchanged_tiles_for_history = best_exchange_tiles[:] # Copy for history
            current_rack_list = racks[player_idx] # Get the actual current rack

            # Create the new rack by removing exchanged tiles
            temp_rack_after_exchange = []
            exchange_counts = Counter(exchanged_tiles_for_history)
            for tile in current_rack_list:
                if exchange_counts.get(tile, 0) > 0:
                    exchange_counts[tile] -= 1
                else:
                    temp_rack_after_exchange.append(tile)

            # Draw new tiles
            num_to_draw = len(exchanged_tiles_for_history)
            drawn_tiles = [bag.pop() for _ in range(num_to_draw) if bag]
            temp_rack_after_exchange.extend(drawn_tiles)
            racks[player_idx] = temp_rack_after_exchange # Update the main rack

            # Return exchanged tiles to bag and shuffle
            bag.extend(exchanged_tiles_for_history)
            random.shuffle(bag)

            # Update game state variables
            move_type = 'exchange'
            score = 0
            consecutive_zero_point_turns += 1
            exchange_count += 1
            pass_count = 0
            next_turn = 3 - turn
            last_played_highlight_coords = set() # Clear highlight
        else:
            print(f"AI {turn} Error: Action was 'exchange' but best_exchange_tiles is empty. Passing.")
            action_chosen = 'pass' # Fallback to passing

    if action_chosen == 'pass':
        print(f"AI {turn} passing.")
        move_type = 'pass'
        score = 0
        consecutive_zero_point_turns += 1
        pass_count += 1
        exchange_count = 0
        next_turn = 3 - turn
        last_played_highlight_coords = set() # Clear highlight

    # --- Record Move ---
    # Ensure all necessary details are captured based on the action taken
    move_data = {
        'player': turn,
        'move_type': move_type,
        'rack': move_rack_before, # Rack *before* the move
        'score': score,
        'word': word,
        'positions': positions, # For 'place' moves, use the positions from the move dict
        'blanks': blanks_used, # For 'place' moves
        'drawn': drawn_tiles, # Tiles drawn *after* the move/exchange
        'coord': coord, # For 'place' moves
        'word_with_blanks': word_with_blanks, # For 'place' moves
        'is_bingo': is_bingo # For 'place' moves
    }
    if move_type == 'exchange':
        move_data['exchanged_tiles'] = exchanged_tiles_for_history
    if move_type == 'place' and best_play_move:
         # Store the tiles actually placed in this turn if available
         move_data['newly_placed'] = best_play_move.get('newly_placed', newly_placed) # Use newly_placed from play_hint_move if available

    move_history.append(move_data)
    current_replay_turn = len(move_history)

    # --- Return updated state ---
    # Return empty list for moves as they are not needed by the caller after AI turn
    return next_turn, first_play, pass_count, exchange_count, consecutive_zero_point_turns, [], dropdown_open, hinting, showing_all_words, paused_for_power_tile, current_power_tile


def power_tile_practice():
    """Placeholder function, logic moved elsewhere."""
    print("Power tile practice setup (handled by mode selection and AI turn).")

# End of Part 6



# Part 7

def get_replay_state(turn_idx, initial_racks):
    """
    Recreate the game state up to turn_idx ITERATIVELY.
    Sorts the racks alphabetically before returning.
    """
    # Start with initial state (ensure deep copies)
    tiles_state = [['' for _ in range(GRID_SIZE)] for _ in range(GRID_SIZE)]
    blanks_state = set()
    scores_state = [0, 0]

    if not isinstance(initial_racks, list) or len(initial_racks) != 2 or \
       not isinstance(initial_racks[0], list) or not isinstance(initial_racks[1], list):
        print(f"Error: Invalid initial_racks format in get_replay_state: {initial_racks}")
        return tiles_state, blanks_state, scores_state, [[], []]

    racks_state = [initial_racks[0][:], initial_racks[1][:]]

    # Apply moves sequentially up to turn_idx
    for i in range(turn_idx):
        if i >= len(move_history):
             print(f"Warning: Replay index {i} out of bounds for move_history (len {len(move_history)})")
             break
        move = move_history[i]
        player_idx = move['player'] - 1

        # Get the rack state *before* applying this move's changes
        current_rack_before_move = racks_state[player_idx][:]
        rack_after_move = current_rack_before_move[:] # Work with a copy for this move

        if move['move_type'] == 'place':
            positions = move.get('positions', [])
            blanks_in_move = move.get('blanks', set())

            # Apply board changes and update rack based on *this* move
            for r, c, letter in positions:
                # Check if this square was empty *before* this move (using current tiles_state)
                is_newly_placed = (0 <= r < GRID_SIZE and 0 <= c < GRID_SIZE and not tiles_state[r][c])

                # Place tile on board state
                if 0 <= r < GRID_SIZE and 0 <= c < GRID_SIZE:
                    tiles_state[r][c] = letter
                    if (r, c) in blanks_in_move:
                        blanks_state.add((r, c))
                else:
                    print(f"Replay Warning: Invalid position ({r},{c}) in move {i}")
                    continue # Skip processing this invalid position

                # If it was newly placed, remove the corresponding tile from the rack_after_move
                if is_newly_placed:
                    if (r,c) in blanks_in_move:
                        if ' ' in rack_after_move: rack_after_move.remove(' ')
                        else: print(f"Replay Warning: Tried to remove blank from rack for move {i}, but not found.")
                    else:
                        if letter in rack_after_move: rack_after_move.remove(letter)
                        else: print(f"Replay Warning: Tried to remove '{letter}' from rack for move {i}, but not found.")

            # Update score
            scores_state[player_idx] += move.get('score', 0)
            # Add drawn tiles to the rack for the *next* turn's state
            rack_after_move.extend(move.get('drawn', []))
            racks_state[player_idx] = rack_after_move

        elif move['move_type'] == 'exchange':
            # Update rack: remove exchanged, add drawn
            exchanged = move.get('exchanged_tiles', [])
            for tile in exchanged:
                 if tile in rack_after_move: rack_after_move.remove(tile)
                 else: print(f"Replay Warning: Tried to remove exchanged tile '{tile}' from rack for move {i}, but not found.")
            rack_after_move.extend(move.get('drawn', []))
            racks_state[player_idx] = rack_after_move
            # Score doesn't change

        elif move['move_type'] == 'pass':
            # No change to board, score, or rack content needed for the state
            racks_state[player_idx] = rack_after_move # Rack state carries over

    # Sort racks alphabetically before returning for replay display
    for rack in racks_state:
        rack.sort() # In-place sort

    # Return the state *after* turn_idx moves have been applied
    return tiles_state, blanks_state, scores_state, racks_state






# Function to Replace: main()
# REASON: Adds human rack sorting after typed plays, exchanges,
#         and cancellation of typed plays. Includes last-word highlighting.

# No changes needed to draw_options_menu as the filtering happens in main's event handling

def main():
    global bag, last_word, last_score, last_start, last_direction, move_history, replay_mode, current_replay_turn, game_mode, is_ai, practice_mode, board, tiles, racks, blanks, main_called, scores, GADDAG_STRUCTURE
    global is_loaded_game, replay_initial_shuffled_bag, initial_racks # Added initial_racks

    print("--- main() function entered ---")

    # --- Initialization Block (Runs Once) ---
    if not main_called:
        print("--- main(): 'if not main_called' block entered ---")
        main_called = True

        print("--- main(): Calling mode_selection_screen()... ---")
        selected_mode_result, return_data = mode_selection_screen()
        print(f"--- main(): mode_selection_screen() returned: mode={selected_mode_result} ---")

        # --- Load GADDAG Structure ---
        try:
            print("Attempting to load GADDAG structure from gaddag.pkl...")
            load_start = time.time()
            with open("gaddag.pkl", 'rb') as f_load: GADDAG_STRUCTURE = pickle.load(f_load)
            print(f"GADDAG loaded in {time.time() - load_start:.2f} seconds.")
        except Exception as e: print(f"\n--- ERROR Loading GADDAG: {e} ---"); pygame.quit(); sys.exit()
        print("GADDAG loading block finished.")

        # --- Game State Initialization ---
        print("--- main(): Starting game state initialization... ---")
        if selected_mode_result == "LOADED_GAME": # Handle LOADED_GAME mode
            print("--- main(): Handling LOADED_GAME setup ---")
            game_mode = "LOADED_GAME"; is_loaded_game = True
            player_names, loaded_history, final_scores_loaded = return_data
            move_history = loaded_history; final_scores = final_scores_loaded
            base_bag = create_standard_bag(); random.shuffle(base_bag); replay_initial_shuffled_bag = base_bag[:]
            board, _, tiles = create_board(); scores = [0, 0]; blanks = set(); racks = [[], []]; bag = []
            replay_mode = True; current_replay_turn = 0; practice_mode = None; is_ai = [False, False]; human_player = 1; first_play = False
            # For loaded games, we don't know the initial racks, set to None or empty
            initial_racks = [[], []] # Cannot reliably get initial racks from GCG
            print(f"--- main(): Loaded Game Setup Complete. Players: {player_names}, Moves: {len(move_history)} ---")
        elif selected_mode_result is not None: # Handle New Game Modes
            print(f"--- main(): Handling New Game Setup ({selected_mode_result}) ---")
            game_mode = selected_mode_result; is_loaded_game = False; replay_initial_shuffled_bag = None
            player_names, human_player, practice_mode, letter_checks, practice_state = return_data
            if practice_state and practice_mode == "eight_letter": # 8-Letter Practice Setup
                print("Loading state from 8-letter practice..."); board, tiles, racks, blanks, bag, scores, turn, first_play = practice_state["board"], practice_state["tiles"], practice_state["racks"], practice_state["blanks"], practice_state["bag"], practice_state["scores"], practice_state["turn"], practice_state["first_play"]; is_ai = [False, False]; print("--- main(): Loaded state from 8-letter practice. ---")
            elif practice_state: # Other Practice Modes
                print("Loading state from other practice mode..."); board, tiles, racks, blanks, bag, scores, turn, first_play = practice_state["board"], practice_state["tiles"], practice_state["racks"], practice_state["blanks"], practice_state["bag"], practice_state["scores"], practice_state["turn"], practice_state["first_play"]; is_ai = [False, False];
                if game_mode == MODE_HVA: is_ai[2 - human_player] = True
                elif game_mode == MODE_AVA or practice_mode == "power_tiles": is_ai = [True, True]; print(f"--- main(): Loaded state from other practice mode. is_ai: {is_ai} ---")
            else: # Standard New Game Setup
                print("Performing standard game initialization..."); board, _, tiles = create_board(); bag = create_standard_bag(); random.shuffle(bag); racks = [[], []]; scores = [0, 0]; turn = 1; blanks = set(); first_play = True
                try: racks[0] = [bag.pop() for _ in range(7)]; racks[1] = [bag.pop() for _ in range(7)]
                except IndexError: print("Error: Not enough tiles in bag."); pygame.quit(); sys.exit()
                for rack in racks: rack.sort() # Sort initial racks
                is_ai = [False, False]
                if game_mode == MODE_HVA: is_ai[2 - human_player] = True
                elif game_mode == MODE_AVA: is_ai = [True, True]; print(f"--- main(): Performed standard game initialization. is_ai: {is_ai} ---")
            # Store initial racks *after* they are populated for new games
            initial_racks = [rack[:] for rack in racks]
        else: print("--- main(): Mode selection returned None. Exiting. ---"); pygame.quit(); sys.exit()

        # --- Common Initializations & Resets ---
        word_positions = []; running = True; dropdown_open = False; return_to_mode_selection = False; all_words_ok_rect = None; all_words_play_rect = None
        hint_rects = []; hint_rect = None; play_button_rect = None; ok_button_rect = None; all_words_button_rect = None; tile_rects = []; exchange_button_rect = None
        cancel_button_rect = None; pass_count = 0; exchange_count = 0; consecutive_zero_point_turns = 0; exchanging = False; hinting = False
        showing_all_words = False; selected_tiles = set(); typing = False; typing_start = None; typing_direction = None; current_r = None; current_c = None
        last_left_click_time = 0; last_left_click_pos = None; hint_moves = []; all_moves = []; selected_hint_index = None; scroll_offset = 0
        last_clicked_pos = None; last_word = ""; last_score = 0; last_start = None; last_direction = None; human_played = False; dragged_tile = None; drag_pos = None; drag_offset = (0,0)
        selected_square = None; original_tiles = None; original_rack = None;
        if selected_mode_result != "LOADED_GAME": move_history = []
        if selected_mode_result != "LOADED_GAME": replay_mode = False; current_replay_turn = 0
        previous_turn = 0; game_over_state = False; showing_stats = False; dialog_x = (WINDOW_WIDTH - DIALOG_WIDTH) // 2; dialog_y = (WINDOW_HEIGHT - DIALOG_HEIGHT) // 2; dragging = False;
        if selected_mode_result != "LOADED_GAME": final_scores = None
        reason = ""; action = None; scoreboard_height = WINDOW_HEIGHT - 80; paused_for_power_tile = False; current_power_tile = None; power_tile_message_shown = False
        last_played_highlight_coords = set() # Store coords of last play for highlighting
        preview_score_enabled = False # State for Score Preview
        current_preview_score = 0
        preview_checkbox_rect = None
        print("--- main(): Performed common variable resets. ---")

        # --- 8-Letter Practice Specific Initialization ---
        practice_target_moves = []; practice_best_move = None; practice_solved = False
        showing_practice_end_dialog = False; practice_end_message = ""; practice_play_again_rect = None
        practice_main_menu_rect = None; practice_quit_rect = None
        if practice_mode == "eight_letter":
            print("--- main(): Performing 8-letter practice specific init... ---")
            if racks and len(racks) > 0 and racks[0] is not None and GADDAG_STRUCTURE:
                practice_target_moves = generate_all_moves_gaddag(racks[0], tiles, board, blanks, GADDAG_STRUCTURE.root)
                if practice_target_moves: practice_best_move = practice_target_moves[0]; print(f"Best move found: {practice_best_move['word']} ({practice_best_move['score']} pts)"); all_moves = practice_target_moves
                else: print("Error: No valid moves found for 8-letter practice setup!"); show_message_dialog("Error: No possible moves found for this setup.", "Practice Error"); return_to_mode_selection = True; running = False
            elif not GADDAG_STRUCTURE: print("Error: Cannot generate practice moves, GADDAG not loaded."); return_to_mode_selection = True; running = False
            else: print("Error: Invalid rack state for Player 1 in 8-letter practice."); return_to_mode_selection = True; running = False
    # --- End of Initialization Block ---

    # --- Main Game Loop ---
    print("--- main(): Entering main game loop (while running:)... ---")
    while running:
        # Calculate Preview Score
        current_preview_score = 0
        if typing and preview_score_enabled and word_positions:
            try: current_preview_score = calculate_score(word_positions, board, tiles, blanks)
            except Exception as e: current_preview_score = 0

        # Generate moves at start of turn
        if turn != previous_turn and not replay_mode and not game_over_state and not paused_for_power_tile and practice_mode != "eight_letter":
            if racks and len(racks) > turn-1 and racks[turn-1] is not None and GADDAG_STRUCTURE:
                print(f"Generating moves for Player {turn}. Rack: {''.join(racks[turn-1])}")
                all_moves = generate_all_moves_gaddag(racks[turn-1], tiles, board, blanks, GADDAG_STRUCTURE.root)
                if all_moves is None: all_moves = []
                print(f"Generated {len(all_moves)} moves for player {turn}")
            elif not GADDAG_STRUCTURE: print("ERROR: Cannot generate moves, GADDAG not loaded."); all_moves = []
            else: print(f"Error: Invalid rack state for player {turn}. Racks: {racks}"); all_moves = []
            previous_turn = turn; human_played = False; power_tile_message_shown = False

        # --- AI Turn Trigger ---
        if not game_over_state and not replay_mode and not paused_for_power_tile and \
           practice_mode != "eight_letter" and 0 <= turn-1 < len(is_ai) and is_ai[turn-1] and not human_played: # Added bounds check for is_ai
            print(f"Triggering AI turn for Player {turn}")
            ai_result = ai_turn(turn, racks, tiles, board, blanks, scores, bag, first_play, pass_count, exchange_count, consecutive_zero_point_turns, player_names, dropdown_open, hinting, showing_all_words, letter_checks)
            if len(ai_result) == 11:
                turn_after_ai, first_play, pass_count, exchange_count, consecutive_zero_point_turns, returned_moves, dropdown_open, hinting, showing_all_words, paused_for_power_tile, current_power_tile = ai_result
                # Update highlight coords after AI move
                if turn_after_ai != turn and move_history:
                     last_ai_move = move_history[-1]
                     if last_ai_move.get('move_type') == 'place': last_played_highlight_coords = set((pos[0], pos[1]) for pos in last_ai_move.get('positions', []))
                     else: last_played_highlight_coords = set()
                turn = turn_after_ai # Update turn variable
                if paused_for_power_tile:
                    all_moves = returned_moves
                    if not power_tile_message_shown: player_name = player_names[turn-1] if player_names[turn-1] else f"Player {turn}"; show_message_dialog(f"A {current_power_tile} is on {player_name}'s rack. Find the highest scoring play using {current_power_tile}.", "Power Tile Practice"); power_tile_message_shown = True
            else: print(f"Error: AI turn returned unexpected number of values: {len(ai_result)}")

        # --- Event Handling ---
        for event in pygame.event.get():
            if event.type == pygame.QUIT: running = False
            # --- Practice End Dialog Handling ---
            elif showing_practice_end_dialog:
                 if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
                     x, y = event.pos; # ... (practice end buttons) ...
                     if practice_play_again_rect and practice_play_again_rect.collidepoint(x,y): running = False; return_to_mode_selection = True
                     elif practice_main_menu_rect and practice_main_menu_rect.collidepoint(x,y): running = False; return_to_mode_selection = True
                     elif practice_quit_rect and practice_quit_rect.collidepoint(x,y): running = False
            # --- Game Over Event Handling ---
            elif game_over_state:
                # Define save action nested function ... (Using corrected save logic)
                def perform_save_action(): # ... (save logic) ...
                    if final_scores:
                        now = datetime.datetime.now(); date_str = now.strftime("%d%b%y").upper(); time_str = now.strftime("%H%M"); seq_num = 1; max_existing_num = 0
                        try:
                            for filename in os.listdir('.'):
                                if filename.startswith(date_str + "-") and filename.endswith(".gcg"):
                                    parts = filename[:-4].split('-');
                                    if len(parts) == 3:
                                        try:
                                            num = int(parts[2])
                                            if num > max_existing_num: max_existing_num = num
                                        except ValueError: continue # Correctly indented except
                            seq_num = max_existing_num + 1
                        except OSError as e: print(f"Error listing directory for sequence number: {e}")
                        # Use initial_racks if available, otherwise use empty racks for GCG
                        racks_for_gcg = initial_racks if initial_racks and len(initial_racks) == 2 else [[], []]
                        save_filename = f"{date_str}-{time_str}-{seq_num}.gcg"; gcg_content = save_game_to_gcg(player_names, move_history, racks_for_gcg, final_scores)
                        try:
                            with open(save_filename, "w") as f: f.write(gcg_content); print(f"Game saved to {save_filename}"); show_message_dialog(f"Game saved as {save_filename}", "Save Successful")
                        except IOError as e: print(f"Error saving game to {save_filename}: {e}"); show_message_dialog(f"Error saving game: {e}", "Save Error")
                    else: print("Cannot save game: Final scores not calculated."); show_message_dialog("Cannot save game - final scores missing.", "Save Error")
                # Handle events in game over state ...
                if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
                    x, y = event.pos # ... (drag, stats, other buttons) ...
                    if dialog_x <= x < dialog_x + DIALOG_WIDTH and dialog_y <= y < dialog_y + 20: dragging = True; drag_offset = (x - dialog_x, y - dialog_y)
                    elif showing_stats:
                        stats_dialog_width, stats_dialog_height = 400, 360; stats_dialog_actual_x = dialog_x + 20; stats_dialog_actual_y = dialog_y + 20; temp_ok_rect = pygame.Rect(stats_dialog_actual_x + stats_dialog_width - BUTTON_WIDTH - 10, stats_dialog_actual_y + stats_dialog_height - BUTTON_HEIGHT - 10, BUTTON_WIDTH, BUTTON_HEIGHT)
                        if temp_ok_rect.collidepoint(x, y): showing_stats = False
                    else:
                        temp_save_rect, temp_quit_rect, temp_replay_rect, temp_play_again_rect, temp_stats_rect = draw_game_over_dialog(dialog_x, dialog_y, final_scores if final_scores else [0,0], reason, player_names)
                        if temp_save_rect.collidepoint(x, y): perform_save_action()
                        elif temp_quit_rect.collidepoint(x, y): running = False
                        elif temp_replay_rect.collidepoint(x, y): # Prepare for replay
                             if is_loaded_game:
                                 if not replay_initial_shuffled_bag: base_bag = create_standard_bag(); random.shuffle(base_bag); replay_initial_shuffled_bag = base_bag[:]
                             else: replay_initial_shuffled_bag = None # Will use iterative get_replay_state
                             game_over_state = False; replay_mode = True; current_replay_turn = 0; practice_mode = None; paused_for_power_tile = False; showing_stats = False; last_played_highlight_coords = set() # Clear highlight
                        elif temp_play_again_rect.collidepoint(x, y): running = False; return_to_mode_selection = True
                        elif temp_stats_rect.collidepoint(x, y): showing_stats = True
                elif event.type == pygame.MOUSEMOTION and dragging: x, y = event.pos; dialog_x = x - drag_offset[0]; dialog_y = y - drag_offset[1]; dialog_x = max(0, min(dialog_x, WINDOW_WIDTH - DIALOG_WIDTH)); dialog_y = max(0, min(dialog_y, WINDOW_HEIGHT - DIALOG_HEIGHT))
                elif event.type == pygame.MOUSEBUTTONUP and event.button == 1: dragging = False
                elif event.type == pygame.KEYDOWN: # Keyboard shortcuts ...
                    if event.key == pygame.K_s: perform_save_action()
                    elif event.key == pygame.K_q: running = False
                    elif event.key == pygame.K_r: # Prepare for replay
                         if is_loaded_game:
                             if not replay_initial_shuffled_bag: base_bag = create_standard_bag(); random.shuffle(base_bag); replay_initial_shuffled_bag = base_bag[:]
                         else: replay_initial_shuffled_bag = None # Will use iterative get_replay_state
                         game_over_state = False; replay_mode = True; current_replay_turn = 0; practice_mode = None; paused_for_power_tile = False; showing_stats = False; last_played_highlight_coords = set() # Clear highlight
                    elif event.key == pygame.K_p: running = False; return_to_mode_selection = True
            # --- Active Game / Replay Event Handling ---
            elif event.type == pygame.MOUSEBUTTONDOWN:
                x, y = event.pos; current_time = pygame.time.get_ticks()
                if event.button == 1: # Left Click ...
                    # --- MODIFICATION START: Handle Options Button Click First ---
                    # Get options rect regardless of mode
                    options_rect_base, dropdown_rects_base = draw_options_menu(turn, dropdown_open, len(bag)) # Use current turn

                    if options_rect_base.collidepoint(x, y):
                        dropdown_open = not dropdown_open
                    elif dropdown_open:
                        clicked_dropdown = False
                        # Determine options based on mode for action filtering
                        if replay_mode:
                            allowed_options = {"Main", "Quit"}
                        elif practice_mode == "eight_letter":
                            allowed_options = {"Give Up", "Main", "Quit"}
                        else:
                            allowed_options = {"Pass", "Exchange", "Main", "Quit"}

                        current_options_list = ["Give Up", "Main", "Quit"] if practice_mode == "eight_letter" else ["Pass", "Exchange", "Main", "Quit"]
                        if replay_mode: # Override options list if in replay for correct indexing
                            current_options_list = ["Main", "Quit"]
                            # Adjust dropdown_rects_base if needed (assuming draw_options_menu doesn't change based on replay)
                            # For simplicity, assume draw_options_menu draws the standard non-practice menu in replay
                            # We need to map the clicked rect index to the correct replay option
                            temp_standard_options = ["Pass", "Exchange", "Main", "Quit"]
                            clicked_standard_option = None
                            for i, rect in enumerate(dropdown_rects_base):
                                if rect and rect.collidepoint(x, y):
                                    if i < len(temp_standard_options):
                                        clicked_standard_option = temp_standard_options[i]
                                        break
                            if clicked_standard_option in allowed_options:
                                selected_option = clicked_standard_option # Use the mapped option
                                clicked_dropdown = True
                                dropdown_open = False
                                # Actions for replay mode
                                if selected_option == "Main":
                                    running = False; return_to_mode_selection = True
                                elif selected_option == "Quit":
                                    if confirm_quit(): running = False
                            else: # Clicked outside allowed options or on disabled rect
                                dropdown_open = False # Close dropdown

                        else: # Not in replay mode
                            for i, rect in enumerate(dropdown_rects_base):
                                if rect and rect.collidepoint(x, y):
                                    selected_option = current_options_list[i]
                                    if selected_option in allowed_options: # Check if allowed in current mode
                                        clicked_dropdown = True
                                        dropdown_open = False
                                        # --- Standard Actions (Non-Replay) ---
                                        if selected_option == "Pass":
                                            move_rack = racks[turn-1][:]; consecutive_zero_point_turns += 1; pass_count += 1; exchange_count = 0; print(f"Player {turn} passed"); human_played = True; paused_for_power_tile = False; move_history.append({'player': turn, 'move_type': 'pass', 'rack': move_rack, 'score': 0, 'word': '', 'coord': '', 'blanks': set(), 'positions': [], 'drawn': [], 'is_bingo': False, 'word_with_blanks': ''}); current_replay_turn = len(move_history); turn = 3 - turn; last_played_highlight_coords = set() # Clear highlight
                                        elif selected_option == "Exchange":
                                            # Check bag count again just before opening dialog
                                            if len(bag) >= 7:
                                                exchanging = True; selected_tiles.clear()
                                            else:
                                                show_message_dialog("Cannot exchange, less than 7 tiles in bag.", "Exchange Error")
                                        elif selected_option == "Give Up": # Specific to 8-letter practice
                                            practice_end_message = f"Best: {practice_best_move['word_with_blanks']} ({practice_best_move['score']} pts)" if practice_best_move else "No best move found."; practice_solved = True; showing_practice_end_dialog = True
                                        elif selected_option == "Main":
                                            running = False; return_to_mode_selection = True
                                        elif selected_option == "Quit":
                                            if confirm_quit(): running = False
                                        # --- End Standard Actions ---
                                        break # Exit inner loop once action is taken
                            if not clicked_dropdown: # Clicked outside any valid dropdown item
                                dropdown_open = False
                    # --- END MODIFICATION: Options Button Handling ---

                    elif replay_mode: # Other clicks in Replay Mode (Buttons)
                         if replay_start_rect.collidepoint(x, y): current_replay_turn = 0; last_played_highlight_coords = set() # Clear highlight
                         elif replay_prev_rect.collidepoint(x, y) and current_replay_turn > 0: current_replay_turn -= 1; last_played_highlight_coords = set() # Clear highlight
                         elif replay_next_rect.collidepoint(x, y) and current_replay_turn < len(move_history): current_replay_turn += 1; last_played_highlight_coords = set() # Clear highlight
                         elif replay_end_rect.collidepoint(x, y): current_replay_turn = len(move_history); last_played_highlight_coords = set() # Clear highlight
                         # No other interactions needed in replay mode

                    elif not (exchanging or hinting or showing_all_words): # Clicks outside dialogs in ACTIVE GAME
                        # --- MODIFICATION: Moved Options button handling above ---
                        # Now handle other active game clicks (Suggest, Rack, Board)
                        suggest_rect_base = draw_suggest_button() # Suggest Button ...
                        if suggest_rect_base and suggest_rect_base.collidepoint(x, y) and (not is_ai[turn-1] or paused_for_power_tile):
                            moves_to_hint = practice_target_moves if practice_mode == "eight_letter" else all_moves
                            if paused_for_power_tile and current_power_tile: power_moves_hint = [m for m in moves_to_hint if any(letter == current_power_tile for _, _, letter in m.get('newly_placed',[]))]; hint_moves = sorted(power_moves_hint, key=lambda m: m['score'], reverse=True)[:5]
                            else: hint_moves = moves_to_hint[:5]
                            hinting = True; selected_hint_index = 0 if hint_moves else None
                        if paused_for_power_tile and hint_rect and hint_rect.collidepoint(x, y): # Hint button (Paused) ...
                             power_moves_hint = [m for m in all_moves if any(letter == current_power_tile for _, _, letter in m.get('newly_placed',[]))]; hint_moves = sorted(power_moves_hint, key=lambda m: m['score'], reverse=True)[:5]; hinting = True; selected_hint_index = 0 if hint_moves else None
                        # Handle Score Preview Checkbox Click
                        if preview_checkbox_rect and preview_checkbox_rect.collidepoint(x, y):
                            preview_score_enabled = not preview_score_enabled
                        current_player_idx = turn - 1 # Rack Buttons ...
                        if 0 <= current_player_idx < len(is_ai) and (not is_ai[current_player_idx] or paused_for_power_tile): # Check bounds for is_ai
                             p1_alpha_rect, p1_rand_rect = None, None; p2_alpha_rect, p2_rand_rect = None, None
                             if len(racks) > 0: p1_alpha_rect, p1_rand_rect = draw_rack(1, racks[0], scores, turn, player_names)
                             if len(racks) > 1 and practice_mode != "eight_letter": p2_alpha_rect, p2_rand_rect = draw_rack(2, racks[1], scores, turn, player_names)
                             if turn == 1:
                                  if p1_alpha_rect and p1_alpha_rect.collidepoint(x, y): racks[0].sort()
                                  elif p1_rand_rect and p1_rand_rect.collidepoint(x, y): random.shuffle(racks[0])
                             elif turn == 2 and practice_mode != "eight_letter":
                                  if p2_alpha_rect and p2_alpha_rect.collidepoint(x, y): racks[1].sort()
                                  elif p2_rand_rect and p2_rand_rect.collidepoint(x, y): random.shuffle(racks[1])
                        # Rack Tile Drag Start ...
                        rack_y = BOARD_SIZE + 80 if turn == 1 else BOARD_SIZE + 150; rack_width_calc = 7 * (TILE_WIDTH + TILE_GAP) - TILE_GAP; replay_area_end_x = 10 + 4 * (REPLAY_BUTTON_WIDTH + REPLAY_BUTTON_GAP); min_rack_start_x = replay_area_end_x + BUTTON_GAP + 20; rack_start_x_calc = max(min_rack_start_x, (BOARD_SIZE - rack_width_calc) // 2)
                        if 0 <= current_player_idx < len(racks) and 0 <= current_player_idx < len(is_ai): # Check bounds
                            rack_len = len(racks[current_player_idx]); tile_idx = get_tile_under_mouse(x, y, rack_start_x_calc, rack_y, rack_len)
                            if tile_idx is not None and not dragged_tile and (not is_ai[current_player_idx] or paused_for_power_tile): dragged_tile = (turn, tile_idx); drag_pos = (x, y); tile_abs_x = rack_start_x_calc + tile_idx * (TILE_WIDTH + TILE_GAP); drag_offset = (x - tile_abs_x, y - rack_y)
                        # Board Click (Typing Start / Arrow) ...
                        if not dragged_tile and (0 <= turn-1 < len(is_ai) and (not is_ai[turn-1] or paused_for_power_tile)): # Only if not dragging and human turn/paused AI
                            col = (x - 40) // SQUARE_SIZE; row = (y - 40) // SQUARE_SIZE
                            if 0 <= row < GRID_SIZE and 0 <= col < GRID_SIZE and not tiles[row][col]: # Click on empty board square
                                is_double_click = (last_left_click_pos == (row, col) and current_time - last_left_click_time < DOUBLE_CLICK_TIME)
                                if is_double_click: # Cancel
                                     selected_square = None; typing = False
                                     if word_positions and original_tiles and original_rack: # Revert
                                          for r_wp, c_wp, _ in word_positions: tiles[r_wp][c_wp] = original_tiles[r_wp][c_wp]
                                          racks[turn-1] = original_rack[:]
                                          # --- ADDED SORT ---
                                          if not is_ai[turn-1]: racks[turn-1].sort() # Sort after reverting
                                          # ------------------
                                          blanks_to_remove = set((r_wp, c_wp) for r_wp, c_wp, _ in word_positions if (r_wp, c_wp) in blanks); blanks.difference_update(blanks_to_remove); word_positions = []; original_tiles = None; original_rack = None
                                elif selected_square is None or selected_square[:2] != (row, col): selected_square = (row, col, "right"); typing = False; word_positions = [] # 1st click
                                elif selected_square[2] == "right": selected_square = (row, col, "down") # 2nd click
                                elif selected_square[2] == "down": selected_square = None # 3rd click
                                last_left_click_pos = (row, col); last_left_click_time = current_time
                            else: selected_square = None # Click outside board or on occupied square

                    # --- Handle clicks within dialogs (Exchange, Hint, All Words) ---
                    # This logic remains nested as it was, only active when the respective flag is True
                    elif exchanging: # Exchange Dialog ...
                        clicked_in_dialog = False
                        if exchange_button_rect and exchange_button_rect.collidepoint(x, y) and selected_tiles:
                             # Check bag count *before* committing exchange
                             if len(bag) >= len(selected_tiles):
                                clicked_in_dialog = True; move_rack = racks[turn-1][:]; tiles_to_exchange = [racks[turn-1][i] for i in sorted(selected_tiles, reverse=True)]
                                temp_rack = [tile for i, tile in enumerate(racks[turn-1]) if i not in selected_tiles]; drawn_tiles = [bag.pop() for _ in range(len(tiles_to_exchange)) if bag]
                                temp_rack.extend(drawn_tiles); racks[turn-1] = temp_rack
                                # --- ADDED SORT ---
                                if not is_ai[turn-1]: racks[turn-1].sort() # Sort human rack
                                # ------------------
                                bag.extend(tiles_to_exchange); random.shuffle(bag); consecutive_zero_point_turns += 1; print(f"Player {turn} exchanged {len(tiles_to_exchange)} tiles")
                                exchanging = False; selected_tiles.clear(); human_played = True; exchange_count += 1; pass_count = 0; paused_for_power_tile = False
                                move_history.append({'player': turn, 'move_type': 'exchange', 'rack': move_rack, 'exchanged_tiles': tiles_to_exchange, 'drawn': drawn_tiles, 'score': 0, 'word': '', 'coord': '', 'blanks': set(), 'positions': [], 'is_bingo': False, 'word_with_blanks': ''})
                                current_replay_turn = len(move_history); turn = 3 - turn
                                last_played_highlight_coords = set() # Clear highlight
                             else: # Not enough tiles in bag
                                 show_message_dialog(f"Cannot exchange {len(selected_tiles)} tiles, only {len(bag)} in bag.", "Exchange Error")
                                 clicked_in_dialog = True # Prevent closing dialog immediately
                        elif cancel_button_rect and cancel_button_rect.collidepoint(x, y): clicked_in_dialog = True; exchanging = False; selected_tiles.clear()
                        elif tile_rects:
                            for i, rect in enumerate(tile_rects):
                                if rect.collidepoint(x, y): clicked_in_dialog = True; selected_tiles.symmetric_difference_update({i}); break
                        dialog_width, dialog_height = 400, 200; dialog_rect_exchange = pygame.Rect((WINDOW_WIDTH - dialog_width) // 2, (WINDOW_HEIGHT - dialog_height) // 2, dialog_width, dialog_height)
                        if dialog_rect_exchange.collidepoint(x,y) and not clicked_in_dialog: pass # Click inside dialog but not on element

                    elif hinting: # Hint Dialog ...
                       clicked_in_dialog = False
                       if play_button_rect and play_button_rect.collidepoint(x, y) and selected_hint_index is not None and selected_hint_index < len(hint_moves):
                           clicked_in_dialog = True; selected_move = hint_moves[selected_hint_index]; move_rack = racks[turn-1][:]
                           if paused_for_power_tile: # Hint in Power Tile Practice ...
                               power_moves_check = [m for m in all_moves if any(letter == current_power_tile for _, _, letter in m.get('newly_placed',[]))]; max_power_score_check = max(m['score'] for m in power_moves_check) if power_moves_check else 0
                               if selected_move['score'] >= max_power_score_check:
                                   next_turn, drawn_tiles, newly_placed = play_hint_move(selected_move, tiles, racks, blanks, scores, turn, bag, board) # play_hint_move sorts human rack if needed
                                   human_played = True; hinting = False; paused_for_power_tile = False; consecutive_zero_point_turns = 0; pass_count = 0; exchange_count = 0
                                   move_history.append({'player': turn, 'move_type': 'place', 'rack': move_rack, 'positions': selected_move.get('positions',[]), 'blanks': selected_move.get('blanks',set()), 'score': selected_move.get('score',0), 'word': selected_move.get('word','N/A'), 'drawn': drawn_tiles, 'coord': get_coord(selected_move.get('start',(0,0)), selected_move.get('direction','right')), 'word_with_blanks': selected_move.get('word_with_blanks',''), 'is_bingo': selected_move.get('is_bingo',False)})
                                   current_replay_turn = len(move_history)
                                   last_played_highlight_coords = set((pos[0], pos[1]) for pos in selected_move.get('positions', [])) # Update highlight
                                   turn = next_turn
                               else: show_message_dialog(f"This is not the highest scoring move with {current_power_tile}!", "Incorrect Move")
                           else: # Normal hint play ...
                               next_turn, drawn_tiles, newly_placed = play_hint_move(selected_move, tiles, racks, blanks, scores, turn, bag, board) # play_hint_move sorts human rack if needed
                               human_played = True; hinting = False; paused_for_power_tile = False; consecutive_zero_point_turns = 0; pass_count = 0; exchange_count = 0
                               if practice_mode != "eight_letter":
                                   move_history.append({'player': turn, 'move_type': 'place', 'rack': move_rack, 'positions': selected_move.get('positions',[]), 'blanks': selected_move.get('blanks',set()), 'score': selected_move.get('score',0), 'word': selected_move.get('word','N/A'), 'drawn': drawn_tiles, 'coord': get_coord(selected_move.get('start',(0,0)), selected_move.get('direction','right')), 'word_with_blanks': selected_move.get('word_with_blanks',''), 'is_bingo': selected_move.get('is_bingo',False)})
                                   current_replay_turn = len(move_history)
                                   last_played_highlight_coords = set((pos[0], pos[1]) for pos in selected_move.get('positions', [])) # Update highlight
                                   turn = next_turn
                               else: # 8-letter practice visual play
                                    print("Hint played visually in 8-letter practice.")
                                    last_played_highlight_coords = set((pos[0], pos[1]) for pos in selected_move.get('positions', []))
                       elif ok_button_rect and ok_button_rect.collidepoint(x, y): clicked_in_dialog = True; hinting = False
                       elif all_words_button_rect and all_words_button_rect.collidepoint(x, y): clicked_in_dialog = True; hinting = False; showing_all_words = True; moves_for_all = practice_target_moves if practice_mode == "eight_letter" else all_moves; selected_hint_index = 0 if moves_for_all else None; scroll_offset = 0
                       elif hint_rects:
                           for i, rect in enumerate(hint_rects):
                               if rect.collidepoint(x, y) and i < len(hint_moves): clicked_in_dialog = True; selected_hint_index = i; break
                       dialog_width, dialog_height = 400, 250; dialog_rect_hint = pygame.Rect((WINDOW_WIDTH - dialog_width) // 2, (WINDOW_HEIGHT - dialog_height) // 2, dialog_width, dialog_height)
                       if dialog_rect_hint.collidepoint(x,y) and not clicked_in_dialog: pass # Click inside dialog but not on element

                    elif showing_all_words: # All Words Dialog ...
                       clicked_in_dialog = False; moves_for_all = practice_target_moves if practice_mode == "eight_letter" else all_moves
                       if all_words_play_rect and all_words_play_rect.collidepoint(x, y) and selected_hint_index is not None and selected_hint_index < len(moves_for_all):
                           clicked_in_dialog = True; selected_move = moves_for_all[selected_hint_index]; move_rack = racks[turn-1][:]; next_turn, drawn_tiles, newly_placed = play_hint_move(selected_move, tiles, racks, blanks, scores, turn, bag, board)
                           human_played = True; showing_all_words = False; paused_for_power_tile = False; consecutive_zero_point_turns = 0; pass_count = 0; exchange_count = 0
                           if practice_mode != "eight_letter":
                               move_history.append({'player': turn, 'move_type': 'place', 'rack': move_rack, 'positions': selected_move.get('positions',[]), 'blanks': selected_move.get('blanks',set()), 'score': selected_move.get('score',0), 'word': selected_move.get('word','N/A'), 'drawn': drawn_tiles, 'coord': get_coord(selected_move.get('start',(0,0)), selected_move.get('direction','right')), 'word_with_blanks': selected_move.get('word_with_blanks',''), 'is_bingo': selected_move.get('is_bingo',False)})
                               current_replay_turn = len(move_history)
                               last_played_highlight_coords = set((pos[0], pos[1]) for pos in selected_move.get('positions', [])) # Update highlight
                               turn = next_turn
                           else: # 8-letter visual play
                               print("Move played visually from All Words in 8-letter practice.")
                               last_played_highlight_coords = set((pos[0], pos[1]) for pos in selected_move.get('positions', []))
                       elif all_words_ok_rect and all_words_ok_rect.collidepoint(x, y): clicked_in_dialog = True; showing_all_words = False
                       elif all_words_rects:
                           for rect, idx in all_words_rects:
                               if rect.collidepoint(x, y): clicked_in_dialog = True; selected_hint_index = idx; break
                       dialog_rect_all = pygame.Rect((WINDOW_WIDTH - ALL_WORDS_DIALOG_WIDTH) // 2, (WINDOW_HEIGHT - ALL_WORDS_DIALOG_HEIGHT) // 2, ALL_WORDS_DIALOG_WIDTH, ALL_WORDS_DIALOG_HEIGHT)
                       if dialog_rect_all.collidepoint(x,y) and not clicked_in_dialog: pass # Click inside dialog but not on element


                elif event.button == 3: # Right Click -> Cancel typing/arrow
                    selected_square = None
                    if typing: # Revert typing
                        if original_tiles and original_rack:
                            for r_wp, c_wp, _ in word_positions: tiles[r_wp][c_wp] = original_tiles[r_wp][c_wp]
                            racks[turn-1] = original_rack[:]
                            # --- ADDED SORT ---
                            if not is_ai[turn-1]: racks[turn-1].sort() # Sort after reverting
                            # ------------------
                            blanks_to_remove = set((r_wp, c_wp) for r_wp, c_wp, _ in word_positions if (r_wp, c_wp) in blanks)
                            blanks.difference_update(blanks_to_remove)
                        # Reset typing state variables (Correctly indented)
                        typing = False; typing_start = None; typing_direction = None
                        word_positions = []; original_tiles = None; original_rack = None

            elif event.type == pygame.MOUSEMOTION: # Mouse Motion ...
                if dragged_tile and drag_pos: drag_pos = event.pos
                elif game_over_state and dragging: x, y = event.pos; dialog_x = x - drag_offset[0]; dialog_y = y - drag_offset[1]; dialog_x = max(0, min(dialog_x, WINDOW_WIDTH - DIALOG_WIDTH)); dialog_y = max(0, min(dialog_y, WINDOW_HEIGHT - DIALOG_HEIGHT))

            elif event.type == pygame.MOUSEBUTTONUP: # Mouse Up ...
                if event.button == 1: # Left button up
                    if game_over_state and dragging: dragging = False
                    elif dragged_tile and (0 <= dragged_tile[0]-1 < len(is_ai) and (not is_ai[dragged_tile[0]-1] or paused_for_power_tile)) and not replay_mode: # Finish dragging a tile
                        x, y = event.pos; player_idx = dragged_tile[0] - 1; rack_y = BOARD_SIZE + 80 if dragged_tile[0] == 1 else BOARD_SIZE + 150
                        rack_width_calc = 7 * (TILE_WIDTH + TILE_GAP) - TILE_GAP; replay_area_end_x = 10 + 4 * (REPLAY_BUTTON_WIDTH + REPLAY_BUTTON_GAP); min_rack_start_x = replay_area_end_x + BUTTON_GAP + 20
                        rack_start_x_calc = max(min_rack_start_x, (BOARD_SIZE - rack_width_calc) // 2); rack_area_rect = pygame.Rect(rack_start_x_calc, rack_y, rack_width_calc, TILE_HEIGHT)
                        if rack_area_rect.collidepoint(x, y): # Dropped back on the rack area
                            if 0 <= player_idx < len(racks): # Check bounds for racks
                                rack_len = len(racks[player_idx]); insert_idx = get_insertion_index(x, rack_start_x_calc, rack_len); original_tile_idx = dragged_tile[1]
                                if 0 <= original_tile_idx < rack_len:
                                    player_rack = racks[player_idx]; tile_to_move = player_rack.pop(original_tile_idx)
                                    if original_tile_idx < insert_idx: insert_idx -= 1
                                    insert_idx = max(0, min(insert_idx, len(player_rack))); player_rack.insert(insert_idx, tile_to_move)
                        dragged_tile = None; drag_pos = None # Stop dragging

            elif event.type == pygame.MOUSEWHEEL: # Mouse Wheel ...
                 mouse_x, mouse_y = pygame.mouse.get_pos()
                 if showing_all_words: # Scroll All Words ...
                     dialog_rect_all = pygame.Rect((WINDOW_WIDTH - ALL_WORDS_DIALOG_WIDTH) // 2, (WINDOW_HEIGHT - ALL_WORDS_DIALOG_HEIGHT) // 2, ALL_WORDS_DIALOG_WIDTH, ALL_WORDS_DIALOG_HEIGHT)
                     if dialog_rect_all.collidepoint(mouse_x, mouse_y):
                          moves_for_scroll = practice_target_moves if practice_mode == "eight_letter" else all_moves; content_height = len(moves_for_scroll) * 30; header_height = 40; button_area_height = BUTTON_HEIGHT + 30
                          visible_content_height = ALL_WORDS_DIALOG_HEIGHT - header_height - button_area_height
                          if content_height > visible_content_height: max_scroll = content_height - visible_content_height; scroll_offset -= event.y * SCROLL_SPEED; scroll_offset = max(0, min(scroll_offset, max_scroll))
                          else: scroll_offset = 0
                 else: # Scroll Scoreboard ...
                     sb_x = BOARD_SIZE + 275; sb_y = 40; sb_w = max(200, WINDOW_WIDTH - BOARD_SIZE - 20); sb_h = WINDOW_HEIGHT - 80;
                     if sb_x + sb_w > WINDOW_WIDTH - 10: sb_w = WINDOW_WIDTH - sb_x - 10
                     if sb_w < 200: sb_x = WINDOW_WIDTH - 210; sb_w = 200
                     scoreboard_rect = pygame.Rect(sb_x, sb_y, sb_w, sb_h)
                     if scoreboard_rect.collidepoint(mouse_x, mouse_y):
                          history_len = current_replay_turn if replay_mode else len(move_history); total_content_height = history_len * 20; is_final_turn_in_replay = replay_mode and current_replay_turn == len(move_history)
                          if (game_over_state or is_final_turn_in_replay) and final_scores is not None: total_content_height += 40
                          if total_content_height > scoreboard_height: max_scroll = total_content_height - scoreboard_height; scroll_offset -= event.y * SCROLL_SPEED; scroll_offset = max(0, min(scroll_offset, max_scroll))
                          else: scroll_offset = 0

            elif event.type == pygame.KEYDOWN: # Keydown ...
                is_human_turn_or_paused = not replay_mode and (0 <= turn-1 < len(is_ai) and (not is_ai[turn-1] or paused_for_power_tile)) # Check bounds
                if is_human_turn_or_paused:
                    # --- Start Typing Logic ---
                    if selected_square and not typing and event.unicode.isalpha():
                        typing = True; original_tiles = [row[:] for row in tiles]; original_rack = racks[turn-1][:]
                        typing_start = selected_square[:2]; typing_direction = selected_square[2]; original_selected_square = selected_square
                        selected_square = None; word_positions = []; current_r, current_c = typing_start
                        letter = event.unicode.upper()
                        if 0 <= current_r < GRID_SIZE and 0 <= current_c < GRID_SIZE and not tiles[current_r][current_c]:
                            placed = False
                            if letter in racks[turn-1]: tiles[current_r][current_c] = letter; racks[turn-1].remove(letter); word_positions.append((current_r, current_c, letter)); placed = True
                            elif ' ' in racks[turn-1]: tiles[current_r][current_c] = letter; racks[turn-1].remove(' '); blanks.add((current_r, current_c)); word_positions.append((current_r, current_c, letter)); placed = True
                            # Corrected Indentation Block 1
                            if placed:
                                if typing_direction == "right":
                                    current_c += 1
                                    while current_c < GRID_SIZE and tiles[current_r][current_c]: current_c += 1
                                elif typing_direction == "down": # Correctly aligned
                                    current_r += 1
                                    while current_r < GRID_SIZE and tiles[current_r][current_c]: current_r += 1 # Correctly indented
                                # Correctly indented
                                current_r = min(current_r, GRID_SIZE - 1)
                                current_c = min(current_c, GRID_SIZE - 1)
                            # End Corrected Block 1
                        else: typing = False; selected_square = original_selected_square
                    # --- Active Typing Logic ---
                    elif typing:
                        if event.key == pygame.K_RETURN or event.key == pygame.K_KP_ENTER: # Finalize Typed Play ...
                            play_finalized_normally = False
                            if word_positions:
                                temp_tiles_val = [row[:] for row in original_tiles];
                                for r_wp, c_wp, l_wp in word_positions:
                                    if 0 <= r_wp < GRID_SIZE and 0 <= c_wp < GRID_SIZE: temp_tiles_val[r_wp][c_wp] = l_wp
                                valid, is_bingo = is_valid_play(word_positions, temp_tiles_val, first_play, len(original_rack), original_tiles, original_rack)
                                if valid:
                                    score = calculate_score(word_positions, board, tiles, blanks); print(f"DEBUG: Valid play typed, score: {score}")
                                    # ... (Practice mode checks remain the same) ...
                                    if practice_mode == "eight_letter":
                                        print("DEBUG: Checking 8-letter practice logic..."); # ... (8-letter logic) ...
                                        if practice_best_move and score == practice_best_move['score']: practice_end_message = f"Congratulations! Best: {practice_best_move['word_with_blanks']} ({score} pts)"; practice_solved = True; showing_practice_end_dialog = True
                                        elif practice_best_move: show_message_dialog(f"Try again. There is another word that scores {practice_best_move['score']}.", "Incorrect")
                                        else: show_message_dialog("Error: No best move data available.", "Error"); return_to_mode_selection = True; running = False
                                        if not practice_solved: # Revert
                                            if original_tiles and original_rack:
                                                for r_wp, c_wp, _ in word_positions: tiles[r_wp][c_wp] = original_tiles[r_wp][c_wp]
                                                racks[turn-1] = original_rack[:]
                                                # --- ADDED SORT ---
                                                if not is_ai[turn-1]: racks[turn-1].sort()
                                                # ------------------
                                                blanks_to_remove = set((r_wp, c_wp) for r_wp, c_wp, _ in word_positions if (r_wp, c_wp) in blanks); blanks.difference_update(blanks_to_remove)
                                        typing = False; typing_start = None; typing_direction = None; word_positions = []; original_tiles = None; original_rack = None
                                        if not practice_solved and not return_to_mode_selection: selected_square = original_selected_square

                                    elif practice_mode == "power_tiles" and paused_for_power_tile: # ... (Power tile logic) ...
                                         print(f"DEBUG: Checking Power Tile ({current_power_tile}) practice logic...")
                                         uses_power = any(letter == current_power_tile for r_wp, c_wp, letter in word_positions); power_moves = [m for m in all_moves if any(pt[2] == current_power_tile for pt in m.get('newly_placed', []))]
                                         max_power_score = max(m['score'] for m in power_moves) if power_moves else 0; print(f"DEBUG: Player used power tile: {uses_power}. Player score: {score}. Max power score: {max_power_score}")
                                         if not uses_power: show_message_dialog(f"Move must use the {current_power_tile}!", "Incorrect")
                                         elif score < max_power_score: show_message_dialog(f"Try again. There is another word that scores {max_power_score}.", "Higher Score Exists")
                                         else: show_message_dialog("That's correct! Great job.", "Correct!"); paused_for_power_tile = False; power_tile_message_shown = False; play_finalized_normally = True
                                         if not play_finalized_normally: # Revert
                                              if original_tiles and original_rack:
                                                  for r_wp, c_wp, _ in word_positions: tiles[r_wp][c_wp] = original_tiles[r_wp][c_wp]
                                                  racks[turn-1] = original_rack[:]
                                                  # --- ADDED SORT ---
                                                  if not is_ai[turn-1]: racks[turn-1].sort()
                                                  # ------------------
                                                  blanks_to_remove = set((r_wp, c_wp) for r_wp, c_wp, _ in word_positions if (r_wp, c_wp) in blanks); blanks.difference_update(blanks_to_remove)
                                              typing = False; typing_start = None; typing_direction = None; word_positions = []; original_tiles = None; original_rack = None; selected_square = original_selected_square
                                    else:
                                        play_finalized_normally = True # Finalize normal play

                                else: # Invalid play
                                    print(f"Invalid play.");
                                    if original_tiles and original_rack: # Revert
                                        for r_wp, c_wp, _ in word_positions: tiles[r_wp][c_wp] = original_tiles[r_wp][c_wp]
                                        racks[turn-1] = original_rack[:]
                                        # --- ADDED SORT ---
                                        if not is_ai[turn-1]: racks[turn-1].sort()
                                        # ------------------
                                        blanks_to_remove = set((r_wp, c_wp) for r_wp, c_wp, _ in word_positions if (r_wp, c_wp) in blanks); blanks.difference_update(blanks_to_remove)
                                    typing = False; typing_start = None; typing_direction = None; word_positions = []; original_tiles = None; original_rack = None; selected_square = original_selected_square
                            else:
                                 typing = False; selected_square = original_selected_square # Enter with no tiles

                            # --- Normal Play Finalization ---
                            if play_finalized_normally:
                                scores[turn-1] += score; first_play = False; drawn_tiles = [bag.pop() for _ in range(len(word_positions)) if bag]; racks[turn-1].extend(drawn_tiles)
                                # --- ADDED SORT ---
                                if not is_ai[turn-1]: racks[turn-1].sort() # Sort human rack
                                # ------------------
                                # Find the full word and its actual start position/direction
                                full_word_tiles_hist, _ = find_main_word(word_positions, tiles)
                                full_word_hist = "".join(t[2] for t in full_word_tiles_hist) if full_word_tiles_hist else "ERROR"
                                # Calculate coord based on actual word start
                                if full_word_tiles_hist:
                                    actual_start_pos = (full_word_tiles_hist[0][0], full_word_tiles_hist[0][1])
                                    actual_direction = "right" if len(set(r for r,c,l in full_word_tiles_hist)) == 1 else "down"
                                    coord_hist = get_coord(actual_start_pos, actual_direction)
                                else: coord_hist = "???"; print("WARNING: Could not determine actual start pos for history coord.")
                                # Format word_with_blanks based on full word
                                word_with_blanks_list_hist = []; placed_pos_set_hist = set((p[0], p[1]) for p in word_positions); blanks_in_play = blanks.copy() & placed_pos_set_hist
                                for wr, wc, w_letter in full_word_tiles_hist: is_blank_hist = (wr, wc) in blanks_in_play; word_with_blanks_list_hist.append(w_letter.lower() if is_blank_hist else w_letter.upper())
                                word_with_blanks_hist = "".join(word_with_blanks_list_hist)
                                # Append correct info to history
                                move_history.append({
                                    'player': turn, 'move_type': 'place', 'rack': original_rack[:],
                                    'positions': full_word_tiles_hist, # Store full word tiles for highlight
                                    'blanks': blanks_in_play, 'score': score, 'word': full_word_hist,
                                    'drawn': drawn_tiles, 'coord': coord_hist, # Use corrected coord
                                    'word_with_blanks': word_with_blanks_hist, 'is_bingo': is_bingo,
                                    'newly_placed': word_positions # Keep track of only typed tiles if needed elsewhere
                                })
                                current_replay_turn = len(move_history); print(f"Player {turn} played: {full_word_hist} at {coord_hist} for {score} points")
                                # Update highlight coords after HUMAN move
                                last_played_highlight_coords = set((pos[0], pos[1]) for pos in full_word_tiles_hist)
                                consecutive_zero_point_turns = 0; pass_count = 0; exchange_count = 0; human_played = True; turn = 3 - turn
                                typing = False; typing_start = None; typing_direction = None; word_positions = []; original_tiles = None; original_rack = None; selected_square = None

                        elif event.key == pygame.K_BACKSPACE: # Backspace ...
                            if word_positions:
                                r_rem, c_rem, letter_rem = word_positions.pop(); tiles[r_rem][c_rem] = ''
                                if (r_rem, c_rem) in blanks: blanks.remove((r_rem, c_rem)); racks[turn-1].append(' ')
                                else: racks[turn-1].append(letter_rem)
                                # --- ADDED SORT ---
                                if not is_ai[turn-1]: racks[turn-1].sort() # Sort after returning tile
                                # ------------------
                                current_r, current_c = r_rem, c_rem # Move cursor back
                            else: # Backspace when no letters typed yet
                                typing = False; selected_square = original_selected_square; original_tiles = None; original_rack = None
                        elif event.key == pygame.K_ESCAPE: # Cancel typing ...
                             if original_tiles and original_rack:
                                 for r_wp, c_wp, _ in word_positions: tiles[r_wp][c_wp] = original_tiles[r_wp][c_wp]
                                 racks[turn-1] = original_rack[:]
                                 # --- ADDED SORT ---
                                 if not is_ai[turn-1]: racks[turn-1].sort() # Sort after reverting
                                 # ------------------
                                 blanks_to_remove = set((r_wp, c_wp) for r_wp, c_wp, _ in word_positions if (r_wp, c_wp) in blanks); blanks.difference_update(blanks_to_remove)
                             typing = False; typing_start = None; typing_direction = None; word_positions = []; original_tiles = None; original_rack = None; selected_square = original_selected_square
                        elif event.unicode.isalpha(): # Typing subsequent letters
                            letter = event.unicode.upper()
                            if 0 <= current_r < GRID_SIZE and 0 <= current_c < GRID_SIZE and not tiles[current_r][current_c]:
                                placed = False
                                if letter in racks[turn-1]: tiles[current_r][current_c] = letter; racks[turn-1].remove(letter); word_positions.append((current_r, current_c, letter)); placed = True
                                elif ' ' in racks[turn-1]: tiles[current_r][current_c] = letter; racks[turn-1].remove(' '); blanks.add((current_r, current_c)); word_positions.append((current_r, current_c, letter)); placed = True
                                # Corrected Indentation Block 2
                                if placed:
                                    if typing_direction == "right":
                                        current_c += 1
                                        while current_c < GRID_SIZE and tiles[current_r][current_c]: current_c += 1
                                    elif typing_direction == "down": # Correctly aligned
                                        current_r += 1
                                        while current_r < GRID_SIZE and tiles[current_r][current_c]: current_r += 1 # Correctly indented
                                    # Correctly indented
                                    current_r = min(current_r, GRID_SIZE - 1)
                                    current_c = min(current_c, GRID_SIZE - 1)
                                # End Corrected Block 2
                            else: print("Cannot type here (occupied or off-board).")


        # --- Game Over Check ---
        if not replay_mode and not game_over_state and practice_mode != "eight_letter":
            game_ended = False; reason = ""; rack0_exists = len(racks)>0 and racks[0] is not None; rack1_exists = len(racks)>1 and racks[1] is not None; rack0_empty = rack0_exists and not racks[0]; rack1_empty = rack1_exists and not racks[1]
            if not bag and (rack0_empty or rack1_empty): game_ended = True; reason = "Bag empty & rack empty"
            elif consecutive_zero_point_turns >= 6: game_ended = True; reason = "Six Consecutive Zero-Point Turns"
            if game_ended:
                print(f"Game over triggered: {reason}");
                final_scores = calculate_final_scores(scores, racks, bag)
                game_over_state = True; exchanging = False; hinting = False; showing_all_words = False; dropdown_open = False; dragging = False; typing = False; selected_square = None
                dialog_x = (WINDOW_WIDTH - DIALOG_WIDTH) // 2; dialog_y = (WINDOW_HEIGHT - DIALOG_HEIGHT) // 2; last_played_highlight_coords = set() # Clear highlight

        # --- Drawing Logic ---
        screen.fill(WHITE)
        # Determine state variables for drawing based on mode
        turn_to_display = turn
        if replay_mode: # Determine state based on replay method
            if is_loaded_game and replay_initial_shuffled_bag is not None:
                tiles_to_display, blanks_to_display, scores_to_display, racks_to_display = simulate_game_up_to(current_replay_turn, move_history, replay_initial_shuffled_bag)
            elif not is_loaded_game and initial_racks is not None: # Check if initial_racks exists
                tiles_to_display, blanks_to_display, scores_to_display, racks_to_display = get_replay_state(current_replay_turn, initial_racks) # Assumes move_history has 'drawn'
            else: # Fallback if initial state cannot be determined
                print("Replay Warning: Missing initial state for replay. Displaying turn 0.")
                tiles_to_display, blanks_to_display, scores_to_display, racks_to_display = get_replay_state(0, [[], []]) # Use empty initial racks as fallback
            # Determine whose turn it *would* be after the displayed move
            if current_replay_turn == 0:
                 turn_to_display = 1
            elif current_replay_turn > 0 and current_replay_turn <= len(move_history):
                 # The turn *after* move N is played by the *other* player
                 turn_to_display = 3 - move_history[current_replay_turn - 1]['player']
            else: # Should not happen if current_replay_turn is capped, but safety
                 turn_to_display = 1 # Default to player 1 if out of bounds
        else: # Live game
            tiles_to_display, blanks_to_display, racks_to_display = tiles, blanks, racks
            scores_to_display = final_scores if game_over_state else scores
            turn_to_display = turn # Already set correctly

        # Draw Board/Tiles ...
        for r in range(GRID_SIZE):
            for c in range(GRID_SIZE):
                pygame.draw.rect(screen, board[r][c], (40 + c * SQUARE_SIZE, 40 + r * SQUARE_SIZE, SQUARE_SIZE, SQUARE_SIZE)); pygame.draw.rect(screen, BLACK, (40 + c * SQUARE_SIZE, 40 + r * SQUARE_SIZE, SQUARE_SIZE, SQUARE_SIZE), 1)
                if tiles_to_display[r][c]:
                    tile_char = tiles_to_display[r][c]; is_blank_on_board = (r, c) in blanks_to_display;
                    is_last_played = (r, c) in last_played_highlight_coords and not replay_mode
                    tile_bg_color = PALE_YELLOW if is_last_played else GREEN
                    if is_blank_on_board: # Draw blank tile
                        center = (40 + c * SQUARE_SIZE + SQUARE_SIZE // 2, 40 + r * SQUARE_SIZE + SQUARE_SIZE // 2); radius = SQUARE_SIZE // 2 - 3
                        if is_last_played: pygame.draw.rect(screen, tile_bg_color, (40 + c * SQUARE_SIZE + 2, 40 + r * SQUARE_SIZE + 2, SQUARE_SIZE - 4, SQUARE_SIZE - 4)) # Highlight behind circle
                        pygame.draw.circle(screen, BLACK, center, radius); text_surf = font.render(tile_char, True, WHITE); text_rect = text_surf.get_rect(center=center); screen.blit(text_surf, text_rect)
                    else: # Draw regular tile
                        tile_rect = pygame.Rect(40 + c * SQUARE_SIZE + 2, 40 + r * SQUARE_SIZE + 2, SQUARE_SIZE - 4, SQUARE_SIZE - 4);
                        pygame.draw.rect(screen, tile_bg_color, tile_rect); # Use determined bg color
                        text_surf = font.render(tile_char, True, BLACK); text_rect = text_surf.get_rect(center=tile_rect.center); screen.blit(text_surf, text_rect)

        # Highlight *new* tiles for the current replay turn (Yellow border)
        if replay_mode and current_replay_turn > 0 and current_replay_turn <= len(move_history): # Check bounds
            last_move_data = move_history[current_replay_turn - 1]
            if last_move_data['move_type'] == 'place':
                 newly_placed_coords = last_move_data.get('newly_placed') # Use newly_placed if available
                 if newly_placed_coords is None: # Fallback calculation
                     original_replay_tiles = [['' for _ in range(GRID_SIZE)] for _ in range(GRID_SIZE)];
                     try:
                         if is_loaded_game and replay_initial_shuffled_bag: original_replay_tiles,_,_,_ = simulate_game_up_to(current_replay_turn - 1, move_history, replay_initial_shuffled_bag)
                         elif not is_loaded_game and initial_racks is not None: original_replay_tiles,_,_,_ = get_replay_state(current_replay_turn - 1, initial_racks)
                     except Exception as e: print(f"Error getting prev state for highlight: {e}")
                     # Use 'positions' from history as fallback source for newly placed
                     newly_placed_coords = [(p[0], p[1], p[2]) for p in last_move_data.get('positions', []) if 0<=p[0]<GRID_SIZE and 0<=p[1]<GRID_SIZE and not original_replay_tiles[p[0]][p[1]]]
                 for r, c, _ in newly_placed_coords:
                      if 0 <= r < GRID_SIZE and 0 <= c < GRID_SIZE:
                           pygame.draw.rect(screen, YELLOW, (40 + c * SQUARE_SIZE, 40 + r * SQUARE_SIZE, SQUARE_SIZE, SQUARE_SIZE), 3)

        # Draw Labels ...
        for r in range(GRID_SIZE): row_label = ui_font.render(str(r + 1), True, BLACK); screen.blit(row_label, (10, 40 + r * SQUARE_SIZE + (SQUARE_SIZE // 2 - row_label.get_height() // 2)))
        for c in range(GRID_SIZE): col_label = ui_font.render(LETTERS[c], True, BLACK); screen.blit(col_label, (40 + c * SQUARE_SIZE + (SQUARE_SIZE // 2 - col_label.get_width() // 2), 10))
        # Draw Racks ...
        p1_rack_to_draw = racks_to_display[0] if len(racks_to_display) > 0 else []; p1_drag_info = dragged_tile if dragged_tile and dragged_tile[0] == 1 else None
        p1_alpha_rect, p1_rand_rect = draw_rack(1, p1_rack_to_draw, scores_to_display, turn_to_display, player_names, p1_drag_info, drag_pos)
        p2_alpha_rect, p2_rand_rect = None, None
        if practice_mode != "eight_letter": p2_rack_to_draw = racks_to_display[1] if len(racks_to_display) > 1 else []; p2_drag_info = dragged_tile if dragged_tile and dragged_tile[0] == 2 else None; p2_alpha_rect, p2_rand_rect = draw_rack(2, p2_rack_to_draw, scores_to_display, turn_to_display, player_names, p2_drag_info, drag_pos)
        # Draw Remaining Tiles ...
        if practice_mode != "eight_letter":
            current_player_index = turn_to_display - 1
            if 0 <= current_player_index < len(racks_to_display):
                 # Need to calculate remaining based on the *displayed* state
                 remaining = get_remaining_tiles(racks_to_display[current_player_index], tiles_to_display, blanks_to_display)
                 draw_remaining_tiles(remaining, turn_to_display)
            else: draw_remaining_tiles({}, turn_to_display) # Show empty if rack invalid
        # Draw UI Buttons ...
        # Pass turn_to_display to options menu drawing
        options_rect, dropdown_rects = draw_options_menu(turn_to_display, dropdown_open, len(bag))
        suggest_rect = None; hint_rect = None
        if not replay_mode: # Only draw Suggest button if not in replay
             suggest_rect = draw_suggest_button()
             if paused_for_power_tile and suggest_rect: hint_x = suggest_rect.x; hint_y = suggest_rect.y + suggest_rect.height + BUTTON_GAP; hint_rect = pygame.Rect(hint_x, hint_y, OPTIONS_WIDTH, OPTIONS_HEIGHT); hover = hint_rect.collidepoint(pygame.mouse.get_pos()); color = BUTTON_HOVER if hover else BUTTON_COLOR; pygame.draw.rect(screen, color, hint_rect); hint_text = button_font.render("Hint", True, BLACK); hint_text_rect = hint_text.get_rect(center=hint_rect.center); screen.blit(hint_text, hint_text_rect)
             # Draw Score Preview Checkbox
             if suggest_rect:
                 checkbox_x = suggest_rect.left
                 checkbox_y = suggest_rect.bottom + BUTTON_GAP
                 preview_checkbox_rect = pygame.Rect(checkbox_x, checkbox_y, 20, 20) # Store rect for click detection
                 draw_checkbox(screen, checkbox_x, checkbox_y, preview_score_enabled)
                 label_surf = ui_font.render("Score Preview", True, BLACK)
                 screen.blit(label_surf, (checkbox_x + 25, checkbox_y + (preview_checkbox_rect.height - label_surf.get_height()) // 2))

        # Draw Scoreboard ...
        history_to_draw = move_history[:current_replay_turn] if replay_mode else move_history; is_final_turn_in_replay = replay_mode and current_replay_turn == len(move_history)
        # Use scores_to_display which reflects the current replay state
        draw_scoreboard(screen, history_to_draw, scroll_offset, scores_to_display, is_ai, final_scores=final_scores, game_over_state=game_over_state or is_final_turn_in_replay)
        # Draw Typing Arrow / Cursor ...
        if selected_square and not typing: draw_arrow(selected_square[0], selected_square[1], selected_square[2])
        elif typing:
             if current_r is not None and current_c is not None: cursor_x = 40 + current_c * SQUARE_SIZE + SQUARE_SIZE // 2; cursor_y = 40 + current_r * SQUARE_SIZE + SQUARE_SIZE - 5;
             if int(time.time() * 2) % 2 == 0: pygame.draw.line(screen, BLACK, (cursor_x - 5, cursor_y), (cursor_x + 5, cursor_y), 2)
             # Draw Preview Score Text
             if preview_score_enabled:
                 preview_text = f"Preview: {current_preview_score}"
                 preview_surf = ui_font.render(preview_text, True, BLACK)
                 rack_y_preview = BOARD_SIZE + 80 if turn == 1 else BOARD_SIZE + 150
                 preview_x = BOARD_SIZE - preview_surf.get_width() - 10 # Example: bottom right of board area
                 preview_y = rack_y_preview - 30 # Example: Above the rack
                 screen.blit(preview_surf, (preview_x, preview_y))

        # Draw Dialogs ...
        if exchanging: tile_rects, exchange_button_rect, cancel_button_rect = draw_exchange_dialog(racks[turn-1], selected_tiles)
        elif hinting: hint_rects, play_button_rect, ok_button_rect, all_words_button_rect = draw_hint_dialog(hint_moves, selected_hint_index)
        elif showing_all_words: moves_for_all = practice_target_moves if practice_mode == "eight_letter" else all_moves; all_words_rects, all_words_play_rect, all_words_ok_rect = draw_all_words_dialog(moves_for_all, selected_hint_index, scroll_offset)
        elif showing_practice_end_dialog: practice_play_again_rect, practice_main_menu_rect, practice_quit_rect = draw_practice_end_dialog(practice_end_message)
        # Draw Replay Controls ...
        if replay_mode:
            replay_controls = [(replay_start_rect, "start"), (replay_prev_rect, "prev"), (replay_next_rect, "next"), (replay_end_rect, "end")]
            for rect, icon_type in replay_controls: hover = rect.collidepoint(pygame.mouse.get_pos()); color = BUTTON_HOVER if hover else BUTTON_COLOR; pygame.draw.rect(screen, color, rect); draw_replay_icon(screen, rect, icon_type)
        # Draw Game Over / Stats Dialog ...
        if game_over_state:
            if final_scores is not None: save_rect, quit_rect, replay_rect, play_again_rect, stats_rect = draw_game_over_dialog(dialog_x, dialog_y, final_scores, reason, player_names)
            if showing_stats and final_scores: ok_button_rect = draw_stats_dialog(dialog_x + 20, dialog_y + 20, player_names, final_scores, tiles)
        # Draw dragged tile last ...
        if dragged_tile and drag_pos:
            player_idx_drag = dragged_tile[0]-1; tile_val = None
            # Use racks_to_display for drawing dragged tile in replay mode
            current_racks_for_drag = racks_to_display if replay_mode else racks
            if 0 <= player_idx_drag < len(current_racks_for_drag) and 0 <= dragged_tile[1] < len(current_racks_for_drag[player_idx_drag]):
                 tile_val = current_racks_for_drag[player_idx_drag][dragged_tile[1]]
            if tile_val:
                tile_x_drag, tile_y_drag = drag_pos
                if tile_val == ' ': center = (tile_x_drag, tile_y_drag); radius = TILE_WIDTH // 2 - 2; pygame.draw.circle(screen, BLACK, center, radius); text = font.render('?', True, WHITE); text_rect = text.get_rect(center=center); screen.blit(text, text_rect)
                else: draw_x = tile_x_drag - drag_offset[0]; draw_y = tile_y_drag - drag_offset[1]; pygame.draw.rect(screen, GREEN, (draw_x, draw_y, TILE_WIDTH, TILE_HEIGHT)); text = font.render(tile_val, True, BLACK); screen.blit(text, (draw_x + 5, draw_y + 5))

        pygame.display.flip() # Update the full display

    # --- End of Main Game Loop ---
    print("--- main(): Exited main game loop. ---")
    if return_to_mode_selection:
        print("--- main(): Returning to mode selection... ---")
        main_called = False # Reset flag
        main() # Restart
    else:
        print("--- main(): Quitting pygame and exiting. ---")
        pygame.quit(); sys.exit()

# --- Program Entry Point ---
if __name__ == "__main__":
    print("--- Script execution started (__name__ == '__main__') ---")
    main_called = False # Ensure flag is reset before first call
    main()
