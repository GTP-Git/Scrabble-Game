# Part 1

import pickle
import random
import copy
import regex as re
import pygame
import sys

# Initialize Pygame
pygame.init()

# DAWG Node class (unchanged)
class Node:
    next_id = 0

    def __init__(self):
        self.is_terminal = False
        self.id = Node.next_id
        Node.next_id += 1
        self.children = {}

    def __str__(self):
        out = [f"Node {self.id}\nChildren:\n"]
        for letter, child in self.children.items():
            out.append(f" {letter} -> {child.id}\n")
        return " ".join(out)

    def __repr__(self):
        out = []
        if self.is_terminal:
            out.append("1")
        else:
            out.append("0")
        for key, val in self.children.items():
            out.append(key)
            out.append(str(val.id))
        return "_".join(out)

    def __hash__(self):
        return self.__repr__().__hash__()

    def __eq__(self, other):
        return self.__repr__() == other.__repr__()

# Square class (unchanged)
class Square:
    def __init__(self, letter=None, modifier="Normal", sentinel=1):
        self.letter = letter
        self.cross_checks_0 = [sentinel] * 26
        self.cross_checks_1 = [sentinel] * 26
        self.cross_checks = self.cross_checks_0
        self.modifier = modifier
        self.visible = True
        self.is_blank = False
        if sentinel == 0:
            self.visible = False

    def __str__(self):
        if not self.visible:
            return ""
        if not self.letter:
            return "_"
        else:
            return self.letter

    def check_switch(self, is_transpose):
        if is_transpose:
            self.cross_checks = self.cross_checks_1
        else:
            self.cross_checks = self.cross_checks_0

# ScrabbleBoard class (unchanged except for print_board modification)
class ScrabbleBoard:
    def __init__(self, dawg_root):
        row_1 = [
            Square(modifier="3WS"), Square(), Square(), Square(modifier="2LS"), Square(),
            Square(), Square(), Square(modifier="3WS"), Square(), Square(),
            Square(), Square(modifier="2LS"), Square(), Square(), Square(modifier="3WS"),
            Square(sentinel=0)
        ]
        row_15 = copy.deepcopy(row_1)
        row_2 = [
            Square(), Square(modifier="2WS"), Square(), Square(), Square(),
            Square(modifier="3LS"), Square(), Square(), Square(), Square(modifier="3LS"),
            Square(), Square(), Square(), Square(modifier="2WS"), Square(),
            Square(sentinel=0)
        ]
        row_14 = copy.deepcopy(row_2)
        row_3 = [
            Square(), Square(), Square(modifier="2WS"), Square(), Square(),
            Square(), Square(modifier="2LS"), Square(), Square(modifier="2LS"), Square(),
            Square(), Square(), Square(modifier="2WS"), Square(), Square(),
            Square(sentinel=0)
        ]
        row_13 = copy.deepcopy(row_3)
        row_4 = [
            Square(modifier="2LS"), Square(), Square(), Square(modifier="2WS"), Square(),
            Square(), Square(), Square(modifier="2LS"), Square(), Square(),
            Square(), Square(modifier="2WS"), Square(), Square(), Square(modifier="2LS"),
            Square(sentinel=0)
        ]
        row_12 = copy.deepcopy(row_4)
        row_5 = [
            Square(), Square(), Square(), Square(), Square(modifier="2WS"),
            Square(), Square(), Square(), Square(), Square(),
            Square(modifier="2WS"), Square(), Square(), Square(), Square(),
            Square(sentinel=0)
        ]
        row_11 = copy.deepcopy(row_5)
        row_6 = [
            Square(), Square(modifier="3LS"), Square(), Square(), Square(),
            Square(modifier="3LS"), Square(), Square(), Square(), Square(modifier="3LS"),
            Square(), Square(), Square(), Square(modifier="3LS"), Square(),
            Square(sentinel=0)
        ]
        row_10 = copy.deepcopy(row_6)
        row_7 = [
            Square(), Square(), Square(modifier="2LS"), Square(), Square(),
            Square(), Square(modifier="2LS"), Square(), Square(modifier="2LS"), Square(),
            Square(), Square(), Square(modifier="2LS"), Square(), Square(),
            Square(sentinel=0)
        ]
        row_9 = copy.deepcopy(row_7)
        row_8 = [
            Square(modifier="3WS"), Square(), Square(), Square(modifier="2LS"), Square(),
            Square(), Square(), Square(modifier="2WS"), Square(), Square(),
            Square(), Square(modifier="2LS"), Square(), Square(), Square(modifier="3WS"),
            Square(sentinel=0)
        ]
        row_16 = [Square(sentinel=0) for _ in range(16)]

        self.board = [row_1, row_2, row_3, row_4, row_5, row_6, row_7, row_8,
                      row_9, row_10, row_11, row_12, row_13, row_14, row_15, row_16]
        self.point_dict = {"A": 1, "B": 3, "C": 3, "D": 2, "E": 1, "F": 4, "G": 2, "H": 4,
                           "I": 1, "J": 8, "K": 5, "L": 1, "M": 3, "N": 1, "O": 1, "P": 3,
                           "Q": 10, "R": 1, "S": 1, "T": 1, "U": 1, "V": 4, "W": 4, "X": 8,
                           "Y": 8, "Z": 10, "%": 0}
        self.words_on_board = []
        self.is_transpose = False
        self.dawg_root = dawg_root
        self.word_rack = []
        self.word_score_dict = {}
        self.best_word = ""
        self.highest_score = 0
        self.dist_from_anchor = 0
        self.letters_from_rack = []
        self.best_row = 0
        self.best_col = 0
        self.upper_cross_check = []
        self.lower_cross_check = []

    def _transpose(self):
        transposed_tuples = copy.deepcopy(list(zip(*self.board)))
        self.board = [list(sublist) for sublist in transposed_tuples]
        self.is_transpose = not self.is_transpose

    def _score_word(self, word, squares, dist_from_anchor):
        score = 0
        score_multiplier = 1
        if self.is_transpose:
            cross_sum_ind = "-"
        else:
            cross_sum_ind = "+"
        board_word = word.replace("%", "")
        if board_word in self.words_on_board:
            return board_word, 0
        word = re.sub("[A-Z]%", "%", word)
        rack_tiles = []
        for letter, square in zip(word, squares):
            if cross_sum_ind in square.modifier:
                score += int(square.modifier[-1])
            if square.modifier:
                rack_tiles.append(letter)
            if "2LS" in square.modifier:
                score += (self.point_dict[letter] * 2)
            elif "3LS" in square.modifier:
                score += (self.point_dict[letter] * 3)
            elif "2WS" in square.modifier:
                score_multiplier *= 2
                score += self.point_dict[letter]
            elif "3WS" in square.modifier:
                score_multiplier *= 3
                score += self.point_dict[letter]
            else:
                score += self.point_dict[letter]
        score *= score_multiplier
        if len(rack_tiles) == 7:
            score += 50
        if score > self.highest_score:
            self.best_word = board_word
            self.highest_score = score
            self.dist_from_anchor = dist_from_anchor
            self.letters_from_rack = rack_tiles

    def _extend_right(self, start_node, square_row, square_col, rack, word, squares, dist_from_anchor):
        square = self.board[square_row][square_col]
        square.check_switch(self.is_transpose)
        if not square.letter:
            if start_node.is_terminal:
                self._score_word(word, squares, dist_from_anchor)
            for letter in start_node.children:
                if self.board[square_row + 1][square_col].letter and self.board[square_row - 1][square_col].letter:
                    continue
                if letter in rack:
                    wildcard = False
                elif "%" in rack:
                    wildcard = True
                else:
                    continue
                if letter in rack and self._cross_check(letter, square):
                    new_node = start_node.children[letter]
                    new_rack = rack.copy()
                    if wildcard:
                        new_word = word + letter + "%"
                        new_rack.remove("%")
                    else:
                        new_word = word + letter
                        new_rack.remove(letter)
                    new_squares = squares + [square]
                    self._extend_right(new_node, square_row, square_col + 1, new_rack, new_word, new_squares, dist_from_anchor)
        else:
            if square.letter in start_node.children:
                new_node = start_node.children[square.letter]
                new_word = word + square.letter
                new_squares = squares + [square]
                self._extend_right(new_node, square_row, square_col + 1, rack, new_word, new_squares, dist_from_anchor)

    def _left_part(self, start_node, anchor_square_row, anchor_square_col, rack, word, squares, limit, dist_from_anchor):
        potential_square = self.board[anchor_square_row][anchor_square_col - dist_from_anchor]
        potential_square.check_switch(self.is_transpose)
        if potential_square.letter:
            return
        self._extend_right(start_node, anchor_square_row, anchor_square_col, rack, word, squares, dist_from_anchor)
        if 0 in potential_square.cross_checks:
            return
        if limit > 0:
            for letter in start_node.children:
                if letter in rack:
                    wildcard = False
                elif "%" in rack:
                    wildcard = True
                else:
                    continue
                new_node = start_node.children[letter]
                new_rack = rack.copy()
                if wildcard:
                    new_word = word + letter + "%"
                    new_rack.remove("%")
                else:
                    new_word = word + letter
                    new_rack.remove(letter)
                new_squares = squares + [potential_square]
                self._left_part(new_node, anchor_square_row, anchor_square_col, new_rack, new_word, new_squares, limit - 1, dist_from_anchor + 1)

    def _update_cross_checks(self):
        while self.upper_cross_check:
            curr_square, lower_letter, lower_row, lower_col = self.upper_cross_check.pop()
            curr_square.check_switch(self.is_transpose)
            if self.is_transpose:
                curr_square.modifier += f"-{self.point_dict[lower_letter]}"
            else:
                curr_square.modifier += f"+{self.point_dict[lower_letter]}"
            chr_val = 65
            if curr_square.letter:
                if not self.is_transpose:
                    self.board[lower_row - 2][lower_col].cross_checks_0 = [0] * 26
                    self.board[lower_row + 1][lower_col].cross_checks_0 = [0] * 26
                else:
                    self.board[lower_row - 2][lower_col].cross_checks_1 = [0] * 26
                    self.board[lower_row + 1][lower_col].cross_checks_1 = [0] * 26
                continue
            for i, ind in enumerate(curr_square.cross_checks):
                if ind == 1:
                    test_node = self.dawg_root.children[chr(chr_val)]
                    if (lower_letter not in test_node.children) or (not test_node.children[lower_letter].is_terminal):
                        curr_square.cross_checks[i] = 0
                chr_val += 1
        while self.lower_cross_check:
            curr_square, upper_letter, upper_row, upper_col = self.lower_cross_check.pop()
            curr_square.check_switch(self.is_transpose)
            if self.is_transpose:
                curr_square.modifier += f"-{self.point_dict[upper_letter]}"
            else:
                curr_square.modifier += f"+{self.point_dict[upper_letter]}"
            chr_val = 65
            if curr_square.letter:
                if not self.is_transpose:
                    self.board[upper_row - 1][upper_col].cross_checks_0 = [0] * 26
                    self.board[upper_row + 2][upper_col].cross_checks_0 = [0] * 26
                else:
                    self.board[upper_row - 1][upper_col].cross_checks_1 = [0] * 26
                    self.board[upper_row + 2][upper_col].cross_checks_1 = [0] * 26
                continue
            for i, ind in enumerate(curr_square.cross_checks):
                if ind == 1:
                    test_node = self.dawg_root.children[upper_letter]
                    if (chr(chr_val) not in test_node.children) or (not test_node.children[chr(chr_val)].is_terminal):
                        curr_square.cross_checks[i] = 0
                chr_val += 1

    def _cross_check(self, letter, square):
        square.check_switch(self.is_transpose)
        chr_val = 65
        for i, ind in enumerate(square.cross_checks):
            if ind == 1 and chr(chr_val) == letter:
                return True
            chr_val += 1
        return False

    def insert_word(self, row, col, word):
        row -= 1
        col -= 1
        if len(word) + col > 15:
            print(f'Cannot insert word "{word}" at column {col + 1}, row {row + 1} not enough space')
            return
        curr_col = col
        modifiers = []
        for i, letter in enumerate(word):
            curr_square_letter = self.board[row][curr_col].letter
            modifiers.append(self.board[row][curr_col].modifier)
            if curr_square_letter:
                if curr_square_letter == letter:
                    if row > 0:
                        self.upper_cross_check.append((self.board[row - 1][curr_col], letter, row, curr_col))
                    if row < 15:
                        self.lower_cross_check.append((self.board[row + 1][curr_col], letter, row, curr_col))
                    curr_col += 1
                else:
                    print(f'Failed to insert letter "{letter}" of "{word}" at column {curr_col + 1}, '
                          f'row {row + 1}. Square is occupied by "{curr_square_letter}"')
                    self.upper_cross_check = []
                    self.lower_cross_check = []
                    for _ in range(i):
                        curr_col -= 1
                        self.board[row][curr_col].letter = None
                        self.board[row][curr_col].modifier = modifiers.pop()
                    return
            else:
                self.board[row][curr_col].letter = letter
                self.board[row][curr_col].is_blank = (i in self.blank_positions)
                self.board[row][curr_col].modifier = ""
                if row > 0:
                    self.upper_cross_check.append((self.board[row - 1][curr_col], letter, row, curr_col))
                if row < 15:
                    self.lower_cross_check.append((self.board[row + 1][curr_col], letter, row, curr_col))
                curr_col += 1
        if curr_col < 15:
            if self.is_transpose:
                self.board[self.best_row][curr_col].cross_checks_0 = [0] * 26
            else:
                self.board[self.best_row][curr_col].cross_checks_1 = [0] * 26
        if col - 1 > -1:
            if self.is_transpose:
                self.board[self.best_row][col - 1].cross_checks_0 = [0] * 26
            else:
                self.board[self.best_row][col - 1].cross_checks_1 = [0] * 26
        self._update_cross_checks()
        self.words_on_board.append(word)

    def get_all_words(self, square_row, square_col, rack):
        square_row -= 1
        square_col -= 1
        self._extend_right(self.dawg_root, square_row, square_col, rack, "", [], 0)
        if self.board[square_row][square_col - 1].letter:
            return
        for i, letter in enumerate(rack):
            potential_square = self.board[square_row][square_col - 1]
            potential_square.check_switch(self.is_transpose)
            if 0 in potential_square.cross_checks or potential_square.letter:
                continue
            temp_rack = rack[:i] + rack[i + 1:]
            self.board[square_row][square_col - 1].letter = letter
            self._left_part(self.dawg_root, square_row, square_col - 1, temp_rack, "", [], 6, 1)
        self.board[square_row][square_col - 1].letter = None

    def get_best_move(self, word_rack):
        self.word_rack = word_rack
        self._update_cross_checks()
        self.best_word = ""
        self.highest_score = 0
        self.best_row = 0
        self.best_col = 0
        self.blank_positions = []
        transposed = False
        for row in range(15):
            for col in range(15):
                curr_square = self.board[row][col]
                if curr_square.letter and (not self.board[row][col - 1].letter):
                    prev_best_score = self.highest_score
                    self.get_all_words(row + 1, col + 1, word_rack)
                    if self.highest_score > prev_best_score:
                        self.best_row = row
                        self.best_col = col
                        # Determine blank positions from letters_from_rack
                        self.blank_positions = []
                        word_with_blanks = self._reconstruct_word_with_blanks()
                        for i, char in enumerate(word_with_blanks):
                            if char.endswith("%"):
                                self.blank_positions.append(i)
        self._transpose()
        for row in range(15):
            for col in range(15):
                curr_square = self.board[row][col]
                if curr_square.letter and (not self.board[row][col - 1].letter):
                    prev_best_score = self.highest_score
                    self.get_all_words(row + 1, col + 1, word_rack)
                    if self.highest_score > prev_best_score:
                        transposed = True
                        self.best_row = row
                        self.best_col = col
                        self.blank_positions = []
                        word_with_blanks = self._reconstruct_word_with_blanks()
                        for i, char in enumerate(word_with_blanks):
                            if char.endswith("%"):
                                self.blank_positions.append(i)
        if not self.best_word:
            self._transpose()
            return word_rack
        if transposed:
            self.insert_word(self.best_row + 1, self.best_col + 1 - self.dist_from_anchor, self.best_word)
            self._transpose()
        else:
            self._transpose()
            self.insert_word(self.best_row + 1, self.best_col + 1 - self.dist_from_anchor, self.best_word)
        self.word_score_dict[self.best_word] = self.highest_score
        for letter in self.letters_from_rack:
            if letter in word_rack:
                word_rack.remove(letter)
        return word_rack

    def _reconstruct_word_with_blanks(self):
        """Reconstruct the word with blank markers based on letters_from_rack."""
        word_with_blanks = ""
        rack_index = 0
        for letter in self.best_word:
            if rack_index < len(self.letters_from_rack) and self.letters_from_rack[rack_index] == letter:
                # Check if this letter was played with a blank
                if rack_index < len(self.letters_from_rack) and "%" in self.word_rack:
                    word_with_blanks += letter + "%"
                else:
                    word_with_blanks += letter
                rack_index += 1
            else:
                word_with_blanks += letter
        return word_with_blanks

    def get_start_move(self, word_rack):
        self.best_row = 7
        self.best_col = 8
        self.blank_positions = []
        for i, letter in enumerate(word_rack):
            potential_square = self.board[7][8]
            temp_rack = word_rack[:i] + word_rack[i + 1:]
            potential_square.letter = letter
            self._left_part(self.dawg_root, 7, 8, temp_rack, "", [], 6, 1)
        self.board[7][8].letter = None
        self.blank_positions = []
        word_with_blanks = self._reconstruct_word_with_blanks()
        for i, char in enumerate(word_with_blanks):
            if char.endswith("%"):
                self.blank_positions.append(i)
        self.insert_word(self.best_row + 1, self.best_col + 1 - self.dist_from_anchor, self.best_word)
        self.board[7][8].modifier = ""
        self.word_score_dict[self.best_word] = self.highest_score
        for letter in self.letters_from_rack:
            if letter in word_rack:
                word_rack.remove(letter)
        return word_rack

# Helper functions (unchanged)
def length_common_prefix(prev_word, word):
    shared_prefix_length = 0
    for letter1, letter2 in zip(prev_word, word):
        if letter1 == letter2:
            shared_prefix_length += 1
        else:
            return shared_prefix_length
    return shared_prefix_length

def minimize(curr_node, common_prefix_length, minimized_nodes, non_minimized_nodes):
    for _ in range(len(non_minimized_nodes), common_prefix_length, -1):
        parent, letter, child = non_minimized_nodes.pop()
        if child in minimized_nodes:
            parent.children[letter] = minimized_nodes[child]
        else:
            minimized_nodes[child] = child
        curr_node = parent
    return curr_node

def build_dawg(lexicon):
    root = Node()
    minimized_nodes = {root: root}
    non_minimized_nodes = []
    curr_node = root
    prev_word = ""
    for word in lexicon:
        common_prefix_length = length_common_prefix(prev_word, word)
        if non_minimized_nodes:
            curr_node = minimize(curr_node, common_prefix_length, minimized_nodes, non_minimized_nodes)
        for letter in word[common_prefix_length:]:
            next_node = Node()
            curr_node.children[letter] = next_node
            non_minimized_nodes.append((curr_node, letter, next_node))
            curr_node = next_node
        curr_node.is_terminal = True
        prev_word = word
    minimize(curr_node, 0, minimized_nodes, non_minimized_nodes)
    return root

def find_in_dawg(word, curr_node):
    for letter in word:
        if letter in curr_node.children:
            curr_node = curr_node.children[letter]
        else:
            return False
    return curr_node.is_terminal

def all_board_words(board):
    board_words = []
    for row in range(15):
        temp_word = ""
        for col in range(16):
            letter = board[row][col].letter
            if letter:
                temp_word += letter
            else:
                if len(temp_word) > 1:
                    board_words.append(temp_word)
                temp_word = ""
    for col in range(16):
        temp_word = ""
        for row in range(16):
            letter = board[row][col].letter
            if letter:
                temp_word += letter
            else:
                if len(temp_word) > 1:
                    board_words.append(temp_word)
                temp_word = ""
    return board_words

def refill_word_rack(rack, tile_bag):
    to_add = min(7 - len(rack), len(tile_bag))
    new_letters = random.sample(tile_bag, to_add)
    rack += new_letters
    return rack, new_letters

# End of Part 1

# Part 2

# UI Constants
GRID_SIZE = 15
SQUARE_SIZE = 40
BOARD_SIZE = GRID_SIZE * SQUARE_SIZE
WINDOW_WIDTH = 1000
WINDOW_HEIGHT = 900
FONT_SIZE = SQUARE_SIZE // 2
TILE_WIDTH = 35
TILE_HEIGHT = 35
TILE_GAP = 5
BUTTON_WIDTH = 100
BUTTON_HEIGHT = 30
BUTTON_GAP = 10
REPLAY_BUTTON_WIDTH = 60
REPLAY_BUTTON_HEIGHT = 40
REPLAY_BUTTON_GAP = 10
LETTERS = "ABCDEFGHIJKLMNO"

# Colors
WHITE = (255, 255, 255)
BLACK = (0, 0, 0)
RED = (255, 100, 100)
PINK = (255, 182, 193)
BLUE = (0, 102, 204)
LIGHT_BLUE = (135, 206, 250)
YELLOW = (255, 255, 153)
GRAY = (200, 200, 200)
BUTTON_COLOR = (180, 180, 180)
TURN_INDICATOR_COLOR = (255, 215, 0)

# Setup display and fonts
screen = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))
pygame.display.set_caption("Scrabble Game")
font = pygame.font.SysFont("Arial", FONT_SIZE, bold=True)
ui_font = pygame.font.SysFont("Arial", 20)
button_font = pygame.font.SysFont("Arial", 16)
tile_count_font = pygame.font.SysFont("Arial", 14)

# Modifier colors
MODIFIER_COLORS = {
    "Normal": WHITE,
    "2LS": LIGHT_BLUE,
    "3LS": BLUE,
    "2WS": PINK,
    "3WS": RED
}

# UI Drawing Functions
def draw_board(board):
    """Draw the Scrabble board with modifiers and labels."""
    for row in range(GRID_SIZE):
        for col in range(GRID_SIZE):
            square = board[row][col]
            color = MODIFIER_COLORS.get(square.modifier, WHITE)
            if row == 7 and col == 7 and not square.letter:  # Center square
                color = PINK
            pygame.draw.rect(screen, color, (col * SQUARE_SIZE + 50, row * SQUARE_SIZE + 50, SQUARE_SIZE, SQUARE_SIZE))
            pygame.draw.rect(screen, BLACK, (col * SQUARE_SIZE + 50, row * SQUARE_SIZE + 50, SQUARE_SIZE, SQUARE_SIZE), 1)
            if square.letter:
                # If the tile is a blank, draw a gray circle behind the letter
                if square.is_blank:
                    circle_center = (col * SQUARE_SIZE + 50 + SQUARE_SIZE // 2, row * SQUARE_SIZE + 50 + SQUARE_SIZE // 2)
                    pygame.draw.circle(screen, GRAY, circle_center, SQUARE_SIZE // 3)
                # Render the letter in uppercase and center it
                text = font.render(square.letter.upper(), True, BLACK)
                text_rect = text.get_rect(center=(col * SQUARE_SIZE + 50 + SQUARE_SIZE // 2, row * SQUARE_SIZE + 50 + SQUARE_SIZE // 2))
                screen.blit(text, text_rect)
            elif row == 7 and col == 7:  # Draw star on center square if empty
                star_text = font.render("*", True, BLACK)
                screen.blit(star_text, (col * SQUARE_SIZE + 50 + SQUARE_SIZE // 3, row * SQUARE_SIZE + 50 + SQUARE_SIZE // 4))
    # Draw column letters
    for col in range(GRID_SIZE):
        text = font.render(LETTERS[col], True, BLACK)
        screen.blit(text, (col * SQUARE_SIZE + 50 + SQUARE_SIZE // 3, 20))
    # Draw row numbers
    for row in range(GRID_SIZE):
        text = font.render(str(row + 1), True, BLACK)
        screen.blit(text, (10, row * SQUARE_SIZE + 50 + SQUARE_SIZE // 4))

def draw_rack(player, rack, score, turn):
    """Draw a player's rack with tiles and buttons."""
    rack_width = 7 * (TILE_WIDTH + TILE_GAP) - TILE_GAP
    start_x = (WINDOW_WIDTH - rack_width) // 2
    rack_y = BOARD_SIZE + 90 if player == 1 else BOARD_SIZE + 160
    # Draw score
    score_text = ui_font.render(f"{'PLAYER 1' if player == 1 else 'AI'} SCORE: {score}", True, BLACK)
    screen.blit(score_text, (start_x, rack_y - 30))
    # Draw turn indicator
    if turn == player:
        pygame.draw.circle(screen, TURN_INDICATOR_COLOR, (start_x - 20, rack_y + TILE_HEIGHT // 2), 10)
    # Draw tiles
    for i, letter in enumerate(rack):
        pygame.draw.rect(screen, YELLOW, (start_x + i * (TILE_WIDTH + TILE_GAP), rack_y, TILE_WIDTH, TILE_HEIGHT))
        display_letter = "?" if letter == "%" else letter
        text = font.render(display_letter, True, BLACK)
        screen.blit(text, (start_x + i * (TILE_WIDTH + TILE_GAP) + TILE_WIDTH // 3, rack_y + TILE_HEIGHT // 4))
    # Draw buttons
    buttons = ["Alphabetize", "Randomize"]
    for i, button in enumerate(buttons):
        button_rect = pygame.Rect(start_x + rack_width + 20 + i * (BUTTON_WIDTH + BUTTON_GAP), rack_y, BUTTON_WIDTH, BUTTON_HEIGHT)
        pygame.draw.rect(screen, BUTTON_COLOR, button_rect)
        text = button_font.render(button, True, BLACK)
        text_rect = text.get_rect(center=button_rect.center)
        screen.blit(text, text_rect)

def draw_buttons():
    """Draw the Options and Suggest buttons."""
    buttons = ["Options", "Suggest"]
    start_x = 50
    y_pos = BOARD_SIZE + 60
    for i, button in enumerate(buttons):
        button_rect = pygame.Rect(start_x + i * (BUTTON_WIDTH + BUTTON_GAP), y_pos, BUTTON_WIDTH, BUTTON_HEIGHT)
        pygame.draw.rect(screen, BUTTON_COLOR, button_rect)
        text = button_font.render(button, True, BLACK)
        text_rect = text.get_rect(center=button_rect.center)
        screen.blit(text, text_rect)

def draw_remaining_tiles(remaining):
    """Draw the list of remaining tiles."""
    title_text = ui_font.render("P1's Unseen Tiles:", True, BLACK)
    screen.blit(title_text, (BOARD_SIZE + 60, 10))
    y_pos = 40
    for letter in sorted(remaining.keys()):
        if remaining[letter] > 0:
            display_letter = "?" if letter == "%" else letter
            tile_string = display_letter * remaining[letter]
            text = tile_count_font.render(tile_string, True, BLACK)
            screen.blit(text, (BOARD_SIZE + 60, y_pos))
            y_pos += 20
    y_pos += 20
    total_tiles = sum(remaining.values())
    vowels = sum(remaining.get(letter, 0) for letter in 'AEIOU')
    consonants = total_tiles - vowels - remaining.get("%", 0)
    text1 = tile_count_font.render(f"Tiles remaining: {total_tiles}", True, BLACK)
    text2 = tile_count_font.render(f"Vowels: {vowels}     Consonants: {consonants}", True, BLACK)
    screen.blit(text1, (BOARD_SIZE + 60, y_pos))
    screen.blit(text2, (BOARD_SIZE + 60, y_pos + 20))

# End of Part 2

# Part 3

from collections import Counter

def draw_dialog():
    """Draw the end-game dialog with Quit, Play Again, and Replay options."""
    # Draw a semi-transparent overlay
    overlay = pygame.Surface((WINDOW_WIDTH, WINDOW_HEIGHT), pygame.SRCALPHA)
    overlay.fill((0, 0, 0, 128))  # Semi-transparent black
    screen.blit(overlay, (0, 0))
    # Draw dialog buttons
    for button in dialog_buttons:
        pygame.draw.rect(screen, BUTTON_COLOR, button['rect'])
        text = button_font.render(button['text'], True, BLACK)
        text_rect = text.get_rect(center=button['rect'].center)
        screen.blit(text, text_rect)

def save_state():
    """Save the current game state for replay functionality."""
    state = {
        'board': copy.deepcopy(game.board),
        'player_rack': player_rack.copy(),
        'ai_rack': ai_rack.copy(),
        'tile_bag': tile_bag.copy(),
        'player_score': player_score,
        'ai_score': ai_score,
        'turn': turn
    }
    game_states.append(state)

def initialize_game():
    """Initialize or reset the game state."""
    global player_score, ai_score, tile_bag, player_rack, ai_rack, game, turn, play, game_states, show_dialog, in_replay, current_state, root
    with open("All Words 2023.txt", "r") as file:
        lexicon = [line.strip() for line in file.readlines()]
    root = build_dawg(lexicon)
    player_score = 0
    ai_score = 0
    tile_bag = ["A"] * 9 + ["B"] * 2 + ["C"] * 2 + ["D"] * 4 + ["E"] * 12 + ["F"] * 2 + ["G"] * 3 + \
               ["H"] * 2 + ["I"] * 9 + ["J"] * 1 + ["K"] * 1 + ["L"] * 4 + ["M"] * 2 + ["N"] * 6 + \
               ["O"] * 8 + ["P"] * 2 + ["Q"] * 1 + ["R"] * 6 + ["S"] * 4 + ["T"] * 6 + ["U"] * 4 + \
               ["V"] * 2 + ["W"] * 2 + ["X"] * 1 + ["Y"] * 2 + ["Z"] * 1 + ["%"] * 2
    player_rack = random.sample(tile_bag, 7)
    [tile_bag.remove(letter) for letter in player_rack]
    ai_rack = random.sample(tile_bag, 7)
    [tile_bag.remove(letter) for letter in ai_rack]
    game = ScrabbleBoard(root)
    turn = 1  # 1 for Player 1, 2 for AI
    play = True
    game_states = []
    show_dialog = False
    in_replay = False
    current_state = 0
    # Save initial state (empty board)
    save_state()
    # Initial move (Player 1)
    player_rack = game.get_start_move(player_rack)
    player_score += game.highest_score
    player_rack, new_letters = refill_word_rack(player_rack, tile_bag)
    [tile_bag.remove(letter) for letter in new_letters]
    save_state()  # Save state after initial move

# Main game function with UI and replay functionality
def play_game():
    global player_score, ai_score, tile_bag, player_rack, ai_rack, game, turn, play, game_states, show_dialog, in_replay, current_state, root, dialog_buttons, replay_buttons

    # Initialize game
    initialize_game()

    # Define dialog buttons (centered horizontally)
    dialog_start_x = (WINDOW_WIDTH - (3 * BUTTON_WIDTH + 2 * BUTTON_GAP)) // 4
    dialog_y = BOARD_SIZE -250  # Positions buttons below the board at y=700
    dialog_buttons = [
        {"text": "Quit", "rect": pygame.Rect(dialog_start_x, dialog_y, BUTTON_WIDTH, BUTTON_HEIGHT)},
        {"text": "Play Again", "rect": pygame.Rect(dialog_start_x + BUTTON_WIDTH + BUTTON_GAP, dialog_y, BUTTON_WIDTH, BUTTON_HEIGHT)},
        {"text": "Replay", "rect": pygame.Rect(dialog_start_x + 2 * (BUTTON_WIDTH + BUTTON_GAP), dialog_y, BUTTON_WIDTH, BUTTON_HEIGHT)},
    ]

    # Define replay buttons (adjusted to be 60 pixels below Options/Suggest, aligned as required)
    replay_start_x = 50  # Align with Options button
    replay_y = BOARD_SIZE + 60 + 60  # 60 pixels below Options/Suggest (660 + 60 = 720)
    replay_buttons = [
        {"text": "<<", "rect": pygame.Rect(replay_start_x, replay_y, REPLAY_BUTTON_WIDTH, REPLAY_BUTTON_HEIGHT)},  # Go to start
        {"text": "<", "rect": pygame.Rect(replay_start_x + REPLAY_BUTTON_WIDTH + REPLAY_BUTTON_GAP, replay_y, REPLAY_BUTTON_WIDTH, REPLAY_BUTTON_HEIGHT)},  # Previous move
        {"text": ">", "rect": pygame.Rect(replay_start_x + 2 * (REPLAY_BUTTON_WIDTH + REPLAY_BUTTON_GAP), replay_y, REPLAY_BUTTON_WIDTH, REPLAY_BUTTON_HEIGHT)},  # Next move
        {"text": ">>", "rect": pygame.Rect(replay_start_x + 3 * (REPLAY_BUTTON_WIDTH + REPLAY_BUTTON_GAP), replay_y, REPLAY_BUTTON_WIDTH, REPLAY_BUTTON_HEIGHT)},  # Go to end, dynamically calculated
    ]

    running = True
    while running:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
            elif event.type == pygame.MOUSEBUTTONDOWN:
                mouse_pos = event.pos
                if show_dialog:
                    if dialog_buttons[0]['rect'].collidepoint(mouse_pos):  # Quit
                        running = False
                    elif dialog_buttons[1]['rect'].collidepoint(mouse_pos):  # Play Again
                        initialize_game()
                    elif dialog_buttons[2]['rect'].collidepoint(mouse_pos):  # Replay
                        in_replay = True
                        current_state = 0
                        show_dialog = False
                elif in_replay:
                    if replay_buttons[0]['rect'].collidepoint(mouse_pos):  # <<
                        current_state = 0
                    elif replay_buttons[1]['rect'].collidepoint(mouse_pos):  # <
                        current_state = max(0, current_state - 1)
                    elif replay_buttons[2]['rect'].collidepoint(mouse_pos):  # >
                        current_state = min(len(game_states) - 1, current_state + 1)
                    elif replay_buttons[3]['rect'].collidepoint(mouse_pos):  # >>
                        current_state = len(game_states) - 1

        # Determine display state
        if in_replay:
            state = game_states[current_state]
            display_board = state['board']
            display_player_rack = state['player_rack']
            display_ai_rack = state['ai_rack']
            display_tile_bag = state['tile_bag']
            display_player_score = state['player_score']
            display_ai_score = state['ai_score']
            display_turn = state['turn']
        else:
            display_board = game.board
            display_player_rack = player_rack
            display_ai_rack = ai_rack
            display_tile_bag = tile_bag
            display_player_score = player_score
            display_ai_score = ai_score
            display_turn = turn

        # Draw the game
        screen.fill(WHITE)
        draw_board(display_board)
        draw_rack(1, display_player_rack, display_player_score, display_turn)
        draw_rack(2, display_ai_rack, display_ai_score, display_turn)
        draw_buttons()
        draw_remaining_tiles(dict(Counter(display_tile_bag)))

        # Draw replay buttons only in replay mode
        if in_replay:
            for button in replay_buttons:
                pygame.draw.rect(screen, BUTTON_COLOR, button['rect'])
                text = button_font.render(button['text'], True, BLACK)
                text_rect = text.get_rect(center=button['rect'].center)
                screen.blit(text, text_rect)

        # Draw dialog when game ends
        if show_dialog:
            draw_dialog()

        pygame.display.flip()

        if play:
            if turn == 1:
                # Player 1's turn (already done for first move)
                turn = 2
            else:
                # AI's turn
                ai_rack = game.get_best_move(ai_rack)
                ai_score += game.highest_score
                ai_rack, new_letters = refill_word_rack(ai_rack, tile_bag)
                [tile_bag.remove(letter) for letter in new_letters]
                save_state()  # Save state after AI move
                turn = 1
                
                if game.best_word == "":
                    if len(tile_bag) >= 7:
                        player_rack, new_letters = refill_word_rack([], tile_bag)
                        [tile_bag.remove(letter) for letter in new_letters]
                        ai_rack, new_letters = refill_word_rack([], tile_bag)
                        [tile_bag.remove(letter) for letter in new_letters]
                    else:
                        play = False
                        show_dialog = True  # Show dialog when game ends
                        for word in all_board_words(game.board):
                            if not find_in_dawg(word, root) and word:
                                raise Exception(f"Invalid word on board: {word}")
        
        pygame.time.wait(0)  # Pause to observe each move

    print(f"Final Player 1 Score: {player_score}")
    print(f"Final AI Score: {ai_score}")
    pygame.quit()
    sys.exit()

if __name__ == "__main__":
    play_game()

# End of Part 3
