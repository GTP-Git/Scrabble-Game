


#python
#Scrabble 2-Ply Sim V11 
#Stable 13APR24

# Part 1


import pygame
import random
import math
import sys
import time
import pickle
import os
import datetime
import itertools
from itertools import permutations, product
from collections import Counter
import copy

# --- GADDAG Node Definition (Add this to Scrabble Game.py) ---
class GaddagNode:
    """Represents a node in the GADDAG."""
    __slots__ = ['children', 'is_terminal'] # Memory optimization

    def __init__(self):
        self.children = {}  # Dictionary mapping letter -> GaddagNode
        self.is_terminal = False # True if a path ending here is a valid word/subword

# --- GADDAG Class Definition (Add this to Scrabble Game.py) ---
class Gaddag:
    """
    Represents the GADDAG data structure.
    This class definition is needed to correctly unpickle the object.
    The actual building happens in gaddag_builder.py.
    """
    SEPARATOR = '>' # Special character used in GADDAG paths

    def __init__(self):
        # The root node will be populated when loading from pickle
        self.root = GaddagNode()

    # No insert method needed here, as we load a pre-built structure.

# Initialize Pygame
pygame.init()
main_called = False # Flag to track if main() has been entered

# Constants
GADDAG_STRUCTURE = None
GRID_SIZE = 15
SQUARE_SIZE = 40
BOARD_SIZE = GRID_SIZE * SQUARE_SIZE
FONT_SIZE = SQUARE_SIZE // 2
TILE_WIDTH = 35
TILE_HEIGHT = 35
TILE_GAP = 5
BUTTON_WIDTH = 100
BUTTON_HEIGHT = 30
BUTTON_GAP = 10
CENTER_SQUARE = (7, 7)
OPTIONS_WIDTH = 100
OPTIONS_HEIGHT = 30
DROPDOWN_HEIGHT = 90
OPTIONS_Y = BOARD_SIZE + 60  # Adjusted from +40 to align with shifted UI
DOUBLE_CLICK_TIME = 300
SECOND_CLICK_TIME = 500  # Time window for second click
ALL_WORDS_DIALOG_WIDTH = 750
ALL_WORDS_DIALOG_HEIGHT = 600
SCROLL_SPEED = 20

STATS_LABEL_X_OFFSET = 10
STATS_P1_VAL_X_OFFSET = 160 # Increased from 120
STATS_P2_VAL_X_OFFSET = 270 # Increased from 230

is_solving_endgame = False # Flag to indicate AI is in endgame calculation
endgame_start_time = 0 # To track duration if needed

EXCHANGE_PREFERENCE_THRESHOLD = 5.0
LOW_SCORE_THRESHOLD = 10
POOL_QUALITY_FACTOR = 1.5
POOL_TILE_VALUES = {' ': 5, 'S': 3, 'Z': 1, 'X': 1, 'Q': -3, 'J': -2, 'V': -2, 'W': -2, 'U': -2, 'I': -1}

# Dialog dimensions for game over dialog
DIALOG_WIDTH = 480
DIALOG_HEIGHT = 250
LETTERS = "ABCDEFGHIJKLMNO"  # For column labels

# Get screen resolution
display_info = pygame.display.Info()
# Set window size to fit within screen resolution (with padding for borders)
WINDOW_WIDTH = min(1400, display_info.current_w - 50)  # 50 pixels padding
WINDOW_HEIGHT = min(900, display_info.current_h - 50)  # 50 pixels padding

# Colors
WHITE = (255, 255, 255)
BLACK = (0, 0, 0)
RED = (255, 100, 100)
PINK = (255, 182, 193)
BLUE = (0, 102, 204)  # Darkened from (173, 216, 230) for TL
LIGHT_BLUE = (135, 206, 250)
HIGHLIGHT_BLUE = (191, 238, 255)
YELLOW = (255, 255, 153)
GRAY = (200, 200, 200)
GREEN = (144, 238, 144)
DARK_GREEN = (100, 200, 100)
PALE_YELLOW = (255, 255, 200)
BUTTON_COLOR = (180, 180, 180)
BUTTON_HOVER = (220, 220, 220)
TURN_INDICATOR_COLOR = (255, 215, 0)
DIALOG_COLOR = (150, 150, 150)
DROPDOWN_COLOR = (200, 200, 200)
SELECTED_TILE_COLOR = (255, 165, 0)
GRAYED_OUT_COLOR = (100, 100, 100)
ARROW_COLOR = (0, 0, 255)
HINT_NORMAL_COLOR = (220, 220, 220)
HINT_SELECTED_COLOR = (180, 180, 255)

# Setup display and font
screen = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))
pygame.display.set_caption("Scrabble Game")
font = pygame.font.SysFont("Arial", FONT_SIZE, bold=True)
ui_font = pygame.font.SysFont("Arial", 20)
button_font = pygame.font.SysFont("Arial", 16)
tile_count_font = pygame.font.SysFont("Arial", 14)
dialog_font = pygame.font.SysFont("Arial", 24)

# Tile bag and values (moved up to be defined before trie)
TILE_DISTRIBUTION = {
    'A': (9, 1), 'B': (2, 3), 'C': (2, 3), 'D': (4, 2), 'E': (12, 1), 'F': (2, 4),
    'G': (3, 2), 'H': (2, 4), 'I': (9, 1), 'J': (1, 8), 'K': (1, 5), 'L': (4, 1),
    'M': (2, 3), 'N': (6, 1), 'O': (8, 1), 'P': (2, 3), 'Q': (1, 10), 'R': (6, 1),
    'S': (4, 1), 'T': (6, 1), 'U': (4, 1), 'V': (2, 4), 'W': (2, 4), 'X': (1, 8),
    'Y': (2, 4), 'Z': (1, 10), ' ': (2, 0)
}
# Global bag - initialized properly in main() or practice setup
bag = []

POWER_TILES = {'J', 'Q', 'X', 'Z'}

# Global game state variables (will be initialized/reset in main)
board = None
tiles = None
racks = None
blanks = None
scores = None
turn = 1
first_play = True
game_mode = None
is_ai = None
practice_mode = None # Added to track practice modes like "eight_letter", "power_tiles"
move_history = []
replay_mode = False
current_replay_turn = 0
last_word = ""
last_score = 0
last_start = None
last_direction = None


def draw_checkbox(screen, x, y, checked):
    pygame.draw.rect(screen, BLACK, (x, y, 20, 20), 1)
    if checked:
        pygame.draw.line(screen, BLACK, (x+2, y+2), (x+18, y+18), 2)
        pygame.draw.line(screen, BLACK, (x+18, y+2), (x+2, y+18), 2)


# --- GCG Handling ---
def save_game_to_gcg(player_names, move_history, initial_racks, final_scores):
    """Save the game to GCG format using move_history directly."""
    gcg_lines = [
        "#",
        f"#player1 {player_names[0]}",
        f"#player2 {player_names[1]}"
    ]
    cumulative_scores = [0, 0]

    for move in move_history:
        player = move['player'] - 1  # 0-based index
        rack = ''.join(sorted(tile if tile != ' ' else '?' for tile in move['rack']))

        if move['move_type'] == 'place':
            # Use the stored full word with blanks
            word_with_blanks = move.get('word_with_blanks', move.get('word','').upper()) # Use getter for safety
            score = move['score']
            cumulative_scores[player] += score
            gcg_lines.append(
                f">{player_names[player]}: {rack} {move['coord']} {word_with_blanks} +{score} {cumulative_scores[player]}"
            )
        elif move['move_type'] == 'exchange':
            exchanged = ''.join(sorted(tile if tile != ' ' else '?' for tile in move.get('exchanged_tiles',[]))) # Use getter
            gcg_lines.append(
                f">{player_names[player]}: {rack} ({exchanged}) +0 {cumulative_scores[player]}"
            )
        elif move['move_type'] == 'pass':
            gcg_lines.append(
                f">{player_names[player]}: {rack} -- +0 {cumulative_scores[player]}"
            )

    gcg_lines.append(f"Final score: {player_names[0]} {final_scores[0]}, {player_names[1]} {final_scores[1]}")

    return '\n'.join(gcg_lines)



def load_game_from_gcg(filename):
    """Load a game from a GCG file, returning data to enter replay mode."""
    move_history = []
    player_names = ["Player1", "Player2"]
    # --- MODIFICATION: Initialize final_scores here ---
    final_scores = [0, 0]
    # --- END MODIFICATION ---
    line_num = 0

    try:
        with open(filename, "r") as f:
            for line in f:
                line_num += 1
                line = line.strip()
                if not line or line.startswith("#"): # Skip empty/comments
                    if line.startswith("#player1"):
                        try: player_names[0] = line.split(maxsplit=1)[1]
                        except IndexError: print(f"GCG Load Warning (Line {line_num}): Malformed #player1 line.")
                    elif line.startswith("#player2"):
                        try: player_names[1] = line.split(maxsplit=1)[1]
                        except IndexError: print(f"GCG Load Warning (Line {line_num}): Malformed #player2 line.")
                    continue

                if line.startswith("Final score:"):
                    try:
                        parts = line.split()
                        if len(parts) < 5: # Need at least "Final score: N1 S1, N2 S2"
                            raise ValueError("Too few parts for Final score line")

                        # --- MODIFICATION: More robust parsing from the end ---
                        score2_str = parts[-1]
                        score1_str = ""
                        # Find the part before score2 that ends with a comma
                        for i in range(len(parts) - 2, 0, -1):
                            if parts[i].endswith(','):
                                score1_str = parts[i].strip(',')
                                break # Found score1 part

                        if score1_str and score2_str.isdigit() and score1_str.isdigit():
                            # Successfully found both scores
                            final_scores[0] = int(score1_str)
                            final_scores[1] = int(score2_str)
                            print(f"GCG Load Info (Line {line_num}): Parsed final scores: {final_scores}")
                        else:
                            # Fallback or less reliable method if needed, but better to raise error
                            raise ValueError("Could not reliably parse final scores from line parts.")
                        # --- END MODIFICATION ---

                    except (IndexError, ValueError) as e:
                        print(f"GCG Load Warning (Line {line_num}): Error parsing final score line: '{line}'. Error: {e}. Using [0, 0].")
                        # Keep final_scores as [0, 0] initialized earlier
                    continue # Move to next line after processing Final score

                if line.startswith(">"):
                    try:
                        parts = line.split() # Split by whitespace
                        if len(parts) < 5: # Minimum parts: >Name: Rack -- +Score CumScore
                            raise ValueError(f"Insufficient parts on move line ({len(parts)})")

                        # --- Robust Parsing Logic ---
                        # 1. Identify parts from the end
                        cumulative_score_str = parts[-1]
                        score_str = parts[-2]
                        # Part before score could be Word, (Exchange), or --
                        third_last_part = parts[-3]

                        # 2. Safely parse scores first
                        try: score = int(score_str[1:]) # Remove initial '+' or '-'
                        except (ValueError, IndexError): raise ValueError(f"Invalid score format '{score_str}'")
                        try: cumulative_score = int(cumulative_score_str)
                        except ValueError: raise ValueError(f"Invalid cumulative score format '{cumulative_score_str}'")

                        # 3. Determine Move Type based on third_last_part
                        move_type = None
                        player_name_parts = []
                        rack_str = ""
                        exchanged_list = []
                        position_str = ""
                        word_played_gcg = ""

                        if third_last_part == "--": # Pass
                            move_type = 'pass'
                            # Structure: > Name(s) : Rack -- +Score CumScore
                            if len(parts) < 5: raise ValueError("Incorrect part count for Pass")
                            rack_str = parts[-4] # Part before -- is Rack
                            player_name_parts = parts[:-4] # All parts before Rack
                        elif third_last_part.startswith("(") and third_last_part.endswith(")"): # Exchange
                            move_type = 'exchange'
                            # Structure: > Name(s) : Rack (Exch) +Score CumScore
                            if len(parts) < 5: raise ValueError("Incorrect part count for Exchange")
                            rack_str = parts[-4] # Part before (Exch) is Rack
                            player_name_parts = parts[:-4] # All parts before Rack
                            exchanged_gcg = third_last_part[1:-1]
                            exchanged_list = [(' ' if char == '?' else char.upper()) for char in exchanged_gcg]
                        else: # Place
                            move_type = 'place'
                            # Structure: > Name(s) : Rack Coord Word +Score CumScore
                            if len(parts) < 6: raise ValueError("Incorrect part count for Place")
                            word_played_gcg = third_last_part # Part before score is Word
                            position_str = parts[-4] # Part before Word is Coord
                            rack_str = parts[-5] # Part before Coord is Rack
                            player_name_parts = parts[:-5] # All parts before Rack

                        # 4. Reconstruct Player Name
                        if not player_name_parts or not player_name_parts[0].startswith(">") or not player_name_parts[-1].endswith(":"):
                            raise ValueError(f"Could not reconstruct player name from parts: {player_name_parts}")
                        player_name_full = " ".join(player_name_parts)
                        player_name = player_name_full[1:-1] # Remove '>' and ':'
                        player = 1 if player_name == player_names[0] else 2
                        # --- End Robust Parsing Logic ---

                        # Append to move_history based on type
                        if move_type == 'pass':
                            move_history.append({
                                'player': player, 'move_type': 'pass', 'score': score,
                                'word': '', 'coord': ''
                            })
                        elif move_type == 'exchange':
                            move_history.append({
                                'player': player, 'move_type': 'exchange', 'exchanged_tiles': exchanged_list,
                                'score': score, 'word': '', 'coord': ''
                            })
                        elif move_type == 'place':
                            # Parse coordinate
                            coord_parse_result = parse_coord(position_str)
                            if coord_parse_result is None or coord_parse_result[0] is None:
                                raise ValueError(f"Invalid coordinate format '{position_str}'")
                            (row, col), direction = coord_parse_result

                            # Reconstruct positions and blanks from the GCG word
                            positions = []; blanks = set()
                            current_r_gcg, current_c_gcg = row, col
                            for i, letter_gcg in enumerate(word_played_gcg):
                                r_place = current_r_gcg if direction == "right" else current_r_gcg + i
                                c_place = current_c_gcg + i if direction == "right" else current_c_gcg
                                if not (0 <= r_place < GRID_SIZE and 0 <= c_place < GRID_SIZE):
                                    raise ValueError(f"Word placement out of bounds: '{word_played_gcg}' at {position_str}")
                                letter_upper = letter_gcg.upper()
                                positions.append((r_place, c_place, letter_upper))
                                if letter_gcg.islower(): blanks.add((r_place, c_place))

                            move_history.append({
                                'player': player, 'move_type': 'place', 'positions': positions,
                                'blanks': blanks, 'score': score, 'word': word_played_gcg.upper(),
                                'start': (row, col), 'direction': direction, 'coord': position_str
                            })

                    except Exception as e:
                        print(f"GCG Load Error (Line {line_num}): Failed to parse move line.")
                        print(f"  Line content: '{line}'")
                        print(f"  Error details: {type(e).__name__}: {e}")
                        raise ValueError(f"Error parsing GCG line {line_num}: {e}") from e

                else:
                    print(f"GCG Load Warning (Line {line_num}): Skipping unrecognized line format: '{line}'")

    except FileNotFoundError:
        print(f"GCG Load Error: File not found '{filename}'")
        raise
    except Exception as e:
        print(f"GCG Load Error: An unexpected error occurred reading file '{filename}' near line {line_num}.")
        print(f"  Error details: {type(e).__name__}: {e}")
        raise

    # Return the final scores that were parsed (or [0,0] if parsing failed/line missing)
    return player_names, move_history, final_scores



# New helper function to create a standard Scrabble bag
def create_standard_bag():
    """Creates and returns a standard Scrabble tile bag list."""
    bag = [letter for letter, (count, _) in TILE_DISTRIBUTION.items() for _ in range(count)]
    return bag



def simulate_game_up_to(target_turn_idx, move_history_loaded, initial_shuffled_bag):
    """
    Simulates a game turn-by-turn up to a target index using loaded move history
    (which lacks 'drawn' info) and an initial shuffled bag state. Handles initial draws.
    Removed Replay Sim Warnings for performance.
    Corrected rack size calculation during simulation.

    Args:
        target_turn_idx (int): The 0-based index of the turn *after* which the state is needed
                               (e.g., 0 for initial state, 1 for state after move 0).
        move_history_loaded (list): The move history loaded from GCG (lacks 'drawn').
        initial_shuffled_bag (list): A list representing the shuffled bag at the very start of the game.

    Returns:
        tuple: (tiles_state, blanks_state, scores_state, racks_state) representing the
               game state after target_turn_idx-1 moves have been applied.
               Racks are sorted alphabetically before returning for display.
    """
    # Initialize game state variables
    tiles_state = [['' for _ in range(GRID_SIZE)] for _ in range(GRID_SIZE)]
    blanks_state = set()
    scores_state = [0, 0]
    racks_state = [[], []]
    # IMPORTANT: Use a copy of the initial bag for the simulation run to avoid modifying the original
    bag_state = initial_shuffled_bag[:]

    # --- Simulate Drawing Initial Racks ---
    try:
        for _ in range(7):
            if bag_state: racks_state[0].append(bag_state.pop())
            else: raise IndexError("Bag empty during initial draw for P1")
        for _ in range(7):
            if bag_state: racks_state[1].append(bag_state.pop())
            else: raise IndexError("Bag empty during initial draw for P2")
    except IndexError as e:
        print(f"Replay Simulation Error: {e}")
        return tiles_state, blanks_state, scores_state, racks_state

    # Apply moves sequentially up to the target turn index (0 to target_turn_idx-1)
    for i in range(target_turn_idx):
        if i >= len(move_history_loaded):
            # print(f"Replay Sim Info: Reached end of available history at move index {i} before target index {target_turn_idx}.") # Commented out
            break

        move = move_history_loaded[i]
        player_idx = move.get('player')
        if player_idx not in [1, 2]:
            continue
        player_idx -= 1

        rack_after_move = racks_state[player_idx][:]
        # --- MODIFICATION: Counter for actual removals ---
        actual_tiles_removed_from_sim_rack = 0
        # --- END MODIFICATION ---

        move_type = move.get('move_type')

        if move_type == 'place':
            positions = move.get('positions', [])
            blanks_in_move = move.get('blanks', set())

            for r, c, letter in positions:
                 is_newly_placed_sim = (0 <= r < GRID_SIZE and 0 <= c < GRID_SIZE and not tiles_state[r][c])

                 if 0 <= r < GRID_SIZE and 0 <= c < GRID_SIZE:
                     tiles_state[r][c] = letter
                     if (r, c) in blanks_in_move:
                         blanks_state.add((r, c))
                 else:
                     continue

                 if is_newly_placed_sim:
                     # tiles_removed_count += 1 # Original counter - no longer needed for drawing
                     if (r,c) in blanks_in_move:
                         if ' ' in rack_after_move:
                             rack_after_move.remove(' ')
                             # --- MODIFICATION: Increment actual removal counter ---
                             actual_tiles_removed_from_sim_rack += 1
                             # --- END MODIFICATION ---
                         else:
                             pass # Warning already commented out
                     else:
                         if letter in rack_after_move:
                             rack_after_move.remove(letter)
                             # --- MODIFICATION: Increment actual removal counter ---
                             actual_tiles_removed_from_sim_rack += 1
                             # --- END MODIFICATION ---
                         else:
                             pass # Warning already commented out

            scores_state[player_idx] += move.get('score', 0)

        elif move_type == 'exchange':
            exchanged_gcg = move.get('exchanged_tiles', [])
            for tile_gcg in exchanged_gcg:
                 tile_to_remove = ' ' if tile_gcg == '?' else tile_gcg.upper()
                 if tile_to_remove in rack_after_move:
                      rack_after_move.remove(tile_to_remove)
                      # --- MODIFICATION: Increment actual removal counter ---
                      actual_tiles_removed_from_sim_rack += 1
                      # --- END MODIFICATION ---
                 else:
                      pass # Warning already commented out
            # Score doesn't change

        elif move_type == 'pass':
            actual_tiles_removed_from_sim_rack = 0 # No tiles removed
            # Score doesn't change

        else:
             continue # Skip draw calculation if move type is unknown

        # --- Simulate Drawing New Tiles ---
        # --- MODIFICATION: Use actual removal count for drawing ---
        num_to_draw = actual_tiles_removed_from_sim_rack
        # --- END MODIFICATION ---
        drawn_simulated = []
        for _ in range(num_to_draw):
             if bag_state:
                 drawn_simulated.append(bag_state.pop())
             else:
                 # print(f"Replay Sim Info: Simulated bag ran out while drawing for move {i}.") # Commented out
                 break
        rack_after_move.extend(drawn_simulated)
        racks_state[player_idx] = rack_after_move

    # Sort final racks alphabetically before returning
    for rack in racks_state:
        rack.sort()

    return tiles_state, blanks_state, scores_state, racks_state




# --- Trie/DAWG Setup ---
class TrieNode: # Keeping simple Trie for now, can replace with minimized DAWG later
    def __init__(self):
        self.children = {}
        self.is_end = False

class Dawg: # Renaming our existing Trie to Dawg for conceptual clarity
    def __init__(self):
        self.root = TrieNode()

    def insert(self, word):
        node = self.root
        for char in word:
            if char not in node.children:
                node.children[char] = TrieNode()
            node = node.children[char]
        node.is_end = True

    def search(self, word):
        """Check if a word exists in the DAWG."""
        node = self.root
        for char in word:
            if char not in node.children:
                return False
            node = node.children[char]
        return node.is_end

# Load the DAWG with words from "All Words 2023.txt"
DAWG = Dawg()
try:
    # Ensure the path is correct or adjust as needed
    with open("All Words 2023.txt", "r") as f:
        for word in (w.strip().upper() for w in f):
            if len(word) > 1: # Optionally filter out single-letter words if not needed
                DAWG.insert(word)
    print("DAWG loaded successfully.")
except FileNotFoundError:
    print("Error: 'All Words 2023.txt' not found. Word validation will not work.")


# --- Mode Selection Constants ---
MODE_HVH = "Human vs Human"
MODE_HVA = "Human vs AI"
MODE_AVA = "AI vs AI"

# --- Replay Button Positions ---
REPLAY_BUTTON_Y = OPTIONS_Y + OPTIONS_HEIGHT + 10
REPLAY_BUTTON_WIDTH = 50
REPLAY_BUTTON_HEIGHT = 30
REPLAY_BUTTON_GAP = 10
replay_start_rect = pygame.Rect(10, REPLAY_BUTTON_Y, REPLAY_BUTTON_WIDTH, REPLAY_BUTTON_HEIGHT)
replay_prev_rect = pygame.Rect(10 + REPLAY_BUTTON_WIDTH + REPLAY_BUTTON_GAP, REPLAY_BUTTON_Y, REPLAY_BUTTON_WIDTH, REPLAY_BUTTON_HEIGHT)
replay_next_rect = pygame.Rect(10 + 2 * (REPLAY_BUTTON_WIDTH + REPLAY_BUTTON_GAP), REPLAY_BUTTON_Y, REPLAY_BUTTON_WIDTH, REPLAY_BUTTON_HEIGHT)
replay_end_rect = pygame.Rect(10 + 3 * (REPLAY_BUTTON_WIDTH + REPLAY_BUTTON_GAP), REPLAY_BUTTON_Y, REPLAY_BUTTON_WIDTH, REPLAY_BUTTON_HEIGHT)




def get_coord(start, direction):
    """
    Generate the coordinate string in GCG format.
    Accepts direction as "right", "down", 'H', or 'V'.
    Horizontal: RowNumberColumnLetter (e.g., 8H)
    Vertical:   ColumnLetterRowNumber (e.g., H8)
    """
    row, col = start
    if not (0 <= row < GRID_SIZE and 0 <= col < GRID_SIZE):
        # Handle invalid start coordinates if necessary, though ideally prevented earlier
        return "???" # Or raise an error

    # Map 'H'/'V' to 'right'/'down' logic internally
    if direction == "right" or direction == 'H': # Horizontal
        # Format: RowNumberColumnLetter
        return f"{row + 1}{LETTERS[col]}"
    elif direction == "down" or direction == 'V': # Vertical
        # Format: ColumnLetterRowNumber
        return f"{LETTERS[col]}{row + 1}"
    else:
        # Handle truly unexpected direction values
        print(f"Warning: Unexpected direction '{direction}' in get_coord.")
        return "???"



def parse_coord(coord):
    """Parse a GCG coordinate (e.g., '8H' or 'H8') into (row, col) and direction."""
    if not coord: return None, None # Handle empty coord
    if coord[0].isalpha():  # Vertical: e.g., H8 or H10
        col_char = coord[0]
        row_str = coord[1:]
        if col_char not in LETTERS or not row_str.isdigit(): return None, None
        col = LETTERS.index(col_char)
        row = int(row_str) - 1
        direction = "down"
    else:  # Horizontal: e.g., 8H or 10A
        i = 0
        while i < len(coord) and coord[i].isdigit(): i += 1
        row_str = coord[:i]
        col_char = coord[i:]
        if not row_str.isdigit() or len(col_char) != 1 or col_char not in LETTERS: return None, None
        row = int(row_str) - 1
        col = LETTERS.index(col_char)
        direction = "right"

    if not (0 <= row < GRID_SIZE and 0 <= col < GRID_SIZE): return None, None # Bounds check
    return (row, col), direction

# --- Board Creation ---
def create_board():
    """Initialize the Scrabble board with special squares and labels."""
    board = [[WHITE for _ in range(GRID_SIZE)] for _ in range(GRID_SIZE)]
    labels = [['' for _ in range(GRID_SIZE)] for _ in range(GRID_SIZE)]
    tiles = [['' for _ in range(GRID_SIZE)] for _ in range(GRID_SIZE)]

    tw = [(0, 0), (0, 7), (0, 14), (7, 0), (7, 14), (14, 0), (14, 7), (14, 14)]
    dw = [(1, 1), (2, 2), (3, 3), (4, 4), (10, 10), (11, 11), (12, 12), (13, 13),
          (1, 13), (2, 12), (3, 11), (4, 10), (10, 4), (11, 3), (12, 2), (13, 1)]
    tl = [(1, 5), (1, 9), (5, 1), (5, 5), (5, 9), (5, 13), (9, 1), (9, 5),
          (9, 9), (9, 13), (13, 5), (13, 9)]
    dl = [(0, 3), (0, 11), (2, 6), (2, 8), (3, 0), (3, 7), (3, 14), (6, 2),
          (6, 6), (6, 8), (6, 12), (7, 3), (7, 11), (8, 2), (8, 6), (8, 8),
          (8, 12), (11, 0), (11, 7), (11, 14), (12, 6), (12, 8), (14, 3), (14, 11)]

    for r, c in tw: board[r][c] = RED
    for r, c in dw: board[r][c] = PINK
    for r, c in tl: board[r][c] = BLUE
    for r, c in dl: board[r][c] = LIGHT_BLUE
    board[7][7] = PINK # Center square

    return board, labels, tiles

# --- Drawing Functions ---
def draw_rack(player, rack, scores, turn, player_names, dragged_tile=None, drag_pos=None, display_scores=None):
    """Draw a player's rack with tiles, scores, and buttons."""
    global practice_mode # Access global practice_mode
    if not rack: return None, None
    if display_scores is None: display_scores = scores
    if practice_mode == "eight_letter" and player == 2: return None, None # Don't draw P2 rack

    rack_width = 7 * (TILE_WIDTH + TILE_GAP) - TILE_GAP
    # Calculate the rightmost extent of the replay buttons area
    # Replay buttons start at x=10, width=50, gap=10. 4 buttons total.
    replay_area_end_x = 10 + 4 * (REPLAY_BUTTON_WIDTH + REPLAY_BUTTON_GAP) # 10 + 4*(50+10) = 250
    # Minimum start x for the rack, considering replay buttons and star indicator offset (star is at start_x - 20)
    min_rack_start_x = replay_area_end_x + BUTTON_GAP + 20 # 250 + 10 + 20 = 280
    # Try to center the rack, but ensure it starts after the minimum x to avoid overlap
    start_x = max(min_rack_start_x, (BOARD_SIZE - rack_width) // 2)

    rack_y = BOARD_SIZE + 80 if player == 1 else BOARD_SIZE + 150

    if turn == player and (practice_mode != "eight_letter" or player == 1): # Draw turn indicator
        # Star indicator position depends on the calculated start_x
        center_x = start_x - 20; center_y = rack_y + TILE_HEIGHT // 2; radius = 10; points = []
        for i in range(10): angle = i * math.pi / 5; r = radius if i % 2 == 0 else radius / 2; x = center_x + r * math.cos(angle); y = center_y + r * math.sin(angle); points.append((x, y))
        pygame.draw.polygon(screen, TURN_INDICATOR_COLOR, points)

    for i, tile in enumerate(rack): # Draw tiles
        tile_x = start_x + i * (TILE_WIDTH + TILE_GAP)
        if dragged_tile == (player, i) and drag_pos: continue
        if tile == ' ':
            center = (tile_x + TILE_WIDTH // 2, rack_y + TILE_HEIGHT // 2); radius = TILE_WIDTH // 2 - 2
            pygame.draw.circle(screen, BLACK, center, radius); text = font.render('?', True, WHITE)
            text_rect = text.get_rect(center=center); screen.blit(text, text_rect)
        else:
            pygame.draw.rect(screen, GREEN, (tile_x, rack_y, TILE_WIDTH, TILE_HEIGHT)); text = font.render(tile, True, BLACK)
            screen.blit(text, (tile_x + 5, rack_y + 5))

    if dragged_tile and dragged_tile[0] == player and drag_pos: # Draw dragged tile
        tile_x, tile_y = drag_pos
        if 0 <= dragged_tile[1] < len(rack):
            tile = rack[dragged_tile[1]]
            if tile == ' ':
                center = (tile_x, tile_y); radius = TILE_WIDTH // 2 - 2; pygame.draw.circle(screen, BLACK, center, radius)
                text = font.render('?', True, WHITE); text_rect = text.get_rect(center=center); screen.blit(text, text_rect)
            else:
                pygame.draw.rect(screen, GREEN, (tile_x - TILE_WIDTH // 2, tile_y - TILE_HEIGHT // 2, TILE_WIDTH, TILE_HEIGHT))
                text = font.render(tile, True, BLACK); screen.blit(text, (tile_x - TILE_WIDTH // 2 + 5, tile_y - TILE_HEIGHT // 2 + 5))

    button_x = start_x + rack_width + BUTTON_GAP # Draw buttons
    alpha_button_rect = pygame.draw.rect(screen, BUTTON_COLOR, (button_x, rack_y, BUTTON_WIDTH, BUTTON_HEIGHT))
    rand_button_rect = pygame.draw.rect(screen, BUTTON_COLOR, (button_x + BUTTON_WIDTH + BUTTON_GAP, rack_y, BUTTON_WIDTH, BUTTON_HEIGHT))
    alpha_text = button_font.render("Alphabetize", True, BLACK); alpha_rect = alpha_text.get_rect(center=alpha_button_rect.center); screen.blit(alpha_text, alpha_rect)
    rand_text = button_font.render("Randomize", True, BLACK); rand_rect = rand_text.get_rect(center=rand_button_rect.center); screen.blit(rand_text, rand_rect)

    player_idx = player - 1 # Draw score
    if 0 <= player_idx < len(player_names) and 0 <= player_idx < len(display_scores):
        player_name_display = player_names[player_idx] if player_names[player_idx] else f"Player {player}"
        score_text = ui_font.render(f"{player_name_display} Score: {display_scores[player_idx]}", True, BLACK)
        screen.blit(score_text, (start_x, rack_y - 20))
    else: print(f"Warning: Invalid player index {player} for score display.")
    return alpha_button_rect, rand_button_rect

def draw_replay_icon(screen, rect, icon_type):
    """Draw centered replay control icons (arrows) on the buttons."""
    center_x, center_y = rect.center; arrow_size = 8
    if icon_type == "start": pygame.draw.polygon(screen, BLACK, [(center_x + 6, center_y - arrow_size), (center_x - 2, center_y), (center_x + 6, center_y + arrow_size)]); pygame.draw.polygon(screen, BLACK, [(center_x - 2, center_y - arrow_size), (center_x - 10, center_y), (center_x - 2, center_y + arrow_size)])
    elif icon_type == "prev": pygame.draw.polygon(screen, BLACK, [(center_x + 6, center_y - arrow_size), (center_x - 6, center_y), (center_x + 6, center_y + arrow_size)])
    elif icon_type == "next": pygame.draw.polygon(screen, BLACK, [(center_x - 6, center_y - arrow_size), (center_x + 6, center_y), (center_x - 6, center_y + arrow_size)])
    elif icon_type == "end": pygame.draw.polygon(screen, BLACK, [(center_x - 6, center_y - arrow_size), (center_x + 2, center_y), (center_x - 6, center_y + arrow_size)]); pygame.draw.polygon(screen, BLACK, [(center_x + 2, center_y - arrow_size), (center_x + 10, center_y), (center_x + 2, center_y + arrow_size)])

def draw_scoreboard(screen, move_history, scroll_offset, scores, is_ai, player_names, final_scores=None, game_over_state=False): # Added player_names parameter
    """Draws the scrollable scoreboard using full player names."""
    scoreboard_x = BOARD_SIZE + 275
    scoreboard_y = 40
    # Adjust width calculation slightly to prevent potential overlap with window edge
    scoreboard_width = max(200, WINDOW_WIDTH - scoreboard_x - 20) # Use scoreboard_x in calculation
    scoreboard_height = WINDOW_HEIGHT - 80

    # Ensure width doesn't make it go off-screen if window is narrow
    if scoreboard_x + scoreboard_width > WINDOW_WIDTH - 10:
        scoreboard_width = WINDOW_WIDTH - scoreboard_x - 10

    # Fallback if width becomes too small
    if scoreboard_width < 150: # Reduced minimum slightly
        scoreboard_x = WINDOW_WIDTH - 160 # Adjust position too
        scoreboard_width = 150

    scoreboard_surface = pygame.Surface((scoreboard_width, scoreboard_height))
    scoreboard_surface.fill(WHITE)
    running_scores = [0, 0]
    y_pos = 10 - scroll_offset
    line_height = 20 # ui_font.get_linesize() might be better if font changes

    for i, move in enumerate(move_history):
        player_idx = move.get('player', 1) - 1 # Default to player 1 if missing, get 0-based index
        if not (0 <= player_idx < 2): # Basic validation
             print(f"Warning: Invalid player index {player_idx+1} in move history item {i}")
             continue

        running_scores[player_idx] += move.get('score', 0)

        # --- MODIFICATION: Use player_names list ---
        player_label = f"P{player_idx + 1}" # Default label
        if player_names and 0 <= player_idx < len(player_names) and player_names[player_idx]:
            player_label = player_names[player_idx] # Use the actual name
        # --- END MODIFICATION ---

        display_score = running_scores[player_idx]
        move_score = move.get('score', 0)
        score_sign = "+" if move_score >= 0 else "" # Add sign for score delta

        # Construct text string
        if move.get('move_type') == 'place':
            word = move.get('word_with_blanks', move.get('word', 'N/A')) # Prefer word_with_blanks
            coord = move.get('coord', 'N/A')
            text = f"{i+1}: {player_label} - {word} at {coord} ({score_sign}{move_score}) Total: {display_score}"
        elif move.get('move_type') == 'pass':
            text = f"{i+1}: {player_label} - Pass ({score_sign}{move_score}) Total: {display_score}"
        elif move.get('move_type') == 'exchange':
            exchanged_count = len(move.get('exchanged_tiles', []))
            text = f"{i+1}: {player_label} - Exch. {exchanged_count} ({score_sign}{move_score}) Total: {display_score}"
        else:
            text = f"{i+1}: {player_label} - Unknown Move Type"

        # Render and blit if visible
        text_surface = ui_font.render(text, True, BLACK)
        if y_pos < scoreboard_height and y_pos + line_height > 0:
            # Highlight alternate player turns for readability
            if player_idx == 0: # Player 1's turn background
                 highlight_rect = pygame.Rect(0, y_pos, scoreboard_width, line_height)
                 pygame.draw.rect(scoreboard_surface, HIGHLIGHT_BLUE, highlight_rect) # Light blue for P1
            # else: Player 2's turn uses default WHITE background

            scoreboard_surface.blit(text_surface, (10, y_pos))

        y_pos += line_height

    # Draw final scores if game is over
    if game_over_state and final_scores is not None:
        y_pos += line_height // 2 # Add a small gap
        p1_final_name = player_names[0] if player_names and player_names[0] else "P1"
        p2_final_name = player_names[1] if player_names and player_names[1] else "P2"
        final_text = f"Final: {p1_final_name}: {final_scores[0]}, {p2_final_name}: {final_scores[1]}"
        final_surface = ui_font.render(final_text, True, BLACK)
        if y_pos < scoreboard_height and y_pos + line_height > 0:
            scoreboard_surface.blit(final_surface, (10, y_pos))

    # Blit the complete scoreboard surface onto the main screen
    screen.blit(scoreboard_surface, (scoreboard_x, scoreboard_y))
    # Draw border around scoreboard area
    pygame.draw.rect(screen, BLACK, (scoreboard_x, scoreboard_y, scoreboard_width, scoreboard_height), 1)



# End of Part 1 (Includes basic drawing functions)

# Part 2 (Includes word finding, scoring, practice setup, mode selection, options menu)
# find_main_word, find_cross_word, find_all_words_formed (Unchanged from Part 2 provided previously)
def find_main_word(new_tiles, tiles):
    """Finds the primary word formed by newly placed tiles."""
    if not new_tiles: return [], None
    rows = set(r for r, c, _ in new_tiles); cols = set(c for r, c, _ in new_tiles)
    if len(rows) == 1: # Potential horizontal word
        orientation = "horizontal"; row = rows.pop(); min_col = min(c for r, c, _ in new_tiles if r == row); max_col = max(c for r, c, _ in new_tiles if r == row)
        while min_col > 0 and tiles[row][min_col - 1]: min_col -= 1
        while max_col < GRID_SIZE - 1 and tiles[row][max_col + 1]: max_col += 1
        main_word = [(row, c, tiles[row][c]) for c in range(min_col, max_col + 1) if tiles[row][c]]
        return (main_word, orientation) if len(main_word) > 1 else ([], None)
    elif len(cols) == 1: # Potential vertical word
        orientation = "vertical"; col = cols.pop(); min_row = min(r for r, c, _ in new_tiles if c == col); max_row = max(r for r, c, _ in new_tiles if c == col)
        while min_row > 0 and tiles[min_row - 1][col]: min_row -= 1
        while max_row < GRID_SIZE - 1 and tiles[max_row + 1][col]: max_row += 1
        main_word = [(r, col, tiles[r][col]) for r in range(min_row, max_row + 1) if tiles[r][col]]
        return (main_word, orientation) if len(main_word) > 1 else ([], None)
    else: return [], None

def find_cross_word(tile, tiles, main_orientation):
    """Finds a cross word formed by a single tile perpendicular to the main word."""
    r, c, _ = tile; cross_word = []
    if main_orientation == "horizontal": # Check vertically
        min_row = r;
        while min_row > 0 and tiles[min_row - 1][c]: min_row -= 1
        max_row = r;
        while max_row < GRID_SIZE - 1 and tiles[max_row + 1][c]: max_row += 1
        if max_row > min_row: cross_word = [(rr, c, tiles[rr][c]) for rr in range(min_row, max_row + 1) if tiles[rr][c]]
    elif main_orientation == "vertical": # Check horizontally
        min_col = c;
        while min_col > 0 and tiles[r][min_col - 1]: min_col -= 1
        max_col = c;
        while max_col < GRID_SIZE - 1 and tiles[r][max_col + 1]: max_col += 1
        if max_col > min_col: cross_word = [(r, cc, tiles[r][cc]) for cc in range(min_col, max_col + 1) if tiles[r][cc]]
    return cross_word if len(cross_word) > 1 else []

def find_all_words_formed(new_tiles, tiles):
    """Finds all words (main and cross) formed by a play."""
    words = [];
    if not new_tiles: return words
    new_positions_set = set((r, c) for r, c, _ in new_tiles)
    main_word_tiles, orientation = find_main_word(new_tiles, tiles)
    if main_word_tiles:
        words.append(main_word_tiles)
        for tile in new_tiles:
            if (tile[0], tile[1]) in new_positions_set:
                cross_word = find_cross_word(tile, tiles, orientation)
                if cross_word: words.append(cross_word)
    elif len(new_tiles) == 1: # Single tile placement check
        tile = new_tiles[0]
        cross_h = find_cross_word(tile, tiles, "vertical");   # Check H
        if cross_h: words.append(cross_h)
        cross_v = find_cross_word(tile, tiles, "horizontal"); # Check V
        if cross_v: words.append(cross_v)
    unique_word_tile_lists = []; seen_signatures = set()
    for word_tile_list in words:
        signature = tuple(sorted((r, c, l) for r, c, l in word_tile_list))
        if signature not in seen_signatures: unique_word_tile_lists.append(word_tile_list); seen_signatures.add(signature)
    return unique_word_tile_lists

# calculate_score (Unchanged from Part 2 provided previously)
def calculate_score(new_tiles, board, tiles, blanks):
    """Calculates the score for a play based on newly placed tiles."""
    total_score = 0; new_positions = set((r, c) for r, c, _ in new_tiles)
    words_formed_details = find_all_words_formed(new_tiles, tiles)
    for word_tiles in words_formed_details:
        word_score = 0; word_multiplier = 1
        for r, c, letter in word_tiles:
            if letter not in TILE_DISTRIBUTION: print(f"Warning: Invalid letter '{letter}' found in word during scoring at ({r},{c}). Skipping."); continue
            is_blank = (r, c) in blanks; letter_value = 0 if is_blank else TILE_DISTRIBUTION[letter][1]; letter_multiplier = 1
            if (r, c) in new_positions:
                square_color = board[r][c]
                if square_color == LIGHT_BLUE: letter_multiplier = 2 # DL
                elif square_color == BLUE: letter_multiplier = 3 # TL
                elif square_color == PINK: word_multiplier *= 2 # DW (Center is also Pink)
                elif square_color == RED: word_multiplier *= 3 # TW
            word_score += letter_value * letter_multiplier
        total_score += word_score * word_multiplier
    if len(new_tiles) == 7: total_score += 50 # Bingo bonus
    return total_score

# select_seven_letter_word, eight_letter_practice, mode_selection_screen, draw_options_menu (Unchanged from Part 2 provided previously)
def select_seven_letter_word(removed_letter, seven_letter_words):
    """Selects a random 7-letter word containing the removed letter."""
    candidates = [word for word in seven_letter_words if removed_letter in word]
    if not candidates: print(f"Warning: No 7-letter words contain '{removed_letter}'. Choosing random 7-letter word."); return random.choice(seven_letter_words) if seven_letter_words else None
    return random.choice(candidates)

def eight_letter_practice():
    """Handles the setup dialog and initialization for 8-Letter Bingo practice."""
    try:
        with open("7-letter-list.txt", "r") as seven_file, open("8-letter-list.txt", "r") as eight_file:
            seven_letter_words = [line.strip().upper() for line in seven_file.readlines()]; eight_letter_words = [line.strip().upper() for line in eight_file.readlines()]
    except FileNotFoundError: print("Error: Could not find 7-letter-list.txt or 8-letter-list.txt"); return False, None, None, None, None, None
    if not seven_letter_words or not eight_letter_words: print("Error: Word list files are empty."); return False, None, None, None, None, None
    dialog_width, dialog_height = 300, 150; dialog_x = (WINDOW_WIDTH - dialog_width) // 2; dialog_y = (WINDOW_HEIGHT - dialog_height) // 2
    proceed = False; text_box_active = False; probability_input = ""
    while True: # Dialog loop
        screen.fill(WHITE); pygame.draw.rect(screen, DIALOG_COLOR, (dialog_x, dialog_y, dialog_width, dialog_height)); pygame.draw.rect(screen, BLACK, (dialog_x, dialog_y, dialog_width, dialog_height), 2)
        title_text = dialog_font.render("8-Letter Bingo Options", True, BLACK); screen.blit(title_text, (dialog_x + 10, dialog_y + 10))
        prob_text = ui_font.render("Probability", True, BLACK); screen.blit(prob_text, (dialog_x + 20, dialog_y + 50))
        text_box_rect = pygame.Rect(dialog_x + 120, dialog_y + 45, 150, 30); pygame.draw.rect(screen, WHITE, text_box_rect); pygame.draw.rect(screen, BLACK, text_box_rect, 1)
        input_text = ui_font.render(probability_input, True, BLACK); screen.blit(input_text, (text_box_rect.x + 5, text_box_rect.y + 5))
        go_rect = pygame.Rect(dialog_x + 50, dialog_y + 100, 100, 30); cancel_rect = pygame.Rect(dialog_x + 160, dialog_y + 100, 100, 30)
        pygame.draw.rect(screen, BUTTON_COLOR, go_rect); pygame.draw.rect(screen, BUTTON_COLOR, cancel_rect)
        go_text = button_font.render("Go", True, BLACK); cancel_text = button_font.render("Cancel", True, BLACK)
        screen.blit(go_text, go_text.get_rect(center=go_rect.center)); screen.blit(cancel_text, cancel_text.get_rect(center=cancel_rect.center))
        for event in pygame.event.get():
            if event.type == pygame.QUIT: pygame.quit(); sys.exit()
            elif event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
                x, y = event.pos; text_box_active = text_box_rect.collidepoint(x, y)
                if go_rect.collidepoint(x, y):
                    max_index = len(eight_letter_words);
                    if probability_input.isdigit(): prob_val = int(probability_input); max_index = min(max(1, prob_val), len(eight_letter_words))
                    selected_eight = random.choice(eight_letter_words[:max_index]); print("Selected 8-letter word:", selected_eight)
                    remove_idx = random.randint(0, 7); removed_letter = selected_eight[remove_idx]; removed_eight = selected_eight[:remove_idx] + selected_eight[remove_idx + 1:]
                    print("Player 1 rack (7 letters):", removed_eight); print("Removed letter:", removed_letter)
                    selected_seven = select_seven_letter_word(removed_letter, seven_letter_words)
                    if selected_seven is None: print("Error: Could not find a suitable 7-letter word."); return False, None, None, None, None, None
                    print("Selected 7-letter word for board:", selected_seven)
                    board, _, tiles = create_board(); local_racks = [[], []]; local_blanks = set(); local_racks[0] = sorted(list(removed_eight)); local_racks[1] = []
                    center_r, center_c = CENTER_SQUARE; word_len = len(selected_seven); start_offset = word_len // 2; place_horizontally = random.choice([True, False]); placement_successful = False
                    if place_horizontally:
                        start_c_place = center_c - start_offset
                        if 0 <= start_c_place and start_c_place + word_len <= GRID_SIZE:
                            for i, letter in enumerate(selected_seven): tiles[center_r][start_c_place + i] = letter
                            placement_successful = True; print(f"Placed '{selected_seven}' horizontally at ({center_r},{start_c_place})")
                    if not placement_successful: # Try vertically
                        start_r_place = center_r - start_offset
                        if 0 <= start_r_place and start_r_place + word_len <= GRID_SIZE:
                            for i, letter in enumerate(selected_seven): tiles[start_r_place + i][center_c] = letter
                            placement_successful = True; print(f"Placed '{selected_seven}' vertically at ({start_r_place},{center_c})")
                    if not placement_successful: print("Error: Could not place 7-letter word centered H or V."); return False, None, None, None, None, None
                    local_bag = []; return True, board, tiles, local_racks, local_blanks, local_bag
                elif cancel_rect.collidepoint(x, y): return False, None, None, None, None, None
            elif event.type == pygame.KEYDOWN and text_box_active:
                if event.key == pygame.K_BACKSPACE: probability_input = probability_input[:-1]
                elif event.unicode.isdigit(): probability_input += event.unicode
        pygame.display.flip()
    return False, None, None, None, None, None # Should not be reached


def is_word_length_allowed(word_len, number_checks):
    """
    Checks if a given word length is allowed based on the number_checks list.
    number_checks corresponds to lengths [2, 3, 4, 5, 6, 7+].
    """
    if word_len < 2: # Words must be at least 2 letters
        return False
    if word_len == 2 and number_checks[0]: return True
    if word_len == 3 and number_checks[1]: return True
    if word_len == 4 and number_checks[2]: return True
    if word_len == 5 and number_checks[3]: return True
    if word_len == 6 and number_checks[4]: return True
    if word_len >= 7 and number_checks[5]: return True # 7+ checkbox
    return False





def mode_selection_screen():
    """Display and handle the game mode selection screen, including Load Game via text input."""
    print("--- mode_selection_screen() entered ---")
    global main_called
    try:
        print("--- mode_selection_screen(): Attempting to load background image... ---")
        image = pygame.image.load("Scrabble_S.png").convert_alpha(); content_width = WINDOW_WIDTH - 200; image = pygame.transform.scale(image, (content_width, WINDOW_HEIGHT)); image.set_alpha(128); content_left = (WINDOW_WIDTH - content_width) // 2
        print("--- mode_selection_screen(): Background image loaded and processed. ---")
    except pygame.error as e:
        print(f"--- mode_selection_screen(): WARNING - Could not load background image 'Scrabble_S.png': {e} ---")
        image = None; content_width = WINDOW_WIDTH; content_left = 0

    modes = [MODE_HVH, MODE_HVA, MODE_AVA]; selected_mode = None; player_names = ["Player 1", "Player 2"]; human_player = 1; input_active = [False, False]; current_input = 0
    practice_mode = None; dropdown_open = False; showing_power_tiles_dialog = False
    letter_checks = [True, True, True, True] # J, Q, X, Z
    number_checks = [True, True, True, True, False, False] # 2, 3, 4, 5, 6, 7+
    practice_state = None
    loaded_game_data = None
    use_endgame_solver_checked = False # Default to not using the solver
    use_ai_simulation_checked = False # Default to not using 2-ply simulation

    # State for Load Game Text Input
    showing_load_input = False; load_filename_input = ""; load_input_active = False
    load_confirm_button_rect = None; load_input_rect = None; load_cancel_button_rect = None

    print("--- mode_selection_screen(): Entering main loop (while selected_mode is None:)... ---")
    loop_count = 0
    while selected_mode is None:
        loop_count += 1
        #if loop_count % 15000 == 0: print(f"--- mode_selection_screen(): Loop iteration {loop_count} ---")

        pygame.event.pump()

        # --- Define positions INSIDE the loop ---
        option_rects = []
        name_rect_x = content_left + (content_width - 200) // 2
        # REMOVED: p2_y_pos = 300 + 60 # Now calculated dynamically below

        # Button Positions (Bottom Row)
        play_later_rect = pygame.Rect(WINDOW_WIDTH - BUTTON_WIDTH - 10, WINDOW_HEIGHT - BUTTON_HEIGHT - 10, BUTTON_WIDTH, BUTTON_HEIGHT)
        load_game_button_rect = pygame.Rect(play_later_rect.left - BUTTON_GAP - BUTTON_WIDTH, play_later_rect.top, BUTTON_WIDTH, BUTTON_HEIGHT)
        batch_game_button_rect = pygame.Rect(load_game_button_rect.left - BUTTON_GAP - BUTTON_WIDTH, play_later_rect.top, BUTTON_WIDTH, BUTTON_HEIGHT)
        start_game_button_rect = pygame.Rect(batch_game_button_rect.left - BUTTON_GAP - BUTTON_WIDTH, play_later_rect.top, BUTTON_WIDTH, BUTTON_HEIGHT)


        # Calculate Load Input Field/Button Positions unconditionally
        load_input_width = 300; load_input_x = load_game_button_rect.left; load_input_y = load_game_button_rect.top - BUTTON_GAP - BUTTON_HEIGHT
        load_input_rect = pygame.Rect(load_input_x, load_input_y, load_input_width, BUTTON_HEIGHT)
        load_confirm_button_rect = pygame.Rect(load_input_x + load_input_width + BUTTON_GAP, load_input_y, BUTTON_WIDTH, BUTTON_HEIGHT)
        load_cancel_button_rect = pygame.Rect(load_confirm_button_rect.right + BUTTON_GAP, load_input_y, BUTTON_WIDTH, BUTTON_HEIGHT)

        # Calculate Checkbox Positions
        last_mode_button_y = 100 + (len(modes) - 1) * 60 + BUTTON_HEIGHT
        checkbox_x_base = content_left + (content_width - 250) // 2 # Approx center alignment
        checkbox_gap = 25 # Vertical gap between checkboxes

        # Endgame Solver Checkbox Position
        endgame_checkbox_x = checkbox_x_base
        endgame_checkbox_y = last_mode_button_y + 20
        endgame_checkbox_rect = pygame.Rect(endgame_checkbox_x, endgame_checkbox_y, 20, 20)
        endgame_label_x = endgame_checkbox_x + 25
        endgame_label_y = endgame_checkbox_y + 2

        # AI Simulation Checkbox Position
        simulation_checkbox_x = checkbox_x_base
        simulation_checkbox_y = endgame_checkbox_y + checkbox_gap
        simulation_checkbox_rect = pygame.Rect(simulation_checkbox_x, simulation_checkbox_y, 20, 20)
        simulation_label_x = simulation_checkbox_x + 25
        simulation_label_y = simulation_checkbox_y + 2

        # --- Calculate Player Name Input Positions Dynamically ---
        name_input_gap = 30 # Gap below the last checkbox
        p1_y_pos = simulation_checkbox_y + simulation_checkbox_rect.height + name_input_gap

        player_name_gap = 40 # Gap between P1 and P2 inputs
        p2_y_pos = p1_y_pos + BUTTON_HEIGHT + player_name_gap # P2 position relative to P1

        # Calculate HVA button rects unconditionally (relative to p2_y_pos)
        hva_button_row_y = p2_y_pos + BUTTON_HEIGHT + 10
        hva_buttons_total_width = (BUTTON_WIDTH * 2 + 20)
        hva_buttons_start_x = content_left + (content_width - hva_buttons_total_width) // 2
        p1_rect_hva = pygame.Rect(hva_buttons_start_x, hva_button_row_y, BUTTON_WIDTH, BUTTON_HEIGHT)
        p2_rect_hva = pygame.Rect(hva_buttons_start_x + BUTTON_WIDTH + 20, hva_button_row_y, BUTTON_WIDTH, BUTTON_HEIGHT)

        # Dropdown positioning (relative to p2_y_pos)
        if modes[current_input] == MODE_HVH and dropdown_open:
            dropdown_x = name_rect_x
            dropdown_button_y = p2_y_pos + BUTTON_HEIGHT + 10 # Position relative to P2 input
            dropdown_y = dropdown_button_y + 30
            options = ["Power Tiles", "8-Letter Bingos", "Bingo, Bango, Bongo", "Only Fives", "End Game"]
            for i, option in enumerate(options): option_rect = pygame.Rect(dropdown_x, dropdown_y + 30 * i, 200, 30); option_rects.append(option_rect)


        # --- Event Handling ---
        for event in pygame.event.get():
            if event.type == pygame.QUIT: pygame.quit(); sys.exit()

            # Handle Load Game Input FIRST if active
            if showing_load_input:
                # [ ... Load game input handling ... ]
                if event.type == pygame.MOUSEBUTTONDOWN:
                    x, y = event.pos
                    if load_input_rect.collidepoint(x, y): load_input_active = True
                    else: load_input_active = False
                    if load_confirm_button_rect.collidepoint(x, y): # Load Confirm ...
                        filepath = load_filename_input.strip()
                        if filepath:
                             print(f"--- mode_selection_screen(): Attempting to load typed file: {filepath} ---")
                             try:
                                 loaded_p_names, loaded_hist, loaded_f_scores = load_game_from_gcg(filepath)
                                 print(f"--- mode_selection_screen(): GCG loaded successfully. Moves: {len(loaded_hist)} ---")
                                 selected_mode = "LOADED_GAME"; loaded_game_data = (loaded_p_names, loaded_hist, loaded_f_scores)
                                 showing_load_input = False; load_input_active = False; break
                             except FileNotFoundError: print(f"--- mode_selection_screen(): Error: File not found '{filepath}' ---"); show_message_dialog(f"Error: File not found:\n{filepath}", "Load Error"); load_input_active = True
                             except Exception as e: print(f"--- mode_selection_screen(): Error loading GCG file '{filepath}': {e} ---"); show_message_dialog(f"Error loading file:\n{e}", "Load Error"); load_input_active = True
                        else: show_message_dialog("Please enter a filename.", "Load Error"); load_input_active = True
                    elif load_cancel_button_rect.collidepoint(x,y): # Load Cancel ...
                         showing_load_input = False; load_input_active = False; load_filename_input = ""
                    if not load_input_rect.collidepoint(x,y): input_active = [False, False] # Deactivate name input too
                elif event.type == pygame.KEYDOWN and load_input_active: # Load Input Typing ...
                    if event.key == pygame.K_RETURN or event.key == pygame.K_KP_ENTER:
                         if load_confirm_button_rect: pygame.event.post(pygame.event.Event(pygame.MOUSEBUTTONDOWN, {'pos': load_confirm_button_rect.center, 'button': 1}))
                    elif event.key == pygame.K_BACKSPACE: load_filename_input = load_filename_input[:-1]
                    elif event.unicode.isprintable(): load_filename_input += event.unicode
                continue # Skip rest of event handling

            # Handle other events if load input wasn't active
            elif event.type == pygame.MOUSEBUTTONDOWN:
                x, y = event.pos
                if showing_power_tiles_dialog: # Power Tiles Dialog ...
                    # [ ... Power tiles dialog handling ... ]
                    dialog_x = (WINDOW_WIDTH - 300) // 2; dialog_y = (WINDOW_HEIGHT - 250) // 2; letter_rects = [pygame.Rect(dialog_x + 20, dialog_y + 40 + i*30, 20, 20) for i in range(4)]; number_rects = [pygame.Rect(dialog_x + 150, dialog_y + 40 + i*30, 20, 20) for i in range(6)]
                    go_rect = pygame.Rect(dialog_x + 50, dialog_y + 220, 100, 30); cancel_rect = pygame.Rect(dialog_x + 160, dialog_y + 220, 100, 30)
                    for i, rect in enumerate(letter_rects):
                        if rect.collidepoint(x, y): letter_checks[i] = not letter_checks[i]
                    for i, rect in enumerate(number_rects):
                        if rect.collidepoint(x, y): number_checks[i] = not number_checks[i] # Update number_checks state
                    if go_rect.collidepoint(x, y):
                        if not any(letter_checks):
                            show_message_dialog("Please select at least one Power Tile (J, Q, X, Z).", "Selection Required")
                        elif not any(number_checks):
                             show_message_dialog("Please select at least one word length.", "Selection Required")
                        else:
                            practice_mode = "power_tiles"; selected_mode = MODE_AVA; showing_power_tiles_dialog = False; print(f"--- mode_selection_screen(): Mode selected via Power Tiles Go: {selected_mode} ---"); break
                    elif cancel_rect.collidepoint(x, y): showing_power_tiles_dialog = False
                else: # Main Selection Screen ...
                    # Must define mode_rects before checking collision
                    mode_rects = []
                    for i, mode in enumerate(modes):
                        y_pos_mode = 100 + i * 60 # Use different variable name to avoid conflict
                        rect = pygame.Rect(content_left + (content_width - (BUTTON_WIDTH * 2 + 20)) // 2, y_pos_mode, BUTTON_WIDTH * 2 + 20, BUTTON_HEIGHT); mode_rects.append(rect)
                    # Check mode buttons
                    for i, rect in enumerate(mode_rects):
                        if rect.collidepoint(x, y):
                            current_input = i; dropdown_open = False
                            if i == 0: player_names = ["Player 1", "Player 2"]; input_active = [False, False]
                            elif i == 1: player_names = ["Player 1", "AI"] if human_player == 1 else ["AI", "Player 2"]; input_active = [True, False] if human_player == 1 else [False, True] # Set initial HVA state
                            elif i == 2: player_names = ["AI 1", "AI 2"]; input_active = [False, False]

                    # Handle Endgame Solver Checkbox Click
                    if endgame_checkbox_rect.collidepoint(x, y):
                        use_endgame_solver_checked = not use_endgame_solver_checked
                    # Handle AI Simulation Checkbox Click
                    elif simulation_checkbox_rect.collidepoint(x, y):
                        use_ai_simulation_checked = not use_ai_simulation_checked

                    # Handle Batch Game Button Click
                    elif batch_game_button_rect.collidepoint(x, y):
                        print("--- mode_selection_screen(): Batch Games button clicked ---")
                        current_selected_game_mode = modes[current_input]
                        if current_selected_game_mode == MODE_HVH:
                             show_message_dialog("Batch mode not available for Human vs Human.", "Mode Error")
                        else: # HVA or AVA selected, proceed
                            num_games = get_batch_game_dialog()
                            if num_games is not None:
                                print(f"--- mode_selection_screen(): Starting batch of {num_games} games ---")
                                selected_mode = "BATCH_MODE"
                                # Include the new checkbox state in the batch config data if needed later
                                loaded_game_data = (current_selected_game_mode, player_names, human_player, use_endgame_solver_checked, use_ai_simulation_checked, num_games)
                                break # Exit mode selection loop
                            else:
                                print("--- mode_selection_screen(): Batch game setup cancelled ---")

                    # Handle Start Game Button Click
                    elif start_game_button_rect.collidepoint(x, y):
                        selected_mode = modes[current_input] # Set the selected mode now
                        print(f"--- mode_selection_screen(): Start Game clicked. Mode: {selected_mode} ---")
                        break # Exit mode selection loop

                    # Check Load Game Button
                    elif load_game_button_rect.collidepoint(x, y):
                        print("--- mode_selection_screen(): Load Game button clicked, showing input ---")
                        showing_load_input = True; load_input_active = True; load_filename_input = ""
                        continue # Skip rest

                    # Check Other Buttons
                    elif play_later_rect.collidepoint(x, y): print("--- mode_selection_screen(): Play Later clicked. Exiting. ---"); pygame.quit(); sys.exit()
                    else: # Handle name inputs, HVA selection, practice dropdown
                        clicked_name_input = False
                        # Use dynamically calculated p1_y_pos and p2_y_pos here
                        p1_name_rect = pygame.Rect(name_rect_x, p1_y_pos, 200, BUTTON_HEIGHT)
                        p2_name_rect = pygame.Rect(name_rect_x, p2_y_pos, 200, BUTTON_HEIGHT) if modes[current_input] == MODE_HVH else None

                        if modes[current_input] == MODE_HVH: # HVH Name Input ...
                            if p1_name_rect.collidepoint(x, y): input_active = [True, False]; clicked_name_input = True
                            elif p2_name_rect and p2_name_rect.collidepoint(x, y): input_active = [False, True]; clicked_name_input = True
                        elif modes[current_input] == MODE_HVA: # HVA Name Input / Play As ...
                            if human_player == 1 and p1_name_rect.collidepoint(x, y): input_active = [True, False]; clicked_name_input = True
                            elif human_player == 2:
                                # Use p2_y_pos for HVA P2 input box as well
                                p2_name_rect_hva = pygame.Rect(name_rect_x, p2_y_pos, 200, BUTTON_HEIGHT)
                                if p2_name_rect_hva.collidepoint(x,y): input_active = [False, True]; clicked_name_input = True
                            # HVA buttons use hva_button_row_y which is relative to p2_y_pos
                            if p1_rect_hva.collidepoint(x, y):
                                human_player = 1; player_names = ["Player 1", "AI"]; input_active = [True, False]
                            elif p2_rect_hva.collidepoint(x, y):
                                human_player = 2; player_names = ["AI", "Player 2"]; input_active = [False, True]

                        if modes[current_input] == MODE_HVH: # Practice Dropdown ...
                            # Use p2_y_pos for dropdown button position
                            dropdown_button_y = p2_y_pos + BUTTON_HEIGHT + 10
                            dropdown_rect = pygame.Rect(name_rect_x, dropdown_button_y, 200, 30)
                            if dropdown_rect.collidepoint(x, y): dropdown_open = not dropdown_open
                            elif dropdown_open:
                                clicked_option = False
                                current_options = ["Power Tiles", "8-Letter Bingos", "Bingo, Bango, Bongo", "Only Fives", "End Game"]
                                for i, option_rect in enumerate(option_rects): # option_rects positions calculated earlier based on dropdown_button_y
                                    if option_rect.collidepoint(x, y):
                                        clicked_option = True; dropdown_open = False
                                        selected_practice_option = current_options[i]

                                        if selected_practice_option == "Power Tiles":
                                            showing_power_tiles_dialog = True
                                        elif selected_practice_option == "8-Letter Bingos":
                                            print("--- mode_selection_screen(): 8-Letter Bingo practice selected. Calling eight_letter_practice()... ---")
                                            proceed, p_board, p_tiles, p_racks, p_blanks, p_bag = eight_letter_practice()
                                            if proceed:
                                                practice_mode = "eight_letter"; selected_mode = MODE_HVH; player_names = ["Player 1", ""]; human_player = 1
                                                practice_state = {"board": p_board, "tiles": p_tiles, "racks": p_racks, "blanks": p_blanks, "bag": p_bag, "first_play": False, "scores": [0, 0], "turn": 1}
                                                print(f"--- mode_selection_screen(): 8-Letter practice setup successful. Selected mode: {selected_mode} ---"); break
                                            else: print("--- mode_selection_screen(): 8-Letter practice setup cancelled or failed. ---")
                                        elif selected_practice_option == "Bingo, Bango, Bongo":
                                            print("--- mode_selection_screen(): Bingo, Bango, Bongo practice selected. ---")
                                            practice_mode = "bingo_bango_bongo"
                                            selected_mode = MODE_AVA # Set game mode to AI vs AI
                                            player_names = ["AI 1", "AI 2"] # Set names accordingly
                                            practice_state = None # Start a standard new game setup
                                            print(f"--- mode_selection_screen(): Bingo, Bango, Bongo setup successful. Selected mode: {selected_mode} ---"); break
                                        elif selected_practice_option == "Only Fives":
                                            print("--- mode_selection_screen(): Only Fives practice selected. ---")
                                            practice_mode = "only_fives"
                                            selected_mode = MODE_HVA # Set game mode to Human vs AI
                                            human_player = 1 # Default to human as Player 1
                                            player_names = ["Player 1", "AI"] # Set names accordingly
                                            practice_state = None # Start a standard new game setup
                                            print(f"--- mode_selection_screen(): Only Fives setup successful. Selected mode: {selected_mode} ---"); break
                                        elif selected_practice_option == "End Game":
                                            print("End Game practice selected - Not implemented yet")
                                        break # Exit options loop
                                if not clicked_option and not dropdown_rect.collidepoint(x,y): dropdown_open = False
                            elif not dropdown_rect.collidepoint(x,y): dropdown_open = False

                        # Deactivate name input if clicking elsewhere
                        dropdown_button_y_check = p2_y_pos + BUTTON_HEIGHT + 10 # Recalculate for check
                        dropdown_rect_check = pygame.Rect(name_rect_x, dropdown_button_y_check, 200, 30) if modes[current_input] == MODE_HVH else None
                        # Add simulation_checkbox_rect to the list of things NOT to deactivate input for
                        if not clicked_name_input and not (dropdown_open and any(r.collidepoint(x,y) for r in option_rects)) and not p1_name_rect.collidepoint(x,y) and not (p2_name_rect and p2_name_rect.collidepoint(x,y)) and not (dropdown_rect_check and dropdown_rect_check.collidepoint(x,y)) and not endgame_checkbox_rect.collidepoint(x, y) and not simulation_checkbox_rect.collidepoint(x, y):
                            input_active = [False, False]

            elif event.type == pygame.KEYDOWN: # Keyboard Input (Names only now)
                if not showing_load_input: # Only handle name input if load input isn't showing
                     active_idx = -1
                     if input_active[0]: active_idx = 0
                     elif input_active[1] and modes[current_input] == MODE_HVH: active_idx = 1
                     elif input_active[1] and modes[current_input] == MODE_HVA and human_player == 2: active_idx = 1
                     if active_idx != -1:
                        if event.key == pygame.K_BACKSPACE: player_names[active_idx] = player_names[active_idx][:-1]
                        elif event.key == pygame.K_RETURN: input_active[active_idx] = False
                        elif event.unicode.isalnum() or event.unicode == ' ':
                            if len(player_names[active_idx]) < 15: player_names[active_idx] += event.unicode

        # --- Drawing Logic ---
        screen.fill(WHITE);
        if image: screen.blit(image, (content_left, 0))
        title_text = dialog_font.render("Select Game Mode", True, BLACK); title_x = content_left + (content_width - title_text.get_width()) // 2; screen.blit(title_text, (title_x, 50))
        mode_rects = [] # Draw Mode Buttons ...
        for i, mode in enumerate(modes):
            y_pos_mode = 100 + i * 60 # Use different variable name
            rect = pygame.Rect(content_left + (content_width - (BUTTON_WIDTH * 2 + 20)) // 2, y_pos_mode, BUTTON_WIDTH * 2 + 20, BUTTON_HEIGHT); hover = rect.collidepoint(pygame.mouse.get_pos())
            color = BUTTON_HOVER if i == current_input or hover else BUTTON_COLOR; pygame.draw.rect(screen, color, rect)
            if i == current_input: pygame.draw.rect(screen, BLACK, rect, 2)
            text = button_font.render(mode, True, BLACK); text_rect = text.get_rect(center=rect.center); screen.blit(text, text_rect); mode_rects.append(rect)

        # Draw Endgame Solver Checkbox
        draw_checkbox(screen, endgame_checkbox_rect.x, endgame_checkbox_rect.y, use_endgame_solver_checked)
        endgame_label_surf = ui_font.render("Use AI Endgame Solver", True, BLACK)
        screen.blit(endgame_label_surf, (endgame_label_x, endgame_label_y))

        # Draw AI Simulation Checkbox
        draw_checkbox(screen, simulation_checkbox_rect.x, simulation_checkbox_rect.y, use_ai_simulation_checked)
        simulation_label_surf = ui_font.render("Use AI 2-ply Simulation", True, BLACK)
        screen.blit(simulation_label_surf, (simulation_label_x, simulation_label_y))

        # Draw Play Later Button ...
        hover = play_later_rect.collidepoint(pygame.mouse.get_pos()); color = BUTTON_HOVER if hover else BUTTON_COLOR; pygame.draw.rect(screen, color, play_later_rect)
        play_later_text = button_font.render("Play Later", True, BLACK); play_later_text_rect = play_later_text.get_rect(center=play_later_rect.center); screen.blit(play_later_text, play_later_text_rect)

        # Draw Load Game Button ...
        hover = load_game_button_rect.collidepoint(pygame.mouse.get_pos()); color = BUTTON_HOVER if hover else BUTTON_COLOR; pygame.draw.rect(screen, color, load_game_button_rect)
        load_game_text = button_font.render("Load Game", True, BLACK); load_game_text_rect = load_game_text.get_rect(center=load_game_button_rect.center); screen.blit(load_game_text, load_game_text_rect)

        # Draw Batch Game Button
        hover = batch_game_button_rect.collidepoint(pygame.mouse.get_pos()); color = BUTTON_HOVER if hover else BUTTON_COLOR; pygame.draw.rect(screen, color, batch_game_button_rect)
        batch_game_text = button_font.render("Batch Games", True, BLACK); batch_game_text_rect = batch_game_text.get_rect(center=batch_game_button_rect.center); screen.blit(batch_game_text, batch_game_text_rect)

        # Draw Start Game Button
        hover = start_game_button_rect.collidepoint(pygame.mouse.get_pos()); color = BUTTON_HOVER if hover else BUTTON_COLOR; pygame.draw.rect(screen, color, start_game_button_rect)
        start_game_text = button_font.render("Start Game", True, BLACK); start_game_text_rect = start_game_text.get_rect(center=start_game_button_rect.center); screen.blit(start_game_text, start_game_text_rect)


        # Draw Load Game Input Field (if active)
        if showing_load_input:
             pygame.draw.rect(screen, WHITE, load_input_rect); pygame.draw.rect(screen, BLACK, load_input_rect, 1 if not load_input_active else 2)
             input_surf = ui_font.render(load_filename_input, True, BLACK); screen.blit(input_surf, (load_input_rect.x + 5, load_input_rect.y + 5))
             if load_input_active and int(time.time() * 2) % 2 == 0: # Blinking cursor
                  cursor_x = load_input_rect.x + 5 + input_surf.get_width(); cursor_y1 = load_input_rect.y + 5; cursor_y2 = load_input_rect.y + load_input_rect.height - 5
                  pygame.draw.line(screen, BLACK, (cursor_x, cursor_y1), (cursor_x, cursor_y2), 1)
             hover = load_confirm_button_rect.collidepoint(pygame.mouse.get_pos()); color = BUTTON_HOVER if hover else BUTTON_COLOR # Confirm Button
             pygame.draw.rect(screen, color, load_confirm_button_rect); text = button_font.render("Load File", True, BLACK); text_rect = text.get_rect(center=load_confirm_button_rect.center); screen.blit(text, text_rect)
             hover = load_cancel_button_rect.collidepoint(pygame.mouse.get_pos()); color = BUTTON_HOVER if hover else BUTTON_COLOR # Cancel Button
             pygame.draw.rect(screen, color, load_cancel_button_rect); text = button_font.render("Cancel", True, BLACK); text_rect = text.get_rect(center=load_cancel_button_rect.center); screen.blit(text, text_rect)

        # Name Input / Practice Dropdown / HVA Selection Drawing ...
        # Use dynamically calculated p1_y_pos and p2_y_pos
        name_rect_width = 200;
        p1_label_text = "Player 1 Name:"; p1_label = ui_font.render(p1_label_text, True, BLACK);
        p1_name_rect = pygame.Rect(name_rect_x, p1_y_pos, name_rect_width, BUTTON_HEIGHT) # Define for drawing
        p1_label_x = name_rect_x - p1_label.get_width() - 10; screen.blit(p1_label, (p1_label_x, p1_y_pos + 5)); p1_bg_color = LIGHT_BLUE if input_active[0] else (GRAY if modes[current_input] == MODE_AVA else WHITE); pygame.draw.rect(screen, p1_bg_color, p1_name_rect); pygame.draw.rect(screen, BLACK, p1_name_rect, 1)
        p1_name_text = ui_font.render(player_names[0], True, BLACK); screen.blit(p1_name_text, (p1_name_rect.x + 5, p1_name_rect.y + 5))

        if modes[current_input] == MODE_HVH:
            p2_label_text = "Player 2 Name:"; p2_label = ui_font.render(p2_label_text, True, BLACK);
            p2_name_rect = pygame.Rect(name_rect_x, p2_y_pos, name_rect_width, BUTTON_HEIGHT) # Define for drawing
            p2_label_x = name_rect_x - p2_label.get_width() - 10; screen.blit(p2_label, (p2_label_x, p2_y_pos + 5))
            pygame.draw.rect(screen, WHITE if not input_active[1] else LIGHT_BLUE, p2_name_rect); pygame.draw.rect(screen, BLACK, p2_name_rect, 1); p2_name_text = ui_font.render(player_names[1], True, BLACK); screen.blit(p2_name_text, (p2_name_rect.x + 5, p2_name_rect.y + 5))
            # Use p2_y_pos for dropdown button position
            dropdown_button_y = p2_y_pos + BUTTON_HEIGHT + 10
            dropdown_rect = pygame.Rect(name_rect_x, dropdown_button_y, 200, 30); hover = dropdown_rect.collidepoint(pygame.mouse.get_pos()); color = BUTTON_HOVER if hover else BUTTON_COLOR; pygame.draw.rect(screen, color, dropdown_rect)
            text = button_font.render("Practice", True, BLACK); text_rect = text.get_rect(center=dropdown_rect.center); screen.blit(text, text_rect)
            if dropdown_open:
                current_options = ["Power Tiles", "8-Letter Bingos", "Bingo, Bango, Bongo", "Only Fives", "End Game"]
                for i, option_rect in enumerate(option_rects): # option_rects positions calculated earlier based on dropdown_button_y
                     hover = option_rect.collidepoint(pygame.mouse.get_pos()); color = BUTTON_HOVER if hover else DROPDOWN_COLOR; pygame.draw.rect(screen, color, option_rect);
                     text = button_font.render(current_options[i], True, BLACK); text_rect = text.get_rect(center=option_rect.center); screen.blit(text, text_rect)
        elif modes[current_input] == MODE_HVA:
            p2_label_text = "AI Name:"; p2_label = ui_font.render(p2_label_text, True, BLACK);
            p2_name_rect = pygame.Rect(name_rect_x, p2_y_pos, name_rect_width, BUTTON_HEIGHT) # Define for drawing
            p2_label_x = name_rect_x - p2_label.get_width() - 10; screen.blit(p2_label, (p2_label_x, p2_y_pos + 5))
            pygame.draw.rect(screen, GRAY, p2_name_rect); pygame.draw.rect(screen, BLACK, p2_name_rect, 1); p2_name_text = ui_font.render(player_names[1], True, BLACK); screen.blit(p2_name_text, (p2_name_rect.x + 5, p2_name_rect.y + 5))
            # Draw HVA Play As buttons using pre-calculated rects (hva_button_row_y is relative to p2_y_pos)
            p1_hover = p1_rect_hva.collidepoint(pygame.mouse.get_pos()); p2_hover = p2_rect_hva.collidepoint(pygame.mouse.get_pos()); pygame.draw.rect(screen, BUTTON_HOVER if p1_hover else BUTTON_COLOR, p1_rect_hva);
            if human_player == 1: pygame.draw.rect(screen, BLACK, p1_rect_hva, 2)
            pygame.draw.rect(screen, BUTTON_HOVER if p2_hover else BUTTON_COLOR, p2_rect_hva);
            if human_player == 2: pygame.draw.rect(screen, BLACK, p2_rect_hva, 2)
            p1_text = button_font.render("Play as P1", True, BLACK); p2_text = button_font.render("Play as P2", True, BLACK); p1_text_rect = p1_text.get_rect(center=p1_rect_hva.center); p2_text_rect = p2_text.get_rect(center=p2_rect_hva.center); screen.blit(p1_text, p1_text_rect); screen.blit(p2_text, p2_text_rect)
        elif modes[current_input] == MODE_AVA:
            p2_label_text = "AI 2 Name:"; p2_label = ui_font.render(p2_label_text, True, BLACK);
            p2_name_rect = pygame.Rect(name_rect_x, p2_y_pos, name_rect_width, BUTTON_HEIGHT) # Define for drawing
            p2_label_x = name_rect_x - p2_label.get_width() - 10; screen.blit(p2_label, (p2_label_x, p2_y_pos + 5))
            pygame.draw.rect(screen, GRAY, p2_name_rect); pygame.draw.rect(screen, BLACK, p2_name_rect, 1); p2_name_text = ui_font.render(player_names[1], True, BLACK); screen.blit(p2_name_text, (p2_name_rect.x + 5, p2_name_rect.y + 5))
            pygame.draw.rect(screen, GRAY, p1_name_rect); pygame.draw.rect(screen, BLACK, p1_name_rect, 1); p1_name_text = ui_font.render(player_names[0], True, BLACK); screen.blit(p1_name_text, (p1_name_rect.x + 5, p1_name_rect.y + 5))

        # Draw Power Tiles Dialog if active ...
        if showing_power_tiles_dialog:
            dialog_width, dialog_height = 300, 250; dialog_x = (WINDOW_WIDTH - dialog_width) // 2; dialog_y = (WINDOW_HEIGHT - dialog_height) // 2; pygame.draw.rect(screen, DIALOG_COLOR, (dialog_x, dialog_y, dialog_width, dialog_height)); pygame.draw.rect(screen, BLACK, (dialog_x, dialog_y, dialog_width, dialog_height), 2)
            title_text = dialog_font.render("Power Tiles Options", True, BLACK); screen.blit(title_text, (dialog_x + 10, dialog_y + 10)); letters = ['J', 'Q', 'X', 'Z']
            for i, letter in enumerate(letters): draw_checkbox(screen, dialog_x + 20, dialog_y + 40 + i*30, letter_checks[i]); text = ui_font.render(letter, True, BLACK); screen.blit(text, (dialog_x + 50, dialog_y + 40 + i*30))
            numbers = ['2', '3', '4', '5', '6', '7+']
            for i, num in enumerate(numbers): draw_checkbox(screen, dialog_x + 150, dialog_y + 40 + i*30, number_checks[i]); text = ui_font.render(num, True, BLACK); screen.blit(text, (dialog_x + 180, dialog_y + 40 + i*30))
            go_rect = pygame.Rect(dialog_x + 50, dialog_y + 220, 100, 30); cancel_rect = pygame.Rect(dialog_x + 160, dialog_y + 220, 100, 30); pygame.draw.rect(screen, BUTTON_COLOR, go_rect); pygame.draw.rect(screen, BUTTON_COLOR, cancel_rect)
            go_text = button_font.render("Go", True, BLACK); cancel_text = button_font.render("Cancel", True, BLACK); screen.blit(go_text, go_text.get_rect(center=go_rect.center)); screen.blit(cancel_text, cancel_text.get_rect(center=cancel_rect.center))


        # --- Display Update ---
        pygame.display.flip()

        # --- Exit Condition Check ---
        if selected_mode: break

    print(f"--- mode_selection_screen(): Exiting loop. Returning mode={selected_mode} ---")
    # Return loaded game data or new game setup data
    if selected_mode == "LOADED_GAME":
        return selected_mode, loaded_game_data
    elif selected_mode == "BATCH_MODE":
        # Return the new checkbox state in the batch config tuple
        return selected_mode, loaded_game_data # loaded_game_data holds batch config here
    else:
        # Return both checkbox states
        return selected_mode, (player_names, human_player, practice_mode, letter_checks, number_checks, use_endgame_solver_checked, use_ai_simulation_checked, practice_state)




def draw_options_menu(turn, dropdown_open, bag_count):
    """Draw the options menu with dropdown functionality, adding Stop Batch."""
    global practice_mode, is_batch_running # Access global flags
    options_x = 10; options_rect = pygame.Rect(options_x, OPTIONS_Y, OPTIONS_WIDTH, OPTIONS_HEIGHT)
    hover = options_rect.collidepoint(pygame.mouse.get_pos()); color = BUTTON_HOVER if hover else BUTTON_COLOR; pygame.draw.rect(screen, color, options_rect)
    options_text = button_font.render("Options", True, BLACK); options_text_rect = options_text.get_rect(center=(options_x + OPTIONS_WIDTH // 2, OPTIONS_Y + OPTIONS_HEIGHT // 2)); screen.blit(options_text, options_text_rect)
    dropdown_rects = []
    if dropdown_open:
        dropdown_y = OPTIONS_Y + OPTIONS_HEIGHT
        # --- MODIFICATION: Change options if batch is running ---
        if is_batch_running:
            options = ["Stop Batch", "Quit"]
        elif practice_mode == "eight_letter":
            options = ["Give Up", "Main", "Quit"]
        else: # Standard game or other practice modes
            options = ["Pass", "Exchange", "Main", "Quit"]
        # --- END MODIFICATION ---

        for i, option in enumerate(options):
            rect = pygame.Rect(options_x, dropdown_y + i * OPTIONS_HEIGHT, OPTIONS_WIDTH, OPTIONS_HEIGHT)
            # Disable Exchange if bag < 7 (only in non-batch, non-8letter modes)
            is_disabled = (not is_batch_running and
                           practice_mode != "eight_letter" and
                           option == "Exchange" and
                           bag_count < 7)

            if is_disabled:
                pygame.draw.rect(screen, GRAYED_OUT_COLOR, rect)
                text = button_font.render(option, True, BLACK)
                dropdown_rects.append(None) # Mark as non-clickable
            else:
                hover = rect.collidepoint(pygame.mouse.get_pos())
                color = BUTTON_HOVER if hover else DROPDOWN_COLOR
                pygame.draw.rect(screen, color, rect)
                text = button_font.render(option, True, BLACK)
                dropdown_rects.append(rect) # Store clickable rect

            text_rect = text.get_rect(center=(options_x + OPTIONS_WIDTH // 2, dropdown_y + i * OPTIONS_HEIGHT + OPTIONS_HEIGHT // 2))
            screen.blit(text, text_rect)
    return options_rect, dropdown_rects

# End of Part 2

# Part 3 (Includes dialogs, stats, message boxes)
# draw_suggest_button, draw_exchange_dialog, confirm_quit, draw_game_over_dialog, draw_score_row, calculate_moves_per_player, calculate_bingos_per_player, calculate_bingo_avg_per_player, draw_moves_row, draw_avg_score_row, draw_bingos_row, draw_bingo_avg_row, calculate_blanks_per_player, draw_blanks_row, draw_stats_dialog, show_message_dialog, draw_practice_end_dialog (Unchanged from Part 3 provided previously)
def draw_suggest_button():
    """Draw the suggest button."""
    suggest_x = 10 + OPTIONS_WIDTH + BUTTON_GAP; suggest_rect = pygame.Rect(suggest_x, OPTIONS_Y, OPTIONS_WIDTH, OPTIONS_HEIGHT)
    hover = suggest_rect.collidepoint(pygame.mouse.get_pos()); color = BUTTON_HOVER if hover else BUTTON_COLOR; pygame.draw.rect(screen, color, suggest_rect)
    suggest_text = button_font.render("Suggest", True, BLACK); suggest_text_rect = suggest_text.get_rect(center=(suggest_x + OPTIONS_WIDTH // 2, OPTIONS_Y + OPTIONS_HEIGHT // 2)); screen.blit(suggest_text, suggest_text_rect)
    return suggest_rect

def draw_exchange_dialog(rack, selected_tiles):
    """Draw the tile exchange dialog."""
    dialog_width, dialog_height = 400, 200; dialog_x = (WINDOW_WIDTH - dialog_width) // 2; dialog_y = (WINDOW_HEIGHT - dialog_height) // 2
    pygame.draw.rect(screen, DIALOG_COLOR, (dialog_x, dialog_y, dialog_width, dialog_height)); pygame.draw.rect(screen, BLACK, (dialog_x, dialog_y, dialog_width, dialog_height), 2)
    prompt_text = dialog_font.render("Select tiles to exchange:", True, BLACK); screen.blit(prompt_text, (dialog_x + 10, dialog_y + 10))
    tile_rects = []; rack_display_width = len(rack) * (TILE_WIDTH + TILE_GAP) - TILE_GAP; start_tile_x = dialog_x + (dialog_width - rack_display_width) // 2
    for i, tile in enumerate(rack):
        tile_x = start_tile_x + i * (TILE_WIDTH + TILE_GAP); tile_y = dialog_y + 50; rect = pygame.Rect(tile_x, tile_y, TILE_WIDTH, TILE_HEIGHT); tile_rects.append(rect)
        if tile == ' ':
            center = rect.center; radius = TILE_WIDTH // 2 - 2; pygame.draw.circle(screen, BLACK, center, radius)
            if i in selected_tiles: pygame.draw.circle(screen, SELECTED_TILE_COLOR, center, radius + 2, 2)
            text = font.render('?', True, WHITE); text_rect = text.get_rect(center=center); screen.blit(text, text_rect)
        else: color = SELECTED_TILE_COLOR if i in selected_tiles else GREEN; pygame.draw.rect(screen, color, rect); text = font.render(tile, True, BLACK); screen.blit(text, (tile_x + 5, tile_y + 5))
    total_button_width = BUTTON_WIDTH * 2 + BUTTON_GAP; button_start_x = dialog_x + (dialog_width - total_button_width) // 2; button_y = dialog_y + dialog_height - BUTTON_HEIGHT - 10
    exchange_button_rect = pygame.Rect(button_start_x, button_y, BUTTON_WIDTH, BUTTON_HEIGHT); cancel_button_rect = pygame.Rect(button_start_x + BUTTON_WIDTH + BUTTON_GAP, button_y, BUTTON_WIDTH, BUTTON_HEIGHT)
    hover = exchange_button_rect.collidepoint(pygame.mouse.get_pos()); color = BUTTON_HOVER if hover else BUTTON_COLOR; pygame.draw.rect(screen, color, exchange_button_rect)
    exchange_text = button_font.render("Exchange", True, BLACK); exchange_text_rect = exchange_text.get_rect(center=exchange_button_rect.center); screen.blit(exchange_text, exchange_text_rect)
    hover = cancel_button_rect.collidepoint(pygame.mouse.get_pos()); color = BUTTON_HOVER if hover else BUTTON_COLOR; pygame.draw.rect(screen, color, cancel_button_rect)
    cancel_text = button_font.render("Cancel", True, BLACK); cancel_text_rect = cancel_text.get_rect(center=cancel_button_rect.center); screen.blit(cancel_text, cancel_text_rect)
    return tile_rects, exchange_button_rect, cancel_button_rect

def confirm_quit():
    """Prompt the user to confirm quitting the game."""
    dialog_width, dialog_height = 300, 100; dialog_x = (WINDOW_WIDTH - dialog_width) // 2; dialog_y = (WINDOW_HEIGHT - dialog_height) // 2
    pygame.draw.rect(screen, DIALOG_COLOR, (dialog_x, dialog_y, dialog_width, dialog_height)); pygame.draw.rect(screen, BLACK, (dialog_x, dialog_y, dialog_width, dialog_height), 2)
    prompt_text = dialog_font.render("Quit game? (Y/N)", True, BLACK); screen.blit(prompt_text, (dialog_x + (dialog_width - prompt_text.get_width()) // 2, dialog_y + 30)); pygame.display.flip()
    while True:
        for event in pygame.event.get():
            if event.type == pygame.QUIT: pygame.quit(); sys.exit()
            elif event.type == pygame.KEYDOWN:
                if event.key == pygame.K_y: return True
                elif event.key == pygame.K_n: return False

def draw_game_over_dialog(dialog_x, dialog_y, final_scores, reason, player_names):
    """Draw the game over dialog and return button rectangles."""
    pygame.draw.rect(screen, DIALOG_COLOR, (dialog_x, dialog_y, DIALOG_WIDTH, DIALOG_HEIGHT)); pygame.draw.rect(screen, BLACK, (dialog_x, dialog_y, DIALOG_WIDTH, DIALOG_HEIGHT), 2)
    title_text = dialog_font.render(f"Game Over - {reason}", True, BLACK); p1_score_text = ui_font.render(f"{player_names[0]} Score: {final_scores[0]}", True, BLACK)
    p2_name_display = player_names[1] if player_names[1] else "Player 2"; p2_score_text = ui_font.render(f"{p2_name_display} Score: {final_scores[1]}", True, BLACK)
    save_text = button_font.render("Save (S)", True, BLACK); quit_text = button_font.render("Quit (Q)", True, BLACK); replay_text = button_font.render("Replay (R)", True, BLACK); play_again_text = button_font.render("Play Again (P)", True, BLACK); stats_text = button_font.render("Statistics", True, BLACK)
    screen.blit(title_text, (dialog_x + 10, dialog_y + 20)); screen.blit(p1_score_text, (dialog_x + 10, dialog_y + 60)); screen.blit(p2_score_text, (dialog_x + 10, dialog_y + 90))
    first_row_width = 3 * BUTTON_WIDTH + 2 * BUTTON_GAP; first_row_start_x = dialog_x + (DIALOG_WIDTH - first_row_width) // 2; second_row_width = 2 * BUTTON_WIDTH + BUTTON_GAP; second_row_start_x = dialog_x + (DIALOG_WIDTH - second_row_width) // 2
    save_rect = pygame.Rect(first_row_start_x, dialog_y + 150, BUTTON_WIDTH, BUTTON_HEIGHT); quit_rect = pygame.Rect(first_row_start_x + BUTTON_WIDTH + BUTTON_GAP, dialog_y + 150, BUTTON_WIDTH, BUTTON_HEIGHT); replay_rect = pygame.Rect(first_row_start_x + 2 * (BUTTON_WIDTH + BUTTON_GAP), dialog_y + 150, BUTTON_WIDTH, BUTTON_HEIGHT)
    play_again_rect = pygame.Rect(second_row_start_x, dialog_y + 190, BUTTON_WIDTH, BUTTON_HEIGHT); stats_rect = pygame.Rect(second_row_start_x + BUTTON_WIDTH + BUTTON_GAP, dialog_y + 190, BUTTON_WIDTH, BUTTON_HEIGHT)
    pygame.draw.rect(screen, BUTTON_COLOR, save_rect); pygame.draw.rect(screen, BUTTON_COLOR, quit_rect); pygame.draw.rect(screen, BUTTON_COLOR, replay_rect); pygame.draw.rect(screen, BUTTON_COLOR, play_again_rect); pygame.draw.rect(screen, BUTTON_COLOR, stats_rect)
    screen.blit(save_text, save_text.get_rect(center=save_rect.center)); screen.blit(quit_text, quit_text.get_rect(center=quit_rect.center)); screen.blit(replay_text, replay_text.get_rect(center=replay_rect.center)); screen.blit(play_again_text, play_again_text.get_rect(center=play_again_rect.center)); screen.blit(stats_text, stats_text.get_rect(center=stats_rect.center))
    return save_rect, quit_rect, replay_rect, play_again_rect, stats_rect

def draw_score_row(screen, dialog_x, y_pos, final_scores):
    """Draw the score row for the statistics dialog."""
    score_label = ui_font.render("Score:", True, BLACK)
    p1_score_text = ui_font.render(str(final_scores[0]), True, BLACK)
    p2_score_text = ui_font.render(str(final_scores[1]), True, BLACK)
    screen.blit(score_label, (dialog_x + STATS_LABEL_X_OFFSET, y_pos))
    screen.blit(p1_score_text, (dialog_x + STATS_P1_VAL_X_OFFSET, y_pos))
    screen.blit(p2_score_text, (dialog_x + STATS_P2_VAL_X_OFFSET, y_pos))


def calculate_moves_per_player(move_history):
    """Calculate the number of moves made by each player from move_history."""
    moves_count = {1: 0, 2: 0}
    for move in move_history:
        player = move['player']
        # --- CORRECTED INDENTATION START ---
        if move['move_type'] in ['place', 'pass', 'exchange']:
            moves_count[player] += 1
        # --- CORRECTED INDENTATION END ---
    return moves_count[1], moves_count[2]

def calculate_bingos_per_player(move_history):
    """Calculate the number of bingos played by each player."""
    bingo_count = {1: 0, 2: 0}
    for move in move_history:
        if move['move_type'] == 'place' and move.get('is_bingo', False): player = move['player']; bingo_count[player] += 1
    return bingo_count[1], bingo_count[2]

def calculate_bingo_avg_per_player(move_history):
    """Calculate the average score of bingos for each player."""
    bingo_scores = {1: [], 2: []}
    for move in move_history:
        if move['move_type'] == 'place' and move.get('is_bingo', False): player = move['player']; bingo_scores[player].append(move['score'])
    avg_p1 = sum(bingo_scores[1]) / len(bingo_scores[1]) if bingo_scores[1] else 0.0; avg_p2 = sum(bingo_scores[2]) / len(bingo_scores[2]) if bingo_scores[2] else 0.0
    return avg_p1, avg_p2

def calculate_tiles_per_turn(move_history):
    """
    Calculate the average number of tiles played per turn for each player.
    Only counts 'place' moves.
    """
    tiles_played_count = {1: 0, 2: 0}
    place_moves_count = {1: 0, 2: 0}

    for move in move_history:
        if move['move_type'] == 'place':
            player = move['player']
            place_moves_count[player] += 1
            # Use 'newly_placed' if available, otherwise fallback to 'positions'
            # 'newly_placed' should be more accurate for tiles *actually* played from the rack
            tiles_played = move.get('newly_placed', move.get('positions', []))
            tiles_played_count[player] += len(tiles_played)

    avg_p1 = tiles_played_count[1] / place_moves_count[1] if place_moves_count[1] > 0 else 0.0
    avg_p2 = tiles_played_count[2] / place_moves_count[2] if place_moves_count[2] > 0 else 0.0

    return avg_p1, avg_p2

def calculate_avg_leave(move_history):
    """
    Calculate the average leave value for each player's rack after their turn.
    Uses the 'rack' field from the move history (which stores the rack *before* the move).
    """
    leave_scores_sum = {1: 0.0, 2: 0.0}
    moves_count = {1: 0, 2: 0}

    for move in move_history:
        player = move['player']
        # Only count moves where a rack was recorded (should be all moves)
        if 'rack' in move and move['rack'] is not None:
            moves_count[player] += 1
            # Evaluate the leave *before* the move was made
            # The 'rack' field in move_history stores the rack *before* the move
            leave_score = evaluate_leave(move['rack'])
            leave_scores_sum[player] += leave_score

    avg_p1 = leave_scores_sum[1] / moves_count[1] if moves_count[1] > 0 else 0.0
    avg_p2 = leave_scores_sum[2] / moves_count[2] if moves_count[2] > 0 else 0.0

    return avg_p1, avg_p2

# --- NEW Statistics Drawing Functions ---

def draw_tiles_per_turn_row(screen, dialog_x, y_pos, avg_p1, avg_p2):
    """Draw the average tiles per turn row for the statistics dialog."""
    label = ui_font.render("Tiles Per Turn:", True, BLACK)
    p1_text = ui_font.render(f"{avg_p1:.2f}", True, BLACK)
    p2_text = ui_font.render(f"{avg_p2:.2f}", True, BLACK)
    screen.blit(label, (dialog_x + STATS_LABEL_X_OFFSET, y_pos))
    screen.blit(p1_text, (dialog_x + STATS_P1_VAL_X_OFFSET, y_pos))
    screen.blit(p2_text, (dialog_x + STATS_P2_VAL_X_OFFSET, y_pos))



def draw_avg_leave_row(screen, dialog_x, y_pos, avg_p1, avg_p2):
    """Draw the average leave value row for the statistics dialog."""
    label = ui_font.render("Avg Leave:", True, BLACK)
    p1_text = ui_font.render(f"{avg_p1:.2f}", True, BLACK)
    p2_text = ui_font.render(f"{avg_p2:.2f}", True, BLACK)
    screen.blit(label, (dialog_x + STATS_LABEL_X_OFFSET, y_pos))
    screen.blit(p1_text, (dialog_x + STATS_P1_VAL_X_OFFSET, y_pos))
    screen.blit(p2_text, (dialog_x + STATS_P2_VAL_X_OFFSET, y_pos))



def draw_moves_row(screen, dialog_x, y_pos, moves_p1, moves_p2):
    """Draw the moves row for the statistics dialog."""
    moves_label = ui_font.render("Moves:", True, BLACK)
    p1_moves_text = ui_font.render(str(moves_p1), True, BLACK)
    p2_moves_text = ui_font.render(str(moves_p2), True, BLACK)
    screen.blit(moves_label, (dialog_x + STATS_LABEL_X_OFFSET, y_pos))
    screen.blit(p1_moves_text, (dialog_x + STATS_P1_VAL_X_OFFSET, y_pos))
    screen.blit(p2_moves_text, (dialog_x + STATS_P2_VAL_X_OFFSET, y_pos))


def draw_avg_score_row(screen, dialog_x, y_pos, avg_p1, avg_p2):
    """Draw the average score per move row for the statistics dialog."""
    avg_label = ui_font.render("Avg Score:", True, BLACK)
    p1_avg_text = ui_font.render(f"{avg_p1:.2f}", True, BLACK)
    p2_avg_text = ui_font.render(f"{avg_p2:.2f}", True, BLACK)
    screen.blit(avg_label, (dialog_x + STATS_LABEL_X_OFFSET, y_pos))
    screen.blit(p1_avg_text, (dialog_x + STATS_P1_VAL_X_OFFSET, y_pos))
    screen.blit(p2_avg_text, (dialog_x + STATS_P2_VAL_X_OFFSET, y_pos))


def draw_bingos_row(screen, dialog_x, y_pos, bingos_p1, bingos_p2):
    """Draw the bingos row for the statistics dialog."""
    bingos_label = ui_font.render("Bingos:", True, BLACK)
    p1_bingos_text = ui_font.render(str(bingos_p1), True, BLACK)
    p2_bingos_text = ui_font.render(str(bingos_p2), True, BLACK)
    screen.blit(bingos_label, (dialog_x + STATS_LABEL_X_OFFSET, y_pos))
    screen.blit(p1_bingos_text, (dialog_x + STATS_P1_VAL_X_OFFSET, y_pos))
    screen.blit(p2_bingos_text, (dialog_x + STATS_P2_VAL_X_OFFSET, y_pos))


def draw_bingo_avg_row(screen, dialog_x, y_pos, bingo_avg_p1, bingo_avg_p2, bingos_p1, bingos_p2):
    """Draw the average bingo score row."""
    bingo_avg_label = ui_font.render("Bingo Avg:", True, BLACK)
    p1_text = "N/A" if bingos_p1 == 0 else f"{bingo_avg_p1:.2f}"
    p2_text = "N/A" if bingos_p2 == 0 else f"{bingo_avg_p2:.2f}"
    p1_bingo_avg_text = ui_font.render(p1_text, True, BLACK)
    p2_bingo_avg_text = ui_font.render(p2_text, True, BLACK)
    screen.blit(bingo_avg_label, (dialog_x + STATS_LABEL_X_OFFSET, y_pos))
    screen.blit(p1_bingo_avg_text, (dialog_x + STATS_P1_VAL_X_OFFSET, y_pos))
    screen.blit(p2_bingo_avg_text, (dialog_x + STATS_P2_VAL_X_OFFSET, y_pos))


def calculate_blanks_per_player(move_history):
    """Calculate the number of blanks played by each player."""
    blanks_p1 = 0; blanks_p2 = 0
    for move in move_history:
        if move['move_type'] == 'place':
            player = move['player']
            blanks_count = len(move.get('blanks', set()))
            # --- CORRECTED INDENTATION START ---
            if player == 1:
                blanks_p1 += blanks_count
            elif player == 2:
                blanks_p2 += blanks_count
            # --- CORRECTED INDENTATION END ---
    return blanks_p1, blanks_p2

def draw_blanks_row(screen, dialog_x, y_pos, blanks_p1, blanks_p2):
    """Draw the blanks played row."""
    blanks_label = ui_font.render("Blanks:", True, BLACK)
    p1_blanks_text = ui_font.render(str(blanks_p1), True, BLACK)
    p2_blanks_text = ui_font.render(str(blanks_p2), True, BLACK)
    screen.blit(blanks_label, (dialog_x + STATS_LABEL_X_OFFSET, y_pos))
    screen.blit(p1_blanks_text, (dialog_x + STATS_P1_VAL_X_OFFSET, y_pos))
    screen.blit(p2_blanks_text, (dialog_x + STATS_P2_VAL_X_OFFSET, y_pos))



# Helper function (can be placed above draw_stats_dialog or inside if preferred)
def get_word_index(word, word_list):
    """Finds the 1-based index of a word in a list, case-insensitive."""
    try:
        # Convert both word and list items to uppercase for case-insensitive search
        return word_list.index(word.upper()) + 1
    except ValueError:
        return None # Word not found in the list



def draw_stats_dialog(dialog_x, dialog_y, player_names, final_scores, tiles, scroll_offset):
    """Draw the complete statistics dialog with scrolling, including quadrant counts."""
    # --- Fixed Dialog Dimensions ---
    stats_dialog_width = 480
    stats_dialog_height = 600 # Fixed height, content will scroll if needed

    # --- Load Word Lists (same as before) ---
    seven_letter_words = []
    eight_letter_words = []
    try:
        with open("7-letter-list.txt", "r") as f:
            seven_letter_words = [line.strip().upper() for line in f]
    except FileNotFoundError:
        print("Warning: 7-letter-list.txt not found for stats dialog.")
    try:
        with open("8-letter-list.txt", "r") as f:
            eight_letter_words = [line.strip().upper() for line in f]
    except FileNotFoundError:
        print("Warning: 8-letter-list.txt not found for stats dialog.")

    # --- Collect Bingo Data (same as before) ---
    p1_bingos_data = []
    p2_bingos_data = []
    for move in move_history:
        if move.get('is_bingo', False):
            player = move['player']
            word = move.get('word', 'N/A').upper() # Use uppercase for lookup
            score = move.get('score', 0)
            word_len = len(word)
            index = None
            if word_len == 7 and seven_letter_words:
                index = get_word_index(word, seven_letter_words)
            elif word_len == 8 and eight_letter_words:
                index = get_word_index(word, eight_letter_words)
            bingo_info = {'word': word, 'score': score, 'index': index, 'len': word_len}
            if player == 1: p1_bingos_data.append(bingo_info)
            elif player == 2: p2_bingos_data.append(bingo_info)

    # --- Calculate Quadrant Counts ---
    quad_counts = calculate_quadrant_counts(move_history) # Uses new logic

    # --- Calculate Content Dimensions ---
    padding = 10
    title_height = 30 # Approx height for title
    header_height = 40 # Player names header
    button_area_height = BUTTON_HEIGHT + padding * 2
    line_height = 25 # Height per stat/bingo line
    bingo_font = pygame.font.SysFont("Arial", 18) # Font for bingo lines

    # Calculate total height needed for ALL content
    fixed_stats_rows = 7 # Score, Moves, Avg Score, Tiles/Turn, Bingos Count, Bingo Avg, Blanks, Avg Leave
    quadrant_rows = 3 # Header + 2 rows for Q2/Q1 and Q3/Q4
    p1_bingo_lines = len(p1_bingos_data)
    p2_bingo_lines = len(p2_bingos_data)
    bingo_header_lines = 0
    if p1_bingo_lines > 0: bingo_header_lines += 1
    if p2_bingo_lines > 0: bingo_header_lines += 1

    total_content_height = (title_height + header_height +
                           (fixed_stats_rows * line_height) +
                           (quadrant_rows * line_height) + # Use updated quadrant row count
                           ((p1_bingo_lines + p2_bingo_lines + bingo_header_lines) * line_height) +
                           padding * 5) # Add some padding between sections

    # --- Create Content Surface ---
    content_surface_width = stats_dialog_width - padding * 2
    content_surface = pygame.Surface((content_surface_width, total_content_height))
    content_surface.fill(DIALOG_COLOR) # Fill with dialog background

    # --- Draw Content onto Surface ---
    y_on_surface = padding # Start drawing from top of surface

    # Title
    title_text = dialog_font.render("Game Statistics", True, BLACK)
    content_surface.blit(title_text, (padding, y_on_surface))
    y_on_surface += title_height + padding

    # Player Names Header
    p1_name_display = player_names[0] if player_names[0] else "Player 1"
    p2_name_display = player_names[1] if player_names[1] else "Player 2"
    p1_name_text = ui_font.render(p1_name_display, True, BLACK)
    p2_name_text = ui_font.render(p2_name_display, True, BLACK)
    # Adjust x-offsets relative to the content surface width
    p1_x_offset_on_surf = STATS_P1_VAL_X_OFFSET - STATS_LABEL_X_OFFSET # Relative offset
    p2_x_offset_on_surf = STATS_P2_VAL_X_OFFSET - STATS_LABEL_X_OFFSET # Relative offset
    content_surface.blit(p1_name_text, (p1_x_offset_on_surf, y_on_surface))
    content_surface.blit(p2_name_text, (p2_x_offset_on_surf, y_on_surface))
    y_on_surface += header_height # Approx height for this header row

    # Helper to draw stat rows onto the surface
    def draw_row_on_surface(label_text, val1_text, val2_text, y_pos):
        label_surf = ui_font.render(label_text, True, BLACK)
        val1_surf = ui_font.render(str(val1_text), True, BLACK)
        val2_surf = ui_font.render(str(val2_text), True, BLACK)
        content_surface.blit(label_surf, (padding, y_pos))
        content_surface.blit(val1_surf, (p1_x_offset_on_surf, y_pos))
        content_surface.blit(val2_surf, (p2_x_offset_on_surf, y_pos))

    # Helper to draw quadrant rows onto the surface
    def draw_quad_row(label1, val1, label2, val2, y_pos):
         text1 = f"{label1}: {val1}"
         text2 = f"{label2}: {val2}"
         surf1 = ui_font.render(text1, True, BLACK)
         surf2 = ui_font.render(text2, True, BLACK)
         # Position them side-by-side
         x_pos1 = padding + 10 # Indent slightly
         x_pos2 = padding + content_surface_width // 2
         content_surface.blit(surf1, (x_pos1, y_pos))
         content_surface.blit(surf2, (x_pos2, y_pos))

    # --- Draw Fixed Stats ---
    moves_p1, moves_p2 = calculate_moves_per_player(move_history)
    avg_p1 = final_scores[0] / moves_p1 if moves_p1 > 0 else 0.00
    avg_p2 = final_scores[1] / moves_p2 if moves_p2 > 0 else 0.00
    bingos_p1_count = len(p1_bingos_data)
    bingos_p2_count = len(p2_bingos_data)
    bingo_avg_p1, bingo_avg_p2 = calculate_bingo_avg_per_player(move_history)
    blanks_p1, blanks_p2 = calculate_blanks_per_player(move_history)
    tiles_per_turn_p1, tiles_per_turn_p2 = calculate_tiles_per_turn(move_history)
    avg_leave_p1, avg_leave_p2 = calculate_avg_leave(move_history)

    draw_row_on_surface("Score:", final_scores[0], final_scores[1], y_on_surface); y_on_surface += line_height
    draw_row_on_surface("Moves:", moves_p1, moves_p2, y_on_surface); y_on_surface += line_height
    draw_row_on_surface("Avg Score:", f"{avg_p1:.2f}", f"{avg_p2:.2f}", y_on_surface); y_on_surface += line_height
    draw_row_on_surface("Tiles Per Turn:", f"{tiles_per_turn_p1:.2f}", f"{tiles_per_turn_p2:.2f}", y_on_surface); y_on_surface += line_height
    draw_row_on_surface("Bingos:", bingos_p1_count, bingos_p2_count, y_on_surface); y_on_surface += line_height
    p1_bingo_avg_str = "N/A" if bingos_p1_count == 0 else f"{bingo_avg_p1:.2f}"
    p2_bingo_avg_str = "N/A" if bingos_p2_count == 0 else f"{bingo_avg_p2:.2f}"
    draw_row_on_surface("Bingo Avg:", p1_bingo_avg_str, p2_bingo_avg_str, y_on_surface); y_on_surface += line_height
    draw_row_on_surface("Blanks:", blanks_p1, blanks_p2, y_on_surface); y_on_surface += line_height
    draw_row_on_surface("Avg Leave:", f"{avg_leave_p1:.2f}", f"{avg_leave_p2:.2f}", y_on_surface); y_on_surface += line_height

    # --- Draw Quadrant Counts ---
    quad_header_surf = ui_font.render("Quadrant Tile Counts:", True, BLACK)
    content_surface.blit(quad_header_surf, (padding, y_on_surface)); y_on_surface += line_height
    # Draw Q2 (TL) and Q1 (TR)
    draw_quad_row("Q2 (TL)", quad_counts["Q2"], "Q1 (TR)", quad_counts["Q1"], y_on_surface); y_on_surface += line_height
    # Draw Q3 (BL) and Q4 (BR)
    draw_quad_row("Q3 (BL)", quad_counts["Q3"], "Q4 (BR)", quad_counts["Q4"], y_on_surface); y_on_surface += line_height

    # --- Draw Bingo Lists ---
    if p1_bingos_data:
        p1_bingo_header = ui_font.render(f"{p1_name_display} Bingos:", True, BLACK)
        content_surface.blit(p1_bingo_header, (padding, y_on_surface))
        y_on_surface += line_height
        for bingo in p1_bingos_data:
            word, score, index, length = bingo['word'], bingo['score'], bingo['index'], bingo['len']
            prob_text = ""
            if (length == 7 or length == 8) and index is not None: prob_text = f" Prob: {index}"
            elif length > 8: prob_text = ""
            else: prob_text = " (N/L)"
            bingo_line = f"  {word} ({score} pts){prob_text}"
            bingo_surf = bingo_font.render(bingo_line, True, BLACK)
            content_surface.blit(bingo_surf, (padding + 10, y_on_surface))
            y_on_surface += line_height

    if p2_bingos_data:
        p2_bingo_header = ui_font.render(f"{p2_name_display} Bingos:", True, BLACK)
        content_surface.blit(p2_bingo_header, (padding, y_on_surface))
        y_on_surface += line_height
        for bingo in p2_bingos_data:
            word, score, index, length = bingo['word'], bingo['score'], bingo['index'], bingo['len']
            prob_text = ""
            if (length == 7 or length == 8) and index is not None: prob_text = f" Prob: {index}"
            elif length > 8: prob_text = ""
            else: prob_text = " (N/L)"
            bingo_line = f"  {word} ({score} pts){prob_text}"
            bingo_surf = bingo_font.render(bingo_line, True, BLACK)
            content_surface.blit(bingo_surf, (padding + 10, y_on_surface))
            y_on_surface += line_height

    # --- Draw Dialog Background and Border on Main Screen ---
    pygame.draw.rect(screen, DIALOG_COLOR, (dialog_x, dialog_y, stats_dialog_width, stats_dialog_height))
    pygame.draw.rect(screen, BLACK, (dialog_x, dialog_y, stats_dialog_width, stats_dialog_height), 2)

    # --- Blit Visible Portion of Content Surface ---
    content_area_y = dialog_y + padding # Top of the scrollable area
    content_area_height = stats_dialog_height - padding * 2 - button_area_height # Height available for scrolling
    visible_area_on_surface = pygame.Rect(0, scroll_offset, content_surface_width, content_area_height)
    screen.blit(content_surface, (dialog_x + padding, content_area_y), visible_area_on_surface)

    # --- Draw OK Button ---
    ok_button_y = dialog_y + stats_dialog_height - button_area_height + padding
    ok_button_rect = pygame.Rect(dialog_x + stats_dialog_width - BUTTON_WIDTH - padding,
                                 ok_button_y,
                                 BUTTON_WIDTH, BUTTON_HEIGHT)
    hover = ok_button_rect.collidepoint(pygame.mouse.get_pos())
    color = BUTTON_HOVER if hover else BUTTON_COLOR
    pygame.draw.rect(screen, color, ok_button_rect)
    ok_text = button_font.render("OK", True, BLACK)
    ok_text_rect = ok_text.get_rect(center=ok_button_rect.center)
    screen.blit(ok_text, ok_text_rect)

    # Return the OK button rect and the total content height for scroll calculation
    return ok_button_rect, total_content_height


def calculate_quadrant_counts(move_history):
    """
    Calculates the number of tiles played in each quadrant (inclusive counting).
    Q1=TopRight, Q2=TopLeft, Q3=BottomLeft, Q4=BottomRight.
    Center tile (7,7) is ignored. Tiles on center row/col are counted in adjacent quadrants.
    """
    counts = {"Q1": 0, "Q2": 0, "Q3": 0, "Q4": 0}
    center_r, center_c = 7, 7

    for move in move_history:
        if move['move_type'] == 'place':
            new_tiles = move.get('newly_placed', move.get('positions', []))
            for r, c, _ in new_tiles:
                if r == center_r and c == center_c:
                    continue # Ignore exact center

                # Check membership for each quadrant inclusively
                is_q1 = (r <= center_r and c >= center_c)
                is_q2 = (r <= center_r and c <= center_c)
                is_q3 = (r >= center_r and c <= center_c)
                is_q4 = (r >= center_r and c >= center_c)

                if is_q1: counts["Q1"] += 1
                if is_q2: counts["Q2"] += 1
                if is_q3: counts["Q3"] += 1
                if is_q4: counts["Q4"] += 1
    return counts



def show_message_dialog(message, title="Message"):
    """
    Display a general message dialog with an OK button, wrapping text
    and dynamically adjusting height.
    """
    # --- MODIFICATION START: Dynamic Height Calculation ---
    base_dialog_width = 400
    min_dialog_height = 150 # Minimum height
    padding = 10 # Padding around elements
    line_spacing = 5 # Extra space between lines
    button_area_height = BUTTON_HEIGHT + padding * 2 # Space for OK button

    # 1. Wrap text first to determine needed lines
    words = message.split(' ')
    lines = []
    current_line = ''
    # Use a slightly reduced width for text wrapping calculation to avoid edge cases
    max_line_width = base_dialog_width - padding * 2 - 10

    for word in words:
        # Handle newline characters explicitly
        if '\n' in word:
            parts = word.split('\n')
            for i, part in enumerate(parts):
                if not part: # Handle consecutive newlines or newline at start/end
                    if current_line: # Add previous line if any
                         lines.append(current_line.strip())
                    lines.append("") # Add empty line for the newline itself
                    current_line = ""
                    continue

                test_line = current_line + part + ' '
                if ui_font.size(test_line)[0] < max_line_width:
                    current_line = test_line
                else:
                    if current_line: # Add the line before the current part
                        lines.append(current_line.strip())
                    # Start new line with the current part, handle if it's too long itself
                    if ui_font.size(part + ' ')[0] < max_line_width:
                         current_line = part + ' '
                    else: # Word itself is too long, just put it on its own line (will overflow visually)
                         lines.append(part)
                         current_line = "" # Start fresh after the long word

                # Add empty line if this part was followed by a newline (except for the last part)
                if i < len(parts) - 1:
                     if current_line: # Add the line formed by the part first
                          lines.append(current_line.strip())
                     lines.append("") # Add the blank line for the newline
                     current_line = ""

        else: # Word does not contain newline
            test_line = current_line + word + ' '
            if ui_font.size(test_line)[0] < max_line_width:
                current_line = test_line
            else:
                if current_line: # Add previous line if any
                    lines.append(current_line.strip())
                # Start new line with the current word, handle if it's too long itself
                if ui_font.size(word + ' ')[0] < max_line_width:
                     current_line = word + ' '
                else: # Word itself is too long
                     lines.append(word)
                     current_line = ""

    if current_line: # Add the last line
        lines.append(current_line.strip())

    # 2. Calculate required height
    title_height = dialog_font.get_linesize()
    text_height = len(lines) * ui_font.get_linesize() + max(0, len(lines) - 1) * line_spacing
    required_height = title_height + text_height + button_area_height + padding * 3 # Title + Text + Button Area + Paddings

    dialog_height = max(min_dialog_height, required_height)
    dialog_width = base_dialog_width # Keep width fixed for now

    # 3. Calculate dialog position
    dialog_x = (WINDOW_WIDTH - dialog_width) // 2
    dialog_y = (WINDOW_HEIGHT - dialog_height) // 2
    # --- MODIFICATION END ---

    # Drawing uses calculated dimensions
    pygame.draw.rect(screen, DIALOG_COLOR, (dialog_x, dialog_y, dialog_width, dialog_height))
    pygame.draw.rect(screen, BLACK, (dialog_x, dialog_y, dialog_width, dialog_height), 2)

    title_surf = dialog_font.render(title, True, BLACK)
    screen.blit(title_surf, (dialog_x + padding, dialog_y + padding))

    # Draw the wrapped text lines
    y_offset = dialog_y + padding + title_height + padding # Start below title
    for line in lines:
        text = ui_font.render(line, True, BLACK)
        screen.blit(text, (dialog_x + padding, y_offset))
        y_offset += ui_font.get_linesize() + line_spacing

    # OK Button position adjusted to new height
    ok_button_rect = pygame.Rect(dialog_x + dialog_width - BUTTON_WIDTH - padding,
                                 dialog_y + dialog_height - BUTTON_HEIGHT - padding,
                                 BUTTON_WIDTH, BUTTON_HEIGHT)

    hover = ok_button_rect.collidepoint(pygame.mouse.get_pos())
    color = BUTTON_HOVER if hover else BUTTON_COLOR
    pygame.draw.rect(screen, color, ok_button_rect)
    ok_text = button_font.render("OK", True, BLACK)
    ok_text_rect = ok_text.get_rect(center=ok_button_rect.center)
    screen.blit(ok_text, ok_text_rect)

    pygame.display.flip() # Update display to show the dialog immediately

    # Event loop for the dialog
    dialog_running = True
    while dialog_running:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()
            elif event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
                 if ok_button_rect.collidepoint(event.pos):
                     dialog_running = False # Exit dialog loop
                     return # Return control to the main loop
            elif event.type == pygame.KEYDOWN:
                 if event.key == pygame.K_RETURN or event.key == pygame.K_KP_ENTER:
                     dialog_running = False # Exit dialog loop
                     return # Return control to the main loop

        # Keep drawing the dialog while waiting for input
        # (Redrawing everything might be overkill, but ensures it stays visible if covered/revealed)
        # Alternatively, just flip without redrawing if performance is an issue.
        pygame.draw.rect(screen, DIALOG_COLOR, (dialog_x, dialog_y, dialog_width, dialog_height))
        pygame.draw.rect(screen, BLACK, (dialog_x, dialog_y, dialog_width, dialog_height), 2)
        screen.blit(title_surf, (dialog_x + padding, dialog_y + padding))
        y_offset = dialog_y + padding + title_height + padding
        for line in lines:
            text = ui_font.render(line, True, BLACK)
            screen.blit(text, (dialog_x + padding, y_offset))
            y_offset += ui_font.get_linesize() + line_spacing
        hover = ok_button_rect.collidepoint(pygame.mouse.get_pos())
        color = BUTTON_HOVER if hover else BUTTON_COLOR
        pygame.draw.rect(screen, color, ok_button_rect)
        screen.blit(ok_text, ok_text_rect)
        pygame.display.flip()
        pygame.time.Clock().tick(30) # Limit frame rate in dialog loop


def draw_practice_end_dialog(message):
    """
    Draw the dialog shown at the end of a practice puzzle,
    dynamically adjusting height based on the message content.
    """
    # --- MODIFICATION START: Dynamic Height Calculation ---
    base_dialog_width = 400
    min_dialog_height = 180 # Keep original minimum height
    padding = 15 # Padding around elements
    line_spacing = 5 # Extra space between lines
    button_area_height = BUTTON_HEIGHT + padding * 2 # Space for buttons + padding

    # 1. Wrap text first to determine needed lines
    words = message.split(' ')
    lines = []
    current_line = ''
    # Use a slightly reduced width for text wrapping calculation
    max_line_width = base_dialog_width - padding * 2 - 10

    for word in words:
        # Handle newline characters explicitly
        if '\n' in word:
            parts = word.split('\n')
            for i, part in enumerate(parts):
                if not part:
                    if current_line: lines.append(current_line.strip())
                    lines.append("")
                    current_line = ""
                    continue
                test_line = current_line + part + ' '
                if ui_font.size(test_line)[0] < max_line_width:
                    current_line = test_line
                else:
                    if current_line: lines.append(current_line.strip())
                    if ui_font.size(part + ' ')[0] < max_line_width:
                         current_line = part + ' '
                    else:
                         lines.append(part)
                         current_line = ""
                if i < len(parts) - 1:
                     if current_line: lines.append(current_line.strip())
                     lines.append("")
                     current_line = ""
        else: # Word does not contain newline
            test_line = current_line + word + ' '
            if ui_font.size(test_line)[0] < max_line_width:
                current_line = test_line
            else:
                if current_line: lines.append(current_line.strip())
                if ui_font.size(word + ' ')[0] < max_line_width:
                     current_line = word + ' '
                else:
                     lines.append(word)
                     current_line = ""
    if current_line: # Add the last line
        lines.append(current_line.strip())

    # 2. Calculate required height
    # No explicit title, start text height calculation directly
    text_height = len(lines) * ui_font.get_linesize() + max(0, len(lines) - 1) * line_spacing
    required_height = text_height + button_area_height + padding * 2 # Text + Button Area + Top/Bottom Padding

    dialog_height = max(min_dialog_height, required_height)
    dialog_width = base_dialog_width # Keep width fixed

    # 3. Calculate dialog position
    dialog_x = (WINDOW_WIDTH - dialog_width) // 2
    dialog_y = (WINDOW_HEIGHT - dialog_height) // 2
    # --- MODIFICATION END ---

    # Drawing uses calculated dimensions
    pygame.draw.rect(screen, DIALOG_COLOR, (dialog_x, dialog_y, dialog_width, dialog_height))
    pygame.draw.rect(screen, BLACK, (dialog_x, dialog_y, dialog_width, dialog_height), 2)

    # Draw the wrapped text lines starting near the top
    y_offset = dialog_y + padding
    for line in lines:
        text_surf = ui_font.render(line, True, BLACK)
        # Center text horizontally within the padded area
        text_rect = text_surf.get_rect(centerx=dialog_x + dialog_width // 2)
        text_rect.top = y_offset # Align top
        screen.blit(text_surf, text_rect)
        # screen.blit(text_surf, (dialog_x + padding, y_offset)) # Original left-align
        y_offset += ui_font.get_linesize() + line_spacing

    # Buttons positioned relative to the new dynamic bottom
    button_y = dialog_y + dialog_height - BUTTON_HEIGHT - padding
    total_button_width = 3 * BUTTON_WIDTH + 2 * BUTTON_GAP
    button_start_x = dialog_x + (dialog_width - total_button_width) // 2

    play_again_rect = pygame.Rect(button_start_x, button_y, BUTTON_WIDTH, BUTTON_HEIGHT)
    main_menu_rect = pygame.Rect(button_start_x + BUTTON_WIDTH + BUTTON_GAP, button_y, BUTTON_WIDTH, BUTTON_HEIGHT)
    quit_rect = pygame.Rect(button_start_x + 2 * (BUTTON_WIDTH + BUTTON_GAP), button_y, BUTTON_WIDTH, BUTTON_HEIGHT)

    # Draw buttons
    pygame.draw.rect(screen, BUTTON_COLOR, play_again_rect)
    pygame.draw.rect(screen, BUTTON_COLOR, main_menu_rect)
    pygame.draw.rect(screen, BUTTON_COLOR, quit_rect)

    play_again_text = button_font.render("Play Again", True, BLACK)
    main_menu_text = button_font.render("Main Menu", True, BLACK)
    quit_text = button_font.render("Quit", True, BLACK)

    screen.blit(play_again_text, play_again_text.get_rect(center=play_again_rect.center))
    screen.blit(main_menu_text, main_menu_text.get_rect(center=main_menu_rect.center))
    screen.blit(quit_text, quit_text.get_rect(center=quit_rect.center))

    return play_again_rect, main_menu_rect, quit_rect



# End of Part 3

# Part 4 (Includes game logic helpers: get_words_played, remaining tiles, validation, anchors)
# get_words_played, get_remaining_tiles, draw_remaining_tiles, draw_arrow, is_valid_play, get_anchor_points (Unchanged from Part 4 provided previously)
def get_words_played(word_positions, tiles):
    """Get all word strings formed by a play based on tile positions."""
    if not word_positions: return []
    words_found = set(); rows_involved_list = []; cols_involved_list = []; valid_positions = True
    for item in word_positions:
        if isinstance(item, tuple) and len(item) >= 3: rows_involved_list.append(item[0]); cols_involved_list.append(item[1])
        else: print(f"Error in get_words_played: Invalid item format: {item}"); valid_positions = False; break
    if not valid_positions: return []
    rows_involved = set(rows_involved_list); cols_involved = set(cols_involved_list)
    if len(rows_involved) == 1: # Horizontal Check
        r = rows_involved.pop(); min_c = min(cols_involved_list); max_c = max(cols_involved_list)
        while min_c > 0 and tiles[r][min_c - 1]: min_c -= 1
        while max_c < GRID_SIZE - 1 and tiles[r][max_c + 1]: max_c += 1
        word_h = "".join(tiles[r][c] for c in range(min_c, max_c + 1) if tiles[r][c])
        if len(word_h) > 1: words_found.add(word_h)
    if len(cols_involved) == 1: # Vertical Check
        c = cols_involved.pop(); min_r = min(rows_involved_list); max_r = max(rows_involved_list)
        while min_r > 0 and tiles[min_r - 1][c]: min_r -= 1
        while max_r < GRID_SIZE - 1 and tiles[max_r + 1][c]: max_r += 1
        word_v = "".join(tiles[r][c] for r in range(min_r, max_r + 1) if tiles[r][c])
        if len(word_v) > 1: words_found.add(word_v)
    for r_new, c_new, _ in word_positions: # Cross Checks
        if len(rows_involved) == 1: # Vertical Cross
            min_r_cross = r_new; max_r_cross = r_new;
            while min_r_cross > 0 and tiles[min_r_cross - 1][c_new]: min_r_cross -= 1;
            while max_r_cross < GRID_SIZE - 1 and tiles[max_r_cross + 1][c_new]: max_r_cross += 1
            if max_r_cross > min_r_cross: cross_word_v = "".join(tiles[r][c_new] for r in range(min_r_cross, max_r_cross + 1) if tiles[r][c_new]);
            if len(cross_word_v) > 1: words_found.add(cross_word_v)
        if len(cols_involved) == 1: # Horizontal Cross
            min_c_cross = c_new; max_c_cross = c_new;
            while min_c_cross > 0 and tiles[r_new][min_c_cross - 1]: min_c_cross -= 1;
            while max_c_cross < GRID_SIZE - 1 and tiles[r_new][max_c_cross + 1]: max_c_cross += 1
            if max_c_cross > min_c_cross: cross_word_h = "".join(tiles[r_new][c] for c in range(min_c_cross, max_c_cross + 1) if tiles[r_new][c]);
            if len(cross_word_h) > 1: words_found.add(cross_word_h)
    return list(words_found)

def get_remaining_tiles(rack, tiles, blanks):
    """Calculate the remaining tiles (excluding those on board and current player's rack)."""
    remaining = {letter: count for letter, (count, _) in TILE_DISTRIBUTION.items()}
    rack_counter = Counter(rack)
    for tile, count in rack_counter.items():
        if tile in remaining: remaining[tile] -= count
    for r in range(GRID_SIZE):
        for c in range(GRID_SIZE):
            if tiles[r][c]:
                if (r, c) in blanks:
                    if ' ' in remaining: remaining[' '] -= 1
                else:
                    letter = tiles[r][c]
                    if letter in remaining: remaining[letter] -= 1
    for letter in remaining: remaining[letter] = max(0, remaining[letter])
    return remaining

def draw_remaining_tiles(remaining, turn):
    """Draw the list of remaining tiles."""
    global practice_mode
    if practice_mode == "eight_letter": return # Don't draw remaining tiles in this mode
    remaining_x = min(BOARD_SIZE + 70, WINDOW_WIDTH - 200);
    if remaining_x < BOARD_SIZE + 10: remaining_x = BOARD_SIZE + 10
    title_text = ui_font.render(f"P{turn}'s Unseen Tiles:", True, BLACK); screen.blit(title_text, (remaining_x, 10))
    y_pos = 40; col_width = 60; max_y = WINDOW_HEIGHT - 100; sorted_letters = sorted(remaining.keys()); current_col_x = remaining_x; items_in_col = 0; max_items_per_col = (max_y - y_pos) // 20
    if max_items_per_col <= 0: max_items_per_col = 1
    last_drawn_y = 40 # Initialize with starting y_pos in case list is empty
    last_drawn_col_x = remaining_x # Track the column x of the last item

    for letter in sorted_letters:
        count = remaining.get(letter, 0)
        if count > 0:
            display_letter = "?" if letter == " " else letter; text_str = f"{display_letter}: {count}"; text = tile_count_font.render(text_str, True, BLACK)
            if items_in_col >= max_items_per_col:
                y_pos = 40 # Reset y_pos for the new column
                current_col_x += col_width
                items_in_col = 0
            screen.blit(text, (current_col_x, y_pos))
            last_drawn_y = y_pos # Update the last drawn y position in the current column
            last_drawn_col_x = current_col_x # Update the column x
            y_pos += 20; items_in_col += 1

    # Calculate summary position directly below the last drawn item's position
    # Add the height of one line (20) to get the position below it, plus a small gap (e.g., 5)
    summary_y_start = last_drawn_y + 20 + 5
    # Ensure it doesn't go off screen
    summary_y_start = min(summary_y_start, max_y + 40) # Use max_y for clamping

    total_tiles = sum(remaining.values()); vowels = sum(remaining.get(letter, 0) for letter in 'AEIOU'); consonants = sum(remaining.get(letter, 0) for letter in remaining if letter.isalpha() and letter not in 'AEIOU '); blanks_rem = remaining.get(' ', 0)
    text1 = tile_count_font.render(f"Tiles remaining: {total_tiles}", True, BLACK); text2 = tile_count_font.render(f"V: {vowels}  C: {consonants}  B: {blanks_rem}", True, BLACK)

    # Align summary text x-coordinate with the start of the list columns
    summary_x = remaining_x
    screen.blit(text1, (summary_x, summary_y_start));
    screen.blit(text2, (summary_x, summary_y_start + 20)) # Draw second line below first




def draw_arrow(row, col, direction):
    """Draw an arrow indicating play direction."""
    center_x = 40 + col * SQUARE_SIZE + SQUARE_SIZE // 2; center_y = 40 + row * SQUARE_SIZE + SQUARE_SIZE // 2; arrow_length = SQUARE_SIZE * 0.4; arrow_width = SQUARE_SIZE * 0.2
    if direction == "right": pygame.draw.line(screen, ARROW_COLOR, (center_x - arrow_length / 2, center_y), (center_x + arrow_length / 2, center_y), 3); pygame.draw.polygon(screen, ARROW_COLOR, [(center_x + arrow_length / 2, center_y - arrow_width / 2), (center_x + arrow_length / 2, center_y + arrow_width / 2), (center_x + arrow_length / 2 + arrow_width, center_y)])
    elif direction == "down": pygame.draw.line(screen, ARROW_COLOR, (center_x, center_y - arrow_length / 2), (center_x, center_y + arrow_length / 2), 3); pygame.draw.polygon(screen, ARROW_COLOR, [(center_x - arrow_width / 2, center_y + arrow_length / 2), (center_x + arrow_width / 2, center_y + arrow_length / 2), (center_x, center_y + arrow_length / 2 + arrow_width)])

# Function to modify: is_valid_play()

def is_valid_play(word_positions, tiles, is_first_play, initial_rack_size, original_tiles, rack):
    """Validate a potential play against game rules and dictionary."""
    # word_positions here is the list of newly placed tiles: [(r, c, letter), ...]
    if not word_positions:
        # Removed Debug Print
        return False, False

    newly_placed_positions_coords = set((r, c) for r, c, _ in word_positions)
    if not newly_placed_positions_coords:
        # Removed Debug Print
        return False, False # No new tiles placed

    # --- Alignment and Gap Checks (remain the same) ---
    rows = sorted(list(set(r for r, _, _ in word_positions))); cols = sorted(list(set(c for _, c, _ in word_positions)))
    is_horizontal = len(rows) == 1; is_vertical = len(cols) == 1
    if not (is_horizontal or is_vertical):
        # Removed Debug Print
        return False, False # Not aligned

    # Check for gaps within the main line of play
    if is_horizontal:
        r = rows[0]; min_col = min(cols); max_col = max(cols)
        # Extend bounds to include adjacent existing tiles
        temp_min_col = min_col; temp_max_col = max_col
        while temp_min_col > 0 and tiles[r][temp_min_col - 1]: temp_min_col -= 1
        while temp_max_col < GRID_SIZE - 1 and tiles[r][temp_max_col + 1]: temp_max_col += 1
        # Check for empty squares within these bounds
        for c in range(temp_min_col, temp_max_col + 1):
            if not tiles[r][c]:
                # Removed Debug Print
                return False, False # Gap found
    elif is_vertical:
        c = cols[0]; min_row = min(rows); max_row = max(rows)
        # Extend bounds
        temp_min_row = min_row; temp_max_row = max_row
        while temp_min_row > 0 and tiles[temp_min_row - 1][c]: temp_min_row -= 1
        while temp_max_row < GRID_SIZE - 1 and tiles[temp_max_row + 1][c]: temp_max_row += 1
        # Check for gaps
        for r in range(temp_min_row, temp_max_row + 1):
            if not tiles[r][c]:
                # Removed Debug Print
                return False, False # Gap found

    # --- Word Validity Check (Use find_all_words_formed) ---
    # Use the more robust function to find all words based on the newly placed tiles
    # It correctly handles single-tile placements forming cross-words.
    all_words_details = find_all_words_formed(word_positions, tiles)

    if not all_words_details:
         # This might happen if only a single letter was placed and it didn't connect
         # to form any word of length 2+ (already checked by connection rule below)
         # Or if find_all_words_formed has a bug.
         # Let's assume connection rule handles the first case.
         # If this triggers otherwise, it indicates an issue.
         # Removed Debug Print
         pass # Continue to connection check

    formed_word_strings = ["".join(tile[2] for tile in word_detail) for word_detail in all_words_details]

    if not formed_word_strings and len(word_positions) > 1: # If multiple tiles placed but no words formed -> invalid
         # Removed Debug Print
         return False, False

    # Check each formed word string against the DAWG
    for word in formed_word_strings:
        if not DAWG.search(word):
            # Removed Debug Print
            return False, False # Word not in dictionary

    # --- Connection Rules Check (remain the same) ---
    if is_first_play:
        if CENTER_SQUARE not in newly_placed_positions_coords:
            # Removed Debug Print
            return False, False
    else:
        connects = False
        for r, c in newly_placed_positions_coords:
            for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < GRID_SIZE and 0 <= nc < GRID_SIZE and original_tiles[nr][nc]:
                    connects = True; break
            if connects: break
        if not connects:
            # Removed Debug Print
            return False, False

    # --- Bingo Check (remains the same) ---
    tiles_played_from_rack = len(newly_placed_positions_coords)
    is_bingo = (initial_rack_size == 7 and tiles_played_from_rack == 7)

    # If all checks passed
    return True, is_bingo



def get_anchor_points(tiles, is_first_play):
    """Get anchor points (empty squares adjacent to existing tiles) for valid moves."""
    anchors = set()
    if is_first_play: anchors.add(CENTER_SQUARE); return anchors
    has_tiles = False
    for r in range(GRID_SIZE):
        for c in range(GRID_SIZE):
            if tiles[r][c]: has_tiles = True # Check if board has any tiles
            if not tiles[r][c]: # Must be an empty square
                 is_anchor = False
                 for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
                     nr, nc = r + dr, c + dc
                     if 0 <= nr < GRID_SIZE and 0 <= nc < GRID_SIZE and tiles[nr][nc]: is_anchor = True; break
                 if is_anchor: anchors.add((r, c))
    if not has_tiles and not is_first_play: anchors.add(CENTER_SQUARE) # Fallback if board empty but not first play
    return anchors

# End of Part 4

# python
# MODIFIED: 01APR24 - Implementing 8-Letter Bingo Practice Mode Fixes (Part 5 - Corrected Attribute Name)

# Part 5

# --- NEW Move Generation (Based on kamilmielnik/scrabble-solver principles) ---
# --- NEW Move Generation (Based on kamilmielnik/scrabble-solver principles - REVISED) ---

# --- GADDAG-Based Move Generation (Replaces generate_valid_moves_new) ---

# --- GADDAG-Based Move Generation (Replaces generate_valid_moves_new and its helpers) ---

# --- GADDAG-Based Move Generation (Replaces generate_valid_moves_new and its helpers) ---

# --- GADDAG-Based Move Generation (Replaces generate_valid_moves_new and its helpers) ---

# Function to Modify: _gaddag_traverse (Refined post-separator logic)

def _gaddag_traverse(
    anchor_pos, rack_counts, tiles, board, blanks, cross_check_sets, gaddag_node,
    current_word_tiles, is_reversed, current_axis, all_found_moves, unique_move_signatures,
    original_tiles_state, is_first_play, full_rack_size, max_len=GRID_SIZE,
    depth=0
):
    """ Recursive helper with refined post-separator logic """
    # Limit recursion depth for safety and logging
    if depth > 20: return

    # --- Base Cases and Pruning ---
    if not current_word_tiles: return
    if len(current_word_tiles) > max_len: return

    # Get the last tile added for step calculation (but might need anchor later)
    r_last, c_last, _, _, _ = current_word_tiles[-1]

    # --- Check if current path forms a valid move ---
    # (Validation logic remains the same as previous version with diagnostic prints)
    if gaddag_node.is_terminal and not is_reversed:
        # ... (validation code identical to previous response) ...
        # Find newly placed tiles
        newly_placed_list_details = [(r, c, l) for r, c, l, _, is_new in current_word_tiles if is_new]
        if newly_placed_list_details:
            new_tiles_sig = tuple(sorted(newly_placed_list_details))
            if new_tiles_sig not in unique_move_signatures:
                # Simulate placement for validation
                temp_tiles = [row[:] for row in original_tiles_state]
                temp_blanks = set(blanks); move_blanks_coords = set(); newly_placed_coords = set()
                for r, c, letter, is_blank, is_new in current_word_tiles:
                    if is_new:
                        if 0 <= r < GRID_SIZE and 0 <= c < GRID_SIZE:
                            temp_tiles[r][c] = letter; newly_placed_coords.add((r, c))
                            if is_blank: temp_blanks.add((r, c)); move_blanks_coords.add((r, c))

                # Use the ORIGINAL is_valid_play now (remove diagnostic version)
                is_valid, is_bingo = is_valid_play(newly_placed_list_details, temp_tiles, is_first_play, full_rack_size, original_tiles_state, rack_counts) # Pass original_tiles_state

                if is_valid:
                    unique_move_signatures.add(new_tiles_sig) # Mark as found
                    score = calculate_score(newly_placed_list_details, board, temp_tiles, temp_blanks)
                    all_words_formed_details = find_all_words_formed(newly_placed_list_details, temp_tiles)
                    # ... (rest of move detail extraction identical to previous response) ...
                    primary_word_tiles = []; primary_word_str = ""; start_pos = (0, 0); orientation = current_axis
                    if all_words_formed_details:
                        # ... (primary word finding logic) ...
                         found_primary = False
                         for word_detail in all_words_formed_details:
                             is_along_axis = False
                             if orientation == 'H' and len(set(r for r,c,l in word_detail)) == 1: is_along_axis = True
                             elif orientation == 'V' and len(set(c for r,c,l in word_detail)) == 1: is_along_axis = True
                             if is_along_axis and any((t[0], t[1]) in newly_placed_coords for t in word_detail):
                                 primary_word_tiles = word_detail; found_primary = True; break
                         if not found_primary: # Fallback
                              for word_detail in all_words_formed_details:
                                  if any((t[0], t[1]) in newly_placed_coords for t in word_detail):
                                       primary_word_tiles = word_detail
                                       if len(set(r for r,c,l in primary_word_tiles)) == 1: orientation = 'H'
                                       elif len(set(c for r,c,l in primary_word_tiles)) == 1: orientation = 'V'
                                       break
                         if not primary_word_tiles and all_words_formed_details: # Extreme fallback
                              primary_word_tiles = all_words_formed_details[0]
                              if len(set(r for r,c,l in primary_word_tiles)) == 1: orientation = 'H'
                              elif len(set(c for r,c,l in primary_word_tiles)) == 1: orientation = 'V'

                         if primary_word_tiles: # Check added
                             primary_word_str = "".join(t[2] for t in primary_word_tiles)
                             start_pos = (primary_word_tiles[0][0], primary_word_tiles[0][1])
                    # ... (word_with_blanks formatting) ...
                    word_with_blanks_list = []
                    for wr, wc, w_letter in primary_word_tiles:
                        is_blank_in_word = (wr, wc) in newly_placed_coords and (wr, wc) in move_blanks_coords
                        word_with_blanks_list.append(w_letter.lower() if is_blank_in_word else w_letter.upper())
                    word_with_blanks = "".join(word_with_blanks_list)
                    leave = list(rack_counts.elements()) # Current rack count is the leave
                    # ... (store move details) ...
                    move_details_dict = {
                        'positions': [(t[0], t[1], t[2]) for t in primary_word_tiles], 'blanks': move_blanks_coords,
                        'word': primary_word_str, 'score': score, 'start': start_pos, 'direction': orientation,
                        'leave': leave, 'is_bingo': is_bingo, 'word_with_blanks': word_with_blanks,
                        'newly_placed': newly_placed_list_details
                    }
                    all_found_moves.append(move_details_dict)


    # --- Explore Next Steps ---
    for letter, next_node in gaddag_node.children.items():
        if letter == Gaddag.SEPARATOR:
            if is_reversed:
                # When crossing the separator, the *anchor position* becomes the reference
                # for the next step calculation in the forward direction.
                # We pass the anchor_pos implicitly; the logic needs to use it.
                # We pass current_word_tiles as is, because it contains the history.
                _gaddag_traverse(
                    anchor_pos, rack_counts, tiles, board, blanks, cross_check_sets,
                    next_node, current_word_tiles, False, current_axis, # Switch is_reversed
                    all_found_moves, unique_move_signatures, original_tiles_state,
                    is_first_play, full_rack_size, max_len, depth + 1
                )
            continue # Move to next child

        # Determine next coordinates
        next_r, next_c = -1, -1
        if is_reversed:
             # Moving backward from the last placed tile (r_last, c_last)
            if current_axis == 'H': next_r, next_c = r_last, c_last - 1 # Left
            else:                   next_r, next_c = r_last - 1, c_last # Up
        else: # Moving forward
            # **** CORRECTED LOGIC ****
            # If current_word_tiles only contains the anchor tile (or tiles placed *before* it),
            # the first step *forward* must be relative to the anchor_pos.
            # Otherwise, step forward from the last placed tile (r_last, c_last).

            # Check if the anchor position is the last element added *or* if all tiles were placed before anchor
            # A simple check: is the anchor position the first tile in our list (and maybe the only one)?
            # A better check: find the tile actually placed *on* the anchor square.
            anchor_r, anchor_c = anchor_pos
            tile_on_anchor = None
            for t_r, t_c, t_l, t_b, t_n in current_word_tiles:
                 if t_r == anchor_r and t_c == anchor_c:
                      tile_on_anchor = (t_r, t_c)
                      break

            # If we haven't placed anything *after* the anchor yet, step from the anchor
            # This happens immediately after crossing the separator.
            # How to detect this? If the last tile added IS the tile_on_anchor
            # or if all tiles were added when is_reversed was True?
            # Let's use the anchor_pos directly as the reference point
            # for the first step in the forward direction.

            # Heuristic: If the last tile's coordinates are the same as the anchor,
            # then the next step must be the first step *away* from the anchor.
            # What if multiple tiles were placed reversed? The last tile isn't the anchor.
            # --> Need a robust way to know if we are taking the *first* step forward.

            # Let's track if we JUST crossed the separator. A simple way is if the last tile
            # added was before or at the anchor point based on axis and anchor coords.
            just_crossed_separator = False
            if len(current_word_tiles) > 0:
                if current_axis == 'H':
                    if c_last <= anchor_c: just_crossed_separator = True
                else: # Vertical
                    if r_last <= anchor_r: just_crossed_separator = True

            # Use anchor as reference ONLY if we just crossed separator, otherwise use last tile
            ref_r, ref_c = (anchor_r, anchor_c) if just_crossed_separator else (r_last, c_last)

            if current_axis == 'H': next_r, next_c = ref_r, ref_c + 1 # Move right
            else:                   next_r, next_c = ref_r + 1, ref_c # Move down
            # **** END CORRECTED LOGIC ****


        # Bounds check
        if not (0 <= next_r < GRID_SIZE and 0 <= next_c < GRID_SIZE): continue

        next_pos = (next_r, next_c)
        existing_tile = tiles[next_r][next_c]

        # Case 1: Square is empty
        # (Rest of logic for placing rack/blank or using existing tile remains the same)
        if not existing_tile:
            cross_axis = 'V' if current_axis == 'H' else 'H'
            allowed_letters = cross_check_sets.get(next_pos, {}).get(cross_axis, set())
            # Option 1a: Use regular tile
            if rack_counts[letter] > 0 and letter in allowed_letters:
                new_rack_counts = rack_counts.copy(); new_rack_counts[letter] -= 1
                if new_rack_counts[letter] == 0: del new_rack_counts[letter]
                _gaddag_traverse(
                    anchor_pos, new_rack_counts, tiles, board, blanks, cross_check_sets,
                    next_node, current_word_tiles + [(next_r, next_c, letter, False, True)],
                    is_reversed, current_axis, all_found_moves, unique_move_signatures,
                    original_tiles_state, is_first_play, full_rack_size, max_len, depth + 1
                )
            # Option 1b: Use blank tile
            if rack_counts[' '] > 0 and ' ' in allowed_letters:
                new_rack_counts = rack_counts.copy(); new_rack_counts[' '] -= 1
                if new_rack_counts[' '] == 0: del new_rack_counts[' ']
                _gaddag_traverse(
                    anchor_pos, new_rack_counts, tiles, board, blanks, cross_check_sets,
                    next_node, current_word_tiles + [(next_r, next_c, letter, True, True)],
                    is_reversed, current_axis, all_found_moves, unique_move_signatures,
                    original_tiles_state, is_first_play, full_rack_size, max_len, depth + 1
                )
        # Case 2: Square has matching existing tile
        elif existing_tile == letter:
            _gaddag_traverse(
                anchor_pos, rack_counts, tiles, board, blanks, cross_check_sets,
                next_node, current_word_tiles + [(next_r, next_c, letter, False, False)],
                is_reversed, current_axis, all_found_moves, unique_move_signatures,
                original_tiles_state, is_first_play, full_rack_size, max_len, depth + 1
            )

# Function to Replace: generate_all_moves_gaddag
# REASON: Includes corrected initiation logic for Strategy 2 (essential for general cases)
#         and reviewed logic for Strategy 1 (intended to handle first play).

def generate_all_moves_gaddag(rack, tiles, board, blanks, gaddag_root):
    """
    Generates ALL valid Scrabble moves using GADDAG traversal.
    Initiates the traversal from anchor points and adjacent existing tiles.
    Includes corrected Strategy 2 initiation.
    (Removed verbose debug prints)
    """
    # print(f"--- generate_all_moves_gaddag called. Rack: {''.join(sorted(rack))}") # Keep initial call log? Optional.
    if not gaddag_root:
        print("ERROR: GADDAG structure not loaded.")
        return []

    all_found_moves = []
    unique_move_signatures = set() # Tracks signatures (new_r, new_c, new_l) to avoid adding identical plays
    rack_counts = Counter(rack)
    is_first_play = sum(1 for row in tiles for t in row if t) == 0
    anchors = get_anchor_points(tiles, is_first_play)
    # REMOVED: print(f"--- generate_all_moves_gaddag: Found anchors: {anchors} ---")
    original_tiles_state = [row[:] for row in tiles] # Keep a safe copy
    full_rack_size = len(rack) # Needed for bingo check

    # --- Precompute Cross-Check Sets ---
    # REMOVED: print("--- generate_all_moves_gaddag: Generating cross-check sets... ---")
    cross_check_sets = {}
    for r in range(GRID_SIZE):
        for c in range(GRID_SIZE):
            if not tiles[r][c]: # Only needed for empty squares
                # Check Vertical context
                up_word = ""; rr = r - 1
                while rr >= 0 and tiles[rr][c]: up_word = tiles[rr][c] + up_word; rr -= 1
                down_word = ""; rr = r + 1
                while rr < GRID_SIZE and tiles[rr][c]: down_word += tiles[rr][c]; rr += 1
                allowed_letters_v = set()
                if not up_word and not down_word: allowed_letters_v = set('ABCDEFGHIJKLMNOPQRSTUVWXYZ ')
                else:
                    for letter in 'ABCDEFGHIJKLMNOPQRSTUVWXYZ':
                        if DAWG.search(up_word + letter + down_word): allowed_letters_v.add(letter)
                    if allowed_letters_v: allowed_letters_v.add(' ')

                # Check Horizontal context
                left_word = ""; cc = c - 1
                while cc >= 0 and tiles[r][cc]: left_word = tiles[r][cc] + left_word; cc -= 1
                right_word = ""; cc = c + 1
                while cc < GRID_SIZE and tiles[r][cc]: right_word += tiles[r][cc]; cc += 1
                allowed_letters_h = set()
                if not left_word and not right_word: allowed_letters_h = set('ABCDEFGHIJKLMNOPQRSTUVWXYZ ')
                else:
                    for letter in 'ABCDEFGHIJKLMNOPQRSTUVWXYZ':
                        if DAWG.search(left_word + letter + right_word): allowed_letters_h.add(letter)
                    if allowed_letters_h: allowed_letters_h.add(' ')

                cross_check_sets[(r, c)] = {'V': allowed_letters_v, 'H': allowed_letters_h}
    # REMOVED: print("--- generate_all_moves_gaddag: Cross-check sets generated. ---")

    # --- Initiate Traversal from Each Anchor ---
    # REMOVED: print("--- generate_all_moves_gaddag: Starting traversal... ---")
    processed_adjacent_starts = set() # Prevent redundant starts *from the same adjacent tile* for different anchors

    for r_anchor, c_anchor in anchors:
        anchor_pos = (r_anchor, c_anchor)

        # --- Strategy 1: Place the first letter *on* the anchor square itself ---
        allowed_h = cross_check_sets.get(anchor_pos, {}).get('H', set())
        allowed_v = cross_check_sets.get(anchor_pos, {}).get('V', set())
        # Try placing regular tiles from rack onto the anchor
        for tile_letter, count in list(rack_counts.items()):
            if count > 0 and tile_letter != ' ':
                if tile_letter in gaddag_root.children:
                    next_node = gaddag_root.children[tile_letter]
                    new_rack_counts = rack_counts.copy(); new_rack_counts[tile_letter] -= 1
                    if new_rack_counts[tile_letter] == 0: del new_rack_counts[tile_letter]
                    initial_tiles = [(r_anchor, c_anchor, tile_letter, False, True)]
                    # Initiate HORIZONTAL exploration (checks Vertical cross-check)
                    if tile_letter in allowed_v:
                         _gaddag_traverse(anchor_pos, new_rack_counts.copy(), tiles, board, blanks, cross_check_sets, next_node, initial_tiles, True, 'H', all_found_moves, unique_move_signatures, original_tiles_state, is_first_play, full_rack_size)
                    # Initiate VERTICAL exploration (checks Horizontal cross-check)
                    if tile_letter in allowed_h:
                         _gaddag_traverse(anchor_pos, new_rack_counts.copy(), tiles, board, blanks, cross_check_sets, next_node, initial_tiles, True, 'V', all_found_moves, unique_move_signatures, original_tiles_state, is_first_play, full_rack_size)
        # Try placing a blank tile from rack onto the anchor
        if rack_counts[' '] > 0:
            # Check if blank is allowed in *either* direction for the anchor
            if ' ' in allowed_h or ' ' in allowed_v:
                new_rack_counts_blank_base = rack_counts.copy(); new_rack_counts_blank_base[' '] -= 1
                if new_rack_counts_blank_base[' '] == 0: del new_rack_counts_blank_base[' ']

                for assigned_letter in 'ABCDEFGHIJKLMNOPQRSTUVWXYZ':
                    if assigned_letter in gaddag_root.children:
                        next_node = gaddag_root.children[assigned_letter]
                        initial_tiles = [(r_anchor, c_anchor, assigned_letter, True, True)]
                        # Initiate HORIZONTAL exploration (if blank allowed vertically)
                        if ' ' in allowed_v:
                            _gaddag_traverse(anchor_pos, new_rack_counts_blank_base.copy(), tiles, board, blanks, cross_check_sets, next_node, initial_tiles, True, 'H', all_found_moves, unique_move_signatures, original_tiles_state, is_first_play, full_rack_size)
                        # Initiate VERTICAL exploration (if blank allowed horizontally)
                        if ' ' in allowed_h:
                            _gaddag_traverse(anchor_pos, new_rack_counts_blank_base.copy(), tiles, board, blanks, cross_check_sets, next_node, initial_tiles, True, 'V', all_found_moves, unique_move_signatures, original_tiles_state, is_first_play, full_rack_size)


        # --- Strategy 2: Start traversal from an *existing* tile adjacent to the anchor ---
        if not is_first_play:
            for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]: # Check N, S, W, E neighbors
                nr, nc = r_anchor + dr, c_anchor + dc
                adj_pos = (nr, nc) # Position of the adjacent tile

                if 0 <= nr < GRID_SIZE and 0 <= nc < GRID_SIZE:
                    existing_tile_letter = tiles[nr][nc]
                    if existing_tile_letter and adj_pos not in processed_adjacent_starts:
                         processed_adjacent_starts.add(adj_pos)

                         if existing_tile_letter in gaddag_root.children:
                            next_node = gaddag_root.children[existing_tile_letter]
                            initial_tiles = [(nr, nc, existing_tile_letter, False, False)] # Existing tile is not blank, not new

                            start_axis = 'V' if dr != 0 else 'H'

                            # Explore FORWARDS (away from existing tile, past the anchor)
                            _gaddag_traverse(
                                anchor_pos, rack_counts.copy(), tiles, board, blanks, cross_check_sets, # Pass copy of rack_counts
                                next_node, initial_tiles[:], False, start_axis, # is_reversed = False
                                all_found_moves, unique_move_signatures, original_tiles_state,
                                is_first_play, full_rack_size
                            )
                            # Explore BACKWARDS (towards where the existing tile came from)
                            _gaddag_traverse(
                                anchor_pos, rack_counts.copy(), tiles, board, blanks, cross_check_sets, # Pass copy of rack_counts
                                next_node, initial_tiles[:], True, start_axis, # is_reversed = True
                                all_found_moves, unique_move_signatures, original_tiles_state,
                                is_first_play, full_rack_size
                            )


    # REMOVED: print(f"--- generate_all_moves_gaddag: Traversal complete. Found {len(all_found_moves)} potential moves before sorting/final check. ---")

    # --- Post-processing ---
    all_found_moves.sort(key=lambda m: m['score'], reverse=True)
    final_unique_moves = []
    seen_final_signatures = set()
    for move in all_found_moves:
        sig_tuple = tuple(sorted(move['newly_placed'])) + (move['score'],)
        if sig_tuple not in seen_final_signatures:
            final_unique_moves.append(move)
            seen_final_signatures.add(sig_tuple)

    # print(f"--- generate_all_moves_gaddag: Returning {len(final_unique_moves)} unique moves. ---") # Keep final count? Optional.
    return final_unique_moves


# Corrected snippet for Part 5 - draw_hint_dialog

# --- Hint Dialog ---
def draw_hint_dialog(moves, selected_index):
    """Draw the hint dialog showing top 5 moves."""
    dialog_width, dialog_height = 400, 250
    dialog_x = (WINDOW_WIDTH - dialog_width) // 2
    dialog_y = (WINDOW_HEIGHT - dialog_height) // 2

    pygame.draw.rect(screen, DIALOG_COLOR, (dialog_x, dialog_y, dialog_width, dialog_height))
    pygame.draw.rect(screen, BLACK, (dialog_x, dialog_y, dialog_width, dialog_height), 2)

    title_text = dialog_font.render("Top 5 Moves" if moves else "No Moves Available", True, BLACK)
    screen.blit(title_text, (dialog_x + 10, dialog_y + 10))

    hint_rects = []
    y_pos = dialog_y + 40
    for i, move in enumerate(moves[:5]):
        color = HINT_SELECTED_COLOR if i == selected_index else HINT_NORMAL_COLOR
        rect = pygame.Rect(dialog_x + 10, y_pos, dialog_width - 20, 30)
        pygame.draw.rect(screen, color, rect)

        word = move.get('word', 'N/A')
        score = move.get('score', 0)
        start_pos = move.get('start', (0,0))
        direction = move.get('direction', 'right')
        leave = move.get('leave', [])
        word_display = move.get('word_with_blanks', word.upper()) # Use formatted word
        coord = get_coord(start_pos, direction)
        leave_str = ''.join(sorted(l if l != ' ' else '?' for l in leave))

        text_str = f"{i+1}. {word_display} ({score} pts) at {coord} ({leave_str})"
        text = ui_font.render(text_str, True, BLACK)

        # Truncate text if too wide
        max_text_width = rect.width - 10
        if text.get_width() > max_text_width:
             avg_char_width = text.get_width() / len(text_str) if len(text_str) > 0 else 10
             # Ensure avg_char_width is not zero to avoid division error
             if avg_char_width > 0:
                 max_chars = int(max_text_width / avg_char_width) - 3 # Calculate max_chars
                 # --- CORRECTED INDENTATION START ---
                 if max_chars < 5: # Check if max_chars is too small
                     max_chars = 5
                 text_str = text_str[:max_chars] + "..." # Truncate and add ellipsis
                 text = ui_font.render(text_str, True, BLACK) # Re-render the truncated text
                 # --- CORRECTED INDENTATION END ---
             # else: # Handle case where avg_char_width is 0 (e.g., empty text_str) - text won't be truncated anyway
             #    pass

        screen.blit(text, (dialog_x + 15, y_pos + 5))
        hint_rects.append(rect)
        y_pos += 30

    # Buttons
    button_y = dialog_y + dialog_height - BUTTON_HEIGHT - 10
    total_button_width = 3 * BUTTON_WIDTH + 2 * BUTTON_GAP
    button_start_x = dialog_x + (dialog_width - total_button_width) // 2

    play_button_rect = pygame.Rect(button_start_x, button_y, BUTTON_WIDTH, BUTTON_HEIGHT)
    all_words_button_rect = pygame.Rect(button_start_x + BUTTON_WIDTH + BUTTON_GAP, button_y, BUTTON_WIDTH, BUTTON_HEIGHT)
    ok_button_rect = pygame.Rect(button_start_x + 2 * (BUTTON_WIDTH + BUTTON_GAP), button_y, BUTTON_WIDTH, BUTTON_HEIGHT)

    # Draw buttons
    pygame.draw.rect(screen, BUTTON_COLOR, play_button_rect)
    pygame.draw.rect(screen, BUTTON_COLOR, all_words_button_rect)
    pygame.draw.rect(screen, BUTTON_COLOR, ok_button_rect)

    play_text = button_font.render("Play", True, BLACK)
    all_words_text = button_font.render("All Words", True, BLACK)
    ok_text = button_font.render("OK", True, BLACK)

    screen.blit(play_text, play_text.get_rect(center=play_button_rect.center))
    screen.blit(all_words_text, all_words_text.get_rect(center=all_words_button_rect.center))
    screen.blit(ok_text, ok_text.get_rect(center=ok_button_rect.center))

    return hint_rects, play_button_rect, ok_button_rect, all_words_button_rect

# End of Part 5

# python
# MODIFIED: 01APR24 - Implementing 8-Letter Bingo Practice Mode Fixes (Part 6)

# python
# MODIFIED: 01APR24 - Implementing 8-Letter Bingo Practice Mode Fixes (Part 6 - Corrected Function Call)

# Part 6

def draw_all_words_dialog(moves, selected_index, current_scroll_offset): # Changed 3rd arg name
    """Draw the dialog showing all valid moves with scrolling."""
    dialog_x = (WINDOW_WIDTH - ALL_WORDS_DIALOG_WIDTH) // 2; dialog_y = (WINDOW_HEIGHT - ALL_WORDS_DIALOG_HEIGHT) // 2
    pygame.draw.rect(screen, DIALOG_COLOR, (dialog_x, dialog_y, ALL_WORDS_DIALOG_WIDTH, ALL_WORDS_DIALOG_HEIGHT)); pygame.draw.rect(screen, BLACK, (dialog_x, dialog_y, ALL_WORDS_DIALOG_WIDTH, ALL_WORDS_DIALOG_HEIGHT), 2)
    header_height = 40; unique_words_count = len(set(move.get('word', '') for move in moves if move.get('word'))); title_text = dialog_font.render(f"All Valid Moves ({unique_words_count} unique words, {len(moves)} plays)", True, BLACK); screen.blit(title_text, (dialog_x + 10, dialog_y + 10))
    content_area_y = dialog_y + header_height; button_area_height = BUTTON_HEIGHT + 30; content_area_height = ALL_WORDS_DIALOG_HEIGHT - header_height - button_area_height; content_area_rect = pygame.Rect(dialog_x, content_area_y, ALL_WORDS_DIALOG_WIDTH, content_area_height)
    content_height = len(moves) * 30; content_surface_width = max(1, ALL_WORDS_DIALOG_WIDTH - 20); content_surface = pygame.Surface((content_surface_width, content_height)); content_surface.fill(DIALOG_COLOR)
    all_words_rects = []; item_height = 30
    for i, move in enumerate(moves):
        y_pos_on_surface = i * item_height
        # --- MODIFICATION: Use current_scroll_offset for visibility check ---
        if y_pos_on_surface >= current_scroll_offset - item_height and y_pos_on_surface < current_scroll_offset + content_area_height:
            color = HINT_SELECTED_COLOR if i == selected_index else HINT_NORMAL_COLOR; rect_on_surface = pygame.Rect(10, y_pos_on_surface, content_surface_width - 20, item_height); pygame.draw.rect(content_surface, color, rect_on_surface)
            word = move.get('word', 'N/A'); score = move.get('score', 0); start_pos = move.get('start', (0,0)); direction = move.get('direction', 'right'); leave = move.get('leave', []); word_display = move.get('word_with_blanks', word.upper())
            coord = get_coord(start_pos, direction); leave_str = ''.join(sorted(l if l != ' ' else '?' for l in leave)); text_str = f"{i+1}. {word_display} ({score} pts) at {coord} ({leave_str})"; text = ui_font.render(text_str, True, BLACK)
            max_text_width = rect_on_surface.width - 10 # Truncate text

            # --- CORRECTED INDENTATION BLOCK START ---
            if text.get_width() > max_text_width:
                avg_char_width = text.get_width() / len(text_str) if len(text_str) > 0 else 10
                if avg_char_width > 0:
                    max_chars = int(max_text_width / avg_char_width) - 3
                    if max_chars < 5: max_chars = 5 # Ensure at least a few chars show
                    text_str = text_str[:max_chars] + "..."
                    text = ui_font.render(text_str, True, BLACK) # Re-render truncated text
                # else: # Handle case where avg_char_width is 0 (e.g., empty text_str) - text won't be truncated anyway
                #    pass
            # --- CORRECTED INDENTATION BLOCK END ---

            content_surface.blit(text, (15, y_pos_on_surface + 5))
            # --- MODIFICATION: Use current_scroll_offset for screen position calculation ---
            screen_y = content_area_y + y_pos_on_surface - current_scroll_offset;
            screen_rect = pygame.Rect(dialog_x + 10, screen_y, content_surface_width - 20, item_height)
            visible_top = content_area_y; visible_bottom = content_area_y + content_area_height; clipped_top = max(visible_top, screen_rect.top); clipped_bottom = min(visible_bottom, screen_rect.bottom)
            if clipped_bottom > clipped_top: clipped_rect = pygame.Rect(screen_rect.left, clipped_top, screen_rect.width, clipped_bottom - clipped_top); all_words_rects.append((clipped_rect, i))

    # --- MODIFICATION: Use current_scroll_offset for blitting source rect ---
    visible_area_on_surface = pygame.Rect(0, current_scroll_offset, content_surface_width, content_area_height);
    screen.blit(content_surface, (dialog_x + 10, content_area_y), visible_area_on_surface)
    pygame.draw.rect(screen, BLACK, (dialog_x + 10, content_area_y, content_surface_width, content_area_height), 1) # Optional border
    total_button_width = 2 * BUTTON_WIDTH + BUTTON_GAP; buttons_x = dialog_x + (ALL_WORDS_DIALOG_WIDTH - total_button_width) // 2; button_y = dialog_y + ALL_WORDS_DIALOG_HEIGHT - BUTTON_HEIGHT - 20
    play_button_rect = pygame.Rect(buttons_x, button_y, BUTTON_WIDTH, BUTTON_HEIGHT); ok_button_rect = pygame.Rect(buttons_x + BUTTON_WIDTH + BUTTON_GAP, button_y, BUTTON_WIDTH, BUTTON_HEIGHT)
    pygame.draw.rect(screen, BUTTON_COLOR, play_button_rect); pygame.draw.rect(screen, BUTTON_COLOR, ok_button_rect)
    play_text = button_font.render("Play", True, BLACK); ok_text = button_font.render("OK", True, BLACK)
    screen.blit(play_text, play_text.get_rect(center=play_button_rect.center)); screen.blit(ok_text, ok_text.get_rect(center=ok_button_rect.center))
    return all_words_rects, play_button_rect, ok_button_rect



def get_insertion_index(x, rack_start_x, rack_len):
    """Determine the insertion index (0 to rack_len) based on mouse x-position."""
    # --- DEBUG PRINT: Function Entry ---
    print(f"--- get_insertion_index(x={x}, rack_start_x={rack_start_x}, rack_len={rack_len}) ---")

    # Boundary before the first tile (index 0)
    # Consider the midpoint of the first tile's visual space
    boundary_before_first = rack_start_x + TILE_WIDTH // 2
    # --- DEBUG PRINT: Index 0 Check ---
    print(f"  Checking index 0 boundary: Is x ({x}) < boundary_before_first ({boundary_before_first})?")
    if x < boundary_before_first:
        print(f"  -> Returning index 0") # DEBUG
        return 0

    # Iterate through the potential insertion points *between* tiles (indices 1 to rack_len)
    # The loop goes from i=0 to rack_len-1 (representing the tile *before* the gap)
    for i in range(rack_len):
        # Calculate the midpoint of the gap *after* tile i
        tile_i_right_edge = rack_start_x + i * (TILE_WIDTH + TILE_GAP) + TILE_WIDTH
        gap_mid_x = tile_i_right_edge + TILE_GAP // 2
        # --- DEBUG PRINT: Gap Check ---
        print(f"  Checking index {i+1} boundary: Is x ({x}) < gap_mid_x ({gap_mid_x}) after tile {i}?")
        if x < gap_mid_x:
            # If x is less than the midpoint of the gap after tile i, insert at index i+1
            print(f"  -> Returning index {i+1}") # DEBUG
            return i + 1

    # If the loop completes, it means x was to the right of the midpoint of the gap after the last tile.
    # Insert at the very end (index rack_len).
    # --- DEBUG PRINT: End of Rack ---
    print(f"  Loop finished. Returning index {rack_len} (end of rack)")
    return rack_len



def count_consecutive_existing(row, col, direction, tiles):
    """Count consecutive existing tiles in a direction (unused currently)."""
    count = 0
    if direction == "right": c = col;
    while c < GRID_SIZE and tiles[row][c]: count += 1; c += 1
    else: r = row;
    while r < GRID_SIZE and tiles[r][col]: count += 1; r += 1
    return count

# New function to handle end-of-game score adjustments
def calculate_final_scores(current_scores, racks, bag):
    """
    Calculates the final scores based on game end conditions and remaining tiles.

    Args:
        current_scores (list): List containing the scores of [Player1, Player2] before adjustments.
        racks (list): List containing the tile lists for [Player1's rack, Player2's rack].
        bag (list): The list representing the tile bag.

    Returns:
        list: A new list containing the final adjusted scores for [Player1, Player2].
    """
    final_scores = list(current_scores) # Start with a copy of current scores
    rack_values = [0, 0]

    # Calculate the value of tiles left on each rack (blanks count as 0)
    for i in range(2):
        if i < len(racks) and racks[i]: # Check if rack exists and is not None
             rack_values[i] = sum(TILE_DISTRIBUTION[tile][1] for tile in racks[i] if tile != ' ')
        # else: rack_values[i] remains 0

    # Determine if a player went out (must have empty rack AND bag must be empty)
    p1_out = (not racks[0]) and (not bag)
    p2_out = (not racks[1]) and (not bag)

    if p1_out:
        print("Final Score Adjust: P1 went out.")
        # Player 1 went out: Add double Player 2's remaining tile value to P1's score. P2 score unchanged.
        adjustment = 2 * rack_values[1]
        final_scores[0] += adjustment
        # final_scores[1] remains unchanged
        print(f"  P2 tiles value: {rack_values[1]}, P1 adjustment: +{adjustment}")
    elif p2_out:
        print("Final Score Adjust: P2 went out.")
        # Player 2 went out: Add double Player 1's remaining tile value to P2's score. P1 score unchanged.
        adjustment = 2 * rack_values[0]
        final_scores[1] += adjustment
        # final_scores[0] remains unchanged
        print(f"  P1 tiles value: {rack_values[0]}, P2 adjustment: +{adjustment}")
    else:
        # Neither player went out: Subtract each player's own remaining tile value from their score.
        print("Final Score Adjust: Neither player went out.")
        final_scores[0] -= rack_values[0]
        final_scores[1] -= rack_values[1]
        print(f"  P1 adjustment: -{rack_values[0]}, P2 adjustment: -{rack_values[1]}")

    print(f"  Scores before: {current_scores}, Scores after: {final_scores}")
    return final_scores


# --- Playing Moves ---
# Function to Modify: play_hint_move
# REASON: Added sorting of the rack *after* drawing new tiles.

# Function to Modify: play_hint_move
# REASON: Re-added sorting of the rack *after* drawing new tiles for human players.

# Function to Modify: play_hint_move
# REASON: Added sorting of the rack *after* drawing new tiles for human players.

def play_hint_move(move, tiles, racks, blanks, scores, turn, bag, board):
    """Plays a move (usually from hint/AI), updates state. Handles practice mode. Sorts human rack."""
    global practice_mode, is_ai # Need is_ai to check if player is human

    player_idx = turn - 1
    if not (0 <= player_idx < len(racks)):
        print(f"Error: Invalid player index {player_idx} in play_hint_move.")
        return turn, [], []

    current_rack = racks[player_idx]
    move_positions = move.get('positions', [])
    move_blanks_coords = move.get('blanks', set())
    newly_placed_details = move.get('newly_placed', [])

    # --- Verification ---
    needed_tiles = Counter()
    blanks_needed_count = 0
    for r, c, letter in newly_placed_details:
        if (r, c) in move_blanks_coords: blanks_needed_count += 1
        else: needed_tiles[letter] += 1
    rack_counter = Counter(current_rack)
    if blanks_needed_count > rack_counter.get(' ', 0):
        print(f"Error playing move: Needs {blanks_needed_count} blanks, only {rack_counter.get(' ', 0)} available.")
        return turn, [], []
    for letter, count in needed_tiles.items():
        if rack_counter.get(letter, 0) < count:
            print(f"Error playing move: Needs {count} '{letter}', only {rack_counter.get(letter, 0)} available.")
            return turn, [], []
    # --- End Verification ---

    # Place tiles & update rack
    rack_after_play = current_rack[:] # Work with a copy
    for r, c, letter in newly_placed_details:
        tiles[r][c] = letter
        if (r, c) in move_blanks_coords:
            if ' ' in rack_after_play: rack_after_play.remove(' '); blanks.add((r, c))
            else: print("Error: Tried to play blank but none in rack_after_play!")
        else:
            if letter in rack_after_play: rack_after_play.remove(letter)
            else: print(f"Error: Tried to play '{letter}' but not in rack_after_play!")

    score = move.get('score', 0)
    scores[player_idx] += score # Update score

    # Draw new tiles (Skip in 8-letter practice)
    drawn_tiles = []
    if practice_mode != "eight_letter":
        num_to_draw = len(newly_placed_details)
        drawn_tiles = [bag.pop() for _ in range(num_to_draw) if bag]
        rack_after_play.extend(drawn_tiles)

    # --- ADDED SORTING ---
    # Sort the rack alphabetically if the player is human
    if not is_ai[player_idx]:
        rack_after_play.sort()
    # --- END ADDED SORTING ---

    racks[player_idx] = rack_after_play # Update main rack AFTER potential sort

    next_turn = turn if practice_mode == "eight_letter" else 3 - turn # Determine next turn
    return next_turn, drawn_tiles, newly_placed_details



def get_tile_under_mouse(x, y, rack_start_x, rack_y, rack_len):
    """Determine which tile index (0 to rack_len-1) is under the mouse cursor."""
    # Iterate through each potential tile position on the rack
    for i in range(rack_len):
        # Calculate the x-coordinate for the current tile
        tile_x = rack_start_x + i * (TILE_WIDTH + TILE_GAP)
        # Create the rectangle for the current tile *inside* the loop
        tile_rect = pygame.Rect(tile_x, rack_y, TILE_WIDTH, TILE_HEIGHT)
        # Check if the mouse coordinates collide with this specific tile's rectangle *inside* the loop
        if tile_rect.collidepoint(x, y):
            return i # Return the index of the collided tile immediately
    # If the loop finishes without finding any collision (or if rack_len was 0), return None
    return None






def get_batch_game_dialog():
    """Displays a dialog to get the number of batch games."""
    dialog_width, dialog_height = 300, 150
    dialog_x = (WINDOW_WIDTH - dialog_width) // 2
    dialog_y = (WINDOW_HEIGHT - dialog_height) // 2
    input_text = ""
    input_active = True
    error_msg = None

    while True:
        screen.fill(WHITE) # Or redraw the mode selection screen behind it
        pygame.draw.rect(screen, DIALOG_COLOR, (dialog_x, dialog_y, dialog_width, dialog_height))
        pygame.draw.rect(screen, BLACK, (dialog_x, dialog_y, dialog_width, dialog_height), 2)

        title_surf = dialog_font.render("Batch Games", True, BLACK)
        screen.blit(title_surf, (dialog_x + 10, dialog_y + 10))

        prompt_surf = ui_font.render("Number of games:", True, BLACK)
        screen.blit(prompt_surf, (dialog_x + 10, dialog_y + 50))

        input_rect = pygame.Rect(dialog_x + 180, dialog_y + 45, 100, 30)
        pygame.draw.rect(screen, WHITE, input_rect)
        pygame.draw.rect(screen, BLACK, input_rect, 1 if not input_active else 2)
        input_surf = ui_font.render(input_text, True, BLACK)
        screen.blit(input_surf, (input_rect.x + 5, input_rect.y + 5))

        if input_active and int(time.time() * 2) % 2 == 0: # Blinking cursor
            cursor_x = input_rect.x + 5 + input_surf.get_width()
            cursor_y1 = input_rect.y + 5
            cursor_y2 = input_rect.y + input_rect.height - 5
            pygame.draw.line(screen, BLACK, (cursor_x, cursor_y1), (cursor_x, cursor_y2), 1)

        ok_rect = pygame.Rect(dialog_x + 40, dialog_y + 100, BUTTON_WIDTH, BUTTON_HEIGHT)
        cancel_rect = pygame.Rect(dialog_x + dialog_width - BUTTON_WIDTH - 40, dialog_y + 100, BUTTON_WIDTH, BUTTON_HEIGHT)
        pygame.draw.rect(screen, BUTTON_COLOR, ok_rect)
        pygame.draw.rect(screen, BUTTON_COLOR, cancel_rect)
        ok_text_surf = button_font.render("Run Batch", True, BLACK)
        cancel_text_surf = button_font.render("Cancel", True, BLACK)
        screen.blit(ok_text_surf, ok_text_surf.get_rect(center=ok_rect.center))
        screen.blit(cancel_text_surf, cancel_text_surf.get_rect(center=cancel_rect.center))

        if error_msg:
            error_surf = ui_font.render(error_msg, True, RED)
            screen.blit(error_surf, (dialog_x + 10, dialog_y + 75))

        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()
            if event.type == pygame.MOUSEBUTTONDOWN:
                x, y = event.pos
                input_active = input_rect.collidepoint(x, y)
                error_msg = None # Clear error on click
                if ok_rect.collidepoint(x, y):
                    try:
                        num_games = int(input_text)
                        if num_games > 0:
                            return num_games
                        else:
                            error_msg = "Enter a positive number."
                    except ValueError:
                        error_msg = "Invalid number."
                elif cancel_rect.collidepoint(x, y):
                    return None # User cancelled
            if event.type == pygame.KEYDOWN:
                if input_active:
                    error_msg = None # Clear error on key press
                    if event.key == pygame.K_RETURN or event.key == pygame.K_KP_ENTER:
                        try:
                            num_games = int(input_text)
                            if num_games > 0:
                                return num_games
                            else:
                                error_msg = "Enter a positive number."
                        except ValueError:
                            error_msg = "Invalid number."
                    elif event.key == pygame.K_BACKSPACE:
                        input_text = input_text[:-1]
                    elif event.unicode.isdigit():
                        input_text += event.unicode
                elif event.key == pygame.K_ESCAPE: # Allow escape to cancel
                     return None

        pygame.display.flip()
        pygame.time.Clock().tick(30)


# --- MODIFIED Batch Game Helper Function ---

def reset_game_state(initial_config):
    """Resets global game variables for a new game in a batch."""
    # --- MODIFICATION: Add 'board' to globals and assign ---
    global board, bag, tiles, racks, blanks, scores, turn, first_play, pass_count
    global exchange_count, consecutive_zero_point_turns, move_history
    global last_played_highlight_coords, is_solving_endgame
    # --- END MODIFICATION ---

    print("--- Resetting Game State for New Batch Game ---")
    # --- MODIFICATION: Assign result to global board ---
    new_board, _, new_tiles = create_board() # Get all parts
    board = new_board # Assign the newly created board layout to the global
    tiles = new_tiles # Assign the newly created empty tiles grid
    # --- END MODIFICATION ---
    blanks = set()
    scores = [0, 0]
    turn = 1
    first_play = True
    pass_count = 0
    exchange_count = 0
    consecutive_zero_point_turns = 0
    move_history = []
    last_played_highlight_coords = set()
    is_solving_endgame = False # Ensure solver flag is reset

    # Create and shuffle a new bag
    bag = create_standard_bag()
    random.shuffle(bag)

    # Deal new racks
    racks = [[], []]
    try:
        racks[0] = [bag.pop() for _ in range(7)]
        racks[1] = [bag.pop() for _ in range(7)]
    except IndexError:
        print("Error: Not enough tiles in bag for initial deal.")
        # This shouldn't happen with a standard bag, but handle defensively
        return False # Indicate failure

    # Sort racks based on initial config (human vs AI)
    is_ai_config = initial_config.get('is_ai', [False, False])
    for i, rack in enumerate(racks):
        if 0 <= i < len(is_ai_config) and not is_ai_config[i]:
            rack.sort()
        # Optionally sort AI racks too: rack.sort()

    return True # Indicate success


def collect_game_stats(game_num, player_names, final_scores, move_history):
    """Calculates and returns stats for a single completed game, including move history and quadrant counts."""
    stats = {'game_number': game_num}
    stats['player1_name'] = player_names[0]
    stats['player2_name'] = player_names[1]
    stats['player1_score'] = final_scores[0]
    stats['player2_score'] = final_scores[1]
    stats['winner'] = 'Draw'
    if final_scores[0] > final_scores[1]:
        stats['winner'] = player_names[0]
    elif final_scores[1] > final_scores[0]:
        stats['winner'] = player_names[1]

    moves_p1, moves_p2 = calculate_moves_per_player(move_history)
    stats['player1_moves'] = moves_p1
    stats['player2_moves'] = moves_p2

    avg_p1 = final_scores[0] / moves_p1 if moves_p1 > 0 else 0.00
    avg_p2 = final_scores[1] / moves_p2 if moves_p2 > 0 else 0.00
    stats['player1_avg_score'] = avg_p1
    stats['player2_avg_score'] = avg_p2

    tiles_p1, tiles_p2 = calculate_tiles_per_turn(move_history)
    stats['player1_avg_tiles'] = tiles_p1
    stats['player2_avg_tiles'] = tiles_p2

    bingos_p1, bingos_p2 = calculate_bingos_per_player(move_history)
    stats['player1_bingos'] = bingos_p1
    stats['player2_bingos'] = bingos_p2

    bingo_avg_p1, bingo_avg_p2 = calculate_bingo_avg_per_player(move_history)
    stats['player1_bingo_avg'] = bingo_avg_p1
    stats['player2_bingo_avg'] = bingo_avg_p2

    blanks_p1, blanks_p2 = calculate_blanks_per_player(move_history)
    stats['player1_blanks'] = blanks_p1
    stats['player2_blanks'] = blanks_p2

    leave_p1, leave_p2 = calculate_avg_leave(move_history)
    stats['player1_avg_leave'] = leave_p1
    stats['player2_avg_leave'] = leave_p2

    # --- MODIFICATION: Calculate and store quadrant counts ---
    stats['quadrant_counts'] = calculate_quadrant_counts(move_history)
    # --- END MODIFICATION ---

    # Store the move history itself
    stats['move_history'] = copy.deepcopy(move_history)

    return stats

def save_batch_statistics(batch_results, player_names):
    """Calculates aggregate stats and saves batch results to a file, including detailed bingo info and quadrant counts per game."""
    if not batch_results:
        print("No batch results to save.")
        return

    # --- Load Word Lists ---
    seven_letter_words = []
    eight_letter_words = []
    try:
        with open("7-letter-list.txt", "r") as f:
            seven_letter_words = [line.strip().upper() for line in f]
    except FileNotFoundError:
        print("Warning: 7-letter-list.txt not found for batch stats file.")
    try:
        with open("8-letter-list.txt", "r") as f:
            eight_letter_words = [line.strip().upper() for line in f]
    except FileNotFoundError:
        print("Warning: 8-letter-list.txt not found for batch stats file.")
    # --- End Load Word Lists ---

    num_games = len(batch_results)
    p1_wins = sum(1 for game in batch_results if game['winner'] == player_names[0])
    p2_wins = sum(1 for game in batch_results if game['winner'] == player_names[1])
    draws = num_games - p1_wins - p2_wins

    p1_total_score = sum(g['player1_score'] for g in batch_results)
    p2_total_score = sum(g['player2_score'] for g in batch_results)
    p1_avg_game_score = p1_total_score / num_games if num_games > 0 else 0.0
    p2_avg_game_score = p2_total_score / num_games if num_games > 0 else 0.0

    # Calculate other aggregate averages (same as before)
    agg_stats = {
        'p1_avg_score_turn': sum(g['player1_avg_score'] * g['player1_moves'] for g in batch_results if g['player1_moves'] > 0) / sum(g['player1_moves'] for g in batch_results if g['player1_moves'] > 0) if sum(g['player1_moves'] for g in batch_results if g['player1_moves'] > 0) > 0 else 0,
        'p2_avg_score_turn': sum(g['player2_avg_score'] * g['player2_moves'] for g in batch_results if g['player2_moves'] > 0) / sum(g['player2_moves'] for g in batch_results if g['player2_moves'] > 0) if sum(g['player2_moves'] for g in batch_results if g['player2_moves'] > 0) > 0 else 0,
        'p1_avg_tiles': sum(g['player1_avg_tiles'] * g['player1_moves'] for g in batch_results if g['player1_moves'] > 0) / sum(g['player1_moves'] for g in batch_results if g['player1_moves'] > 0) if sum(g['player1_moves'] for g in batch_results if g['player1_moves'] > 0) > 0 else 0,
        'p2_avg_tiles': sum(g['player2_avg_tiles'] * g['player2_moves'] for g in batch_results if g['player2_moves'] > 0) / sum(g['player2_moves'] for g in batch_results if g['player2_moves'] > 0) if sum(g['player2_moves'] for g in batch_results if g['player2_moves'] > 0) > 0 else 0,
        'p1_avg_bingo_score': sum(g['player1_bingo_avg'] * g['player1_bingos'] for g in batch_results if g['player1_bingos'] > 0) / sum(g['player1_bingos'] for g in batch_results if g['player1_bingos'] > 0) if sum(g['player1_bingos'] for g in batch_results if g['player1_bingos'] > 0) > 0 else 0,
        'p2_avg_bingo_score': sum(g['player2_bingo_avg'] * g['player2_bingos'] for g in batch_results if g['player2_bingos'] > 0) / sum(g['player2_bingos'] for g in batch_results if g['player2_bingos'] > 0) if sum(g['player2_bingos'] for g in batch_results if g['player2_bingos'] > 0) > 0 else 0,
        'p1_avg_leave': sum(g['player1_avg_leave'] * g['player1_moves'] for g in batch_results if g['player1_moves'] > 0) / sum(g['player1_moves'] for g in batch_results if g['player1_moves'] > 0) if sum(g['player1_moves'] for g in batch_results if g['player1_moves'] > 0) > 0 else 0,
        'p2_avg_leave': sum(g['player2_avg_leave'] * g['player2_moves'] for g in batch_results if g['player2_moves'] > 0) / sum(g['player2_moves'] for g in batch_results if g['player2_moves'] > 0) if sum(g['player2_moves'] for g in batch_results if g['player2_moves'] > 0) > 0 else 0,
        'total_p1_bingos': sum(g['player1_bingos'] for g in batch_results),
        'total_p2_bingos': sum(g['player2_bingos'] for g in batch_results),
        'total_p1_blanks': sum(g['player1_blanks'] for g in batch_results),
        'total_p2_blanks': sum(g['player2_blanks'] for g in batch_results),
    }

    # --- Average Bingos per Game ---
    p1_avg_bingos_per_game = agg_stats['total_p1_bingos'] / num_games if num_games > 0 else 0.0
    p2_avg_bingos_per_game = agg_stats['total_p2_bingos'] / num_games if num_games > 0 else 0.0

    # --- Aggregate Average Bingo Index ---
    total_bingo_index_sum = 0
    bingos_with_index_count = 0

    # --- Aggregate Power Tile First Play Scores ---
    power_tiles = {'J', 'Q', 'X', 'Z'}
    power_tile_scores = {'J': 0.0, 'Q': 0.0, 'X': 0.0, 'Z': 0.0}
    power_tile_counts = {'J': 0, 'Q': 0, 'X': 0, 'Z': 0}

    # Iterate through games to calculate combined index and power tile scores
    for game in batch_results:
        game_move_history = game.get('move_history', [])
        first_power_used_in_game = set() # Track first use *within this game*

        for move in game_move_history:
            if move.get('move_type') == 'place':
                word = move.get('word', '').upper()
                score = move.get('score', 0)
                word_len = len(word)

                # Calculate Bingo Index (Existing Logic)
                if move.get('is_bingo', False):
                    index = None
                    if word_len == 7 and seven_letter_words:
                        index = get_word_index(word, seven_letter_words)
                    elif word_len == 8 and eight_letter_words:
                        index = get_word_index(word, eight_letter_words)
                    if index is not None:
                        total_bingo_index_sum += index
                        bingos_with_index_count += 1

                # --- NEW: Calculate Power Tile First Play Scores ---
                power_in_word = {char for char in word if char in power_tiles}
                for pt in power_in_word:
                    if pt not in first_power_used_in_game:
                        power_tile_scores[pt] += score
                        power_tile_counts[pt] += 1
                        first_power_used_in_game.add(pt) # Mark as used for this game
                # --- END NEW Power Tile Logic ---

    aggregate_avg_bingo_index = total_bingo_index_sum / bingos_with_index_count if bingos_with_index_count > 0 else 0.0

    # --- Calculate Average Power Tile Scores ---
    avg_power_scores = {}
    for pt in power_tiles:
        avg_power_scores[pt] = power_tile_scores[pt] / power_tile_counts[pt] if power_tile_counts[pt] > 0 else 0.0
    # --- END Power Tile Calculation ---


    # --- Aggregate Quadrant Averages ---
    total_quad_counts = {"Q1": 0, "Q2": 0, "Q3": 0, "Q4": 0}
    for game in batch_results:
        quad_counts = game.get('quadrant_counts', {})
        for key in total_quad_counts:
            total_quad_counts[key] += quad_counts.get(key, 0)
    avg_quad_counts = {key: val / num_games if num_games > 0 else 0 for key, val in total_quad_counts.items()}


    # Generate filename (same as before)
    now = datetime.datetime.now()
    date_str = now.strftime("%d%b%y").upper()
    time_str = now.strftime("%H%M")
    seq_num = 1
    max_existing_num = 0
    try:
        for filename in os.listdir('.'):
            # Adjust filename check if necessary, e.g., check for specific BATCH pattern
            if filename.startswith(f"{date_str}-") and filename.endswith(".txt") and "-BATCH-" in filename:
                parts = filename[:-4].split('-')
                # Expecting DDMMMYY-HHMM-BATCH-Seq or similar
                if len(parts) >= 4 and parts[2] == "BATCH":
                    try:
                        num = int(parts[-1]) # Assume sequence number is last part
                        if num > max_existing_num: max_existing_num = num
                    except ValueError: continue
        seq_num = max_existing_num + 1
    except OSError as e:
        print(f"Error listing directory for batch sequence number: {e}")

    save_filename = f"{date_str}-{time_str}-BATCH-{seq_num}.txt" # Keep BATCH indicator

    # Write to file
    try:
        with open(save_filename, "w") as f:
            f.write(f"--- Batch Game Results ---\n")
            f.write(f"Total Games: {num_games}\n")
            f.write(f"Players: {player_names[0]} vs {player_names[1]}\n")
            f.write("-" * 25 + "\n")
            f.write("Overall Summary:\n")
            f.write(f"  {player_names[0]} Wins: {p1_wins} ({p1_wins/num_games:.1%})\n")
            f.write(f"  {player_names[1]} Wins: {p2_wins} ({p2_wins/num_games:.1%})\n")
            f.write(f"  Draws: {draws} ({draws/num_games:.1%})\n")
            f.write(f"  Avg Game Score {player_names[0]}: {p1_avg_game_score:.2f}\n")
            f.write(f"  Avg Game Score {player_names[1]}: {p2_avg_game_score:.2f}\n")
            f.write("-" * 25 + "\n")
            f.write("Aggregate Statistics (Per Turn / Game Averages):\n")
            f.write(f"                     {player_names[0]:>12} {player_names[1]:>12}\n")
            f.write(f"Avg Score/Turn:    {agg_stats['p1_avg_score_turn']:>12.2f} {agg_stats['p2_avg_score_turn']:>12.2f}\n")
            f.write(f"Avg Tiles/Turn:    {agg_stats['p1_avg_tiles']:>12.2f} {agg_stats['p2_avg_tiles']:>12.2f}\n")
            f.write(f"Total Bingos:      {agg_stats['total_p1_bingos']:>12} {agg_stats['total_p2_bingos']:>12}\n")
            f.write(f"Avg Bingos/Game:   {p1_avg_bingos_per_game:>12.2f} {p2_avg_bingos_per_game:>12.2f}\n")
            f.write(f"Avg Bingo Score:   {agg_stats['p1_avg_bingo_score']:>12.2f} {agg_stats['p2_avg_bingo_score']:>12.2f}\n")
            f.write(f"Total Blanks Used: {agg_stats['total_p1_blanks']:>12} {agg_stats['total_p2_blanks']:>12}\n")
            f.write(f"Avg Leave Value:   {agg_stats['p1_avg_leave']:>12.2f} {agg_stats['p2_avg_leave']:>12.2f}\n")
            f.write("-" * 25 + "\n")
            f.write("Aggregate Bingo Index (7/8 Letter Words):\n")
            f.write(f"  Avg Index (Combined): {aggregate_avg_bingo_index:>6.1f}  (Based on {bingos_with_index_count} bingos)\n")
            f.write("-" * 25 + "\n")
            # --- ADDED: Write Power Tile Scores ---
            f.write("Power Tile First Play Scores (Aggregate Avg):\n")
            for pt in sorted(power_tiles): # Sort J, Q, X, Z for consistent order
                 count = power_tile_counts[pt]
                 avg_score = avg_power_scores[pt]
                 f.write(f"  {pt}: {avg_score:>10.2f}  (Based on {count} plays)\n")
            f.write("-" * 25 + "\n")
            # --- END Power Tile Scores ---
            f.write("Aggregate Quadrant Usage (Avg Tiles Per Game):\n")
            f.write(f"  Q2 (Top-Left):  {avg_quad_counts['Q2']:>6.2f}    Q1 (Top-Right):   {avg_quad_counts['Q1']:>6.2f}\n")
            f.write(f"  Q3 (Bot-Left):  {avg_quad_counts['Q3']:>6.2f}    Q4 (Bot-Right):  {avg_quad_counts['Q4']:>6.2f}\n")
            f.write("=" * 40 + "\n")
            f.write("Individual Game Results:\n")
            f.write("=" * 40 + "\n")

            # --- Loop through games and add bingo/quadrant details ---
            for game in batch_results:
                f.write(f"Game {game['game_number']}:\n")
                f.write(f"  Score: {game['player1_name']} {game['player1_score']} - {game['player2_name']} {game['player2_score']}\n")
                f.write(f"  Winner: {game['winner']}\n")
                f.write(f"  Moves: P1={game['player1_moves']}, P2={game['player2_moves']}\n")

                # Write Quadrant Counts for this game
                quad_counts = game.get('quadrant_counts', {"Q1": 0, "Q2": 0, "Q3": 0, "Q4": 0})
                f.write(f"  Quadrants: Q2={quad_counts['Q2']}, Q1={quad_counts['Q1']}, Q3={quad_counts['Q3']}, Q4={quad_counts['Q4']}\n")

                # Write Bingo Details for this game
                game_move_history = game.get('move_history', [])
                game_p1_bingos = []
                game_p2_bingos = []

                for move in game_move_history:
                    if move.get('is_bingo', False):
                        player = move['player']
                        word = move.get('word', 'N/A').upper()
                        score = move.get('score', 0)
                        word_len = len(word)
                        index = None
                        if word_len == 7 and seven_letter_words:
                            index = get_word_index(word, seven_letter_words)
                        elif word_len == 8 and eight_letter_words:
                            index = get_word_index(word, eight_letter_words)

                        prob_text = ""
                        if (word_len == 7 or word_len == 8) and index is not None:
                            prob_text = f" Prob: {index}"
                        elif word_len > 8:
                            prob_text = ""
                        else: # Index is None
                            prob_text = " (N/L)"

                        bingo_line = f"    {word} ({score} pts){prob_text}"
                        if player == 1:
                            game_p1_bingos.append(bingo_line)
                        elif player == 2:
                            game_p2_bingos.append(bingo_line)

                if game_p1_bingos:
                    f.write(f"  {game['player1_name']} Bingos:\n")
                    for line in game_p1_bingos:
                        f.write(line + "\n")
                if game_p2_bingos:
                    f.write(f"  {game['player2_name']} Bingos:\n")
                    for line in game_p2_bingos:
                        f.write(line + "\n")

                f.write("-" * 20 + "\n")

        print(f"Batch statistics saved to {save_filename}")
        show_message_dialog(f"Batch complete.\nStats saved to {save_filename}", "Batch Finished")
    except IOError as e:
        print(f"Error saving batch statistics to {save_filename}: {e}")
        show_message_dialog(f"Error saving batch stats: {e}", "Save Error")
    except NameError as e:
         print(f"Error during batch save - function missing? {e}")
         show_message_dialog(f"Error saving batch stats (missing function?): {e}", "Save Error")
    except Exception as e: # Catch broader exceptions during file writing
        print(f"An unexpected error occurred saving batch statistics: {e}")
        import traceback
        traceback.print_exc() # Print stack trace for debugging
        show_message_dialog(f"Unexpected error saving batch stats: {e}", "Save Error")









# --- AI Logic ---

# --- AI Strategy Helper Functions ---

# --- Static Leave Values & Constants (Assumed to be defined elsewhere in the full code) ---
GOOD_LEAVE_BONUS = {' ': 25.6, 'S': 8.0, 'Z': 5.1, 'X': 3.3, 'E': 0.3, 'A': 0.6, 'R': 1.1, 'N': 0.2,'H': 1.1, 'C': 0.9, 'M': 0.6, 'D': 0.5}
BAD_LEAVE_PENALTY = {'T': -0.1, 'I': -2.1, 'L': -0.2, 'Q': -6.8, 'J': -1.5, 'V': -5.5, 'W': -3.8, 'K': -0.5, 'F': -2.2, 'Y': -0.6, 'U': -5.1, 'B': -2.0, 'G': -2.9, 'P': -0.5, 'O': -2.5}
DUPLICATE_PENALTY = -4.2 # Applied for each duplicate beyond the first
VOWELS = "AEIOU"
BALANCE_PENALTY_FACTOR = -4.0 # Penalty per vowel count away from ideal range
# --- END Constants ---


def evaluate_leave(rack, verbose=False):
    """
    Calculates a score adjustment based on static tile values, duplicate penalties,
    and V/C balance deviation (with special handling for 1 and 2-tile leaves).
    Includes verbose debug printing. Higher scores are better leaves.

    Args:
        rack (list): A list of characters representing the tiles left.
        verbose (bool): If True, print detailed calculation steps.

    Returns:
        int: A score adjustment (positive or negative), rounded from float.
    """
    if not rack:
        return 0

    leave_score = 0.0 # Use float for calculations
    rack_str = "".join(sorted(rack))
    if verbose: print(f"--- Evaluating Leave (Verbose): '{rack_str}' ---")

    rack_counts = Counter(rack)
    num_tiles = len(rack)
    vowel_count = 0

    # 1. Apply Static Bonuses/Penalties for each tile present
    if verbose: print("  Static Tile Values:")
    current_tile_value_score = 0.0
    for tile, count in rack_counts.items():
        if tile in VOWELS: vowel_count += count # Count vowels
        bonus = GOOD_LEAVE_BONUS.get(tile, 0.0)
        penalty = BAD_LEAVE_PENALTY.get(tile, 0.0)
        tile_value = (bonus + penalty) * count

        if verbose:
            if bonus != 0.0: print(f"    - Tile '{tile}' (x{count}): Bonus per tile = {bonus:.1f}, Total = {bonus*count:.1f}")
            if penalty != 0.0: print(f"    - Tile '{tile}' (x{count}): Penalty per tile = {penalty:.1f}, Total = {penalty*count:.1f}")
            if bonus == 0.0 and penalty == 0.0: print(f"    - Tile '{tile}' (x{count}): Neutral value = 0.0")

        current_tile_value_score += tile_value
    if verbose: print(f"    Subtotal (Tile Values): {current_tile_value_score:.1f}")
    leave_score += current_tile_value_score

    # 2. Apply Duplicate Penalties
    if verbose: print("  Duplicate Penalties:")
    current_duplicate_penalty = 0.0
    has_duplicates = False
    for tile, count in rack_counts.items():
        if count > 1:
            has_duplicates = True
            penalty_applied = DUPLICATE_PENALTY * (count - 1)
            if verbose: print(f"    - Tile '{tile}' (x{count}): Penalty for {count-1} duplicate(s) = {penalty_applied:.1f}")
            current_duplicate_penalty += penalty_applied
    if verbose:
        if current_duplicate_penalty == 0.0: print("    None")
        print(f"    Subtotal (Duplicates): {current_duplicate_penalty:.1f}")
    leave_score += current_duplicate_penalty

    # --- MODIFIED: Apply V/C Balance Deviation Penalty (with refined 1/2 tile exceptions) ---
    if verbose: print("  V/C Balance Deviation Penalty:")
    current_balance_penalty = 0.0

    # Determine if the V/C balance check should be skipped
    skip_balance_check = False
    if num_tiles == 1:
        if verbose: print("    (Leave has 1 tile, skipping V/C balance check)")
        skip_balance_check = True
    elif num_tiles == 2 and not has_duplicates:
        # Skip only if it's a balanced V+C pair
        if vowel_count == 1:
             if verbose: print("    (Leave has 2 non-duplicate tiles: 1 Vowel, 1 Consonant - skipping V/C balance check)")
             skip_balance_check = True
        else:
             # It's 2 non-duplicates, but both V or both C - DO NOT SKIP
             if verbose: print("    (Leave has 2 non-duplicate tiles: Both Vowels or Both Consonants - applying V/C balance check)")
             skip_balance_check = False # Explicitly ensure it's not skipped
    elif num_tiles == 0: # Should be caught by initial check, but safe
        skip_balance_check = True

    # Proceed with balance calculation only if not skipped
    if not skip_balance_check:
        consonant_count = num_tiles - vowel_count

        # Calculate ideal range for *this* number of tiles
        # For 2 tiles, the ideal range logic might seem odd, but the deviation calculation works:
        # - If 2V (vowel_count=2), ideal_min=1, ideal_max=1. Deviation = 2-1 = 1. Penalty applied.
        # - If 2C (vowel_count=0), ideal_min=1, ideal_max=1. Deviation = 1-0 = 1. Penalty applied.
        ideal_min = max(1, math.floor(num_tiles / 3))
        ideal_max = max(ideal_min, math.floor(num_tiles * 0.45))

        if verbose: print(f"    Tiles: {num_tiles}, Vowels: {vowel_count}, Consonants: {consonant_count}, Ideal Vowel Range: [{ideal_min}-{ideal_max}]")

        deviation = 0
        if vowel_count < ideal_min:
            deviation = ideal_min - vowel_count
            if verbose: print(f"    Deviation: Too few vowels (deviation {deviation})")
        elif vowel_count > ideal_max:
            deviation = vowel_count - ideal_max
            if verbose: print(f"    Deviation: Too many vowels (deviation {deviation})")

        if deviation > 0:
            current_balance_penalty = BALANCE_PENALTY_FACTOR * deviation
            if verbose: print(f"    Penalty Applied: {current_balance_penalty:.1f}")
        elif verbose:
             # Only print "Balance OK" if we actually performed the check and found no deviation
             print("    Balance OK (No deviation penalty).")

    elif verbose and num_tiles > 0: # Print reason if skipped and rack wasn't empty
        pass # Message already printed above when setting skip_balance_check

    if verbose: print(f"    Subtotal (Balance): {current_balance_penalty:.1f}")
    leave_score += current_balance_penalty
    # --- END MODIFIED ---

    final_adjustment = int(round(leave_score)) # Round float score to nearest int
    if verbose: print(f"--- Final Leave Adjustment for '{rack_str}': {final_adjustment} (Raw Score: {leave_score:.1f}) ---")
    return final_adjustment


def evaluate_single_move(move_dict, leave_evaluation_func):
    """
    Combines the immediate score of a move with the evaluated score of its leave.

    Args:
        move_dict (dict): The dictionary representing the move (must contain 'score' and 'leave').
        leave_evaluation_func (function): The function to use for evaluating the leave (e.g., evaluate_leave).

    Returns:
        float: The combined evaluation score for the move.
               Using float allows for potential future weighting.
    """
    immediate_score = move_dict.get('score', 0)
    leave = move_dict.get('leave', [])
    leave_score_adjustment = leave_evaluation_func(leave)

    # Simple combination for now: add leave adjustment to immediate score
    # Future difficulty levels could apply weights here:
    # e.g., weight_score * immediate_score + weight_leave * leave_score_adjustment
    combined_score = float(immediate_score + leave_score_adjustment)

    return combined_score


def analyze_unseen_pool(remaining_tiles_dict):
    """
    Analyzes the quality of the unseen tile pool (bag + opponent rack).
    NOTE: In reality, we only know the bag for sure. This uses the combined pool.

    Args:
        remaining_tiles_dict (dict): Dictionary mapping letters to counts of unseen tiles.

    Returns:
        dict: Analysis containing counts and a quality score.
              {'total': int, 'vowels': int, 'consonants': int, 'blanks': int,
               's_count': int, 'power_tiles': int, 'bad_tiles': int, 'quality_score': float}
    """
    analysis = {
        'total': 0, 'vowels': 0, 'consonants': 0, 'blanks': 0,
        's_count': 0, 'power_tiles': 0, 'bad_tiles': 0, 'quality_score': 0.0
    }
    if not remaining_tiles_dict:
        return analysis

    vowel_letters = "AEIOU"
    power_letters = "SZJQX" # Tiles often opening up bingos or high scores
    bad_letters = "VWUQKI" # Tiles often considered difficult or less valuable

    raw_quality_sum = 0.0

    for tile, count in remaining_tiles_dict.items():
        if count <= 0: continue # Skip tiles with zero or negative count

        analysis['total'] += count

        if tile == ' ':
            analysis['blanks'] += count
        elif tile in vowel_letters:
            analysis['vowels'] += count
        else:
            analysis['consonants'] += count

        if tile == 'S':
            analysis['s_count'] += count
        if tile in power_letters:
            analysis['power_tiles'] += count
        if tile in bad_letters:
            analysis['bad_tiles'] += count

        # Add to raw quality score based on predefined values
        raw_quality_sum += POOL_TILE_VALUES.get(tile, 0) * count

    # Normalize quality score slightly based on pool size (average value per tile)
    if analysis['total'] > 0:
        analysis['quality_score'] = raw_quality_sum / analysis['total']
    else:
        analysis['quality_score'] = 0.0

    # print(f"DEBUG analyze_unseen_pool: Pool: {remaining_tiles_dict}, Analysis: {analysis}") # Optional debug
    return analysis

def estimate_draw_value(num_to_draw, pool_analysis):
    """
    Provides a simple heuristic estimate of the value gained by drawing tiles.

    Args:
        num_to_draw (int): The number of tiles to be drawn.
        pool_analysis (dict): The result from analyze_unseen_pool.

    Returns:
        float: An estimated score adjustment based on pool quality.
    """
    # Simple heuristic: base value is proportional to pool quality score and number drawn
    # Positive quality score means pool is generally good, negative means generally bad
    estimated_value = pool_analysis.get('quality_score', 0.0) * num_to_draw * POOL_QUALITY_FACTOR
    # print(f"DEBUG estimate_draw_value: Draw {num_to_draw}, Quality {pool_analysis.get('quality_score', 0.0):.2f}, Estimated Value: {estimated_value:.1f}") # Optional debug
    return estimated_value


def find_best_exchange_option(rack, remaining_tiles_dict, bag_count):
    """
    Determines the best set of tiles to exchange to maximize the
    evaluated score of the *remaining* tiles, plus an estimated draw value.

    Args:
        rack (list): The AI's current rack.
        remaining_tiles_dict (dict): Dictionary of unseen tiles (bag + opponent).
        bag_count (int): Number of tiles currently in the bag.

    Returns:
        tuple: (list_of_tiles_to_exchange, best_estimated_value)
               Returns ([], -float('inf')) if no valid exchange is possible or beneficial.
    """
    best_overall_exchange_tiles = []
    best_overall_estimated_value = -float('inf') # Keep track of the best value found across all numbers of tiles exchanged

    if not rack:
        return [], -float('inf')

    pool_analysis = analyze_unseen_pool(remaining_tiles_dict)

    # Iterate through exchanging k=1 to min(7, len(rack)) tiles
    for k in range(1, min(len(rack), 7) + 1):
        # Check if there are enough tiles in the bag to perform this exchange
        if bag_count < k:
            continue # Cannot exchange k tiles if fewer than k are in the bag

        best_leave_for_k = []
        best_leave_score_for_k = -float('inf')
        current_exchange_tiles_for_k = []

        # Find the combination of k tiles to *remove* that leaves the best rack
        # This is equivalent to finding the best combination of (len(rack) - k) tiles to *keep*
        num_to_keep = len(rack) - k
        if num_to_keep < 0: continue # Should not happen, but safety check

        if num_to_keep == 0: # Exchanging all tiles
             leave_score = 0 # No leave value if keeping zero tiles
             kept_tiles = []
             exchanged_tiles = rack[:]
        else:
            best_kept_subset = []
            # Iterate through all combinations of tiles to KEEP
            for kept_subset_tuple in itertools.combinations(rack, num_to_keep):
                kept_subset_list = list(kept_subset_tuple)
                current_leave_score = evaluate_leave(kept_subset_list) # Evaluate the potential leave

                if current_leave_score > best_leave_score_for_k:
                    best_leave_score_for_k = current_leave_score
                    best_kept_subset = kept_subset_list

            # Determine which tiles were exchanged to achieve this best leave
            temp_rack_counts = Counter(rack)
            temp_kept_counts = Counter(best_kept_subset)
            temp_rack_counts.subtract(temp_kept_counts)
            exchanged_tiles = list(temp_rack_counts.elements())
            kept_tiles = best_kept_subset
            leave_score = best_leave_score_for_k # The score of the best leave found for keeping num_to_keep tiles

        # Calculate the total estimated value for exchanging these 'k' tiles
        estimated_value_of_draw = estimate_draw_value(k, pool_analysis)
        total_estimated_value = leave_score + estimated_value_of_draw

        # print(f"DEBUG Exchange Option (k={k}): Exchanging {exchanged_tiles}, Keeping {kept_tiles}, Leave Score: {leave_score}, Draw Est: {estimated_value_of_draw:.1f}, Total Est: {total_estimated_value:.1f}") # Optional debug

        # Update the overall best exchange found so far
        if total_estimated_value > best_overall_estimated_value:
            best_overall_estimated_value = total_estimated_value
            best_overall_exchange_tiles = exchanged_tiles

    # print(f"DEBUG Best Exchange Found: Tiles={best_overall_exchange_tiles}, Est Value={best_overall_estimated_value:.1f}") # Optional debug
    return best_overall_exchange_tiles, best_overall_estimated_value



# --- NEW Endgame Solver Functions ---

def get_rack_value(rack):
    """Calculates the sum of tile values in a rack."""
    return sum(TILE_DISTRIBUTION[tile][1] for tile in rack if tile != ' ')

def calculate_endgame_score_diff(player_rack, opponent_rack, current_score_diff):
    """
    Calculates the final score difference from the perspective of the player
    whose turn it *would* be, assuming the game just ended.
    """
    player_val = get_rack_value(player_rack)
    opponent_val = get_rack_value(opponent_rack)

    if not player_rack: # Player went out
        # Player gains opponent's remaining value, opponent loses nothing extra relative to player
        final_diff = current_score_diff + opponent_val
    elif not opponent_rack: # Opponent went out
        # Player loses their own remaining value, opponent gains nothing extra relative to player
        final_diff = current_score_diff - player_val
    else: # Game ended via passes or other stalemate (treat as simultaneous deduction)
        final_diff = current_score_diff - player_val + opponent_val

    return final_diff

def format_move_for_debug(move, rack_before):
    """ Creates a concise string representation of a move for debug output. """
    if move == "PASS":
        return "PASS"
    elif isinstance(move, dict):
        word = move.get('word_with_blanks', move.get('word', '?'))
        score = move.get('score', 0)
        coord = get_coord(move.get('start', (0,0)), move.get('direction', '?'))
        leave = move.get('leave', [])
        leave_str = "".join(sorted(l if l != ' ' else '?' for l in leave))
        # Rack before might be useful context, but keep it concise
        # rack_before_str = "".join(sorted(l if l != ' ' else '?' for l in rack_before))
        # return f"[{word} {coord} ({score:+}) L:{leave_str} R:{rack_before_str}]"
        return f"[{word} {coord} ({score:+}) L:{leave_str}]"
    else:
        return "[INVALID MOVE]"

# --- NEW Helper Function for Drawing Indicator ---
def draw_endgame_solving_indicator():
    """Draws the 'AI Solving Endgame...' text."""
    # Ensure necessary globals like screen, dialog_font, RED, WINDOW_WIDTH are accessible
    # Or pass them as arguments if preferred
    solve_text = "AI Solving Endgame..."
    solve_surf = dialog_font.render(solve_text, True, RED)
    # Position it somewhere noticeable, e.g., top center
    solve_rect = solve_surf.get_rect(centerx=WINDOW_WIDTH // 2, top=10)
    # Optional: Add a semi-transparent background
    bg_rect = solve_rect.inflate(20, 10)
    bg_surf = pygame.Surface(bg_rect.size, pygame.SRCALPHA)
    bg_surf.fill((200, 200, 200, 180)) # Grayish background
    screen.blit(bg_surf, bg_rect)
    screen.blit(solve_surf, solve_rect)




# --- NEW Heuristic Evaluation Function ---
def evaluate_endgame_heuristic(rack_player, rack_opponent, current_score_diff):
    """
    Estimates the final score difference at a search depth limit.
    A simple heuristic: assumes the game ends now and calculates score diff.
    More complex heuristics could consider tile values left, etc.
    """
    # For now, use the same logic as the terminal calculation.
    # This assumes the player whose turn it is *might* go out or deductions happen.
    # It's not perfect but provides a baseline evaluation.
    return calculate_endgame_score_diff(rack_player, rack_opponent, current_score_diff)



# --- MODIFIED Endgame Solver Function (with Depth Limit & Heuristic) ---
def negamax_endgame(rack_player, rack_opponent, tiles, blanks, board,
                    current_score_diff, alpha, beta, depth, pass_count,
                    max_depth, search_depth_limit): # Added search_depth_limit
    """
    Negamax solver for the endgame (empty bag) with depth limit.
    Returns (best_score_diff_for_player, best_move_sequence).
    Score difference is from the perspective of the player whose turn it is.
    """
    # --- Debug Print: Function Entry ---
    if depth < 4: # Limit debug print depth
        print(f"{'  ' * depth}DEBUG Depth {depth}: Enter Negamax. PlayerRack={''.join(sorted(rack_player))}, OppRack={''.join(sorted(rack_opponent))}, ScoreDiff={current_score_diff:.1f}, Alpha={alpha:.1f}, Beta={beta:.1f}, PassCount={pass_count}")

    # --- Base Cases: Game Over OR Depth Limit Reached ---
    # MODIFICATION: Check depth limit first
    if depth >= search_depth_limit:
        heuristic_score = evaluate_endgame_heuristic(rack_player, rack_opponent, current_score_diff)
        if depth < 4: print(f"{'  ' * depth}DEBUG Depth {depth}: Depth Limit Reached. HeuristicScore={heuristic_score:.1f}")
        return heuristic_score, [] # Return heuristic score and empty sequence

    if not rack_player or not rack_opponent or pass_count >= 6:
        final_diff = calculate_endgame_score_diff(rack_player, rack_opponent, current_score_diff)
        if depth < 4: print(f"{'  ' * depth}DEBUG Depth {depth}: Terminal Node. FinalDiff={final_diff:.1f}")
        return final_diff, []

    # --- Generate Moves ---
    possible_moves = generate_all_moves_gaddag(rack_player, tiles, board, blanks, GADDAG_STRUCTURE.root)
    if possible_moves is None: possible_moves = []

    # --- Include Pass as an option ---
    can_pass = True

    # --- Evaluate Moves ---
    best_value = -float('inf')
    best_sequence = None

    # Heuristic move ordering
    playout_moves = [m for m in possible_moves if len(m.get('leave', rack_player)) == 0]
    other_moves = [m for m in possible_moves if len(m.get('leave', rack_player)) > 0]
    other_moves.sort(key=lambda m: m.get('score', 0), reverse=True)

    ordered_moves = playout_moves + other_moves
    if can_pass:
        ordered_moves.append("PASS")

    if not ordered_moves: # No plays and cannot pass
        final_diff = calculate_endgame_score_diff(rack_player, rack_opponent, current_score_diff)
        if depth < 4: print(f"{'  ' * depth}DEBUG Depth {depth}: No moves possible. Terminal. FinalDiff={final_diff:.1f}")
        return final_diff, []

    # --- Iterate Through Moves ---
    for move_index, move in enumerate(ordered_moves):
        # Create copies for simulation
        sim_tiles = copy.deepcopy(tiles)
        sim_blanks = blanks.copy()
        sim_rack_player = rack_player[:]
        sim_rack_opponent = rack_opponent[:]
        sim_score_diff = current_score_diff
        sim_pass_count = pass_count
        current_move_details = move

        # --- Debug Print: Trying a Move ---
        if depth < 4: print(f"{'  ' * depth}DEBUG Depth {depth}: Trying move {move_index+1}/{len(ordered_moves)}: {format_move_for_debug(move, rack_player)}")

        if move == "PASS":
            sim_pass_count += 1
            # Recursive call for opponent's turn, passing depth limit
            value, subsequent_sequence = negamax_endgame(
                sim_rack_opponent, sim_rack_player, sim_tiles, sim_blanks, board,
                -sim_score_diff, -beta, -alpha, depth + 1, sim_pass_count, max_depth, search_depth_limit
            )
            value = -value # Flip score back
        else: # It's a play move (dictionary)
            sim_pass_count = 0
            newly_placed_details = move.get('newly_placed', [])
            move_blanks = move.get('blanks', set())
            move_score = move.get('score', 0)

            # Simulate placing tiles and updating rack
            temp_rack = sim_rack_player[:]
            valid_placement = True
            for r, c, letter in newly_placed_details:
                if 0 <= r < GRID_SIZE and 0 <= c < GRID_SIZE:
                    sim_tiles[r][c] = letter
                    if (r, c) in move_blanks:
                        sim_blanks.add((r, c))
                        if ' ' in temp_rack: temp_rack.remove(' ')
                        else: valid_placement = False; break
                    else:
                        if letter in temp_rack: temp_rack.remove(letter)
                        else: valid_placement = False; break
                else: valid_placement = False; break

            if not valid_placement:
                 if depth < 4: print(f"{'  ' * depth}DEBUG Depth {depth}: Skipping move due to simulation error.")
                 continue # Skip if simulation failed

            sim_rack_player = temp_rack
            sim_score_diff += move_score

            # Recursive call for opponent, passing depth limit
            value, subsequent_sequence = negamax_endgame(
                sim_rack_opponent, sim_rack_player, sim_tiles, sim_blanks, board,
                -sim_score_diff, -beta, -alpha, depth + 1, sim_pass_count, max_depth, search_depth_limit
            )
            value = -value # Flip score back

        # --- Debug Print: Value Returned from Recursion ---
        if depth < 4: print(f"{'  ' * depth}DEBUG Depth {depth}: Move {format_move_for_debug(move, rack_player)} resulted in value {value:.1f}")

        # --- Update Best Sequence ---
        if value > best_value:
            if depth < 4: print(f"{'  ' * depth}DEBUG Depth {depth}: New best value! {value:.1f} > {best_value:.1f}")
            best_value = value
            best_sequence = [current_move_details] + subsequent_sequence

        # --- Alpha-Beta Pruning ---
        alpha = max(alpha, value)
        if alpha >= beta:
            if depth < 4: print(f"{'  ' * depth}DEBUG Depth {depth}: Pruning (alpha={alpha:.1f} >= beta={beta:.1f})")
            break # Prune

    # If no moves were possible at all
    if best_sequence is None:
         final_diff = calculate_endgame_score_diff(rack_player, rack_opponent, current_score_diff)
         if depth < 4: print(f"{'  ' * depth}DEBUG Depth {depth}: No valid sequence found from this node. Returning terminal diff {final_diff:.1f}")
         return final_diff, []

    # --- Debug Print: Returning from Function ---
    if depth < 4: print(f"{'  ' * depth}DEBUG Depth {depth}: Returning Best Value={best_value:.1f}, Seq Start={format_move_for_debug(best_sequence[0], rack_player) if best_sequence else 'None'}")

    return best_value, best_sequence


# --- MODIFIED Top-Level Solver Function (Passes Depth Limit) ---
def solve_endgame(rack_player, rack_opponent, tiles, blanks, board, current_score_diff):
    """
    Top-level function to initiate the endgame solver with a depth limit.
    Calls negamax once and prints the single best sequence found.
    Returns the best first move to make.
    """
    global is_solving_endgame, endgame_start_time
    print("--- Starting Endgame Solver ---")
    is_solving_endgame = True
    endgame_start_time = time.time()

    # Make deep copies to avoid modifying original game state during search
    tiles_copy = copy.deepcopy(tiles)
    blanks_copy = blanks.copy()
    rack_player_copy = rack_player[:]
    rack_opponent_copy = rack_opponent[:]

    # --- MODIFICATION: Define and pass search depth limit ---
    # Adjust this value based on performance vs. strength trade-off
    # 6 or 8 is often a reasonable starting point for endgames
    search_depth_limit = 6
    max_possible_depth = len(rack_player_copy) + len(rack_opponent_copy)
    actual_search_depth = min(search_depth_limit, max_possible_depth) # Don't search deeper than possible
    print(f"--- Endgame Search Depth Limit: {actual_search_depth} ---")
    # --- END MODIFICATION ---


    # Initial call to negamax, passing the depth limit
    best_score_diff, best_move_sequence = negamax_endgame(
        rack_player_copy, rack_opponent_copy, tiles_copy, blanks_copy, board,
        current_score_diff, -float('inf'), float('inf'), 0, 0,
        max_possible_depth, actual_search_depth # Pass both max possible and actual limit
    )


    solve_duration = time.time() - endgame_start_time
    print(f"--- Endgame Solver Finished ({solve_duration:.2f}s) ---")
    is_solving_endgame = False # Reset flag

    # Print the single best sequence found
    if best_move_sequence:
        # Use the score returned by the limited search (might be heuristic)
        print(f"Best Endgame Sequence Found (Score: {best_score_diff:.0f} at depth {actual_search_depth}):")
        current_player_idx = 0 # 0 for initial player, 1 for opponent
        turn_num = 1
        temp_rack_p = rack_player[:] # Use copies for printing debug sequence
        temp_rack_o = rack_opponent[:]
        # Only print the sequence up to the search depth limit if desired,
        # or the full sequence returned (which might end with heuristic moves)
        # For simplicity, print the whole sequence returned.
        for i, move in enumerate(best_move_sequence):
            player_indicator = "P1►" if current_player_idx == 0 else "P2►"
            rack_to_use = temp_rack_p if current_player_idx == 0 else temp_rack_o
            print(f"  {turn_num}. {player_indicator} {format_move_for_debug(move, rack_to_use)}")

            # Simulate rack change for next debug line (approximate)
            if move != "PASS":
                 if isinstance(move, dict):
                     # Estimate leave based on newly_placed count
                     newly_placed_count = len(move.get('newly_placed', []))
                     if current_player_idx == 0:
                         temp_rack_p = temp_rack_p[newly_placed_count:]
                     else:
                         temp_rack_o = temp_rack_o[newly_placed_count:]
                 else: # Pass move doesn't change rack
                     pass

            current_player_idx = 1 - current_player_idx # Switch player
            if current_player_idx == 0: turn_num += 1 # Increment turn number after P2 moves

        return best_move_sequence[0] # Return only the first move to make
    else:
        print("Endgame Solver: No optimal sequence found (e.g., immediate game end).")
        return "PASS" # Default to passing if no sequence found







def ai_turn(turn, racks, tiles, board, blanks, scores, bag, first_play, pass_count, exchange_count, consecutive_zero_point_turns, player_names, dropdown_open=False, hinting=False, showing_all_words=False, letter_checks=None):
    """
    Handles the AI's turn, selecting moves based on score and leave evaluation,
    incorporating the new exchange strategy, practice mode rules, and endgame solver.
    Includes screen update before long endgame calculation and checks USE_ENDGAME_SOLVER.
    Checks for playable bingos in BBB mode. Uses updated get_coord for history.
    """
    global last_word, last_score, last_start, last_direction, move_history, current_replay_turn, practice_mode, GADDAG_STRUCTURE, last_played_highlight_coords
    global is_solving_endgame # Access the global flag
    global USE_ENDGAME_SOLVER
    global paused_for_bingo_practice # Access BBB flag

    player_idx = turn - 1
    opponent_idx = 1 - player_idx
    current_rack = racks[player_idx][:] # Use a copy for analysis
    bag_count = len(bag)
    print(f"AI Player {turn} turn started. Rack: {''.join(sorted(current_rack))}, Bag: {bag_count}, Practice: {practice_mode}") # Log sorted rack

    # --- MODIFICATION: Endgame Solver Check (with USE_ENDGAME_SOLVER flag) ---
    if USE_ENDGAME_SOLVER and bag_count == 0 and practice_mode != "eight_letter" and not is_solving_endgame:
        print("AI: Bag empty and solver enabled, entering endgame solver...")
        opponent_rack = racks[opponent_idx][:]
        current_score_diff = scores[player_idx] - scores[opponent_idx]

        # --- Update screen to show indicator BEFORE solving ---
        is_solving_endgame = True # Set flag
        # Force redraw of the current screen state including the indicator
        screen.fill(WHITE) # Clear screen
        # Simplified redraw - adapt based on actual drawing dependencies
        for r in range(GRID_SIZE): # Draw board and tiles
            for c in range(GRID_SIZE):
                pygame.draw.rect(screen, board[r][c], (40 + c * SQUARE_SIZE, 40 + r * SQUARE_SIZE, SQUARE_SIZE, SQUARE_SIZE)); pygame.draw.rect(screen, BLACK, (40 + c * SQUARE_SIZE, 40 + r * SQUARE_SIZE, SQUARE_SIZE, SQUARE_SIZE), 1)
                if tiles[r][c]:
                    tile_char = tiles[r][c]; is_blank_on_board = (r, c) in blanks;
                    tile_bg_color = GREEN
                    if is_blank_on_board: center = (40 + c * SQUARE_SIZE + SQUARE_SIZE // 2, 40 + r * SQUARE_SIZE + SQUARE_SIZE // 2); radius = SQUARE_SIZE // 2 - 3; pygame.draw.circle(screen, BLACK, center, radius); text_surf = font.render(tile_char, True, WHITE); text_rect = text_surf.get_rect(center=center); screen.blit(text_surf, text_rect)
                    else: tile_rect = pygame.Rect(40 + c * SQUARE_SIZE + 2, 40 + r * SQUARE_SIZE + 2, SQUARE_SIZE - 4, SQUARE_SIZE - 4); pygame.draw.rect(screen, tile_bg_color, tile_rect); text_surf = font.render(tile_char, True, BLACK); text_rect = text_surf.get_rect(center=tile_rect.center); screen.blit(text_surf, text_rect)
        draw_rack(1, racks[0], scores, turn, player_names) # Draw racks
        if practice_mode != "eight_letter": draw_rack(2, racks[1], scores, turn, player_names)
        draw_scoreboard(screen, move_history, 0, scores, is_ai, player_names) # Draw scoreboard (scroll 0)
        # Draw the indicator itself using the dedicated function
        draw_endgame_solving_indicator() # Use the helper
        pygame.display.flip() # Update the display NOW
        # --- End screen update ---

        # Call the endgame solver (this might take time)
        best_first_move = solve_endgame(current_rack, opponent_rack, tiles, blanks, board, current_score_diff)
        # is_solving_endgame is reset inside solve_endgame after calculation

        if best_first_move == "PASS":
            print("AI Endgame: Optimal move is PASS.")
            action_chosen = 'pass'
            best_play_move = None # Ensure no play is attempted
        elif isinstance(best_first_move, dict):
            print(f"AI Endgame: Optimal move is PLAY: {format_move_for_debug(best_first_move, current_rack)}")
            action_chosen = 'play'
            best_play_move = best_first_move # Use the move returned by the solver
        else: # Solver returned None or unexpected value
            print("AI Endgame: Solver did not return a valid move. Defaulting to pass.")
            action_chosen = 'pass'
            best_play_move = None

        # --- Skip normal move generation and evaluation ---
        # Execute the chosen action (play or pass) directly
        move_rack_before = racks[player_idx][:]
        exchanged_tiles_for_history = []
        next_turn = turn
        drawn_tiles = []
        newly_placed = []
        move_type = ''
        score = 0
        word = ''
        positions = []
        blanks_used = set()
        coord = '' # Initialize coord
        word_with_blanks = ''
        is_bingo = False

        if action_chosen == 'play' and best_play_move:
            next_turn, drawn_tiles, newly_placed = play_hint_move(best_play_move, tiles, racks, blanks, scores, turn, bag, board) # Bag is empty, drawn_tiles will be []
            move_type = 'place'
            score = best_play_move.get('score', 0)
            word = best_play_move.get('word', 'N/A')
            positions = best_play_move.get('positions', [])
            blanks_used = best_play_move.get('blanks', set())
            start = best_play_move.get('start', (0,0))
            direction = best_play_move.get('direction', 'right')
            # --- Use updated get_coord ---
            coord = get_coord(start, direction)
            # --- End Use updated get_coord ---
            word_with_blanks = best_play_move.get('word_with_blanks', '')
            is_bingo = best_play_move.get('is_bingo', False)
            first_play = False
            consecutive_zero_point_turns = 0
            pass_count = 0
            exchange_count = 0
            last_played_highlight_coords = set((pos[0], pos[1]) for pos in positions)
        elif action_chosen == 'pass':
            move_type = 'pass'
            score = 0
            consecutive_zero_point_turns += 1
            pass_count += 1
            exchange_count = 0
            next_turn = 3 - turn
            last_played_highlight_coords = set()

        # Record Move
        move_data = { 'player': turn, 'move_type': move_type, 'rack': move_rack_before, 'score': score, 'word': word, 'positions': positions, 'blanks': blanks_used, 'drawn': drawn_tiles, 'coord': coord, 'word_with_blanks': word_with_blanks, 'is_bingo': is_bingo }
        if move_type == 'place' and best_play_move: move_data['newly_placed'] = best_play_move.get('newly_placed', newly_placed)
        move_history.append(move_data)
        current_replay_turn = len(move_history)

        # Return state after executing the solver's first move
        return next_turn, first_play, pass_count, exchange_count, consecutive_zero_point_turns, [], dropdown_open, hinting, showing_all_words, False, None, False # Reset paused state

    # --- Normal Turn Logic (if not in endgame solver OR solver disabled) ---
    paused_for_power_tile = False
    paused_for_bingo_practice = False # Initialize BBB pause flag
    current_power_tile = None
    all_moves = []

    # Generate moves using GADDAG
    if GADDAG_STRUCTURE:
        all_moves = generate_all_moves_gaddag(racks[player_idx], tiles, board, blanks, GADDAG_STRUCTURE.root)
    else:
        print("ERROR: AI cannot generate moves, GADDAG not loaded.")
        all_moves = []

    if all_moves is None: all_moves = []
    print(f"AI Player {turn} generated {len(all_moves)} raw moves.")

    # Filter moves for "Only Fives" practice mode
    if practice_mode == "only_fives":
        original_tiles_copy = [row[:] for row in tiles] # Copy current board
        original_blanks_copy = blanks.copy()
        filtered_moves = []
        for move in all_moves:
            temp_tiles = [row[:] for row in original_tiles_copy]
            temp_blanks = original_blanks_copy.copy()
            newly_placed_details = move.get('newly_placed', [])
            if not newly_placed_details: continue

            for r, c, letter in newly_placed_details:
                 if 0 <= r < GRID_SIZE and 0 <= c < GRID_SIZE:
                     temp_tiles[r][c] = letter
                     if (r, c) in move.get('blanks', set()):
                         temp_blanks.add((r, c))

            words_formed_details = find_all_words_formed(newly_placed_details, temp_tiles)
            if any(len("".join(t[2] for t in word_detail)) == 5 for word_detail in words_formed_details):
                filtered_moves.append(move)
        all_moves = filtered_moves # Replace all_moves with the filtered list
        print(f"AI Player {turn} filtered moves for 'Only Fives'. Remaining: {len(all_moves)}")

    # --- Practice Mode Pause Checks ---
    # Power Tile Practice Pause Check
    if practice_mode == "power_tiles" and letter_checks:
        checked_power_tiles = {letter for i, letter in enumerate(['J', 'Q', 'X', 'Z']) if letter_checks[i]}
        power_tiles_on_rack = sorted([tile for tile in current_rack if tile in checked_power_tiles])
        if power_tiles_on_rack:
            current_power_tile = power_tiles_on_rack[0]
            paused_for_power_tile = True
            print(f"AI turn paused for power tile practice. Target: {current_power_tile}")
            return turn, first_play, pass_count, exchange_count, consecutive_zero_point_turns, all_moves, dropdown_open, hinting, showing_all_words, paused_for_power_tile, current_power_tile, False

    # Bingo, Bango, Bongo Practice Pause Check
    elif practice_mode == "bingo_bango_bongo":
        found_bingo = False
        for move in all_moves:
            if move.get('is_bingo', False):
                found_bingo = True
                break
        if found_bingo:
            paused_for_bingo_practice = True
            print(f"AI turn paused for Bingo, Bango, Bongo practice. Bingo found.")
            return turn, first_play, pass_count, exchange_count, consecutive_zero_point_turns, all_moves, dropdown_open, hinting, showing_all_words, False, None, paused_for_bingo_practice

    # --- AI Action Decision Logic (Normal Turn or Non-Pausing Practice) ---
    move_rack_before = racks[player_idx][:]
    exchanged_tiles_for_history = []
    action_chosen = 'pass' # Default action
    best_play_move = None
    best_play_evaluation = -float('inf')
    best_exchange_tiles = []
    best_exchange_evaluation = -float('inf')

    can_play = bool(all_moves)
    can_exchange_proactively = bag_count >= 7

    # 1. Evaluate Best Play
    if can_play:
        print(f"AI {turn} evaluating {len(all_moves)} plays...")
        current_top_raw_score = -float('inf')
        top_raw_score_move = None # Keep track for logging

        for move in all_moves:
            evaluated_score = evaluate_single_move(move, evaluate_leave) # Pass the function itself
            immediate_score = move.get('score', 0)

            if evaluated_score > best_play_evaluation:
                best_play_evaluation = evaluated_score
                best_play_move = move
            if immediate_score > current_top_raw_score:
                 current_top_raw_score = immediate_score
                 top_raw_score_move = move
        print("-" * 20)
        print(f"AI {turn} Play Evaluation Complete:")
        if top_raw_score_move: print(f"  Top Raw Score Move : '{top_raw_score_move.get('word','N/A')}' ({top_raw_score_move.get('score',0)} pts)")
        else: print("  Top Raw Score Move : None Found")
        if best_play_move:
            chosen_score = best_play_move.get('score', 0); chosen_leave = best_play_move.get('leave', []); chosen_leave_str = ''.join(sorted(chosen_leave))
            print(f"  Best Evaluated Play: '{best_play_move.get('word','N/A')}' (Raw Score: {chosen_score})"); print(f"    Leave Tiles: '{chosen_leave_str}'")
            leave_adjust = evaluate_leave(chosen_leave, verbose=False); # Set verbose=False for less output
            print(f"    --------------------"); print(f"    Final Play Eval Score: {chosen_score + leave_adjust:.2f} (Raw: {chosen_score}, Leave Adj: {leave_adjust})")
        else: print("  Best Evaluated Play: None Found")
        print("-" * 20)


    # 2. Evaluate Best Exchange Option
    if not can_play or can_exchange_proactively:
        print(f"AI {turn} evaluating exchange options...")
        remaining_tiles_dict = get_remaining_tiles(racks[player_idx], tiles, blanks)
        best_exchange_tiles, best_exchange_evaluation = find_best_exchange_option(racks[player_idx], remaining_tiles_dict, bag_count)
        if best_exchange_tiles: print(f"  Best Exchange Option Found: Exchange {len(best_exchange_tiles)} tiles ({''.join(sorted(best_exchange_tiles))}), Est Value: {best_exchange_evaluation:.1f}")
        else: print("  No beneficial exchange option found.")


    # 3. Make the Decision
    if can_play:
        action_chosen = 'play'
        if can_exchange_proactively and best_exchange_tiles:
            is_low_score_play = best_play_move and best_play_move.get('score', 0) < LOW_SCORE_THRESHOLD
            is_exchange_significantly_better = best_exchange_evaluation > best_play_evaluation + EXCHANGE_PREFERENCE_THRESHOLD
            if is_low_score_play and is_exchange_significantly_better:
                print(f"AI {turn}: DECISION -> Proactive Exchange (Low score play '{best_play_move.get('word','N/A')}' ({best_play_move.get('score',0)}) and Exchange eval {best_exchange_evaluation:.1f} > Play eval {best_play_evaluation:.1f} + {EXCHANGE_PREFERENCE_THRESHOLD})")
                action_chosen = 'exchange'
            elif not is_low_score_play and is_exchange_significantly_better:
                 print(f"AI {turn}: DECISION -> Proactive Exchange (Exchange eval {best_exchange_evaluation:.1f} > Play eval {best_play_evaluation:.1f} + {EXCHANGE_PREFERENCE_THRESHOLD})")
                 action_chosen = 'exchange'
            else:
                 print(f"AI {turn}: DECISION -> Play ('{best_play_move.get('word','N/A')}') (Exchange not sufficiently better or play score not low)")
    elif best_exchange_tiles:
        print(f"AI {turn}: DECISION -> Mandatory Exchange (No plays possible)")
        action_chosen = 'exchange'
    else:
        print(f"AI {turn}: DECISION -> Pass (No plays, no viable exchange)")
        action_chosen = 'pass'

    # --- Execute Action (Normal Turn) ---
    next_turn = turn # Default, might change
    drawn_tiles = []
    newly_placed = []
    move_type = ''
    score = 0
    word = ''
    positions = []
    blanks_used = set()
    coord = '' # Initialize coord
    word_with_blanks = ''
    is_bingo = False

    if action_chosen == 'play':
        if best_play_move:
            print(f"AI {turn} playing move: '{best_play_move.get('word', 'N/A')}'")
            next_turn, drawn_tiles, newly_placed = play_hint_move(best_play_move, tiles, racks, blanks, scores, turn, bag, board)
            move_type = 'place'; score = best_play_move.get('score', 0); word = best_play_move.get('word', 'N/A'); positions = best_play_move.get('positions', []); blanks_used = best_play_move.get('blanks', set()); start = best_play_move.get('start', (0,0)); direction = best_play_move.get('direction', 'right');
            # --- Use updated get_coord ---
            coord = get_coord(start, direction);
            # --- End Use updated get_coord ---
            word_with_blanks = best_play_move.get('word_with_blanks', ''); is_bingo = best_play_move.get('is_bingo', False)
            first_play = False; consecutive_zero_point_turns = 0; pass_count = 0; exchange_count = 0; last_played_highlight_coords = set((pos[0], pos[1]) for pos in positions)
        else:
            print(f"AI {turn} Error: Action was 'play' but best_play_move is None. Passing.")
            action_chosen = 'pass' # Fallback

    if action_chosen == 'exchange':
        if best_exchange_tiles:
            print(f"AI {turn} exchanging {len(best_exchange_tiles)} tiles: {''.join(sorted(best_exchange_tiles))}")
            exchanged_tiles_for_history = best_exchange_tiles[:]; current_rack_list = racks[player_idx]
            temp_rack_after_exchange = []; exchange_counts = Counter(exchanged_tiles_for_history)
            for tile in current_rack_list:
                if exchange_counts.get(tile, 0) > 0: exchange_counts[tile] -= 1
                else: temp_rack_after_exchange.append(tile)
            num_to_draw = len(exchanged_tiles_for_history); drawn_tiles = [bag.pop() for _ in range(num_to_draw) if bag]; temp_rack_after_exchange.extend(drawn_tiles); racks[player_idx] = temp_rack_after_exchange
            bag.extend(exchanged_tiles_for_history); random.shuffle(bag)
            move_type = 'exchange'; score = 0; consecutive_zero_point_turns += 1; exchange_count += 1; pass_count = 0; next_turn = 3 - turn; last_played_highlight_coords = set()
        else:
            print(f"AI {turn} Error: Action was 'exchange' but best_exchange_tiles is empty. Passing.")
            action_chosen = 'pass' # Fallback

    if action_chosen == 'pass':
        print(f"AI {turn} passing.")
        move_type = 'pass'; score = 0; consecutive_zero_point_turns += 1; pass_count += 1; exchange_count = 0; next_turn = 3 - turn; last_played_highlight_coords = set()

    # --- Record Move ---
    move_data = { 'player': turn, 'move_type': move_type, 'rack': move_rack_before, 'score': score, 'word': word, 'positions': positions, 'blanks': blanks_used, 'drawn': drawn_tiles, 'coord': coord, 'word_with_blanks': word_with_blanks, 'is_bingo': is_bingo }
    if move_type == 'exchange': move_data['exchanged_tiles'] = exchanged_tiles_for_history
    if move_type == 'place' and best_play_move: move_data['newly_placed'] = best_play_move.get('newly_placed', newly_placed)
    move_history.append(move_data)
    current_replay_turn = len(move_history)

    # --- Return updated state ---
    return next_turn, first_play, pass_count, exchange_count, consecutive_zero_point_turns, [], dropdown_open, hinting, showing_all_words, paused_for_power_tile, current_power_tile, paused_for_bingo_practice





# End of Part 6



# Part 7

def get_replay_state(turn_idx, initial_racks):
    """
    Recreate the game state up to turn_idx ITERATIVELY.
    Sorts the racks alphabetically before returning.
    """
    # Start with initial state (ensure deep copies)
    tiles_state = [['' for _ in range(GRID_SIZE)] for _ in range(GRID_SIZE)]
    blanks_state = set()
    scores_state = [0, 0]

    if not isinstance(initial_racks, list) or len(initial_racks) != 2 or \
       not isinstance(initial_racks[0], list) or not isinstance(initial_racks[1], list):
        print(f"Error: Invalid initial_racks format in get_replay_state: {initial_racks}")
        return tiles_state, blanks_state, scores_state, [[], []]

    racks_state = [initial_racks[0][:], initial_racks[1][:]]

    # Apply moves sequentially up to turn_idx
    for i in range(turn_idx):
        if i >= len(move_history):
             print(f"Warning: Replay index {i} out of bounds for move_history (len {len(move_history)})")
             break
        move = move_history[i]
        player_idx = move['player'] - 1

        # Get the rack state *before* applying this move's changes
        current_rack_before_move = racks_state[player_idx][:]
        rack_after_move = current_rack_before_move[:] # Work with a copy for this move

        if move['move_type'] == 'place':
            positions = move.get('positions', [])
            blanks_in_move = move.get('blanks', set())

            # Apply board changes and update rack based on *this* move
            for r, c, letter in positions:
                # Check if this square was empty *before* this move (using current tiles_state)
                is_newly_placed = (0 <= r < GRID_SIZE and 0 <= c < GRID_SIZE and not tiles_state[r][c])

                # Place tile on board state
                if 0 <= r < GRID_SIZE and 0 <= c < GRID_SIZE:
                    tiles_state[r][c] = letter
                    if (r, c) in blanks_in_move:
                        blanks_state.add((r, c))
                else:
                    print(f"Replay Warning: Invalid position ({r},{c}) in move {i}")
                    continue # Skip processing this invalid position

                # If it was newly placed, remove the corresponding tile from the rack_after_move
                if is_newly_placed:
                    if (r,c) in blanks_in_move:
                        if ' ' in rack_after_move: rack_after_move.remove(' ')
                        else: print(f"Replay Warning: Tried to remove blank from rack for move {i}, but not found.")
                    else:
                        if letter in rack_after_move: rack_after_move.remove(letter)
                        else: print(f"Replay Warning: Tried to remove '{letter}' from rack for move {i}, but not found.")

            # Update score
            scores_state[player_idx] += move.get('score', 0)
            # Add drawn tiles to the rack for the *next* turn's state
            rack_after_move.extend(move.get('drawn', []))
            racks_state[player_idx] = rack_after_move

        elif move['move_type'] == 'exchange':
            # Update rack: remove exchanged, add drawn
            exchanged = move.get('exchanged_tiles', [])
            for tile in exchanged:
                 if tile in rack_after_move: rack_after_move.remove(tile)
                 else: print(f"Replay Warning: Tried to remove exchanged tile '{tile}' from rack for move {i}, but not found.")
            rack_after_move.extend(move.get('drawn', []))
            racks_state[player_idx] = rack_after_move
            # Score doesn't change

        elif move['move_type'] == 'pass':
            # No change to board, score, or rack content needed for the state
            racks_state[player_idx] = rack_after_move # Rack state carries over

    # Sort racks alphabetically before returning for replay display
    for rack in racks_state:
        rack.sort() # In-place sort

    # Return the state *after* turn_idx moves have been applied
    return tiles_state, blanks_state, scores_state, racks_state













def main():
    # --- MODIFICATION: Declare key modified globals ---
    global turn, previous_turn, game_over_state, final_scores, running_inner, batch_stop_requested
    global return_to_mode_selection, human_played, pass_count, exchange_count, consecutive_zero_point_turns
    global dropdown_open, exchanging, hinting, showing_all_words, selected_tiles, typing, selected_square
    global word_positions, original_tiles, original_rack, dragged_tile, drag_pos, dragging, scroll_offset
    global last_played_highlight_coords, current_replay_turn, showing_stats, dialog_x, dialog_y
    global paused_for_power_tile, current_power_tile, power_tile_message_shown
    global practice_solved, showing_practice_end_dialog, practice_end_message
    # Also include the main state variables accessed globally
    global bag, last_word, last_score, last_start, last_direction, move_history, replay_mode, game_mode, is_ai, practice_mode, board, tiles, racks, blanks, main_called, scores, GADDAG_STRUCTURE
    global is_loaded_game, replay_initial_shuffled_bag, initial_racks
    global number_checks # Make it accessible within main
    global is_solving_endgame # Access global flag
    global USE_ENDGAME_SOLVER
    global is_batch_running, total_batch_games, current_batch_game_num, batch_results, initial_game_config
    # --- ADDED: Stats dialog position and dragging state ---
    global stats_scroll_offset, stats_dialog_x, stats_dialog_y, stats_dialog_dragging, stats_dialog_drag_offset
    # --- ADDED: Drag offset for tile dragging ---
    global drag_offset
    # --- ADDED: Scroll offset for All Words dialog ---
    global all_words_scroll_offset
    # --- ADDED: BBB Practice Mode Flags ---
    global paused_for_bingo_practice, bingo_practice_message_shown
    # --- END MODIFICATION ---


    print("--- main() function entered ---")

    # --- Initialization Block (Runs Once) ---
    if not main_called:
        print("--- main(): 'if not main_called' block entered ---")
        main_called = True

        is_batch_running = False
        total_batch_games = 0
        current_batch_game_num = 0
        batch_results = []
        initial_game_config = {} # Store config for resets

        print("--- main(): Calling mode_selection_screen()... ---")
        selected_mode_result, return_data = mode_selection_screen()
        print(f"--- main(): mode_selection_screen() returned: mode={selected_mode_result} ---")

        # --- Load GADDAG Structure ---
        try:
            print("Attempting to load GADDAG structure from gaddag.pkl...")
            load_start = time.time()
            with open("gaddag.pkl", 'rb') as f_load: GADDAG_STRUCTURE = pickle.load(f_load)
            print(f"GADDAG loaded in {time.time() - load_start:.2f} seconds.")
        except Exception as e: print(f"\n--- ERROR Loading GADDAG: {e} ---"); pygame.quit(); sys.exit()
        print("GADDAG loading block finished.")

        # --- Game State Initialization ---
        print("--- main(): Starting game state initialization... ---")
        if selected_mode_result == "LOADED_GAME": # Handle LOADED_GAME mode
            print("--- main(): Handling LOADED_GAME setup ---")
            game_mode = "LOADED_GAME"; is_loaded_game = True
            player_names, loaded_history, final_scores_loaded = return_data
            move_history = loaded_history; final_scores = final_scores_loaded
            base_bag = create_standard_bag(); random.shuffle(base_bag); replay_initial_shuffled_bag = base_bag[:]
            board, _, tiles = create_board(); scores = [0, 0]; blanks = set(); racks = [[], []]; bag = []
            replay_mode = True; current_replay_turn = 0; practice_mode = None; is_ai = [False, False]; human_player = 1; first_play = False
            initial_racks = [[], []] # GCG Load doesn't provide initial racks directly
            number_checks = [True] * 6 # Default to all lengths allowed if loading
            USE_ENDGAME_SOLVER = True # Default to True for loaded games
            print(f"--- main(): Loaded Game Setup Complete. Players: {player_names}, Moves: {len(move_history)} ---")
        elif selected_mode_result == "BATCH_MODE":
            is_batch_running = True
            game_mode, player_names, human_player, use_endgame_solver_checked, num_games = return_data
            total_batch_games = num_games
            current_batch_game_num = 1 # Start with game 1
            batch_results = []
            USE_ENDGAME_SOLVER = use_endgame_solver_checked
            practice_mode = None # Batch mode overrides practice modes for now
            letter_checks = [True]*4 # Use defaults
            number_checks = [True]*6

            # Store initial config needed for reset
            initial_game_config = {
                'game_mode': game_mode,
                'player_names': player_names,
                'human_player': human_player,
                'use_endgame_solver': USE_ENDGAME_SOLVER
            }
            # Determine is_ai based on stored config
            is_ai = [False, False]
            if initial_game_config['game_mode'] == MODE_HVA:
                is_ai[2 - initial_game_config['human_player']] = True
            elif initial_game_config['game_mode'] == MODE_AVA:
                is_ai = [True, True]
            initial_game_config['is_ai'] = is_ai # Store for reset

            # Perform initial game state setup for the *first* batch game
            if not reset_game_state(initial_game_config):
                 print("FATAL: Could not initialize first batch game.")
                 pygame.quit(); sys.exit()
            first_play = True # Ensure first play is true for first game
            initial_racks = [r[:] for r in racks] # Store initial racks for first game (for GCG if needed)

            print(f"--- main(): Batch Mode Setup Complete. Running {total_batch_games} games. ---")
        elif selected_mode_result is not None: # Handle Normal New Game Modes
            print(f"--- main(): Handling New Game Setup ({selected_mode_result}) ---")
            game_mode = selected_mode_result; is_loaded_game = False; replay_initial_shuffled_bag = None
            player_names, human_player, practice_mode, letter_checks, number_checks, use_endgame_solver_checked, practice_state = return_data
            USE_ENDGAME_SOLVER = use_endgame_solver_checked # Set global based on selection
            print(f"--- main(): Use Endgame Solver set to: {USE_ENDGAME_SOLVER} ---")
            if practice_state and practice_mode == "eight_letter": # 8-Letter Practice Setup
                print("Loading state from 8-letter practice..."); board, tiles, racks, blanks, bag, scores, turn, first_play = practice_state["board"], practice_state["tiles"], practice_state["racks"], practice_state["blanks"], practice_state["bag"], practice_state["scores"], practice_state["turn"], practice_state["first_play"]; is_ai = [False, False]; print("--- main(): Loaded state from 8-letter practice. ---")
            elif practice_state: # Other Practice Modes (like Power Tiles)
                print("Loading state from other practice mode..."); board, tiles, racks, blanks, bag, scores, turn, first_play = practice_state["board"], practice_state["tiles"], practice_state["racks"], practice_state["blanks"], practice_state["bag"], practice_state["scores"], practice_state["turn"], practice_state["first_play"]; is_ai = [False, False];
                if game_mode == MODE_HVA: is_ai[2 - human_player] = True
                elif game_mode == MODE_AVA or practice_mode == "power_tiles" or practice_mode == "bingo_bango_bongo": is_ai = [True, True]; print(f"--- main(): Loaded state from other practice mode. is_ai: {is_ai} ---")
            else: # Standard New Game Setup (including Only Fives)
                print("Performing standard game initialization..."); board, _, tiles = create_board(); bag = create_standard_bag(); random.shuffle(bag); racks = [[], []]; scores = [0, 0]; turn = 1; blanks = set(); first_play = True
                try: racks[0] = [bag.pop() for _ in range(7)]; racks[1] = [bag.pop() for _ in range(7)]
                except IndexError: print("Error: Not enough tiles in bag."); pygame.quit(); sys.exit()

                is_ai = [False, False]
                if game_mode == MODE_HVA: # Covers Only Fives (set to HVA)
                    is_ai[2 - human_player] = True # AI is player 2 if human is player 1
                elif game_mode == MODE_AVA: is_ai = [True, True];
                print(f"--- main(): Initialized is_ai: {is_ai} ---")

                # Sort racks initially, especially for human in Only Fives
                for i, rack in enumerate(racks):
                    if 0 <= i < len(is_ai) and not is_ai[i]:
                         rack.sort()
                    # Optionally sort AI racks too: rack.sort()

                print(f"--- main(): Performed standard game initialization. is_ai: {is_ai} ---") # Log final is_ai state
            # Store initial racks *after* they are populated for new games
            initial_racks = [rack[:] for rack in racks]
        else: print("--- main(): Mode selection returned None. Exiting. ---"); pygame.quit(); sys.exit()

        # --- Common Initializations & Resets ---
        word_positions = []; running = True; dropdown_open = False; return_to_mode_selection = False; all_words_ok_rect = None; all_words_play_rect = None
        hint_rects = []; hint_rect = None; play_button_rect = None; ok_button_rect = None; all_words_button_rect = None; tile_rects = []; exchange_button_rect = None
        cancel_button_rect = None; pass_count = 0; exchange_count = 0; consecutive_zero_point_turns = 0; exchanging = False; hinting = False
        showing_all_words = False; selected_tiles = set(); typing = False; typing_start = None; typing_direction = None; current_r = None; current_c = None
        last_left_click_time = 0; last_left_click_pos = None; hint_moves = []; all_moves = []; selected_hint_index = None; scroll_offset = 0
        last_clicked_pos = None; last_word = ""; last_score = 0; last_start = None; last_direction = None; human_played = False; dragged_tile = None; drag_pos = None; drag_offset = (0,0)
        selected_square = None; original_tiles = None; original_rack = None;
        if selected_mode_result != "LOADED_GAME": move_history = [] # Reset history if not loaded
        if selected_mode_result != "LOADED_GAME": replay_mode = False; current_replay_turn = 0 # Reset replay if not loaded
        previous_turn = 0; game_over_state = False; showing_stats = False; dialog_x = (WINDOW_WIDTH - DIALOG_WIDTH) // 2; dialog_y = (WINDOW_HEIGHT - DIALOG_HEIGHT) // 2; dragging = False;
        if selected_mode_result != "LOADED_GAME": final_scores = None # Reset final scores if not loaded
        reason = ""; action = None; scoreboard_height = WINDOW_HEIGHT - 80; paused_for_power_tile = False; current_power_tile = None; power_tile_message_shown = False
        last_played_highlight_coords = set() # Store coords of last play for highlighting
        preview_score_enabled = False # State for Score Preview
        current_preview_score = 0
        preview_checkbox_rect = None
        is_solving_endgame = False # Initialize endgame flag
        stats_scroll_offset = 0 # Initialize stats scroll offset
        stats_dialog_x = 0
        stats_dialog_y = 0
        stats_dialog_dragging = False
        stats_dialog_drag_offset = (0, 0)
        all_words_scroll_offset = 0
        # --- ADDED: Initialize BBB Practice Mode Flags ---
        paused_for_bingo_practice = False
        bingo_practice_message_shown = False
        # --- END ADDED ---
        print("--- main(): Performed common variable resets. ---")

        # --- 8-Letter Practice Specific Initialization ---
        practice_target_moves = []; practice_best_move = None; practice_solved = False
        showing_practice_end_dialog = False; practice_end_message = ""; practice_play_again_rect = None
        practice_main_menu_rect = None; practice_quit_rect = None
        if practice_mode == "eight_letter":
            print("--- main(): Performing 8-letter practice specific init... ---")
            if racks and len(racks) > 0 and racks[0] is not None and GADDAG_STRUCTURE:
                practice_target_moves = generate_all_moves_gaddag(racks[0], tiles, board, blanks, GADDAG_STRUCTURE.root)
                if practice_target_moves: practice_best_move = practice_target_moves[0]; print(f"Best move found: {practice_best_move['word']} ({practice_best_move['score']} pts)"); all_moves = practice_target_moves
                else: print("Error: No valid moves found for 8-letter practice setup!"); show_message_dialog("Error: No possible moves found for this setup.", "Practice Error"); return_to_mode_selection = True; running = False
            elif not GADDAG_STRUCTURE: print("Error: Cannot generate practice moves, GADDAG not loaded."); return_to_mode_selection = True; running = False
            else: print("Error: Invalid rack state for Player 1 in 8-letter practice."); return_to_mode_selection = True; running = False
    # --- End of Initialization Block ---

    # --- Outer Batch Loop ---
    batch_stop_requested = False
    # Ensure loop runs at least once for non-batch modes
    num_loops = total_batch_games if is_batch_running else 1
    for game_num in range(1, num_loops + 1):
        if is_batch_running:
            current_batch_game_num = game_num
            print(f"\n--- Starting Batch Game {current_batch_game_num} of {total_batch_games} ---")
            if game_num > 1: # Reset state for games after the first
                if not reset_game_state(initial_game_config):
                    print(f"FATAL: Failed to reset state for game {game_num}. Stopping batch.")
                    break # Stop batch if reset fails
                # Need to re-assign is_ai based on stored config after reset
                is_ai = initial_game_config.get('is_ai', [False, False])
                player_names = initial_game_config.get('player_names', ["P1", "P2"])
                # Reset turn-specific vars that might persist visually otherwise
                previous_turn = 0
                game_over_state = False
                final_scores = None
                paused_for_power_tile = False # Reset practice flags too
                paused_for_bingo_practice = False
                power_tile_message_shown = False
                bingo_practice_message_shown = False
                # Reset other relevant per-game flags if necessary

        # --- Inner Game Loop (Existing 'while running:') ---
        running_inner = True # Control flag for the inner loop
        # --- Define button rects outside the event loop but inside the game loop ---
        # These will be None until the game over dialog is drawn
        save_rect, quit_rect, replay_rect, play_again_rect, stats_rect = None, None, None, None, None
        stats_ok_button_rect = None # For the stats dialog
        stats_total_content_height = 0 # Store height for scroll calculation

        while running_inner:
            # --- Check for batch stop request ---
            if batch_stop_requested:
                running_inner = False
                break # Exit inner loop

            # Calculate Preview Score
            current_preview_score = 0
            if typing and preview_score_enabled and word_positions:
                try: current_preview_score = calculate_score(word_positions, board, tiles, blanks)
                except Exception as e: current_preview_score = 0

            # Generate moves at start of turn (Skip if AI is solving endgame or paused for practice)
            if turn != previous_turn and not replay_mode and not game_over_state and not paused_for_power_tile and not paused_for_bingo_practice and practice_mode != "eight_letter" and not is_solving_endgame:
                if racks and len(racks) > turn-1 and racks[turn-1] is not None and GADDAG_STRUCTURE:
                    all_moves = generate_all_moves_gaddag(racks[turn-1], tiles, board, blanks, GADDAG_STRUCTURE.root)
                    if all_moves is None: all_moves = []
                elif not GADDAG_STRUCTURE: print("ERROR: Cannot generate moves, GADDAG not loaded."); all_moves = []
                else: print(f"Error: Invalid rack state for player {turn}. Racks: {racks}"); all_moves = []
                previous_turn = turn; human_played = False; power_tile_message_shown = False; bingo_practice_message_shown = False # Reset message flags

            # --- AI Turn Trigger (Skip if already solving endgame or paused for practice) ---
            if not game_over_state and not replay_mode and not paused_for_power_tile and not paused_for_bingo_practice and \
               practice_mode != "eight_letter" and 0 <= turn-1 < len(is_ai) and is_ai[turn-1] and not human_played and not is_solving_endgame:
                ai_result = ai_turn(turn, racks, tiles, board, blanks, scores, bag, first_play, pass_count, exchange_count, consecutive_zero_point_turns, player_names, dropdown_open, hinting, showing_all_words, letter_checks)
                # --- MODIFICATION: Unpack extended return tuple ---
                if len(ai_result) == 12:
                    turn_after_ai, first_play, pass_count, exchange_count, consecutive_zero_point_turns, returned_moves, dropdown_open, hinting, showing_all_words, paused_for_power_tile, current_power_tile, paused_for_bingo_practice = ai_result
                    if turn_after_ai != turn and move_history:
                         last_ai_move = move_history[-1]
                         if last_ai_move.get('move_type') == 'place': last_played_highlight_coords = set((pos[0], pos[1]) for pos in last_ai_move.get('positions', []))
                         else: last_played_highlight_coords = set()
                    turn = turn_after_ai # Update turn variable
                    if paused_for_power_tile or paused_for_bingo_practice:
                        all_moves = returned_moves # Store moves returned by AI for human validation
                        # Message display logic moved below event loop
                else: print(f"Error: AI turn returned unexpected number of values: {len(ai_result)}")

            # --- Practice Mode Message Display (Show only once per pause) ---
            if paused_for_power_tile and not power_tile_message_shown:
                player_name = player_names[turn-1] if player_names[turn-1] else f"Player {turn}"
                show_message_dialog(f"A {current_power_tile} is on {player_name}'s rack. Find the highest scoring play using {current_power_tile} (matching selected lengths).", "Power Tile Practice")
                power_tile_message_shown = True
            elif paused_for_bingo_practice and not bingo_practice_message_shown:
                player_name = player_names[turn-1] if player_names[turn-1] else f"Player {turn}"
                show_message_dialog(f"A bingo is playable on {player_name}'s rack. Find the highest scoring bingo.", "Bingo, Bango, Bongo!")
                bingo_practice_message_shown = True

            # --- Event Handling ---
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    running_inner = False; running = False; batch_stop_requested = True # Ensure outer loop stops too
                    break # Exit event loop

                # --- Practice End Dialog Handling (Always check first) ---
                if showing_practice_end_dialog:
                     if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
                         x, y = event.pos;
                         if practice_play_again_rect and practice_play_again_rect.collidepoint(x,y): running_inner = False; return_to_mode_selection = True; batch_stop_requested = True
                         elif practice_main_menu_rect and practice_main_menu_rect.collidepoint(x,y): running_inner = False; return_to_mode_selection = True; batch_stop_requested = True
                         elif practice_quit_rect and practice_quit_rect.collidepoint(x,y): running_inner = False; running = False; batch_stop_requested = True
                     continue # Skip ALL other event handling if this dialog is showing

                # --- MOUSEBUTTONDOWN Handling ---
                if event.type == pygame.MOUSEBUTTONDOWN:
                    # Allow options menu click even during batch mode
                    options_rect_base, dropdown_rects_base = draw_options_menu(turn, dropdown_open, len(bag))
                    if options_rect_base.collidepoint(event.pos[0], event.pos[1]):
                        dropdown_open = not dropdown_open
                        continue # Handled click, skip rest for this event

                    elif dropdown_open:
                        clicked_dropdown_item = False
                        # Determine options list based on state
                        if is_batch_running: current_options_list = ["Stop Batch", "Quit"]
                        elif replay_mode or game_over_state: current_options_list = ["Main", "Quit"]
                        elif practice_mode == "eight_letter": current_options_list = ["Give Up", "Main", "Quit"]
                        else: current_options_list = ["Pass", "Exchange", "Main", "Quit"]

                        drawn_options = current_options_list
                        for i, rect in enumerate(dropdown_rects_base):
                            if rect and rect.collidepoint(event.pos[0], event.pos[1]):
                                if i < len(drawn_options):
                                    selected_option = drawn_options[i]
                                    clicked_dropdown_item = True
                                    dropdown_open = False
                                    # --- Actions ---
                                    if selected_option == "Stop Batch":
                                        print("--- Batch Run Aborted by User ---")
                                        batch_stop_requested = True
                                        running_inner = False
                                    elif selected_option == "Pass":
                                        move_rack = racks[turn-1][:]; consecutive_zero_point_turns += 1; pass_count += 1; exchange_count = 0; print(f"Player {turn} passed"); human_played = True; paused_for_power_tile = False; paused_for_bingo_practice = False; move_history.append({'player': turn, 'move_type': 'pass', 'rack': move_rack, 'score': 0, 'word': '', 'coord': '', 'blanks': set(), 'positions': [], 'drawn': [], 'is_bingo': False, 'word_with_blanks': ''}); current_replay_turn = len(move_history); turn = 3 - turn; last_played_highlight_coords = set()
                                    elif selected_option == "Exchange":
                                        if len(bag) >= 7:
                                            exchanging = True; selected_tiles.clear()
                                        else:
                                            show_message_dialog("Cannot exchange, less than 7 tiles in bag.", "Exchange Error")
                                    elif selected_option == "Give Up":
                                        practice_end_message = f"Best: {practice_best_move['word_with_blanks']} ({practice_best_move['score']} pts)" if practice_best_move else "No best move found."; practice_solved = True; showing_practice_end_dialog = True
                                    elif selected_option == "Main":
                                        running_inner = False; return_to_mode_selection = True; batch_stop_requested = True
                                    elif selected_option == "Quit":
                                        if confirm_quit(): running_inner = False; running = False; batch_stop_requested = True
                                    break
                        if clicked_dropdown_item:
                            continue # Handled click, skip rest for this event
                        else: # Clicked outside dropdown items while open
                            dropdown_open = False
                            # Let click fall through if not on an item

                    # --- Process other MOUSEBUTTONDOWN only if NOT in batch mode ---
                    if not is_batch_running:
                        x, y = event.pos
                        current_time = pygame.time.get_ticks()

                        if event.button == 1: # Left Click
                            # --- Game Over Event Handling ---
                            if game_over_state:
                                if save_rect and save_rect.collidepoint(x, y):
                                    # --- ADDED: Save Logic ---
                                    if final_scores and player_names and move_history and initial_racks:
                                        gcg_content = save_game_to_gcg(player_names, move_history, initial_racks, final_scores)
                                        now = datetime.datetime.now()
                                        date_str = now.strftime("%d%b%y").upper()
                                        time_str = now.strftime("%H%M")
                                        seq_num = 1
                                        max_existing_num = 0
                                        try:
                                            for filename in os.listdir('.'):
                                                if filename.startswith(f"{date_str}-") and filename.endswith(".gcg") and "-GAME-" in filename:
                                                    parts = filename[:-4].split('-')
                                                    if len(parts) >= 4 and parts[2] == "GAME":
                                                        try:
                                                            num = int(parts[-1])
                                                            if num > max_existing_num: max_existing_num = num
                                                        except ValueError: continue
                                            seq_num = max_existing_num + 1
                                        except OSError as e: print(f"Error listing directory for save sequence number: {e}")
                                        save_filename = f"{date_str}-{time_str}-GAME-{seq_num}.gcg"
                                        try:
                                            with open(save_filename, "w") as f: f.write(gcg_content)
                                            print(f"Game saved to {save_filename}")
                                            show_message_dialog(f"Game saved to:\n{save_filename}", "Game Saved")
                                        except IOError as e: print(f"Error saving game to {save_filename}: {e}"); show_message_dialog(f"Error saving game: {e}", "Save Error")
                                    else: print("Error: Missing data required for saving."); show_message_dialog("Could not save game: Missing data.", "Save Error")
                                    # --- END ADDED: Save Logic ---
                                elif quit_rect and quit_rect.collidepoint(x, y):
                                    running_inner = False; running = False; batch_stop_requested = True
                                elif replay_rect and replay_rect.collidepoint(x, y):
                                    # --- ADDED: Replay Logic ---
                                    if move_history: # Ensure there's something to replay
                                        print("Entering Replay Mode...")
                                        replay_mode = True
                                        current_replay_turn = 0
                                        game_over_state = False # Exit game over state
                                        showing_stats = False # Close stats dialog if open
                                        last_played_highlight_coords = set() # Clear highlights
                                        # No need to reset board/racks, get_replay_state handles it
                                    else: print("Cannot enter replay: No move history found.")
                                    # --- END ADDED: Replay Logic ---
                                elif play_again_rect and play_again_rect.collidepoint(x, y):
                                    running_inner = False; return_to_mode_selection = True; batch_stop_requested = True
                                elif stats_rect and stats_rect.collidepoint(x, y):
                                    showing_stats = True
                                    stats_dialog_x = (WINDOW_WIDTH - 480) // 2 # Center horizontally
                                    stats_dialog_y = (WINDOW_HEIGHT - 600) // 2 # Center vertically
                                    stats_scroll_offset = 0 # Reset scroll
                                    stats_dialog_dragging = False
                                elif showing_stats and stats_ok_button_rect and stats_ok_button_rect.collidepoint(x, y):
                                    showing_stats = False
                                elif showing_stats: # Check for drag start on stats dialog title bar
                                    title_bar_height = 40 # Approximate height of the title area
                                    stats_title_rect = pygame.Rect(stats_dialog_x, stats_dialog_y, 480, title_bar_height)
                                    if stats_title_rect.collidepoint(x, y):
                                        stats_dialog_dragging = True
                                        stats_dialog_drag_offset = (x - stats_dialog_x, y - stats_dialog_y)
                                elif not showing_stats: # Click outside buttons while game over dialog is up
                                    dialog_rect = pygame.Rect(dialog_x, dialog_y, DIALOG_WIDTH, DIALOG_HEIGHT)
                                    if dialog_rect.collidepoint(x, y): # Check if click is inside main dialog
                                        dragging = True
                                        drag_offset = (x - dialog_x, y - dialog_y)
                                continue # Skip rest of MOUSEBUTTONDOWN if game over handled it

                            # --- Active Game / Replay Event Handling ---
                            if replay_mode: # Replay buttons
                                if replay_start_rect.collidepoint(x, y): current_replay_turn = 0; last_played_highlight_coords = set()
                                elif replay_prev_rect.collidepoint(x, y) and current_replay_turn > 0: current_replay_turn -= 1; last_played_highlight_coords = set()
                                elif replay_next_rect.collidepoint(x, y) and current_replay_turn < len(move_history): current_replay_turn += 1; last_played_highlight_coords = set()
                                elif replay_end_rect.collidepoint(x, y): current_replay_turn = len(move_history); last_played_highlight_coords = set()
                            elif not (exchanging or hinting or showing_all_words): # Active game clicks
                                # Suggest Button ...
                                suggest_rect_base = draw_suggest_button()
                                # --- MODIFICATION: Allow suggest in BBB practice ---
                                is_human_turn_or_paused_practice = not is_ai[turn-1] or paused_for_power_tile or paused_for_bingo_practice
                                if suggest_rect_base and suggest_rect_base.collidepoint(x, y) and is_human_turn_or_paused_practice:
                                    moves_to_hint = []
                                    if practice_mode == "eight_letter":
                                        moves_to_hint = practice_target_moves
                                    elif practice_mode == "power_tiles" and paused_for_power_tile and current_power_tile:
                                        power_moves_hint = [m for m in all_moves if any(letter == current_power_tile for _, _, letter in m.get('newly_placed',[])) and is_word_length_allowed(len(m.get('word','')), number_checks)]
                                        moves_to_hint = sorted(power_moves_hint, key=lambda m: m['score'], reverse=True)
                                    # --- ADDED: Filter for BBB ---
                                    elif practice_mode == "bingo_bango_bongo" and paused_for_bingo_practice:
                                        bingo_moves_hint = [m for m in all_moves if m.get('is_bingo', False)]
                                        moves_to_hint = sorted(bingo_moves_hint, key=lambda m: m['score'], reverse=True)
                                    # --- END ADDED ---
                                    else: # Normal game or other modes
                                        moves_to_hint = all_moves

                                    hint_moves = moves_to_hint[:5] # Get top 5 of the relevant list
                                    hinting = True; selected_hint_index = 0 if hint_moves else None

                                # Hint button (only drawn in PT mode currently)
                                if paused_for_power_tile and hint_rect and hint_rect.collidepoint(x, y):
                                     power_moves_hint = [m for m in all_moves if any(letter == current_power_tile for _, _, letter in m.get('newly_placed',[])) and is_word_length_allowed(len(m.get('word','')), number_checks)]; hint_moves = sorted(power_moves_hint, key=lambda m: m['score'], reverse=True)[:5]; hinting = True; selected_hint_index = 0 if hint_moves else None
                                # Score Preview Checkbox Click
                                if preview_checkbox_rect and preview_checkbox_rect.collidepoint(x, y):
                                    preview_score_enabled = not preview_score_enabled
                                # Rack Buttons ...
                                current_player_idx = turn - 1
                                if 0 <= current_player_idx < len(is_ai) and is_human_turn_or_paused_practice: # Use combined check
                                     p1_alpha_rect, p1_rand_rect = None, None; p2_alpha_rect, p2_rand_rect = None, None
                                     if len(racks) > 0: p1_alpha_rect, p1_rand_rect = draw_rack(1, racks[0], scores, turn, player_names)
                                     if len(racks) > 1 and practice_mode != "eight_letter": p2_alpha_rect, p2_rand_rect = draw_rack(2, racks[1], scores, turn, player_names)
                                     if turn == 1:
                                          if p1_alpha_rect and p1_alpha_rect.collidepoint(x, y): racks[0].sort()
                                          elif p1_rand_rect and p1_rand_rect.collidepoint(x, y): random.shuffle(racks[0])
                                     elif turn == 2 and practice_mode != "eight_letter":
                                          if p2_alpha_rect and p2_alpha_rect.collidepoint(x, y): racks[1].sort()
                                          elif p2_rand_rect and p2_rand_rect.collidepoint(x, y): random.shuffle(racks[1])
                                # Rack Tile Drag Start ...
                                rack_y = BOARD_SIZE + 80 if turn == 1 else BOARD_SIZE + 150; rack_width_calc = 7 * (TILE_WIDTH + TILE_GAP) - TILE_GAP; replay_area_end_x = 10 + 4 * (REPLAY_BUTTON_WIDTH + REPLAY_BUTTON_GAP); min_rack_start_x = replay_area_end_x + BUTTON_GAP + 20; rack_start_x_calc = max(min_rack_start_x, (BOARD_SIZE - rack_width_calc) // 2)
                                if 0 <= current_player_idx < len(racks) and 0 <= current_player_idx < len(is_ai):
                                    rack_len = len(racks[current_player_idx]); tile_idx = get_tile_under_mouse(x, y, rack_start_x_calc, rack_y, rack_len)
                                    if tile_idx is not None and not dragged_tile and is_human_turn_or_paused_practice: # Use combined check
                                        dragged_tile = (turn, tile_idx); drag_pos = (x, y);
                                        tile_abs_x = rack_start_x_calc + tile_idx * (TILE_WIDTH + TILE_GAP)
                                        tile_center_x = tile_abs_x + TILE_WIDTH // 2
                                        tile_center_y = rack_y + TILE_HEIGHT // 2
                                        drag_offset = (x - tile_center_x, y - tile_center_y)
                                # Board Click (Typing Start / Arrow) ...
                                if not dragged_tile and is_human_turn_or_paused_practice: # Use combined check
                                    col = (x - 40) // SQUARE_SIZE; row = (y - 40) // SQUARE_SIZE
                                    if 0 <= row < GRID_SIZE and 0 <= col < GRID_SIZE and not tiles[row][col]:
                                        is_double_click = (last_left_click_pos == (row, col) and current_time - last_left_click_time < DOUBLE_CLICK_TIME)
                                        if is_double_click:
                                             selected_square = None; typing = False
                                             if word_positions and original_tiles and original_rack:
                                                  for r_wp, c_wp, _ in word_positions: tiles[r_wp][c_wp] = original_tiles[r_wp][c_wp]
                                                  racks[turn-1] = original_rack[:]
                                                  if not is_ai[turn-1]: racks[turn-1].sort()
                                                  blanks_to_remove = set((r_wp, c_wp) for r_wp, c_wp, _ in word_positions if (r_wp, c_wp) in blanks); blanks.difference_update(blanks_to_remove); word_positions = []; original_tiles = None; original_rack = None
                                        elif selected_square is None or selected_square[:2] != (row, col):
                                            selected_square = (row, col, "right"); typing = False; word_positions = []
                                        elif selected_square[2] == "right":
                                            selected_square = (row, col, "down")
                                        elif selected_square[2] == "down":
                                            selected_square = None
                                        last_left_click_pos = (row, col); last_left_click_time = current_time
                                    else:
                                        selected_square = None

                            # --- Handle clicks within dialogs (Exchange, Hint, All Words) ---
                            elif exchanging:
                                # ... (exchange dialog logic as before) ...
                                pass
                            elif hinting:
                                clicked_in_dialog = False
                                if play_button_rect and play_button_rect.collidepoint(x, y) and selected_hint_index is not None and selected_hint_index < len(hint_moves):
                                    clicked_in_dialog = True; selected_move = hint_moves[selected_hint_index]; move_rack = racks[turn-1][:]
                                    if paused_for_power_tile: # Hint in Power Tile Practice ...
                                        power_moves_filtered = [ m for m in all_moves if any(letter == current_power_tile for _, _, letter in m.get('newly_placed',[])) and is_word_length_allowed(len(m.get('word','')), number_checks) ]
                                        max_power_score_filtered = max(m['score'] for m in power_moves_filtered) if power_moves_filtered else 0
                                        if selected_move['score'] >= max_power_score_filtered:
                                            next_turn, drawn_tiles, newly_placed = play_hint_move(selected_move, tiles, racks, blanks, scores, turn, bag, board)
                                            human_played = True; hinting = False; paused_for_power_tile = False; consecutive_zero_point_turns = 0; pass_count = 0; exchange_count = 0
                                            move_history.append({'player': turn, 'move_type': 'place', 'rack': move_rack, 'positions': selected_move.get('positions',[]), 'blanks': selected_move.get('blanks',set()), 'score': selected_move.get('score',0), 'word': selected_move.get('word','N/A'), 'drawn': drawn_tiles, 'coord': get_coord(selected_move.get('start',(0,0)), selected_move.get('direction','right')), 'word_with_blanks': selected_move.get('word_with_blanks',''), 'is_bingo': selected_move.get('is_bingo',False)})
                                            current_replay_turn = len(move_history)
                                            last_played_highlight_coords = set((pos[0], pos[1]) for pos in selected_move.get('positions', []))
                                            turn = next_turn
                                        else: show_message_dialog(f"This is not the highest scoring move with {current_power_tile} matching the selected lengths!", "Incorrect Move")
                                    # --- ADDED: BBB Hint Play Logic ---
                                    elif paused_for_bingo_practice:
                                        bingo_moves = [m for m in all_moves if m.get('is_bingo', False)]
                                        max_bingo_score = max(m['score'] for m in bingo_moves) if bingo_moves else 0
                                        if selected_move.get('is_bingo', False) and selected_move['score'] >= max_bingo_score:
                                            next_turn, drawn_tiles, newly_placed = play_hint_move(selected_move, tiles, racks, blanks, scores, turn, bag, board)
                                            human_played = True; hinting = False; paused_for_bingo_practice = False; consecutive_zero_point_turns = 0; pass_count = 0; exchange_count = 0
                                            move_history.append({'player': turn, 'move_type': 'place', 'rack': move_rack, 'positions': selected_move.get('positions',[]), 'blanks': selected_move.get('blanks',set()), 'score': selected_move.get('score',0), 'word': selected_move.get('word','N/A'), 'drawn': drawn_tiles, 'coord': get_coord(selected_move.get('start',(0,0)), selected_move.get('direction','right')), 'word_with_blanks': selected_move.get('word_with_blanks',''), 'is_bingo': selected_move.get('is_bingo',False)})
                                            current_replay_turn = len(move_history)
                                            last_played_highlight_coords = set((pos[0], pos[1]) for pos in selected_move.get('positions', []))
                                            turn = next_turn
                                        else: show_message_dialog(f"This is not the highest scoring bingo! Max score is {max_bingo_score}.", "Incorrect Move")
                                    # --- END ADDED ---
                                    else: # Normal hint play ...
                                        next_turn, drawn_tiles, newly_placed = play_hint_move(selected_move, tiles, racks, blanks, scores, turn, bag, board)
                                        human_played = True; hinting = False; paused_for_power_tile = False; consecutive_zero_point_turns = 0; pass_count = 0; exchange_count = 0
                                        if practice_mode != "eight_letter":
                                            move_history.append({'player': turn, 'move_type': 'place', 'rack': move_rack, 'positions': selected_move.get('positions',[]), 'blanks': selected_move.get('blanks',set()), 'score': selected_move.get('score',0), 'word': selected_move.get('word','N/A'), 'drawn': drawn_tiles, 'coord': get_coord(selected_move.get('start',(0,0)), selected_move.get('direction','right')), 'word_with_blanks': selected_move.get('word_with_blanks',''), 'is_bingo': selected_move.get('is_bingo',False)})
                                            current_replay_turn = len(move_history)
                                            last_played_highlight_coords = set((pos[0], pos[1]) for pos in selected_move.get('positions', []))
                                            turn = next_turn
                                        else: # 8-letter practice visual play
                                            last_played_highlight_coords = set((pos[0], pos[1]) for pos in selected_move.get('positions', []))
                                elif ok_button_rect and ok_button_rect.collidepoint(x, y): clicked_in_dialog = True; hinting = False
                                elif all_words_button_rect and all_words_button_rect.collidepoint(x, y):
                                    clicked_in_dialog = True; hinting = False; showing_all_words = True;
                                    # --- MODIFICATION: Filter All Words for BBB ---
                                    if practice_mode == "eight_letter": moves_for_all = practice_target_moves
                                    elif practice_mode == "power_tiles" and paused_for_power_tile: moves_for_all = sorted([m for m in all_moves if any(letter == current_power_tile for _, _, letter in m.get('newly_placed',[])) and is_word_length_allowed(len(m.get('word','')), number_checks)], key=lambda m: m['score'], reverse=True)
                                    elif practice_mode == "bingo_bango_bongo" and paused_for_bingo_practice: moves_for_all = sorted([m for m in all_moves if m.get('is_bingo', False)], key=lambda m: m['score'], reverse=True)
                                    else: moves_for_all = all_moves
                                    # --- END MODIFICATION ---
                                    selected_hint_index = 0 if moves_for_all else None;
                                    all_words_scroll_offset = 0 # Reset scroll when opening
                                elif hint_rects:
                                    for i, rect in enumerate(hint_rects):
                                        if rect.collidepoint(x, y) and i < len(hint_moves): clicked_in_dialog = True; selected_hint_index = i; break
                                dialog_width, dialog_height = 400, 250; dialog_rect_hint = pygame.Rect((WINDOW_WIDTH - dialog_width) // 2, (WINDOW_HEIGHT - dialog_height) // 2, dialog_width, dialog_height)
                                if dialog_rect_hint.collidepoint(x,y) and not clicked_in_dialog: pass # Click inside dialog but not on element

                            elif showing_all_words: # All Words Dialog ...
                                clicked_in_dialog = False;
                                # --- MODIFICATION: Filter All Words for BBB ---
                                if practice_mode == "eight_letter": moves_for_all = practice_target_moves
                                elif practice_mode == "power_tiles" and paused_for_power_tile: moves_for_all = sorted([m for m in all_moves if any(letter == current_power_tile for _, _, letter in m.get('newly_placed',[])) and is_word_length_allowed(len(m.get('word','')), number_checks)], key=lambda m: m['score'], reverse=True)
                                elif practice_mode == "bingo_bango_bongo" and paused_for_bingo_practice: moves_for_all = sorted([m for m in all_moves if m.get('is_bingo', False)], key=lambda m: m['score'], reverse=True)
                                else: moves_for_all = all_moves
                                # --- END MODIFICATION ---

                                if all_words_play_rect and all_words_play_rect.collidepoint(x, y) and selected_hint_index is not None and selected_hint_index < len(moves_for_all):
                                    clicked_in_dialog = True; selected_move = moves_for_all[selected_hint_index]; move_rack = racks[turn-1][:];
                                    # --- ADDED: BBB Play from All Words ---
                                    if paused_for_bingo_practice:
                                        bingo_moves = [m for m in all_moves if m.get('is_bingo', False)]
                                        max_bingo_score = max(m['score'] for m in bingo_moves) if bingo_moves else 0
                                        if selected_move.get('is_bingo', False) and selected_move['score'] >= max_bingo_score:
                                            next_turn, drawn_tiles, newly_placed = play_hint_move(selected_move, tiles, racks, blanks, scores, turn, bag, board)
                                            human_played = True; showing_all_words = False; paused_for_bingo_practice = False; consecutive_zero_point_turns = 0; pass_count = 0; exchange_count = 0
                                            move_history.append({'player': turn, 'move_type': 'place', 'rack': move_rack, 'positions': selected_move.get('positions',[]), 'blanks': selected_move.get('blanks',set()), 'score': selected_move.get('score',0), 'word': selected_move.get('word','N/A'), 'drawn': drawn_tiles, 'coord': get_coord(selected_move.get('start',(0,0)), selected_move.get('direction','right')), 'word_with_blanks': selected_move.get('word_with_blanks',''), 'is_bingo': selected_move.get('is_bingo',False)})
                                            current_replay_turn = len(move_history)
                                            last_played_highlight_coords = set((pos[0], pos[1]) for pos in selected_move.get('positions', []))
                                            turn = next_turn
                                        else: show_message_dialog(f"This is not the highest scoring bingo! Max score is {max_bingo_score}.", "Incorrect Move")
                                    # --- END ADDED ---
                                    else: # Normal or PT play from All Words
                                        next_turn, drawn_tiles, newly_placed = play_hint_move(selected_move, tiles, racks, blanks, scores, turn, bag, board)
                                        human_played = True; showing_all_words = False; paused_for_power_tile = False; consecutive_zero_point_turns = 0; pass_count = 0; exchange_count = 0
                                        if practice_mode != "eight_letter":
                                            move_history.append({'player': turn, 'move_type': 'place', 'rack': move_rack, 'positions': selected_move.get('positions',[]), 'blanks': selected_move.get('blanks',set()), 'score': selected_move.get('score',0), 'word': selected_move.get('word','N/A'), 'drawn': drawn_tiles, 'coord': get_coord(selected_move.get('start',(0,0)), selected_move.get('direction','right')), 'word_with_blanks': selected_move.get('word_with_blanks',''), 'is_bingo': selected_move.get('is_bingo',False)})
                                            current_replay_turn = len(move_history)
                                            last_played_highlight_coords = set((pos[0], pos[1]) for pos in selected_move.get('positions', []))
                                            turn = next_turn
                                        else: # 8-letter visual play
                                            last_played_highlight_coords = set((pos[0], pos[1]) for pos in selected_move.get('positions', []))
                                elif all_words_ok_rect and all_words_ok_rect.collidepoint(x, y): clicked_in_dialog = True; showing_all_words = False
                                elif all_words_rects:
                                    for rect, idx in all_words_rects:
                                        if rect.collidepoint(x, y): clicked_in_dialog = True; selected_hint_index = idx; break
                                dialog_rect_all = pygame.Rect((WINDOW_WIDTH - ALL_WORDS_DIALOG_WIDTH) // 2, (WINDOW_HEIGHT - ALL_WORDS_DIALOG_HEIGHT) // 2, ALL_WORDS_DIALOG_WIDTH, ALL_WORDS_DIALOG_HEIGHT)
                                if dialog_rect_all.collidepoint(x,y) and not clicked_in_dialog: pass # Click inside dialog but not on element

                        # --- Right Click Handling ---
                        elif event.button == 3: # Right Click -> Cancel typing/arrow
                            selected_square = None
                            if typing:
                                if original_tiles and original_rack:
                                    for r_wp, c_wp, _ in word_positions: tiles[r_wp][c_wp] = original_tiles[r_wp][c_wp]
                                    racks[turn-1] = original_rack[:]
                                    if not is_ai[turn-1]: racks[turn-1].sort()
                                    blanks_to_remove = set((r_wp, c_wp) for r_wp, c_wp, _ in word_positions if (r_wp, c_wp) in blanks)
                                    blanks.difference_update(blanks_to_remove)
                                typing = False; typing_start = None; typing_direction = None
                                word_positions = []; original_tiles = None; original_rack = None

                # --- MOUSEMOTION Handling (Only if NOT in batch) ---
                elif event.type == pygame.MOUSEMOTION and not is_batch_running:
                    if dragged_tile and drag_pos:
                        drag_pos = event.pos
                    if game_over_state and dragging:
                        x, y = event.pos; dialog_x = x - drag_offset[0]; dialog_y = y - drag_offset[1]; dialog_x = max(0, min(dialog_x, WINDOW_WIDTH - DIALOG_WIDTH)); dialog_y = max(0, min(dialog_y, WINDOW_HEIGHT - DIALOG_HEIGHT))
                    if showing_stats and stats_dialog_dragging:
                        x, y = event.pos
                        stats_dialog_x = x - stats_dialog_drag_offset[0]
                        stats_dialog_y = y - stats_dialog_drag_offset[1]
                        stats_dialog_x = max(0, min(stats_dialog_x, WINDOW_WIDTH - 480))
                        stats_dialog_y = max(0, min(stats_dialog_y, WINDOW_HEIGHT - 600))

                # --- MOUSEBUTTONUP Handling (Only if NOT in batch) ---
                elif event.type == pygame.MOUSEBUTTONUP and not is_batch_running:
                    x, y = event.pos
                    if event.button == 1: # Left button up
                        if game_over_state and dragging: dragging = False
                        if showing_stats and stats_dialog_dragging: stats_dialog_dragging = False
                        elif dragged_tile and (0 <= dragged_tile[0]-1 < len(is_ai) and (not is_ai[dragged_tile[0]-1] or paused_for_power_tile or paused_for_bingo_practice)) and not replay_mode: # Allow drag drop in practice pause
                            player_idx = dragged_tile[0] - 1
                            rack_y = BOARD_SIZE + 80 if dragged_tile[0] == 1 else BOARD_SIZE + 150
                            rack_width_calc = 7 * (TILE_WIDTH + TILE_GAP) - TILE_GAP
                            replay_area_end_x = 10 + 4 * (REPLAY_BUTTON_WIDTH + REPLAY_BUTTON_GAP)
                            min_rack_start_x = replay_area_end_x + BUTTON_GAP + 20
                            rack_start_x_calc = max(min_rack_start_x, (BOARD_SIZE - rack_width_calc) // 2)
                            rack_area_rect = pygame.Rect(rack_start_x_calc, rack_y, rack_width_calc, TILE_HEIGHT)

                            if rack_area_rect.collidepoint(x, y): # Dropped ON the rack area
                                if 0 <= player_idx < len(racks):
                                    player_rack = racks[player_idx]
                                    rack_len = len(player_rack)
                                    insert_idx_raw = get_insertion_index(x, rack_start_x_calc, rack_len)
                                    original_tile_idx = dragged_tile[1]
                                    if 0 <= original_tile_idx < rack_len:
                                        tile_to_move = player_rack.pop(original_tile_idx)
                                        insert_idx_adjusted = insert_idx_raw
                                        if original_tile_idx < insert_idx_raw: insert_idx_adjusted -= 1
                                        insert_idx_final = max(0, min(insert_idx_adjusted, len(player_rack)))
                                        player_rack.insert(insert_idx_final, tile_to_move)
                            # Always clear drag state after drop attempt
                            dragged_tile = None; drag_pos = None;

                # --- MOUSEWHEEL Handling (Only if NOT in batch) ---
                elif event.type == pygame.MOUSEWHEEL and not is_batch_running:
                    mouse_x, mouse_y = pygame.mouse.get_pos()
                    if showing_all_words: # Scroll All Words ...
                        dialog_rect_all = pygame.Rect((WINDOW_WIDTH - ALL_WORDS_DIALOG_WIDTH) // 2, (WINDOW_HEIGHT - ALL_WORDS_DIALOG_HEIGHT) // 2, ALL_WORDS_DIALOG_WIDTH, ALL_WORDS_DIALOG_HEIGHT)
                        if dialog_rect_all.collidepoint(mouse_x, mouse_y):
                             # --- MODIFICATION: Filter All Words for BBB ---
                             if practice_mode == "eight_letter": moves_for_scroll = practice_target_moves
                             elif practice_mode == "power_tiles" and paused_for_power_tile: moves_for_scroll = sorted([m for m in all_moves if any(letter == current_power_tile for _, _, letter in m.get('newly_placed',[])) and is_word_length_allowed(len(m.get('word','')), number_checks)], key=lambda m: m['score'], reverse=True)
                             elif practice_mode == "bingo_bango_bongo" and paused_for_bingo_practice: moves_for_scroll = sorted([m for m in all_moves if m.get('is_bingo', False)], key=lambda m: m['score'], reverse=True)
                             else: moves_for_scroll = all_moves
                             # --- END MODIFICATION ---
                             content_height = len(moves_for_scroll) * 30;
                             header_height = 40; button_area_height = BUTTON_HEIGHT + 30
                             visible_content_height = ALL_WORDS_DIALOG_HEIGHT - header_height - button_area_height
                             if content_height > visible_content_height:
                                 max_scroll = content_height - visible_content_height;
                                 all_words_scroll_offset -= event.y * SCROLL_SPEED; # Use dedicated variable
                                 all_words_scroll_offset = max(0, min(all_words_scroll_offset, max_scroll))
                             else: all_words_scroll_offset = 0
                    elif showing_stats: # Scroll Stats ...
                         stats_dialog_rect = pygame.Rect(stats_dialog_x, stats_dialog_y, 480, 600) # Use fixed size
                         if stats_dialog_rect.collidepoint(mouse_x, mouse_y):
                             padding = 10
                             button_area_height = BUTTON_HEIGHT + padding * 2
                             visible_content_height = 600 - padding * 2 - button_area_height # Fixed height minus padding and button
                             if stats_total_content_height > visible_content_height:
                                 max_scroll = stats_total_content_height - visible_content_height
                                 stats_scroll_offset -= event.y * SCROLL_SPEED
                                 stats_scroll_offset = max(0, min(stats_scroll_offset, max_scroll))
                             else: stats_scroll_offset = 0
                    else: # Scroll Scoreboard ...
                         sb_x = BOARD_SIZE + 275; sb_y = 40; sb_w = max(200, WINDOW_WIDTH - BOARD_SIZE - 20); sb_h = WINDOW_HEIGHT - 80;
                         if sb_x + sb_w > WINDOW_WIDTH - 10: sb_w = WINDOW_WIDTH - sb_x - 10
                         if sb_w < 150: sb_x = WINDOW_WIDTH - 160; sb_w = 150 # Adjusted min width slightly
                         scoreboard_rect = pygame.Rect(sb_x, sb_y, sb_w, sb_h)
                         if scoreboard_rect.collidepoint(mouse_x, mouse_y):
                              history_len = current_replay_turn if replay_mode else len(move_history); total_content_height = history_len * 20; is_final_turn_in_replay = replay_mode and current_replay_turn == len(move_history)
                              if (game_over_state or is_final_turn_in_replay) and final_scores is not None: total_content_height += 40
                              if total_content_height > scoreboard_height: max_scroll = total_content_height - scoreboard_height; scroll_offset -= event.y * SCROLL_SPEED; scroll_offset = max(0, min(scroll_offset, max_scroll))
                              else: scroll_offset = 0

                # --- KEYDOWN Handling ---
                elif event.type == pygame.KEYDOWN:

                    # --- Game Over Key Handling (Only if NOT in batch) ---
                    if game_over_state and not is_batch_running:
                        # ... (Game over key handling as before) ...
                        pass

                    # --- Hint Dialog Key Handling (Enter/Escape) ---
                    elif hinting and not is_batch_running: # Check hinting state first
                        if event.key == pygame.K_RETURN or event.key == pygame.K_KP_ENTER:
                            if selected_hint_index is not None and selected_hint_index < len(hint_moves):
                                selected_move = hint_moves[selected_hint_index]; move_rack = racks[turn-1][:]
                                if paused_for_power_tile: # Hint in Power Tile Practice ...
                                    power_moves_filtered = [ m for m in all_moves if any(letter == current_power_tile for _, _, letter in m.get('newly_placed',[])) and is_word_length_allowed(len(m.get('word','')), number_checks) ]
                                    max_power_score_filtered = max(m['score'] for m in power_moves_filtered) if power_moves_filtered else 0
                                    if selected_move['score'] >= max_power_score_filtered:
                                        next_turn, drawn_tiles, newly_placed = play_hint_move(selected_move, tiles, racks, blanks, scores, turn, bag, board)
                                        human_played = True; hinting = False; paused_for_power_tile = False; consecutive_zero_point_turns = 0; pass_count = 0; exchange_count = 0
                                        move_history.append({'player': turn, 'move_type': 'place', 'rack': move_rack, 'positions': selected_move.get('positions',[]), 'blanks': selected_move.get('blanks',set()), 'score': selected_move.get('score',0), 'word': selected_move.get('word','N/A'), 'drawn': drawn_tiles, 'coord': get_coord(selected_move.get('start',(0,0)), selected_move.get('direction','right')), 'word_with_blanks': selected_move.get('word_with_blanks',''), 'is_bingo': selected_move.get('is_bingo',False)})
                                        current_replay_turn = len(move_history)
                                        last_played_highlight_coords = set((pos[0], pos[1]) for pos in selected_move.get('positions', []))
                                        turn = next_turn
                                    else: show_message_dialog(f"This is not the highest scoring move with {current_power_tile} matching the selected lengths!", "Incorrect Move")
                                # --- ADDED: BBB Hint Play Logic ---
                                elif paused_for_bingo_practice:
                                    bingo_moves = [m for m in all_moves if m.get('is_bingo', False)]
                                    max_bingo_score = max(m['score'] for m in bingo_moves) if bingo_moves else 0
                                    if selected_move.get('is_bingo', False) and selected_move['score'] >= max_bingo_score:
                                        next_turn, drawn_tiles, newly_placed = play_hint_move(selected_move, tiles, racks, blanks, scores, turn, bag, board)
                                        human_played = True; hinting = False; paused_for_bingo_practice = False; consecutive_zero_point_turns = 0; pass_count = 0; exchange_count = 0
                                        move_history.append({'player': turn, 'move_type': 'place', 'rack': move_rack, 'positions': selected_move.get('positions',[]), 'blanks': selected_move.get('blanks',set()), 'score': selected_move.get('score',0), 'word': selected_move.get('word','N/A'), 'drawn': drawn_tiles, 'coord': get_coord(selected_move.get('start',(0,0)), selected_move.get('direction','right')), 'word_with_blanks': selected_move.get('word_with_blanks',''), 'is_bingo': selected_move.get('is_bingo',False)})
                                        current_replay_turn = len(move_history)
                                        last_played_highlight_coords = set((pos[0], pos[1]) for pos in selected_move.get('positions', []))
                                        turn = next_turn
                                    else: show_message_dialog(f"This is not the highest scoring bingo! Max score is {max_bingo_score}.", "Incorrect Move")
                                # --- END ADDED ---
                                else: # Normal hint play ...
                                    next_turn, drawn_tiles, newly_placed = play_hint_move(selected_move, tiles, racks, blanks, scores, turn, bag, board)
                                    human_played = True; hinting = False; paused_for_power_tile = False; consecutive_zero_point_turns = 0; pass_count = 0; exchange_count = 0
                                    if practice_mode != "eight_letter":
                                        move_history.append({'player': turn, 'move_type': 'place', 'rack': move_rack, 'positions': selected_move.get('positions',[]), 'blanks': selected_move.get('blanks',set()), 'score': selected_move.get('score',0), 'word': selected_move.get('word','N/A'), 'drawn': drawn_tiles, 'coord': get_coord(selected_move.get('start',(0,0)), selected_move.get('direction','right')), 'word_with_blanks': selected_move.get('word_with_blanks',''), 'is_bingo': selected_move.get('is_bingo',False)})
                                        current_replay_turn = len(move_history)
                                        last_played_highlight_coords = set((pos[0], pos[1]) for pos in selected_move.get('positions', []))
                                        turn = next_turn
                                    else: # 8-letter practice visual play
                                        last_played_highlight_coords = set((pos[0], pos[1]) for pos in selected_move.get('positions', []))
                        elif event.key == pygame.K_ESCAPE:
                            hinting = False # Close hint dialog on Escape

                    # --- All Words Dialog Key Handling (Enter/Escape) ---
                    elif showing_all_words and not is_batch_running:
                        if event.key == pygame.K_RETURN or event.key == pygame.K_KP_ENTER:
                            # --- MODIFICATION: Filter All Words for BBB ---
                            if practice_mode == "eight_letter": moves_for_all = practice_target_moves
                            elif practice_mode == "power_tiles" and paused_for_power_tile: moves_for_all = sorted([m for m in all_moves if any(letter == current_power_tile for _, _, letter in m.get('newly_placed',[])) and is_word_length_allowed(len(m.get('word','')), number_checks)], key=lambda m: m['score'], reverse=True)
                            elif practice_mode == "bingo_bango_bongo" and paused_for_bingo_practice: moves_for_all = sorted([m for m in all_moves if m.get('is_bingo', False)], key=lambda m: m['score'], reverse=True)
                            else: moves_for_all = all_moves
                            # --- END MODIFICATION ---
                            if selected_hint_index is not None and selected_hint_index < len(moves_for_all):
                                selected_move = moves_for_all[selected_hint_index]; move_rack = racks[turn-1][:];
                                # --- ADDED: BBB Play from All Words ---
                                if paused_for_bingo_practice:
                                    bingo_moves = [m for m in all_moves if m.get('is_bingo', False)]
                                    max_bingo_score = max(m['score'] for m in bingo_moves) if bingo_moves else 0
                                    if selected_move.get('is_bingo', False) and selected_move['score'] >= max_bingo_score:
                                        next_turn, drawn_tiles, newly_placed = play_hint_move(selected_move, tiles, racks, blanks, scores, turn, bag, board)
                                        human_played = True; showing_all_words = False; paused_for_bingo_practice = False; consecutive_zero_point_turns = 0; pass_count = 0; exchange_count = 0
                                        move_history.append({'player': turn, 'move_type': 'place', 'rack': move_rack, 'positions': selected_move.get('positions',[]), 'blanks': selected_move.get('blanks',set()), 'score': selected_move.get('score',0), 'word': selected_move.get('word','N/A'), 'drawn': drawn_tiles, 'coord': get_coord(selected_move.get('start',(0,0)), selected_move.get('direction','right')), 'word_with_blanks': selected_move.get('word_with_blanks',''), 'is_bingo': selected_move.get('is_bingo',False)})
                                        current_replay_turn = len(move_history)
                                        last_played_highlight_coords = set((pos[0], pos[1]) for pos in selected_move.get('positions', []))
                                        turn = next_turn
                                    else: show_message_dialog(f"This is not the highest scoring bingo! Max score is {max_bingo_score}.", "Incorrect Move")
                                # --- END ADDED ---
                                else: # Normal or PT play from All Words
                                    next_turn, drawn_tiles, newly_placed = play_hint_move(selected_move, tiles, racks, blanks, scores, turn, bag, board)
                                    human_played = True; showing_all_words = False; paused_for_power_tile = False; consecutive_zero_point_turns = 0; pass_count = 0; exchange_count = 0
                                    if practice_mode != "eight_letter":
                                        move_history.append({'player': turn, 'move_type': 'place', 'rack': move_rack, 'positions': selected_move.get('positions',[]), 'blanks': selected_move.get('blanks',set()), 'score': selected_move.get('score',0), 'word': selected_move.get('word','N/A'), 'drawn': drawn_tiles, 'coord': get_coord(selected_move.get('start',(0,0)), selected_move.get('direction','right')), 'word_with_blanks': selected_move.get('word_with_blanks',''), 'is_bingo': selected_move.get('is_bingo',False)})
                                        current_replay_turn = len(move_history)
                                        last_played_highlight_coords = set((pos[0], pos[1]) for pos in selected_move.get('positions', []))
                                        turn = next_turn
                                    else: # 8-letter visual play
                                        last_played_highlight_coords = set((pos[0], pos[1]) for pos in selected_move.get('positions', []))
                        elif event.key == pygame.K_ESCAPE:
                            showing_all_words = False # Close dialog on Escape

                    # --- Active Game Typing (Only if NOT game over, NOT batch, NOT hinting, NOT showing all words) ---
                    elif not game_over_state and not is_batch_running and not hinting and not showing_all_words: # Added not showing_all_words check
                        is_human_turn_or_paused = not replay_mode and (0 <= turn-1 < len(is_ai) and (not is_ai[turn-1] or paused_for_power_tile or paused_for_bingo_practice)) # Include BBB pause

                        if is_human_turn_or_paused:
                            # --- Start Typing Logic ---
                            if selected_square and not typing and hasattr(event, 'unicode') and event.unicode.isalpha(): # Check hasattr
                                typing = True; original_tiles = [row[:] for row in tiles]; original_rack = racks[turn-1][:]
                                typing_start = selected_square[:2]; typing_direction = selected_square[2]; original_selected_square = selected_square
                                selected_square = None; word_positions = []; current_r, current_c = typing_start
                                letter = event.unicode.upper()
                                if 0 <= current_r < GRID_SIZE and 0 <= current_c < GRID_SIZE and not tiles[current_r][current_c]:
                                    placed = False
                                    if letter in racks[turn-1]:
                                        tiles[current_r][current_c] = letter; racks[turn-1].remove(letter); word_positions.append((current_r, current_c, letter)); placed = True
                                    elif ' ' in racks[turn-1]:
                                        tiles[current_r][current_c] = letter; racks[turn-1].remove(' '); blanks.add((current_r, current_c)); word_positions.append((current_r, current_c, letter)); placed = True

                                    if placed:
                                        if typing_direction == "right":
                                            current_c += 1
                                            while current_c < GRID_SIZE and tiles[current_r][current_c]: current_c += 1
                                        elif typing_direction == "down":
                                            current_r += 1
                                            while current_r < GRID_SIZE and tiles[current_r][current_c]: current_r += 1
                                        current_r = min(current_r, GRID_SIZE - 1)
                                        current_c = min(current_c, GRID_SIZE - 1)
                                    else:
                                        typing = False
                                        selected_square = original_selected_square
                                        original_tiles = None
                                        original_rack = None
                                else:
                                    typing = False; selected_square = original_selected_square

                            # --- Active Typing Logic ---
                            elif typing:
                                if hasattr(event, 'unicode') and event.unicode.isalpha(): # Check letters FIRST
                                    letter = event.unicode.upper()
                                    if 0 <= current_r < GRID_SIZE and 0 <= current_c < GRID_SIZE and not tiles[current_r][current_c]:
                                        placed = False
                                        if letter in racks[turn-1]:
                                            tiles[current_r][current_c] = letter; racks[turn-1].remove(letter); word_positions.append((current_r, current_c, letter)); placed = True
                                        elif ' ' in racks[turn-1]:
                                            tiles[current_r][current_c] = letter; racks[turn-1].remove(' '); blanks.add((current_r, current_c)); word_positions.append((current_r, current_c, letter)); placed = True

                                        if placed:
                                            if typing_direction == "right":
                                                current_c += 1
                                                while current_c < GRID_SIZE and tiles[current_r][current_c]: current_c += 1
                                            elif typing_direction == "down":
                                                current_r += 1
                                                while current_r < GRID_SIZE and tiles[current_r][current_c]: current_r += 1
                                            current_r = min(current_r, GRID_SIZE - 1)
                                            current_c = min(current_c, GRID_SIZE - 1)

                                elif event.key == pygame.K_RETURN or event.key == pygame.K_KP_ENTER: # Finalize Typed Play ...
                                    play_finalized_normally = False
                                    revert_play = False # Flag to indicate if the play should be reverted
                                    message_to_show = None # Store message to show after potential reversion

                                    if word_positions:
                                        # Simulate the board state *after* typing
                                        temp_tiles_val = [row[:] for row in original_tiles]
                                        for r_wp, c_wp, l_wp in word_positions:
                                            if 0 <= r_wp < GRID_SIZE and 0 <= c_wp < GRID_SIZE:
                                                temp_tiles_val[r_wp][c_wp] = l_wp

                                        # Validate the placement itself
                                        valid, is_bingo = is_valid_play(word_positions, temp_tiles_val, first_play, len(original_rack), original_tiles, original_rack)

                                        if valid:
                                            score = calculate_score(word_positions, board, tiles, blanks) # Calculate score based on final board state

                                            # Find all words formed by the typed letters
                                            all_words_details = find_all_words_formed(word_positions, temp_tiles_val)
                                            typed_word_str = "" # Primary word for length check if needed
                                            typed_word_len = 0
                                            if all_words_details:
                                                start_r_type, start_c_type = typing_start
                                                for word_detail in all_words_details:
                                                    if any(t[0] == start_r_type and t[1] == start_c_type for t in word_detail):
                                                        typed_word_str = "".join(tile[2] for tile in word_detail)
                                                        typed_word_len = len(typed_word_str)
                                                        break
                                                if not typed_word_str and all_words_details:
                                                     typed_word_str = "".join(tile[2] for tile in all_words_details[0])
                                                     typed_word_len = len(typed_word_str)

                                            # --- Practice Mode Checks ---
                                            if practice_mode == "eight_letter":
                                                if practice_best_move and score == practice_best_move['score']:
                                                    practice_end_message = f"Congratulations! Best: {practice_best_move['word_with_blanks']} ({score} pts)"
                                                    practice_solved = True
                                                    showing_practice_end_dialog = True # Show the end dialog instead of message box
                                                elif practice_best_move:
                                                    message_to_show = (f"Try again. There is another word that scores {practice_best_move['score']}.", "Incorrect")
                                                    revert_play = True
                                                else: # Error case
                                                    message_to_show = ("Error: No best move data available.", "Error")
                                                    return_to_mode_selection = True; running = False # Exit on error
                                                    revert_play = True # Revert before exiting

                                            elif practice_mode == "power_tiles" and paused_for_power_tile:
                                                 uses_power = any(letter == current_power_tile for r_wp, c_wp, letter in word_positions)
                                                 power_moves_filtered = [ m for m in all_moves if any(pt[2] == current_power_tile for pt in m.get('newly_placed', [])) and is_word_length_allowed(len(m.get('word','')), number_checks) ]
                                                 max_power_score_filtered = max(m['score'] for m in power_moves_filtered) if power_moves_filtered else 0

                                                 if not uses_power:
                                                     message_to_show = (f"Move must use the {current_power_tile}!", "Incorrect")
                                                     revert_play = True
                                                 elif not is_word_length_allowed(typed_word_len, number_checks):
                                                     message_to_show = (f"Word length ({typed_word_len}) is not allowed by your selection.", "Incorrect Length")
                                                     revert_play = True
                                                 elif score < max_power_score_filtered:
                                                     message_to_show = (f"Try again. There is another word using {current_power_tile} with allowed length(s) that scores {max_power_score_filtered}.", "Higher Score Exists")
                                                     revert_play = True
                                                 else: # Correct!
                                                     message_to_show = ("That's correct! Great job.", "Correct!")
                                                     paused_for_power_tile = False; power_tile_message_shown = False
                                                     play_finalized_normally = True # Allow normal finalization

                                            # --- ADDED: BBB Practice Check ---
                                            elif practice_mode == "bingo_bango_bongo" and paused_for_bingo_practice:
                                                if not is_bingo:
                                                    message_to_show = ("Play must be a bingo!", "Incorrect")
                                                    revert_play = True
                                                else:
                                                    bingo_moves = [m for m in all_moves if m.get('is_bingo', False)]
                                                    max_bingo_score = max(m['score'] for m in bingo_moves) if bingo_moves else 0
                                                    if score < max_bingo_score:
                                                        message_to_show = (f"Try again. There is a higher scoring bingo ({max_bingo_score} pts).", "Higher Score Exists")
                                                        revert_play = True
                                                    else: # Correct! Highest scoring bingo played.
                                                        message_to_show = ("That's correct! Great job.", "Correct!")
                                                        paused_for_bingo_practice = False; bingo_practice_message_shown = False
                                                        play_finalized_normally = True # Allow normal finalization
                                            # --- END ADDED ---

                                            elif practice_mode == "only_fives":
                                                found_five_letter_word = False
                                                if all_words_details:
                                                    found_five_letter_word = any(len("".join(t[2] for t in word_detail)) == 5 for word_detail in all_words_details)

                                                if found_five_letter_word:
                                                    play_finalized_normally = True # Play is valid for this mode
                                                else:
                                                    message_to_show = ("Play must form at least one 5-letter word.", "Invalid Play")
                                                    revert_play = True

                                            else: # Normal game mode
                                                play_finalized_normally = True # Finalize normal play

                                        else: # Invalid play (based on is_valid_play)
                                            message_to_show = ("Invalid play.", "Error") # Inform user
                                            revert_play = True

                                    else: # Pressed Enter with no letters typed
                                         typing = False; selected_square = original_selected_square # Revert to arrow

                                    # --- Centralized Reversion and Message Display ---
                                    if revert_play:
                                        if original_tiles and original_rack:
                                            for r_wp, c_wp, _ in word_positions: tiles[r_wp][c_wp] = original_tiles[r_wp][c_wp]
                                            racks[turn-1] = original_rack[:]
                                            if not is_ai[turn-1]: racks[turn-1].sort()
                                            blanks_to_remove = set((r_wp, c_wp) for r_wp, c_wp, _ in word_positions if (r_wp, c_wp) in blanks); blanks.difference_update(blanks_to_remove)
                                        typing = False; typing_start = None; typing_direction = None; word_positions = []; original_tiles = None; original_rack = None
                                        if not return_to_mode_selection: # Don't reset arrow if exiting
                                            selected_square = original_selected_square

                                    # Show message *after* potential reversion is complete
                                    if message_to_show:
                                        show_message_dialog(message_to_show[0], message_to_show[1])
                                        message_to_show = None # Clear message after showing

                                    # --- Normal Play Finalization (only if play_finalized_normally is True) ---
                                    if play_finalized_normally:
                                        scores[turn-1] += score; first_play = False; drawn_tiles = [bag.pop() for _ in range(len(word_positions)) if bag]; racks[turn-1].extend(drawn_tiles)
                                        if not is_ai[turn-1]: racks[turn-1].sort() # Sort human rack
                                        # Find the full word and its actual start position/direction
                                        full_word_tiles_hist, main_word_orientation = find_main_word(word_positions, tiles) # Use final board state 'tiles'
                                        full_word_hist = "".join(t[2] for t in full_word_tiles_hist) if full_word_tiles_hist else "ERROR"
                                        # Calculate coord based on actual word start
                                        if full_word_tiles_hist:
                                            actual_start_pos = (full_word_tiles_hist[0][0], full_word_tiles_hist[0][1])
                                            # Determine direction based on main word orientation
                                            actual_direction = "right" if main_word_orientation == "horizontal" else "down"
                                            # --- Use updated get_coord ---
                                            coord_hist = get_coord(actual_start_pos, actual_direction)
                                            # --- End Use updated get_coord ---
                                        else: coord_hist = "???"; print("WARNING: Could not determine actual start pos/direction for history coord.")
                                        # Format word_with_blanks based on full word
                                        word_with_blanks_list_hist = []; placed_pos_set_hist = set((p[0], p[1]) for p in word_positions); blanks_in_play = blanks.copy() & placed_pos_set_hist
                                        for wr, wc, w_letter in full_word_tiles_hist: is_blank_hist = (wr, wc) in blanks_in_play; word_with_blanks_list_hist.append(w_letter.lower() if is_blank_hist else w_letter.upper())
                                        word_with_blanks_hist = "".join(word_with_blanks_list_hist)
                                        # Append correct info to history
                                        move_history.append({
                                            'player': turn, 'move_type': 'place', 'rack': original_rack[:],
                                            'positions': full_word_tiles_hist, # Store full word tiles for highlight
                                            'blanks': blanks_in_play, 'score': score, 'word': full_word_hist,
                                            'drawn': drawn_tiles, 'coord': coord_hist, # Use corrected coord
                                            'word_with_blanks': word_with_blanks_hist, 'is_bingo': is_bingo,
                                            'newly_placed': word_positions # Keep track of only typed tiles if needed elsewhere
                                        })
                                        current_replay_turn = len(move_history); print(f"Player {turn} played: {full_word_hist} at {coord_hist} for {score} points")
                                        # Update highlight coords after HUMAN move
                                        last_played_highlight_coords = set((pos[0], pos[1]) for pos in full_word_tiles_hist)
                                        consecutive_zero_point_turns = 0; pass_count = 0; exchange_count = 0; human_played = True; turn = 3 - turn
                                        typing = False; typing_start = None; typing_direction = None; word_positions = []; original_tiles = None; original_rack = None; selected_square = None

                                elif event.key == pygame.K_BACKSPACE: # Backspace ...
                                    if word_positions:
                                        r_rem, c_rem, letter_rem = word_positions.pop(); tiles[r_rem][c_rem] = ''
                                        if (r_rem, c_rem) in blanks: blanks.remove((r_rem, c_rem)); racks[turn-1].append(' ')
                                        else: racks[turn-1].append(letter_rem)
                                        if not is_ai[turn-1]: racks[turn-1].sort()
                                        current_r, current_c = r_rem, c_rem
                                    else: # Backspace when no letters typed yet
                                        typing = False; selected_square = original_selected_square; original_tiles = None; original_rack = None
                                elif event.key == pygame.K_ESCAPE: # Cancel typing ...
                                     if original_tiles and original_rack:
                                         for r_wp, c_wp, _ in word_positions: tiles[r_wp][c_wp] = original_tiles[r_wp][c_wp]
                                         racks[turn-1] = original_rack[:]
                                         if not is_ai[turn-1]: racks[turn-1].sort()
                                         blanks_to_remove = set((r_wp, c_wp) for r_wp, c_wp, _ in word_positions if (r_wp, c_wp) in blanks); blanks.difference_update(blanks_to_remove)
                                     typing = False; typing_start = None; typing_direction = None; word_positions = []; original_tiles = None; original_rack = None; selected_square = original_selected_square


            # --- Game Over Check ---
            if not replay_mode and not game_over_state and practice_mode != "eight_letter":
                game_ended = False; reason = ""; rack0_exists = len(racks)>0 and racks[0] is not None; rack1_exists = len(racks)>1 and racks[1] is not None; rack0_empty = rack0_exists and not racks[0]; rack1_empty = rack1_exists and not racks[1]
                if not bag and (rack0_empty or rack1_empty): game_ended = True; reason = "Bag empty & rack empty"
                elif consecutive_zero_point_turns >= 6: game_ended = True; reason = "Six Consecutive Zero-Point Turns"
                if game_ended:
                    print(f"Game over triggered: {reason}");
                    final_scores = calculate_final_scores(scores, racks, bag)
                    game_over_state = True; exchanging = False; hinting = False; showing_all_words = False; dropdown_open = False; dragging = False; typing = False; selected_square = None
                    dialog_x = (WINDOW_WIDTH - DIALOG_WIDTH) // 2; dialog_y = (WINDOW_HEIGHT - DIALOG_HEIGHT) // 2; last_played_highlight_coords = set() # Clear highlight
                    if is_batch_running:
                        running_inner = False

            # --- Drawing Logic ---
            screen.fill(WHITE)
            # Determine state variables for drawing based on mode
            turn_to_display = turn
            if replay_mode: # Determine state based on replay method
                if is_loaded_game and replay_initial_shuffled_bag is not None:
                    tiles_to_display, blanks_to_display, scores_to_display, racks_to_display = simulate_game_up_to(current_replay_turn, move_history, replay_initial_shuffled_bag)
                elif not is_loaded_game and initial_racks is not None: # Check if initial_racks exists
                    tiles_to_display, blanks_to_display, scores_to_display, racks_to_display = get_replay_state(current_replay_turn, initial_racks) # Assumes move_history has 'drawn'
                else: # Fallback if initial state cannot be determined
                    print("Replay Warning: Missing initial state for replay. Displaying turn 0.")
                    tiles_to_display, blanks_to_display, scores_to_display, racks_to_display = get_replay_state(0, [[], []]) # Use empty initial racks as fallback
                # Determine whose turn it *would* be after the displayed move
                if current_replay_turn == 0:
                     turn_to_display = 1
                elif current_replay_turn > 0 and current_replay_turn <= len(move_history):
                     turn_to_display = 3 - move_history[current_replay_turn - 1]['player']
                else: # Should not happen if current_replay_turn is capped, but safety
                     turn_to_display = 1 # Default to player 1 if out of bounds
            else: # Live game
                tiles_to_display, blanks_to_display, racks_to_display = tiles, blanks, racks
                scores_to_display = final_scores if game_over_state else scores
                turn_to_display = turn # Already set correctly

            # Draw Board/Tiles ...
            for r in range(GRID_SIZE):
                for c in range(GRID_SIZE):
                    pygame.draw.rect(screen, board[r][c], (40 + c * SQUARE_SIZE, 40 + r * SQUARE_SIZE, SQUARE_SIZE, SQUARE_SIZE)); pygame.draw.rect(screen, BLACK, (40 + c * SQUARE_SIZE, 40 + r * SQUARE_SIZE, SQUARE_SIZE, SQUARE_SIZE), 1)
                    if tiles_to_display[r][c]:
                        tile_char = tiles_to_display[r][c]; is_blank_on_board = (r, c) in blanks_to_display;
                        is_last_played = (r, c) in last_played_highlight_coords and not replay_mode
                        tile_bg_color = PALE_YELLOW if is_last_played else GREEN
                        if is_blank_on_board: # Draw blank tile
                            center = (40 + c * SQUARE_SIZE + SQUARE_SIZE // 2, 40 + r * SQUARE_SIZE + SQUARE_SIZE // 2); radius = SQUARE_SIZE // 2 - 3
                            if is_last_played: pygame.draw.rect(screen, tile_bg_color, (40 + c * SQUARE_SIZE + 2, 40 + r * SQUARE_SIZE + 2, SQUARE_SIZE - 4, SQUARE_SIZE - 4)) # Highlight behind circle
                            pygame.draw.circle(screen, BLACK, center, radius); text_surf = font.render(tile_char, True, WHITE); text_rect = text_surf.get_rect(center=center); screen.blit(text_surf, text_rect)
                        else: # Draw regular tile
                            tile_rect = pygame.Rect(40 + c * SQUARE_SIZE + 2, 40 + r * SQUARE_SIZE + 2, SQUARE_SIZE - 4, SQUARE_SIZE - 4);
                            pygame.draw.rect(screen, tile_bg_color, tile_rect); # Use determined bg color
                            text_surf = font.render(tile_char, True, BLACK); text_rect = text_surf.get_rect(center=tile_rect.center); screen.blit(text_surf, text_rect)

            # Highlight *new* tiles for the current replay turn (Yellow border)
            if replay_mode and current_replay_turn > 0 and current_replay_turn <= len(move_history): # Check bounds
                last_move_data = move_history[current_replay_turn - 1]
                if last_move_data['move_type'] == 'place':
                     newly_placed_coords = last_move_data.get('newly_placed') # Use newly_placed if available
                     if newly_placed_coords is None: # Fallback calculation
                         original_replay_tiles = [['' for _ in range(GRID_SIZE)] for _ in range(GRID_SIZE)];
                         try:
                             if is_loaded_game and replay_initial_shuffled_bag: original_replay_tiles,_,_,_ = simulate_game_up_to(current_replay_turn - 1, move_history, replay_initial_shuffled_bag)
                             elif not is_loaded_game and initial_racks is not None: original_replay_tiles,_,_,_ = get_replay_state(current_replay_turn - 1, initial_racks)
                         except Exception as e: print(f"Error getting prev state for highlight: {e}")
                         # Use 'positions' from history as fallback source for newly placed
                         newly_placed_coords = [(p[0], p[1], p[2]) for p in last_move_data.get('positions', []) if 0<=p[0]<GRID_SIZE and 0<=p[1]<GRID_SIZE and not original_replay_tiles[p[0]][p[1]]]
                     for r, c, _ in newly_placed_coords:
                          if 0 <= r < GRID_SIZE and 0 <= c < GRID_SIZE:
                               pygame.draw.rect(screen, YELLOW, (40 + c * SQUARE_SIZE, 40 + r * SQUARE_SIZE, SQUARE_SIZE, SQUARE_SIZE), 3)

            # Draw Labels ...
            for r in range(GRID_SIZE): row_label = ui_font.render(str(r + 1), True, BLACK); screen.blit(row_label, (10, 40 + r * SQUARE_SIZE + (SQUARE_SIZE // 2 - row_label.get_height() // 2)))
            for c in range(GRID_SIZE): col_label = ui_font.render(LETTERS[c], True, BLACK); screen.blit(col_label, (40 + c * SQUARE_SIZE + (SQUARE_SIZE // 2 - col_label.get_width() // 2), 10))
            # Draw Racks ...
            p1_rack_to_draw = racks_to_display[0] if len(racks_to_display) > 0 else []; p1_drag_info = dragged_tile if dragged_tile and dragged_tile[0] == 1 else None
            p1_alpha_rect, p1_rand_rect = draw_rack(1, p1_rack_to_draw, scores_to_display, turn_to_display, player_names, p1_drag_info, drag_pos)
            p2_alpha_rect, p2_rand_rect = None, None
            if practice_mode != "eight_letter": p2_rack_to_draw = racks_to_display[1] if len(racks_to_display) > 1 else []; p2_drag_info = dragged_tile if dragged_tile and dragged_tile[0] == 2 else None; p2_alpha_rect, p2_rand_rect = draw_rack(2, p2_rack_to_draw, scores_to_display, turn_to_display, player_names, p2_drag_info, drag_pos)
            # Draw Remaining Tiles ...
            if practice_mode != "eight_letter":
                current_player_index = turn_to_display - 1
                if 0 <= current_player_index < len(racks_to_display):
                     remaining = get_remaining_tiles(racks_to_display[current_player_index], tiles_to_display, blanks_to_display)
                     draw_remaining_tiles(remaining, turn_to_display)
                else: draw_remaining_tiles({}, turn_to_display) # Show empty if rack invalid

            # --- Draw UI Buttons (Suggest/Hint/Preview only if not game over/replay) ---
            if not replay_mode and not game_over_state and not is_batch_running:
                 suggest_rect = draw_suggest_button()
                 if paused_for_power_tile and suggest_rect: hint_x = suggest_rect.x; hint_y = suggest_rect.y + suggest_rect.height + BUTTON_GAP; hint_rect = pygame.Rect(hint_x, hint_y, OPTIONS_WIDTH, OPTIONS_HEIGHT); hover = hint_rect.collidepoint(pygame.mouse.get_pos()); color = BUTTON_HOVER if hover else BUTTON_COLOR; pygame.draw.rect(screen, color, hint_rect); hint_text = button_font.render("Hint", True, BLACK); hint_text_rect = hint_text.get_rect(center=hint_rect.center); screen.blit(hint_text, hint_text_rect)
                 # Draw Score Preview Checkbox
                 if suggest_rect:
                     checkbox_x = suggest_rect.left
                     checkbox_y = suggest_rect.bottom + BUTTON_GAP
                     preview_checkbox_rect = pygame.Rect(checkbox_x, checkbox_y, 20, 20) # Store rect for click detection
                     draw_checkbox(screen, checkbox_x, checkbox_y, preview_score_enabled)
                     label_surf = ui_font.render("Score Preview", True, BLACK)
                     screen.blit(label_surf, (checkbox_x + 25, checkbox_y + (preview_checkbox_rect.height - label_surf.get_height()) // 2))
            # --- End Draw UI Buttons ---

            # Draw Scoreboard ...
            history_to_draw = move_history[:current_replay_turn] if replay_mode else move_history
            is_final_turn_in_replay = replay_mode and current_replay_turn == len(move_history)
            sb_x = BOARD_SIZE + 275
            sb_y = 40
            sb_w = max(200, WINDOW_WIDTH - sb_x - 20)
            if sb_x + sb_w > WINDOW_WIDTH - 10:
                sb_w = WINDOW_WIDTH - sb_x - 10
            if sb_w < 150: # Adjusted min width slightly
                sb_x = WINDOW_WIDTH - 160
                sb_w = 150
            draw_scoreboard(screen, history_to_draw, scroll_offset, scores_to_display, is_ai, player_names, final_scores=final_scores, game_over_state=game_over_state or is_final_turn_in_replay)

            # Draw Typing Arrow / Cursor ...
            if selected_square and not typing: draw_arrow(selected_square[0], selected_square[1], selected_square[2])
            elif typing:
                 if current_r is not None and current_c is not None: cursor_x = 40 + current_c * SQUARE_SIZE + SQUARE_SIZE // 2; cursor_y = 40 + current_r * SQUARE_SIZE + SQUARE_SIZE - 5;
                 if int(time.time() * 2) % 2 == 0: pygame.draw.line(screen, BLACK, (cursor_x - 5, cursor_y), (cursor_x + 5, cursor_y), 2)
                 # Draw Preview Score Text
                 if preview_score_enabled:
                     preview_text = f"Preview: {current_preview_score}"
                     preview_surf = ui_font.render(preview_text, True, BLACK)
                     rack_y_preview = BOARD_SIZE + 80 if turn == 1 else BOARD_SIZE + 150
                     preview_x = BOARD_SIZE - preview_surf.get_width() - 10 # Example: bottom right of board area
                     preview_y = rack_y_preview - 30 # Example: Above the rack
                     screen.blit(preview_surf, (preview_x, preview_y))

            # Draw Endgame Solving Indicator
            if is_solving_endgame:
                draw_endgame_solving_indicator() # Use the helper function

            # Draw Batch Progress Indicator (if running)
            if is_batch_running:
                batch_text = f"Running Game: {current_batch_game_num} / {total_batch_games}"
                batch_surf = ui_font.render(batch_text, True, BLUE)
                indicator_center_x = sb_x + sb_w // 2
                indicator_top_y = sb_y - batch_surf.get_height() - 5 # 5 pixels above scoreboard top
                batch_rect = batch_surf.get_rect(centerx=indicator_center_x, top=max(5, indicator_top_y)) # Ensure not off top edge
                screen.blit(batch_surf, batch_rect)


            # Draw Dialogs ...
            if exchanging: tile_rects, exchange_button_rect, cancel_button_rect = draw_exchange_dialog(racks[turn-1], selected_tiles)
            elif hinting: hint_rects, play_button_rect, ok_button_rect, all_words_button_rect = draw_hint_dialog(hint_moves, selected_hint_index)
            elif showing_all_words:
                 # --- MODIFICATION: Filter All Words for BBB ---
                 if practice_mode == "eight_letter": moves_for_all = practice_target_moves
                 elif practice_mode == "power_tiles" and paused_for_power_tile: moves_for_all = sorted([m for m in all_moves if any(letter == current_power_tile for _, _, letter in m.get('newly_placed',[])) and is_word_length_allowed(len(m.get('word','')), number_checks)], key=lambda m: m['score'], reverse=True)
                 elif practice_mode == "bingo_bango_bongo" and paused_for_bingo_practice: moves_for_all = sorted([m for m in all_moves if m.get('is_bingo', False)], key=lambda m: m['score'], reverse=True)
                 else: moves_for_all = all_moves
                 # --- END MODIFICATION ---
                 all_words_rects, all_words_play_rect, all_words_ok_rect = draw_all_words_dialog(moves_for_all, selected_hint_index, all_words_scroll_offset)
            elif showing_practice_end_dialog: practice_play_again_rect, practice_main_menu_rect, practice_quit_rect = draw_practice_end_dialog(practice_end_message)

            # --- Draw Game Over / Stats Dialog / Replay Controls ---
            if game_over_state and not is_batch_running: # Don't show game over dialog during batch
                if final_scores is not None:
                    save_rect, quit_rect, replay_rect, play_again_rect, stats_rect = draw_game_over_dialog(dialog_x, dialog_y, final_scores, reason, player_names)
                if showing_stats and final_scores:
                    stats_ok_button_rect, stats_total_content_height = draw_stats_dialog(stats_dialog_x, stats_dialog_y, player_names, final_scores, tiles, stats_scroll_offset)
                draw_options_menu(turn_to_display, dropdown_open, len(bag)) # Draw options last
            elif replay_mode:
                replay_controls = [(replay_start_rect, "start"), (replay_prev_rect, "prev"), (replay_next_rect, "next"), (replay_end_rect, "end")]
                for rect, icon_type in replay_controls: hover = rect.collidepoint(pygame.mouse.get_pos()); color = BUTTON_HOVER if hover else BUTTON_COLOR; pygame.draw.rect(screen, color, rect); draw_replay_icon(screen, rect, icon_type)
                draw_options_menu(turn_to_display, dropdown_open, len(bag)) # Draw options last
            else:
                draw_options_menu(turn_to_display, dropdown_open, len(bag)) # Draw options last

            # Draw dragged tile last ...
            if dragged_tile and drag_pos:
                player_idx_drag = dragged_tile[0]-1; tile_val = None
                current_racks_for_drag = racks_to_display if replay_mode else racks
                if 0 <= player_idx_drag < len(current_racks_for_drag) and 0 <= dragged_tile[1] < len(current_racks_for_drag[player_idx_drag]):
                     tile_val = current_racks_for_drag[player_idx_drag][dragged_tile[1]]
                if tile_val:
                    draw_x = drag_pos[0] - (TILE_WIDTH // 2) - drag_offset[0]
                    draw_y = drag_pos[1] - (TILE_HEIGHT // 2) - drag_offset[1]
                    if tile_val == ' ':
                        center = (drag_pos[0] - drag_offset[0], drag_pos[1] - drag_offset[1]) # Center based on offset
                        radius = TILE_WIDTH // 2 - 2; pygame.draw.circle(screen, BLACK, center, radius); text = font.render('?', True, WHITE); text_rect = text.get_rect(center=center); screen.blit(text, text_rect)
                    else:
                        pygame.draw.rect(screen, GREEN, (draw_x, draw_y, TILE_WIDTH, TILE_HEIGHT)); text = font.render(tile_val, True, BLACK); screen.blit(text, (draw_x + 5, draw_y + 5))


            pygame.display.flip() # Update the full display

            # --- Handle end of inner loop for batch ---
            if game_over_state and is_batch_running:
                print(f"--- Finished Batch Game {current_batch_game_num} ---")
                # Collect stats for the completed game
                game_stats = collect_game_stats(current_batch_game_num, player_names, final_scores, move_history)
                batch_results.append(game_stats)
                running_inner = False # Exit inner loop to start next game or finish batch

        # --- End of Inner Game Loop ---
        if batch_stop_requested:
            print("--- Batch run stopping due to user request or error ---")
            break # Exit outer loop

    # --- End of Outer Batch Loop ---

    # --- Save batch stats after loop finishes ---
    if is_batch_running and batch_results:
        save_batch_statistics(batch_results, player_names)
        return_to_mode_selection = True

    print("--- main(): Exited main game loop(s). ---")
    if return_to_mode_selection:
        print("--- main(): Returning to mode selection... ---")
        main_called = False # Reset flag
        main() # Restart
    else:
        print("--- main(): Quitting pygame and exiting. ---")
        pygame.quit(); sys.exit()



# --- Program Entry Point ---
if __name__ == "__main__":
    print("--- Script execution started (__name__ == '__main__') ---")
    main_called = False # Ensure flag is reset before first call
    main()
