#Okay, here is the entire Python code with all the previously discussed updates incorporated into the relevant functions.

#python
# Stable: 30MAR25, 19:17 - Modified based on user request to fix initialization and other issues

#Stable version before major changes



# Part 1

# To-Do: ...then complete endgames with full analysis (multiple parts and steps here)
# To-Do: get actual RGB values for the official Scrabble board
# To-Do: create and save statistics, both in game and to a file for persistence
# To-Do: allow me to load a game and a) play it in my game b) gather stats from it, and...
# To-Do: ...c) automatically write those stats to my Scrabble spreadsheet
# To-Do: allow user to break/stop word Suggestion, sometimes it takes forever
# To-Do: give some strategy guidance to the AI, blank and S handling, etc.
# To-Do: when mode is AI vs AI, gray out Suggest and Options? Can I even click to Quit?

# To-Do: ----DONE----move the Player 1’s turn text off the board, it blocks letters
# To-Do: —---DONE—---add in 50-pt bonus for using all seven letters
# To-Do: ----DONE----allow for drag-n-drop tile rack letter manipulation
# To-Do: ----DONE----verify words for legality against a word list, All Words 2023.txt, located on my desktop
# To-Do: ----DONE----add code to handle blank tiles
# To-Do: ----DONE----add Pass, Exchange, Quit
# To-Do: ----DONE----change mechanics of playing a word to allow typing
# To-Do: ----DONE----change look of direction arrow, right click to remove, remove when typing starts
# To-Do: ----DONE----remaining tile list should print out all tiles remaining, not just A:3 format
# To-Do: ----DONE----allow the computer to play against itself
# To-Do: ----DONE----fix scoring, likely not accounting for both vertical and horizontal words
# To-Do: ----DONE----ensure bag draw is random, seems to be a lot of  blanks to start the game
# To-Do: ----DONE----change color of blanks, can't see against white background; maybe lowercase?
# To-Do: ----DONE----add last play and score note, likely at the bottom of the remaining letters list
# To-Do: ----DONE----Player 1 score text is overlaid on the bottom of the board, need to extend game window vertically
# To-Do: ----DONE----save Suggest results for the turn so no need to regenerate is asked again
# To-Do: —---DONE—---Generate all valid moves
# To-Do: —---DONE—---in word suggestion, show the leave on the rack after the word would be played
# To-Do: ----DONE----dramatically speed up the word generation algorithm
# To-Do: ----DONE----implement replay mode
# To-Do: ----DONE----change board coordinate references from (1,1) to A1, explain why to Grok




import pygame
import random
import math
import sys
import time
from itertools import permutations, product
from collections import Counter

# Initialize Pygame
pygame.init()
main_called = False # Flag to track if main() has been entered

# Constants
GRID_SIZE = 15
SQUARE_SIZE = 40
BOARD_SIZE = GRID_SIZE * SQUARE_SIZE
FONT_SIZE = SQUARE_SIZE // 2
TILE_WIDTH = 35
TILE_HEIGHT = 35
TILE_GAP = 5
BUTTON_WIDTH = 100
BUTTON_HEIGHT = 30
BUTTON_GAP = 10
CENTER_SQUARE = (7, 7)
OPTIONS_WIDTH = 100
OPTIONS_HEIGHT = 30
DROPDOWN_HEIGHT = 90
OPTIONS_Y = BOARD_SIZE + 60  # Adjusted from +40 to align with shifted UI
DOUBLE_CLICK_TIME = 300
SECOND_CLICK_TIME = 500  # Time window for second click
ALL_WORDS_DIALOG_WIDTH = 750
ALL_WORDS_DIALOG_HEIGHT = 600
SCROLL_SPEED = 20

# Dialog dimensions for game over dialog
DIALOG_WIDTH = 480
DIALOG_HEIGHT = 250
LETTERS = "ABCDEFGHIJKLMNO"  # For column labels

# Get screen resolution
display_info = pygame.display.Info()
# Set window size to fit within screen resolution (with padding for borders)
WINDOW_WIDTH = min(1400, display_info.current_w - 50)  # 50 pixels padding
WINDOW_HEIGHT = min(900, display_info.current_h - 50)  # 50 pixels padding

# Colors
WHITE = (255, 255, 255)
BLACK = (0, 0, 0)
RED = (255, 100, 100)
PINK = (255, 182, 193)
BLUE = (0, 102, 204)  # Darkened from (173, 216, 230) for TL
LIGHT_BLUE = (135, 206, 250)
HIGHLIGHT_BLUE = (191, 238, 255)
YELLOW = (255, 255, 153)
GRAY = (200, 200, 200)
GREEN = (144, 238, 144)
DARK_GREEN = (100, 200, 100)
BUTTON_COLOR = (180, 180, 180)
BUTTON_HOVER = (220, 220, 220)
TURN_INDICATOR_COLOR = (255, 215, 0)
DIALOG_COLOR = (150, 150, 150)
DROPDOWN_COLOR = (200, 200, 200)
SELECTED_TILE_COLOR = (255, 165, 0)
GRAYED_OUT_COLOR = (100, 100, 100)
ARROW_COLOR = (0, 0, 255)
HINT_NORMAL_COLOR = (220, 220, 220)
HINT_SELECTED_COLOR = (180, 180, 255)

# Setup display and font
screen = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))
pygame.display.set_caption("Scrabble Game")
font = pygame.font.SysFont("Arial", FONT_SIZE, bold=True)
ui_font = pygame.font.SysFont("Arial", 20)
button_font = pygame.font.SysFont("Arial", 16)
tile_count_font = pygame.font.SysFont("Arial", 14)
dialog_font = pygame.font.SysFont("Arial", 24)

# Tile bag and values (moved up to be defined before trie)
TILE_DISTRIBUTION = {
    'A': (9, 1), 'B': (2, 3), 'C': (2, 3), 'D': (4, 2), 'E': (12, 1), 'F': (2, 4),
    'G': (3, 2), 'H': (2, 4), 'I': (9, 1), 'J': (1, 8), 'K': (1, 5), 'L': (4, 1),
    'M': (2, 3), 'N': (6, 1), 'O': (8, 1), 'P': (2, 3), 'Q': (1, 10), 'R': (6, 1),
    'S': (4, 1), 'T': (6, 1), 'U': (4, 1), 'V': (2, 4), 'W': (2, 4), 'X': (1, 8),
    'Y': (2, 4), 'Z': (1, 10), ' ': (2, 0)
}
bag = [letter for letter, (count, _) in TILE_DISTRIBUTION.items() for _ in range(count)]

POWER_TILES = {'J', 'Q', 'X', 'Z'}

def draw_checkbox(screen, x, y, checked):
    pygame.draw.rect(screen, BLACK, (x, y, 20, 20), 1)
    if checked:
        pygame.draw.line(screen, BLACK, (x+2, y+2), (x+18, y+18), 2)
        pygame.draw.line(screen, BLACK, (x+18, y+2), (x+2, y+18), 2)


# Part 1
def save_game_to_gcg(player_names, move_history, initial_racks, final_scores):
    """Save the game to GCG format using move_history directly."""
    gcg_lines = [
        "#",
        f"#player1 {player_names[0]}",
        f"#player2 {player_names[1]}"
    ]
    cumulative_scores = [0, 0]

    for move in move_history:
        player = move['player'] - 1  # 0-based index
        rack = ''.join(sorted(tile if tile != ' ' else '?' for tile in move['rack']))

        if move['move_type'] == 'place':
            # Use the stored full word with blanks
            word_with_blanks = move.get('word_with_blanks', move.get('word','').upper()) # Use getter for safety
            score = move['score']
            cumulative_scores[player] += score
            gcg_lines.append(
                f">{player_names[player]}: {rack} {move['coord']} {word_with_blanks} +{score} {cumulative_scores[player]}"
            )
        elif move['move_type'] == 'exchange':
            exchanged = ''.join(sorted(tile if tile != ' ' else '?' for tile in move.get('exchanged_tiles',[]))) # Use getter
            gcg_lines.append(
                f">{player_names[player]}: {rack} ({exchanged}) +0 {cumulative_scores[player]}"
            )
        elif move['move_type'] == 'pass':
            gcg_lines.append(
                f">{player_names[player]}: {rack} -- +0 {cumulative_scores[player]}"
            )

    gcg_lines.append(f"Final score: {player_names[0]} {final_scores[0]}, {player_names[1]} {final_scores[1]}")

    return '\n'.join(gcg_lines)

def load_game_from_gcg(filename):
    """Load a game from a GCG file, returning data to enter replay mode."""
    move_history = []
    player_names = ["Player1", "Player2"]
    final_scores = [0, 0]

    with open(filename, "r") as f:
        for line in f:
            line = line.strip()
            if line.startswith("#player1"):
                player_names[0] = line.split()[1]
            elif line.startswith("#player2"):
                player_names[1] = line.split()[1]
            elif line.startswith("Final score:"):
                parts = line.split()
                final_scores[0] = int(parts[2].strip(','))
                final_scores[1] = int(parts[4])
            elif line.startswith(">"):
                parts = line.split()
                player_name = parts[0][1:-1]  # Remove > and :
                player = 1 if player_name == player_names[0] else 2
                rack = parts[1]
                move_details = parts[2]
                score = int(parts[3][1:])
                cumulative_score = int(parts[4])

                if move_details == "--":
                    move_history.append({
                        'player': player,
                        'move_type': 'pass',
                        'score': score,
                        'word': '',
                        'coord': ''
                    })
                elif move_details.startswith("("):
                    exchanged = move_details[1:-1]
                    move_history.append({
                        'player': player,
                        'move_type': 'exchange',
                        'exchanged_tiles': list(exchanged),
                        'score': score,
                        'word': '',
                        'coord': ''
                    })
                else:
                    position = parts[2]
                    word = parts[3]
                    if position[0].isalpha():  # Vertical: e.g., H8
                        col = LETTERS.index(position[0])
                        row = int(position[1:]) - 1
                        direction = "down"
                    else:  # Horizontal: e.g., 8H
                        row = int(position[0]) - 1
                        col = LETTERS.index(position[1])
                        direction = "right"
                    positions = []
                    blanks = set()
                    for i, letter in enumerate(word):
                        r = row if direction == "right" else row + i
                        c = col + i if direction == "right" else col
                        positions.append((r, c, letter))
                        if letter.islower():  # GCG uses lowercase for blanks
                            blanks.add((r, c))
                    move_history.append({
                        'player': player,
                        'move_type': 'place',
                        'positions': positions,
                        'blanks': blanks,
                        'score': score,
                        'word': word.upper(),
                        'start': (row, col),
                        'direction': direction,
                        'coord': position
                    })

    return player_names, move_history, final_scores


# Trie for efficient word prefix matching
class TrieNode:
    def __init__(self):
        self.children = {}
        self.is_end = False

class Trie:
    def __init__(self):
        self.root = TrieNode()

    def insert(self, word):
        node = self.root
        for char in word:
            if char not in node.children:
                node.children[char] = TrieNode()
            node = node.children[char]
        node.is_end = True

    def search(self, word):
        """Check if a word exists in the Trie."""
        node = self.root
        for char in word:
            if char not in node.children:
                return False
            node = node.children[char]
        return node.is_end

    def get_words_with_letters(self, letters):
        """Generate all possible words using the given letters, treating blanks as wildcards."""
        counter = Counter(letters)
        blanks = counter.get(' ', 0)  # Count of blank tiles
        if ' ' in counter:
            del counter[' ']  # Remove blanks from the letter counter
        words = []

        def dfs(node, prefix, blanks_left):
            """Depth-first search to find words, using blanks as wildcards."""
            if node.is_end:
                words.append(prefix)
            for char in node.children:
                if counter[char] > 0:
                    counter[char] -= 1
                    dfs(node.children[char], prefix + char, blanks_left)
                    counter[char] += 1  # Restore count after recursion
                elif blanks_left > 0:
                    dfs(node.children[char], prefix + char, blanks_left - 1)  # Use a blank as a wildcard

        dfs(self.root, '', blanks)
        return words

# Define a simple DAWG node for demonstration (in practice, this would be precomputed)
class DawgNode:
    def __init__(self):
        self.edges = {}  # letter -> next_node
        self.is_terminal = False  # Marks end of a word

class Dawg:
    def __init__(self):
        self.root = DawgNode()

    def insert(self, word):
        node = self.root
        for char in word:
            if char not in node.edges:
                node.edges[char] = DawgNode()
            node = node.edges[char]
        node.is_terminal = True


# Load the DAWG with words from "All Words 2023.txt"
DAWG = Dawg()
try:
    with open("All Words 2023.txt", "r") as f:
        for word in (w.strip().upper() for w in f):
            DAWG.insert(word)
except FileNotFoundError:
    print("Error: 'All Words 2023.txt' not found. Word validation will not work.")
    # Optionally, exit or provide a way to specify the file path
    # sys.exit()


# Mode selection constants
MODE_HVH = "Human vs Human"
MODE_HVA = "Human vs AI"
MODE_AVA = "AI vs AI"
#AI_DELAY = 200  # 1-second delay for AI moves

# Replay button positions
REPLAY_BUTTON_Y = OPTIONS_Y + OPTIONS_HEIGHT + 10  # 660 + 30 + 10 = 700, below Options and Suggest
REPLAY_BUTTON_WIDTH = 50
REPLAY_BUTTON_HEIGHT = 30
REPLAY_BUTTON_GAP = 10
replay_start_rect = pygame.Rect(10, REPLAY_BUTTON_Y, REPLAY_BUTTON_WIDTH, REPLAY_BUTTON_HEIGHT)  # << at x=10
replay_prev_rect = pygame.Rect(10 + REPLAY_BUTTON_WIDTH + REPLAY_BUTTON_GAP, REPLAY_BUTTON_Y, REPLAY_BUTTON_WIDTH, REPLAY_BUTTON_HEIGHT)  # < at x=70
replay_next_rect = pygame.Rect(10 + 2 * (REPLAY_BUTTON_WIDTH + REPLAY_BUTTON_GAP), REPLAY_BUTTON_Y, REPLAY_BUTTON_WIDTH, REPLAY_BUTTON_HEIGHT)  # > at x=130
replay_end_rect = pygame.Rect(10 + 3 * (REPLAY_BUTTON_WIDTH + REPLAY_BUTTON_GAP), REPLAY_BUTTON_Y, REPLAY_BUTTON_WIDTH, REPLAY_BUTTON_HEIGHT)  # >> at x=190


def get_coord(start, direction):
    row, col = start
    if direction == "right":
        return f"{row + 1}{LETTERS[col]}"
    else:  # "down"
        return f"{LETTERS[col]}{row + 1}"

def parse_coord(coord):
    """Parse a GCG coordinate (e.g., '8H' or 'H8') into (row, col) and direction."""
    if coord[0].isalpha():  # Vertical: e.g., H8 or H10
        col = LETTERS.index(coord[0])
        row = int(coord[1:]) - 1
        direction = "down"
    else:  # Horizontal: e.g., 8H or 10A
        i = 0
        while i < len(coord) and coord[i].isdigit():
            i += 1
        row = int(coord[:i]) - 1
        col = LETTERS.index(coord[i])
        direction = "right"
    return (row, col), direction

def create_board():
    """Initialize the Scrabble board with special squares and labels."""
    board = [[WHITE for _ in range(GRID_SIZE)] for _ in range(GRID_SIZE)]  # Changed from GRAY to WHITE
    labels = [['' for _ in range(GRID_SIZE)] for _ in range(GRID_SIZE)]
    tiles = [['' for _ in range(GRID_SIZE)] for _ in range(GRID_SIZE)]

    tw = [(0, 0), (0, 7), (0, 14), (7, 0), (7, 14), (14, 0), (14, 7), (14, 14)]
    dw = [
        (1, 1), (2, 2), (3, 3), (4, 4), (10, 10), (11, 11), (12, 12), (13, 13),
        (1, 13), (2, 12), (3, 11), (4, 10), (10, 4), (11, 3), (12, 2), (13, 1)
    ]
    tl = [
        (1, 5), (1, 9), (5, 1), (5, 5), (5, 9), (5, 13), (9, 1), (9, 5),
        (9, 9), (9, 13), (13, 5), (13, 9)
    ]
    dl = [
        (0, 3), (0, 11), (2, 6), (2, 8), (3, 0), (3, 7), (3, 14), (6, 2),
        (6, 6), (6, 8), (6, 12), (7, 3), (7, 11), (8, 2), (8, 6), (8, 8),
        (8, 12), (11, 0), (11, 7), (11, 14), (12, 6), (12, 8), (14, 3), (14, 11)
    ]

    for r, c in tw:
        board[r][c] = RED
    for r, c in dw:
        board[r][c] = PINK
    for r, c in tl:
        board[r][c] = BLUE
    for r, c in dl:
        board[r][c] = LIGHT_BLUE
    board[7][7] = PINK

    return board, labels, tiles

# Function 4: draw_rack (Updated)
def draw_rack(player, rack, scores, turn, player_names, dragged_tile=None, drag_pos=None, display_scores=None):
    """Draw a player's rack with tiles, scores, and buttons."""
    if not rack:  # Skip drawing if rack is empty or None
        return None, None
    if display_scores is None:
        display_scores = scores
    # Check practice_mode which should be global or passed in
    # Assuming practice_mode is global for now
    global practice_mode
    if practice_mode == "eight_letter" and player == 2:
        return None, None # Don't draw P2 rack in this mode

    rack_width = 7 * (TILE_WIDTH + TILE_GAP) - TILE_GAP
    # Simplified centering relative to board
    start_x = max(OPTIONS_WIDTH + BUTTON_GAP + 10, (BOARD_SIZE - rack_width) // 2) # Ensure space for options

    rack_y = BOARD_SIZE + 80 if player == 1 else BOARD_SIZE + 150

    if turn == player:
        center_x = start_x - 20 # Position indicator left of the rack
        center_y = rack_y + TILE_HEIGHT // 2
        radius = 10
        points = []
        for i in range(10):
            angle = i * math.pi / 5
            r = radius if i % 2 == 0 else radius / 2
            x = center_x + r * math.cos(angle)
            y = center_y + r * math.sin(angle)
            points.append((x, y))
        pygame.draw.polygon(screen, TURN_INDICATOR_COLOR, points)

    for i, tile in enumerate(rack):
        tile_x = start_x + i * (TILE_WIDTH + TILE_GAP)
        if dragged_tile == (player, i) and drag_pos:
            continue  # Skip drawing the dragged tile here
        if tile == ' ':
            # Draw black circle for blank in rack
            center = (tile_x + TILE_WIDTH // 2, rack_y + TILE_HEIGHT // 2)
            radius = TILE_WIDTH // 2 - 2
            pygame.draw.circle(screen, BLACK, center, radius)
            text = font.render('?', True, WHITE)
            text_rect = text.get_rect(center=center)
            screen.blit(text, text_rect)
        else:
            # Regular tile in rack
            pygame.draw.rect(screen, GREEN, (tile_x, rack_y, TILE_WIDTH, TILE_HEIGHT))
            text = font.render(tile, True, BLACK)
            screen.blit(text, (tile_x + 5, rack_y + 5))

    if dragged_tile and dragged_tile[0] == player and drag_pos: # Check drag_pos exists
        tile_x, tile_y = drag_pos
        # Ensure dragged_tile[1] is a valid index for the current rack
        if 0 <= dragged_tile[1] < len(rack):
            tile = rack[dragged_tile[1]]
            if tile == ' ':
                # Draw black circle for blank being dragged
                center = (tile_x, tile_y)
                radius = TILE_WIDTH // 2 - 2
                pygame.draw.circle(screen, BLACK, center, radius)
                text = font.render('?', True, WHITE)
                text_rect = text.get_rect(center=center)
                screen.blit(text, text_rect)
            else:
                # Regular tile being dragged
                pygame.draw.rect(screen, GREEN, (tile_x - TILE_WIDTH // 2, tile_y - TILE_HEIGHT // 2, TILE_WIDTH, TILE_HEIGHT))
                text = font.render(tile, True, BLACK)
                screen.blit(text, (tile_x - TILE_WIDTH // 2 + 5, tile_y - TILE_HEIGHT // 2 + 5))

    button_x = start_x + rack_width + BUTTON_GAP
    alpha_button_rect = pygame.draw.rect(screen, BUTTON_COLOR, (button_x, rack_y, BUTTON_WIDTH, BUTTON_HEIGHT))
    rand_button_rect = pygame.draw.rect(screen, BUTTON_COLOR, (button_x + BUTTON_WIDTH + BUTTON_GAP, rack_y, BUTTON_WIDTH, BUTTON_HEIGHT))

    alpha_text = button_font.render("Alphabetize", True, BLACK)
    alpha_rect = alpha_text.get_rect(center=(button_x + BUTTON_WIDTH // 2, rack_y + BUTTON_HEIGHT // 2))
    screen.blit(alpha_text, alpha_rect)
    rand_text = button_font.render("Randomize", True, BLACK)
    rand_rect = rand_text.get_rect(center=(button_x + BUTTON_WIDTH + BUTTON_GAP + BUTTON_WIDTH // 2, rack_y + BUTTON_HEIGHT // 2))
    screen.blit(rand_text, rand_rect)

    # Ensure player index is valid before accessing player_names or display_scores
    if 0 <= player - 1 < len(player_names) and 0 <= player - 1 < len(display_scores):
        score_text = ui_font.render(f"{player_names[player-1]} Score: {display_scores[player-1]}", True, BLACK)
        screen.blit(score_text, (start_x, rack_y - 20))
    else:
        # Handle potential index error (e.g., during replay state transitions)
        print(f"Warning: Invalid player index {player} for score display.")


    return alpha_button_rect, rand_button_rect

# Function 5: draw_replay_icon (Updated)
def draw_replay_icon(screen, rect, icon_type):
    """Draw centered replay control icons (arrows) on the buttons."""
    center_x, center_y = rect.center
    arrow_size = 8  # Size of each arrow segment for consistent scaling

    if icon_type == "start": # << (Go to Start)
        pygame.draw.polygon(screen, BLACK, [(center_x + 6, center_y - arrow_size), (center_x - 2, center_y), (center_x + 6, center_y + arrow_size)]) # Left arrow 1
        pygame.draw.polygon(screen, BLACK, [(center_x - 2, center_y - arrow_size), (center_x - 10, center_y), (center_x - 2, center_y + arrow_size)]) # Left arrow 2
    elif icon_type == "prev": # < (Previous Move)
        pygame.draw.polygon(screen, BLACK, [(center_x + 6, center_y - arrow_size), (center_x - 6, center_y), (center_x + 6, center_y + arrow_size)]) # Single Left arrow
    elif icon_type == "next": # > (Next Move)
        pygame.draw.polygon(screen, BLACK, [(center_x - 6, center_y - arrow_size), (center_x + 6, center_y), (center_x - 6, center_y + arrow_size)]) # Single Right arrow
    elif icon_type == "end": # >> (Go to End)
        pygame.draw.polygon(screen, BLACK, [(center_x - 6, center_y - arrow_size), (center_x + 2, center_y), (center_x - 6, center_y + arrow_size)]) # Right arrow 1
        pygame.draw.polygon(screen, BLACK, [(center_x + 2, center_y - arrow_size), (center_x + 10, center_y), (center_x + 2, center_y + arrow_size)]) # Right arrow 2

# Function 6: draw_scoreboard (Updated)
def draw_scoreboard(screen, move_history, scroll_offset, scores, is_ai, final_scores=None, game_over_state=False):
    scoreboard_x = BOARD_SIZE + 275  # Right of the board
    scoreboard_y = 40  # Align with board top
    scoreboard_width = max(200, WINDOW_WIDTH - BOARD_SIZE - 20)  # Ensure minimum width of 200
    scoreboard_height = WINDOW_HEIGHT - 80  # Full height minus margins

    # Adjust scoreboard_x if window is too narrow
    if scoreboard_x + scoreboard_width > WINDOW_WIDTH - 10:
        scoreboard_width = WINDOW_WIDTH - scoreboard_x - 10  # Fit within window
        if scoreboard_width < 200:  # If still too small, reposition
            scoreboard_x = WINDOW_WIDTH - 210  # Move left to fit 200px width
            scoreboard_width = 200

    # Create scoreboard surface
    scoreboard_surface = pygame.Surface((scoreboard_width, scoreboard_height))
    scoreboard_surface.fill(WHITE)

    # Running totals for display during game
    running_scores = [0, 0]  # [P1, P2]
    y_pos = 10 - scroll_offset

    for i, move in enumerate(move_history):
        player_idx = move['player'] - 1
        running_scores[player_idx] += move['score']
        # Check if player index is valid for is_ai list
        player_label = "AI" if 0 <= player_idx < len(is_ai) and is_ai[player_idx] else f"P{move['player']}"
        display_score = running_scores[player_idx]
        if move['move_type'] == 'place':
            # Ensure 'word' and 'coord' keys exist
            word = move.get('word', 'N/A')
            coord = move.get('coord', 'N/A')
            text = f"{i+1}: {player_label} - {word} at {coord} (+{move['score']}) Total: {display_score}"
        elif move['move_type'] == 'pass':
            text = f"{i+1}: {player_label} - Pass (+0) Total: {display_score}"
        elif move['move_type'] == 'exchange':
            text = f"{i+1}: {player_label} - Exchange (+0) Total: {display_score}"
        else:
            text = f"{i+1}: {player_label} - Unknown Move Type" # Handle unexpected types

        text_surface = ui_font.render(text, True, BLACK)
        if y_pos < scoreboard_height and y_pos + 20 > 0:  # Render if any part is visible
            if (i // 2) % 2 == 0:  # Highlight moves 1-2, 5-6, etc.
                rect_width = 10 + text_surface.get_width() + 10
                highlight_rect = pygame.Rect(0, y_pos, rect_width, 20)
                pygame.draw.rect(scoreboard_surface, HIGHLIGHT_BLUE, highlight_rect)
            scoreboard_surface.blit(text_surface, (10, y_pos))
        y_pos += 20

    # Display final scores when game is over, matching draw_stats_dialog
    if game_over_state and final_scores is not None:
        y_pos += 20  # Add spacing after last move
        final_text = f"Final Scores: P1: {final_scores[0]}, P2: {final_scores[1]}"
        final_surface = ui_font.render(final_text, True, BLACK)
        if y_pos < scoreboard_height and y_pos + 20 > 0:
            scoreboard_surface.blit(final_surface, (10, y_pos))

    screen.blit(scoreboard_surface, (scoreboard_x, scoreboard_y))


# End of Part 1

# Part 2

# Function 7: find_main_word (Updated)
def find_main_word(new_tiles, tiles):
    if not new_tiles: return [], None # Handle empty input

    rows = set(r for r, c, _ in new_tiles)
    cols = set(c for r, c, _ in new_tiles)

    if len(rows) == 1: # Potential horizontal word
        orientation = "horizontal"
        row = rows.pop()
        min_col = min(c for r, c, _ in new_tiles if r == row)
        max_col = max(c for r, c, _ in new_tiles if r == row)
        # Extend to include adjacent existing tiles
        while min_col > 0 and tiles[row][min_col - 1]: min_col -= 1
        while max_col < GRID_SIZE - 1 and tiles[row][max_col + 1]: max_col += 1
        # Collect all tiles in the extended range
        main_word = [(row, c, tiles[row][c]) for c in range(min_col, max_col + 1) if tiles[row][c]]
        # Only return if it forms a word of length > 1
        return (main_word, orientation) if len(main_word) > 1 else ([], None)

    elif len(cols) == 1: # Potential vertical word
        orientation = "vertical"
        col = cols.pop()
        min_row = min(r for r, c, _ in new_tiles if c == col)
        max_row = max(r for r, c, _ in new_tiles if c == col)
        # Extend to include adjacent existing tiles
        while min_row > 0 and tiles[min_row - 1][col]: min_row -= 1
        while max_row < GRID_SIZE - 1 and tiles[max_row + 1][col]: max_row += 1
        # Collect all tiles in the extended range
        main_word = [(r, col, tiles[r][col]) for r in range(min_row, max_row + 1) if tiles[r][col]]
        # Only return if it forms a word of length > 1
        return (main_word, orientation) if len(main_word) > 1 else ([], None)

    else: # Tiles not aligned or single tile
         # If it's a single tile, it doesn't form a "main" word by itself
         # The calling function (find_all_words_formed) will check for cross words.
        return [], None

def find_cross_word(tile, tiles, main_orientation):
    r, c, _ = tile
    if main_orientation == "horizontal":
        min_row = r
        while min_row > 0 and tiles[min_row - 1][c]:
            min_row -= 1
        max_row = r
        while max_row < GRID_SIZE - 1 and tiles[max_row + 1][c]:
            max_row += 1
        if max_row > min_row:
            return [(rr, c, tiles[rr][c]) for rr in range(min_row, max_row + 1)]
        else:
            return []
    elif main_orientation == "vertical":
        min_col = c
        while min_col > 0 and tiles[r][min_col - 1]:
            min_col -= 1
        max_col = c
        while max_col < GRID_SIZE - 1 and tiles[r][max_col + 1]:
            max_col += 1
        if max_col > min_col:
            return [(r, cc, tiles[r][cc]) for cc in range(min_col, max_col + 1)]
        else:
            return []
    else:
        return []

# Function 8: find_all_words_formed (Updated)
def find_all_words_formed(new_tiles, tiles):
    words = []
    if not new_tiles: return words

    new_positions_set = set((r, c) for r, c, _ in new_tiles)
    main_word_tiles, orientation = find_main_word(new_tiles, tiles)

    if main_word_tiles:
        words.append(main_word_tiles)
        # Check for cross words perpendicular to the main word
        for tile in new_tiles:
            cross_word = find_cross_word(tile, tiles, orientation)
            if cross_word and len(cross_word) > 1:
                words.append(cross_word)
    else:
        # If no main word (e.g., single tile placement), check for cross words in both directions
        # This handles cases where a single tile connects two existing words or extends one.
        for tile in new_tiles:
            # Check horizontal cross word (as if main was vertical)
            cross_h = find_cross_word(tile, tiles, "vertical")
            if cross_h and len(cross_h) > 1:
                words.append(cross_h)
            # Check vertical cross word (as if main was horizontal)
            cross_v = find_cross_word(tile, tiles, "horizontal")
            if cross_v and len(cross_v) > 1:
                words.append(cross_v)

    # Ensure uniqueness of word tile lists (though content might be same word string)
    unique_word_tile_lists = []
    seen_signatures = set()
    for word_tile_list in words:
        signature = tuple(sorted((r, c, l) for r, c, l in word_tile_list))
        if signature not in seen_signatures:
            unique_word_tile_lists.append(word_tile_list)
            seen_signatures.add(signature)

    return unique_word_tile_lists


def calculate_score(new_tiles, board, tiles, blanks):
    total_score = 0
    new_positions = set((r, c) for r, c, _ in new_tiles)
    words = find_all_words_formed(new_tiles, tiles)
    for word_tiles in words:
        word_score = 0
        word_multiplier = 1
        for r, c, letter in word_tiles:
            if letter not in TILE_DISTRIBUTION:
                continue
            letter_value = 0 if (r, c) in blanks else TILE_DISTRIBUTION[letter][1]
            letter_multiplier = 1
            if (r, c) in new_positions:
                if board[r][c] == LIGHT_BLUE:
                    letter_multiplier = 2
                elif board[r][c] == BLUE:
                    letter_multiplier = 3
                if board[r][c] == PINK:
                    word_multiplier *= 2
                elif board[r][c] == RED:
                    word_multiplier *= 3
            word_score += letter_value * letter_multiplier
        word_score *= word_multiplier
        total_score += word_score
    if len(new_tiles) == 7:
        total_score += 50
    return total_score

import random


def select_seven_letter_word(removed_letter, seven_letter_words):
    candidates = [word for word in seven_letter_words if removed_letter in word]
    if not candidates:
        print(f"No 7-letter words contain '{removed_letter}'")
        # Ensure seven_letter_words is not empty before choosing
        return random.choice(seven_letter_words) if seven_letter_words else None
    return random.choice(candidates)

# Function 1: eight_letter_practice (Updated)
def eight_letter_practice():
    """Handle 8-letter practice mode: open word list files, display dialog, and set up practice game."""
    # Removed global declarations, state will be returned

    # Part 1, 2, 3, 4: Read word lists at the start for use later
    try:
        with open("7-letter-list.txt", "r") as seven_file, open("8-letter-list.txt", "r") as eight_file:
            seven_letter_words = [line.strip().upper() for line in seven_file.readlines()]
            eight_letter_words = [line.strip().upper() for line in eight_file.readlines()]
    except FileNotFoundError:
        print("Error: Could not find 7-letter-list.txt or 8-letter-list.txt")
        # Return failure state
        return False, None, None, None, None, None

    # Check if lists are empty
    if not seven_letter_words or not eight_letter_words:
        print("Error: Word list files are empty.")
        return False, None, None, None, None, None


    # Dialog dimensions and position
    dialog_width, dialog_height = 300, 150
    dialog_x = (WINDOW_WIDTH - dialog_width) // 2
    dialog_y = (WINDOW_HEIGHT - dialog_height) // 2

    # Variables to return
    proceed = False
    text_box_active = False
    probability_input = ""

    # Dialog loop
    while True:
        screen.fill(WHITE)
        pygame.draw.rect(screen, DIALOG_COLOR, (dialog_x, dialog_y, dialog_width, dialog_height))
        pygame.draw.rect(screen, BLACK, (dialog_x, dialog_y, dialog_width, dialog_height), 2)

        title_text = dialog_font.render("8-Letter Bingo Options", True, BLACK)
        screen.blit(title_text, (dialog_x + 10, dialog_y + 10))

        prob_text = ui_font.render("Probability", True, BLACK)
        screen.blit(prob_text, (dialog_x + 20, dialog_y + 50))
        text_box_rect = pygame.Rect(dialog_x + 120, dialog_y + 45, 150, 30)
        pygame.draw.rect(screen, WHITE, text_box_rect)
        pygame.draw.rect(screen, BLACK, text_box_rect, 1)
        input_text = ui_font.render(probability_input, True, BLACK)
        screen.blit(input_text, (text_box_rect.x + 5, text_box_rect.y + 5))

        go_rect = pygame.Rect(dialog_x + 50, dialog_y + 100, 100, 30)
        cancel_rect = pygame.Rect(dialog_x + 160, dialog_y + 100, 100, 30)
        pygame.draw.rect(screen, BUTTON_COLOR, go_rect)
        pygame.draw.rect(screen, BUTTON_COLOR, cancel_rect)
        go_text = button_font.render("Go", True, BLACK)
        cancel_text = button_font.render("Cancel", True, BLACK)
        screen.blit(go_text, go_text.get_rect(center=go_rect.center))
        screen.blit(cancel_text, cancel_text.get_rect(center=cancel_rect.center))

        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()
            elif event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
                x, y = event.pos
                if text_box_rect.collidepoint(x, y):
                    text_box_active = True
                else:
                    text_box_active = False
                if go_rect.collidepoint(x, y):
                    # Process input and select 8-letter word
                    max_index = len(eight_letter_words) if not probability_input else int(probability_input)
                    if max_index < 1:
                        max_index = 1
                    elif max_index > len(eight_letter_words):
                        max_index = len(eight_letter_words)
                    selected_eight = random.choice(eight_letter_words[:max_index])
                    print("Selected 8-letter word:", selected_eight)

                    # Part 1: Randomly remove one letter from the 8-letter word
                    remove_idx = random.randint(0, 7)
                    removed_letter = selected_eight[remove_idx]  # Capture the removed letter
                    removed_eight = selected_eight[:remove_idx] + selected_eight[remove_idx + 1:]

                    # Part 1.5: Debug print removed_eight
                    print("Removed eight (7 letters):", removed_eight)
                    print("Removed letter:", removed_letter)

                    # Select 7-letter word (original functionality)
                    selected_seven = select_seven_letter_word(removed_letter, seven_letter_words)
                    if selected_seven is None: # Handle case where no suitable 7-letter word found
                        print("Error: Could not find a suitable 7-letter word.")
                        return False, None, None, None, None, None # Indicate failure
                    print("Selected 7-letter word:", selected_seven)

                    # Part 3, 4, 5: Set up game state locally
                    # Initialize board and tiles
                    board, _, tiles = create_board() # Note: create_board returns board, labels, tiles
                    local_racks = [[], []]  # Initialize racks
                    local_blanks = set()

                    # Part 4: Place removed_eight on Player 1's rack in alphabetical order
                    local_racks[0] = sorted(list(removed_eight))

                    # Ensure Player 2's rack is empty
                    local_racks[1] = []

                    # Part 5: Place selected_seven on the board through the center
                    center_r, center_c = CENTER_SQUARE  # (7, 7)
                    print(f"Placing {selected_seven} on board, starting at ({center_r}, {center_c})")
                    # Ensure placement doesn't go off board
                    if center_c + len(selected_seven) <= GRID_SIZE:
                        for i, letter in enumerate(selected_seven):
                            tiles[center_r][center_c + i] = letter  # Horizontal placement through center
                    else:
                        print("Error: Selected 7-letter word too long for center placement.")
                        return False, None, None, None, None, None # Indicate failure


                    # Create a fresh bag for this mode
                    local_bag = [letter for letter, (count, _) in TILE_DISTRIBUTION.items() for _ in range(count)]
                    random.shuffle(local_bag)

                    # Remove placed tiles from the local bag (optional, but good practice)
                    for char in selected_seven:
                        if char in local_bag: local_bag.remove(char)
                    for char in removed_eight:
                        if char in local_bag: local_bag.remove(char)


                    # Return the initialized state instead of modifying globals or calling main()
                    return True, board, tiles, local_racks, local_blanks, local_bag

                elif cancel_rect.collidepoint(x, y):
                     # Indicate cancellation and return None for state variables
                    return False, None, None, None, None, None
            elif event.type == pygame.KEYDOWN and text_box_active:
                if event.key == pygame.K_BACKSPACE:
                    probability_input = probability_input[:-1]
                elif event.unicode.isdigit():
                    probability_input += event.unicode

        pygame.display.flip()
    # Add a default return if the loop exits unexpectedly (e.g., window closed)
    return False, None, None, None, None, None

# Function 2: mode_selection_screen (Updated)
def mode_selection_screen():
    """Display and handle the game mode selection screen."""
    global main_called # Keep track if main needs restarting
    # Load and prepare the background image
    try:
        image = pygame.image.load("Scrabble_S.png").convert_alpha()
        content_width = WINDOW_WIDTH - 200  # Reduce width by 200 pixels
        image = pygame.transform.scale(image, (content_width, WINDOW_HEIGHT))
        image.set_alpha(128)  # Set transparency to 128
        content_left = (WINDOW_WIDTH - content_width) // 2  # Center the content area
    except pygame.error as e:
        print(f"Warning: Could not load background image 'Scrabble_S.png': {e}")
        image = None # Handle gracefully if image fails to load
        content_width = WINDOW_WIDTH
        content_left = 0


    modes = [MODE_HVH, MODE_HVA, MODE_AVA]
    selected_mode = None
    player_names = ["Player 1", "Player 2"]
    human_player = 1  # Default to Player 1 in Human vs AI
    input_active = [False, False]
    current_input = 0 # Index for the selected mode button (0=HVH, 1=HVA, 2=AVA)
    practice_mode = None  # Initialize practice_mode
    dropdown_open = False  # State for Player 2 dropdown
    showing_power_tiles_dialog = False
    #showing_bingo_dialog = False
    #seven_letter_file = None
    #eight_letter_file = None

    # Add these lines before the while loop
    letter_checks = [True, True, True, True]  # For J, Q, X, Z, all initially checked
    number_checks = [True, True, True, True, False, False]  # For 2,3,4,5,6,7+, 2-5 checked, 6,7+ unchecked
    practice_state = None # Initialize practice_state dictionary

    while selected_mode is None:
        option_rects = [] # Define inside loop to recalculate if dropdown opens/closes
        if modes[current_input] == MODE_HVH and dropdown_open:
            dropdown_x = content_left + (content_width - 200) // 2  # Same as name_rect_x
            # Position dropdown below the "Practice" button itself
            name_rect_x = content_left + (content_width - 200) // 2
            dropdown_button_y = 300 + 60 + BUTTON_HEIGHT + 10 # Y position of the Practice button
            dropdown_y = dropdown_button_y + 30 # Start options below the button

            options = ["Power Tiles", "8-Letter Bingos", "End Game"]
            for i, option in enumerate(options):
                option_rect = pygame.Rect(dropdown_x, dropdown_y + 30 * i, 200, 30) # Use i directly
                option_rects.append(option_rect)


        screen.fill(WHITE)
        if image: # Only blit if image loaded successfully
            screen.blit(image, (content_left, 0))  # Blit image at centered position

        # Draw title centered within content area
        title_text = dialog_font.render("Select Game Mode", True, BLACK)
        title_x = content_left + (content_width - title_text.get_width()) // 2
        screen.blit(title_text, (title_x, 50))

        mode_rects = []
        for i, mode in enumerate(modes):
            y_pos = 100 + i * 60
            rect = pygame.Rect(content_left + (content_width - (BUTTON_WIDTH * 2 + 20)) // 2, y_pos, BUTTON_WIDTH * 2 + 20, BUTTON_HEIGHT)
            hover = rect.collidepoint(pygame.mouse.get_pos())
            # Highlight the currently selected mode button differently
            if i == current_input:
                 color = BUTTON_HOVER # Or a distinct selected color
                 pygame.draw.rect(screen, color, rect)
                 pygame.draw.rect(screen, BLACK, rect, 2) # Add border to selected
            else:
                 color = BUTTON_HOVER if hover else BUTTON_COLOR
                 pygame.draw.rect(screen, color, rect)

            text = button_font.render(mode, True, BLACK)
            text_rect = text.get_rect(center=rect.center)
            screen.blit(text, text_rect)
            mode_rects.append(rect)

        # Draw Play Later button in lower-right corner
        play_later_rect = pygame.Rect(WINDOW_WIDTH - BUTTON_WIDTH - 10, WINDOW_HEIGHT - BUTTON_HEIGHT - 10, BUTTON_WIDTH, BUTTON_HEIGHT)
        hover = play_later_rect.collidepoint(pygame.mouse.get_pos())
        color = BUTTON_HOVER if hover else BUTTON_COLOR
        pygame.draw.rect(screen, color, play_later_rect)
        play_later_text = button_font.render("Play Later", True, BLACK)
        play_later_text_rect = play_later_text.get_rect(center=play_later_rect.center)
        screen.blit(play_later_text, play_later_text_rect)

        name_y_start = 300
        name_rect_width = 200
        name_rect_x = content_left + (content_width - name_rect_width) // 2

        # Player 1 Name Input (Always visible)
        p1_y_pos = name_y_start
        p1_label_text = "Player 1 Name:"
        p1_label = ui_font.render(p1_label_text, True, BLACK)
        p1_name_rect = pygame.Rect(name_rect_x, p1_y_pos, name_rect_width, BUTTON_HEIGHT)
        p1_label_x = name_rect_x - p1_label.get_width() - 10
        screen.blit(p1_label, (p1_label_x, p1_y_pos + 5))
        pygame.draw.rect(screen, WHITE if not input_active[0] else LIGHT_BLUE, p1_name_rect)
        pygame.draw.rect(screen, BLACK, p1_name_rect, 1)
        p1_name_text = ui_font.render(player_names[0], True, BLACK)
        screen.blit(p1_name_text, (p1_name_rect.x + 5, p1_name_rect.y + 5))

        # Player 2 / AI Name Input (Depends on mode)
        p2_y_pos = name_y_start + 60
        if modes[current_input] == MODE_HVH:
            p2_label_text = "Player 2 Name:"
            p2_label = ui_font.render(p2_label_text, True, BLACK)
            p2_name_rect = pygame.Rect(name_rect_x, p2_y_pos, name_rect_width, BUTTON_HEIGHT)
            p2_label_x = name_rect_x - p2_label.get_width() - 10
            screen.blit(p2_label, (p2_label_x, p2_y_pos + 5))
            pygame.draw.rect(screen, WHITE if not input_active[1] else LIGHT_BLUE, p2_name_rect)
            pygame.draw.rect(screen, BLACK, p2_name_rect, 1)
            p2_name_text = ui_font.render(player_names[1], True, BLACK)
            screen.blit(p2_name_text, (p2_name_rect.x + 5, p2_name_rect.y + 5))

            # Draw dropdown under Player 2 text box if in HvH mode
            dropdown_button_y = p2_y_pos + BUTTON_HEIGHT + 10 # Below Player 2 text box
            dropdown_rect = pygame.Rect(name_rect_x, dropdown_button_y, 200, 30)
            hover = dropdown_rect.collidepoint(pygame.mouse.get_pos())
            color = BUTTON_HOVER if hover else BUTTON_COLOR
            pygame.draw.rect(screen, color, dropdown_rect)
            text = button_font.render("Practice", True, BLACK)
            text_rect = text.get_rect(center=dropdown_rect.center)
            screen.blit(text, text_rect)

            if dropdown_open:
                options = ["Power Tiles", "8-Letter Bingos", "End Game"]
                for i, option in enumerate(options):
                    # Ensure option_rects has been populated
                    if i < len(option_rects):
                        option_rect = option_rects[i]
                        hover = option_rect.collidepoint(pygame.mouse.get_pos())
                        color = BUTTON_HOVER if hover else DROPDOWN_COLOR
                        pygame.draw.rect(screen, color, option_rect)
                        text = button_font.render(option, True, BLACK)
                        text_rect = text.get_rect(center=option_rect.center)
                        screen.blit(text, text_rect)

        elif modes[current_input] == MODE_HVA:
            p2_label_text = "AI Name:"
            p2_label = ui_font.render(p2_label_text, True, BLACK)
            p2_name_rect = pygame.Rect(name_rect_x, p2_y_pos, name_rect_width, BUTTON_HEIGHT)
            p2_label_x = name_rect_x - p2_label.get_width() - 10
            screen.blit(p2_label, (p2_label_x, p2_y_pos + 5))
            pygame.draw.rect(screen, GRAY, p2_name_rect) # AI name not editable
            pygame.draw.rect(screen, BLACK, p2_name_rect, 1)
            p2_name_text = ui_font.render(player_names[1], True, BLACK) # Show default "AI" or similar
            screen.blit(p2_name_text, (p2_name_rect.x + 5, p2_name_rect.y + 5))

            # Draw "Play as P1/P2" buttons for HVA
            button_row_y = p2_y_pos + BUTTON_HEIGHT + 10
            p1_rect = pygame.Rect(content_left + (content_width - (BUTTON_WIDTH * 2 + 20)) // 2, button_row_y, BUTTON_WIDTH, BUTTON_HEIGHT)
            p2_rect = pygame.Rect(content_left + (content_width - (BUTTON_WIDTH * 2 + 20)) // 2 + BUTTON_WIDTH + 20, button_row_y, BUTTON_WIDTH, BUTTON_HEIGHT)
            p1_hover = p1_rect.collidepoint(pygame.mouse.get_pos())
            p2_hover = p2_rect.collidepoint(pygame.mouse.get_pos())
            # Highlight selected human player
            pygame.draw.rect(screen, BUTTON_HOVER if p1_hover else BUTTON_COLOR, p1_rect)
            if human_player == 1: pygame.draw.rect(screen, BLACK, p1_rect, 2)
            pygame.draw.rect(screen, BUTTON_HOVER if p2_hover else BUTTON_COLOR, p2_rect)
            if human_player == 2: pygame.draw.rect(screen, BLACK, p2_rect, 2)

            p1_text = button_font.render("Play as P1", True, BLACK)
            p2_text = button_font.render("Play as P2", True, BLACK)
            p1_text_rect = p1_text.get_rect(center=p1_rect.center)
            p2_text_rect = p2_text.get_rect(center=p2_rect.center)
            screen.blit(p1_text, p1_text_rect)
            screen.blit(p2_text, p2_text_rect)

        elif modes[current_input] == MODE_AVA:
             # AI vs AI - show non-editable AI names
            p2_label_text = "AI 2 Name:"
            p2_label = ui_font.render(p2_label_text, True, BLACK)
            p2_name_rect = pygame.Rect(name_rect_x, p2_y_pos, name_rect_width, BUTTON_HEIGHT)
            p2_label_x = name_rect_x - p2_label.get_width() - 10
            screen.blit(p2_label, (p2_label_x, p2_y_pos + 5))
            pygame.draw.rect(screen, GRAY, p2_name_rect) # AI name not editable
            pygame.draw.rect(screen, BLACK, p2_name_rect, 1)
            p2_name_text = ui_font.render(player_names[1], True, BLACK) # Show default "AI 2"
            screen.blit(p2_name_text, (p2_name_rect.x + 5, p2_name_rect.y + 5))
            # Also make P1 name non-editable for AVA? Optional.
            pygame.draw.rect(screen, GRAY, p1_name_rect) # P1 name not editable in AVA
            pygame.draw.rect(screen, BLACK, p1_name_rect, 1)
            p1_name_text = ui_font.render(player_names[0], True, BLACK) # Show default "AI 1" or P1
            screen.blit(p1_name_text, (p1_name_rect.x + 5, p1_name_rect.y + 5))


        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()
            elif event.type == pygame.MOUSEBUTTONDOWN:
                x, y = event.pos
                if showing_power_tiles_dialog:
                    dialog_x = (WINDOW_WIDTH - 300) // 2
                    dialog_y = (WINDOW_HEIGHT - 250) // 2  # Updated height to 250
                    # Define checkbox rectangles
                    letter_rects = [pygame.Rect(dialog_x + 20, dialog_y + 40 + i*30, 20, 20) for i in range(4)]
                    number_rects = [pygame.Rect(dialog_x + 150, dialog_y + 40 + i*30, 20, 20) for i in range(6)]
                    go_rect = pygame.Rect(dialog_x + 50, dialog_y + 220, 100, 30)  # Updated y to 220
                    cancel_rect = pygame.Rect(dialog_x + 160, dialog_y + 220, 100, 30)  # Updated y to 220

                    # Check clicks on letter checkboxes
                    for i, rect in enumerate(letter_rects):
                        if rect.collidepoint(x, y):
                            letter_checks[i] = not letter_checks[i]
                    # Check clicks on number checkboxes
                    for i, rect in enumerate(number_rects):
                        if rect.collidepoint(x, y):
                            number_checks[i] = not number_checks[i]
                    # Existing button handling
                    if go_rect.collidepoint(x, y):
                        practice_mode = "power_tiles"
                        selected_mode = MODE_AVA # Power tile practice runs as AI vs AI until pause
                        showing_power_tiles_dialog = False
                        # Break the loop as mode is selected
                        break
                    elif cancel_rect.collidepoint(x, y):
                        showing_power_tiles_dialog = False
                else: # Not in power tiles dialog
                    # Handle mode selection buttons
                    for i, rect in enumerate(mode_rects):
                        if rect.collidepoint(x, y):
                            current_input = i
                            # Reset player names/AI status based on new selection
                            if i == 0: # HVH
                                player_names = ["Player 1", "Player 2"]
                                input_active = [False, False] # Allow editing both
                            elif i == 1: # HVA
                                # Keep current human_player choice, update names accordingly
                                player_names = ["Player 1", "AI"] if human_player == 1 else ["AI", "Player 2"]
                                input_active = [True, False] if human_player == 1 else [False, True] # Allow editing human name
                            elif i == 2: # AVA
                                player_names = ["AI 1", "AI 2"] # Or keep P1/P2? Let's use AI names
                                input_active = [False, False] # No editing
                            dropdown_open = False # Close dropdown when changing mode
                            # Don't set selected_mode here, wait for confirmation (e.g., clicking Play/Go or specific HVA buttons)

                    if play_later_rect.collidepoint(x, y):
                        pygame.quit()
                        sys.exit()

                    # Handle name input activation
                    if modes[current_input] == MODE_HVH:
                        if p1_name_rect.collidepoint(x, y):
                            input_active = [True, False]
                        elif p2_name_rect.collidepoint(x, y):
                            input_active = [False, True]
                        # Deactivate if clicking elsewhere (handled below)
                    elif modes[current_input] == MODE_HVA:
                        # Only allow activating the human player's name input
                        if human_player == 1 and p1_name_rect.collidepoint(x, y):
                            input_active = [True, False]
                        elif human_player == 2 and p2_name_rect.collidepoint(x, y): # p2_name_rect is AI name, should be P1 rect check?
                             # This logic needs fixing. If human is P2, click should activate P2 name.
                             # Let's assume p1_name_rect is always P1, p2_name_rect is P2/AI
                             # If human is P2, they edit player_names[1] via p2_name_rect (if it exists and is editable)
                             # This part is confusing, let's simplify: only P1 name editable in HVA for now.
                             if human_player == 1 and p1_name_rect.collidepoint(x,y):
                                  input_active = [True, False]
                             else: # Human is P2 or clicked elsewhere
                                  input_active = [False, False] # Deactivate P1 input
                        # Deactivate if clicking elsewhere (handled below)


                    # Handle HVA "Play as" buttons
                    if modes[current_input] == MODE_HVA:
                        # Need p1_rect and p2_rect defined from drawing logic above
                        button_row_y = 300 + 60 + BUTTON_HEIGHT + 10
                        p1_rect_hva = pygame.Rect(content_left + (content_width - (BUTTON_WIDTH * 2 + 20)) // 2, button_row_y, BUTTON_WIDTH, BUTTON_HEIGHT)
                        p2_rect_hva = pygame.Rect(content_left + (content_width - (BUTTON_WIDTH * 2 + 20)) // 2 + BUTTON_WIDTH + 20, button_row_y, BUTTON_WIDTH, BUTTON_HEIGHT)

                        if p1_rect_hva.collidepoint(x, y):
                            human_player = 1
                            player_names = ["Player 1", "AI"] # Update names
                            input_active = [True, False] # Allow editing P1 name
                            selected_mode = MODE_HVA # Confirm mode selection
                            break # Exit loop
                        elif p2_rect_hva.collidepoint(x, y):
                            human_player = 2
                            player_names = ["AI", "Player 2"] # Update names
                            input_active = [False, False] # Don't allow editing P2 name here? Or should we? Let's disable for now.
                            selected_mode = MODE_HVA # Confirm mode selection
                            break # Exit loop

                    # Toggle dropdown if Practice button is clicked (only in HVH)
                    if modes[current_input] == MODE_HVH:
                        # Define dropdown_rect based on drawing logic
                        dropdown_button_y = 300 + 60 + BUTTON_HEIGHT + 10
                        dropdown_rect = pygame.Rect(name_rect_x, dropdown_button_y, 200, 30)

                        if dropdown_rect.collidepoint(x, y):
                            dropdown_open = not dropdown_open
                        elif dropdown_open:
                            clicked_option = False
                            # Check clicks within the dropdown options
                            for i, option_rect in enumerate(option_rects):
                                if option_rect.collidepoint(x, y):
                                    clicked_option = True
                                    if i == 0:  # Power Tiles
                                        showing_power_tiles_dialog = True
                                        dropdown_open = False
                                    elif i == 1:  # 8-Letter Bingos
                                        # Call the modified function
                                        proceed, practice_board, practice_tiles, practice_racks, practice_blanks, practice_bag = eight_letter_practice()
                                        if proceed:
                                            practice_mode = "eight_letter"
                                            # Set mode to AVA for this practice as intended by original logic
                                            selected_mode = MODE_AVA # Set game mode
                                            player_names = ["Player 1", "AI 2"] # Consistent with AVA mode setup
                                            # Store the practice state to be returned
                                            practice_state = {
                                                "board": practice_board,
                                                "tiles": practice_tiles,
                                                "racks": practice_racks,
                                                "blanks": practice_blanks,
                                                "bag": practice_bag,
                                                "first_play": False, # Board is pre-populated
                                                "scores": [0, 0], # Start scores at 0
                                                "turn": 1 # Player 1 starts
                                            }
                                            # Break the while loop as mode is now selected
                                        else:
                                            # Handle cancellation if needed (e.g., reset state)
                                            pass
                                        dropdown_open = False
                                    elif i == 2: # End Game
                                         print("End Game practice selected - Not implemented yet")
                                         dropdown_open = False
                                    # Break inner loop once an option is clicked
                                    break
                            # If click was outside options but dropdown was open, close it
                            if not clicked_option:
                                dropdown_open = False
                        # If click was outside dropdown button and options, close dropdown
                        # Also deactivate name inputs if clicking elsewhere
                        elif not dropdown_rect.collidepoint(x,y):
                             dropdown_open = False
                             if not p1_name_rect.collidepoint(x,y) and not p2_name_rect.collidepoint(x,y):
                                  input_active = [False, False]


                    # If mode is HVH or AVA, clicking the mode button again confirms selection
                    if modes[current_input] in [MODE_HVH, MODE_AVA]:
                         mode_button_rect = mode_rects[current_input]
                         if mode_button_rect.collidepoint(x,y):
                              selected_mode = modes[current_input]
                              # Finalize player names for AVA if selected this way
                              if selected_mode == MODE_AVA:
                                   player_names = ["AI 1", "AI 2"]
                              break # Exit loop
                    # Deactivate name input if clicking outside relevant areas
                    elif not (p1_name_rect.collidepoint(x,y) or (modes[current_input] == MODE_HVH and p2_name_rect.collidepoint(x,y))):
                         input_active = [False, False]


            elif event.type == pygame.KEYDOWN:
                 active_idx = -1
                 if input_active[0]: active_idx = 0
                 elif input_active[1] and modes[current_input] == MODE_HVH: active_idx = 1 # Only allow P2 edit in HVH

                 if active_idx != -1: # Check if any input is active
                    if event.key == pygame.K_BACKSPACE:
                        player_names[active_idx] = player_names[active_idx][:-1]
                    elif event.key == pygame.K_RETURN:
                        input_active[active_idx] = False # Deactivate on Enter
                    elif event.unicode.isalnum() or event.unicode == ' ':
                        if len(player_names[active_idx]) < 15:
                            player_names[active_idx] += event.unicode

        # Check if selected_mode was set inside the loop break (e.g., by HVA buttons or practice modes)
        if selected_mode is not None:
             break # Exit the while loop

        # Draw Power Tiles Dialog if active
        if showing_power_tiles_dialog:
            dialog_width, dialog_height = 300, 250  # Changed from 200 to 250
            dialog_x = (WINDOW_WIDTH - dialog_width) // 2
            dialog_y = (WINDOW_HEIGHT - dialog_height) // 2
            pygame.draw.rect(screen, DIALOG_COLOR, (dialog_x, dialog_y, dialog_width, dialog_height))
            pygame.draw.rect(screen, BLACK, (dialog_x, dialog_y, dialog_width, dialog_height), 2)
            title_text = dialog_font.render("Power Tiles Options", True, BLACK)
            screen.blit(title_text, (dialog_x + 10, dialog_y + 10))

            letters = ['J', 'Q', 'X', 'Z']
            for i, letter in enumerate(letters):
                draw_checkbox(screen, dialog_x + 20, dialog_y + 40 + i*30, letter_checks[i])
                text = ui_font.render(letter, True, BLACK)
                screen.blit(text, (dialog_x + 50, dialog_y + 40 + i*30))

            numbers = ['2', '3', '4', '5', '6', '7+']
            for i, num in enumerate(numbers):
                draw_checkbox(screen, dialog_x + 150, dialog_y + 40 + i*30, number_checks[i])
                text = ui_font.render(num, True, BLACK)
                screen.blit(text, (dialog_x + 180, dialog_y + 40 + i*30))

            go_rect = pygame.Rect(dialog_x + 50, dialog_y + 220, 100, 30)  # Changed from 180 to 220
            cancel_rect = pygame.Rect(dialog_x + 160, dialog_y + 220, 100, 30)  # Changed from 180 to 220
            pygame.draw.rect(screen, BUTTON_COLOR, go_rect)
            pygame.draw.rect(screen, BUTTON_COLOR, cancel_rect)
            go_text = button_font.render("Go", True, BLACK)
            cancel_text = button_font.render("Cancel", True, BLACK)
            screen.blit(go_text, go_text.get_rect(center=go_rect.center))
            screen.blit(cancel_text, cancel_text.get_rect(center=cancel_rect.center))


        pygame.display.flip()

    # Return the selected mode, names, player info, practice mode, checks, and the practice state dict
    return selected_mode, player_names, human_player, practice_mode, letter_checks if practice_mode == "power_tiles" else None, practice_state

# Function 9: draw_options_menu (Updated)
def draw_options_menu(turn, dropdown_open, bag_count):
    """Draw the options menu with dropdown functionality."""
    options_x = 10
    options_rect = pygame.Rect(options_x, OPTIONS_Y, OPTIONS_WIDTH, OPTIONS_HEIGHT)

    hover = options_rect.collidepoint(pygame.mouse.get_pos())
    color = BUTTON_HOVER if hover else BUTTON_COLOR
    pygame.draw.rect(screen, color, options_rect)
    options_text = button_font.render("Options", True, BLACK)
    options_text_rect = options_text.get_rect(center=(options_x + OPTIONS_WIDTH // 2, OPTIONS_Y + OPTIONS_HEIGHT // 2))
    screen.blit(options_text, options_text_rect)

    dropdown_rects = [] # Store rects or None for disabled options
    if dropdown_open:
        dropdown_y = OPTIONS_Y + OPTIONS_HEIGHT
        options = ["Pass", "Exchange", "Main", "Quit"]  # Modified: Added "Main" before "Quit"
        for i, option in enumerate(options):
            rect = pygame.Rect(options_x, dropdown_y + i * OPTIONS_HEIGHT, OPTIONS_WIDTH, OPTIONS_HEIGHT)
            is_disabled = (option == "Exchange" and bag_count < 7) # Standard rule: need 7+ tiles in bag

            if is_disabled:
                pygame.draw.rect(screen, GRAYED_OUT_COLOR, rect)
                text = button_font.render(option, True, BLACK) # Still draw text
                dropdown_rects.append(None) # Mark as not clickable
            else:
                hover = rect.collidepoint(pygame.mouse.get_pos())
                color = BUTTON_HOVER if hover else DROPDOWN_COLOR
                pygame.draw.rect(screen, color, rect)
                text = button_font.render(option, True, BLACK)
                dropdown_rects.append(rect) # Add clickable rect

            text_rect = text.get_rect(center=(options_x + OPTIONS_WIDTH // 2, dropdown_y + i * OPTIONS_HEIGHT + OPTIONS_HEIGHT // 2))
            screen.blit(text, text_rect)

    return options_rect, dropdown_rects

# End of Part 2

# Part 3

def draw_suggest_button():
    """Draw the suggest button."""
    suggest_x = 10 + OPTIONS_WIDTH + BUTTON_GAP
    suggest_rect = pygame.Rect(suggest_x, OPTIONS_Y, OPTIONS_WIDTH, OPTIONS_HEIGHT)

    hover = suggest_rect.collidepoint(pygame.mouse.get_pos())
    color = BUTTON_HOVER if hover else BUTTON_COLOR
    pygame.draw.rect(screen, color, suggest_rect)
    suggest_text = button_font.render("Suggest", True, BLACK)
    suggest_text_rect = suggest_text.get_rect(center=(suggest_x + OPTIONS_WIDTH // 2, OPTIONS_Y + OPTIONS_HEIGHT // 2))
    screen.blit(suggest_text, suggest_text_rect)

    return suggest_rect

# Function 10: draw_exchange_dialog (Updated)
def draw_exchange_dialog(rack, selected_tiles):
    """Draw the tile exchange dialog."""
    dialog_width, dialog_height = 400, 200
    dialog_x = (WINDOW_WIDTH - dialog_width) // 2
    dialog_y = (WINDOW_HEIGHT - dialog_height) // 2

    pygame.draw.rect(screen, DIALOG_COLOR, (dialog_x, dialog_y, dialog_width, dialog_height))
    pygame.draw.rect(screen, BLACK, (dialog_x, dialog_y, dialog_width, dialog_height), 2)

    prompt_text = dialog_font.render("Select tiles to exchange:", True, BLACK)
    screen.blit(prompt_text, (dialog_x + 10, dialog_y + 10))

    tile_rects = []
    rack_display_width = len(rack) * (TILE_WIDTH + TILE_GAP) - TILE_GAP
    start_tile_x = dialog_x + (dialog_width - rack_display_width) // 2 # Center tiles

    for i, tile in enumerate(rack):
        tile_x = start_tile_x + i * (TILE_WIDTH + TILE_GAP)
        tile_y = dialog_y + 50
        rect = pygame.Rect(tile_x, tile_y, TILE_WIDTH, TILE_HEIGHT)
        tile_rects.append(rect)

        if tile == ' ':
            # Draw black circle for blank
            center = rect.center
            radius = TILE_WIDTH // 2 - 2
            # color = SELECTED_TILE_COLOR if i in selected_tiles else BLACK # Highlight border if selected
            pygame.draw.circle(screen, BLACK, center, radius) # Background circle
            if i in selected_tiles:
                 pygame.draw.circle(screen, SELECTED_TILE_COLOR, center, radius + 2, 2) # Highlight outline
            text = font.render('?', True, WHITE)
            text_rect = text.get_rect(center=center)
            screen.blit(text, text_rect)
        else:
            # Regular tile
            color = SELECTED_TILE_COLOR if i in selected_tiles else GREEN
            pygame.draw.rect(screen, color, rect)
            text = font.render(tile, True, BLACK)
            screen.blit(text, (tile_x + 5, tile_y + 5))

    # Center buttons horizontally
    total_button_width = BUTTON_WIDTH * 2 + BUTTON_GAP
    button_start_x = dialog_x + (dialog_width - total_button_width) // 2
    button_y = dialog_y + dialog_height - BUTTON_HEIGHT - 10

    exchange_button_rect = pygame.Rect(button_start_x, button_y, BUTTON_WIDTH, BUTTON_HEIGHT)
    cancel_button_rect = pygame.Rect(button_start_x + BUTTON_WIDTH + BUTTON_GAP, button_y, BUTTON_WIDTH, BUTTON_HEIGHT)

    # Draw Exchange button
    hover = exchange_button_rect.collidepoint(pygame.mouse.get_pos())
    color = BUTTON_HOVER if hover else BUTTON_COLOR
    pygame.draw.rect(screen, color, exchange_button_rect)
    exchange_text = button_font.render("Exchange", True, BLACK)
    exchange_text_rect = exchange_text.get_rect(center=exchange_button_rect.center)
    screen.blit(exchange_text, exchange_text_rect)

    # Draw Cancel button
    hover = cancel_button_rect.collidepoint(pygame.mouse.get_pos())
    color = BUTTON_HOVER if hover else BUTTON_COLOR
    pygame.draw.rect(screen, color, cancel_button_rect)
    cancel_text = button_font.render("Cancel", True, BLACK)
    cancel_text_rect = cancel_text.get_rect(center=cancel_button_rect.center)
    screen.blit(cancel_text, cancel_text_rect)

    return tile_rects, exchange_button_rect, cancel_button_rect


def confirm_quit():
    """Prompt the user to confirm quitting the game."""
    dialog_width, dialog_height = 300, 100
    dialog_x = (WINDOW_WIDTH - dialog_width) // 2
    dialog_y = (WINDOW_HEIGHT - dialog_height) // 2

    pygame.draw.rect(screen, DIALOG_COLOR, (dialog_x, dialog_y, dialog_width, dialog_height))
    pygame.draw.rect(screen, BLACK, (dialog_x, dialog_y, dialog_width, dialog_height), 2)

    prompt_text = dialog_font.render("Quit game? (Y/N)", True, BLACK)
    screen.blit(prompt_text, (dialog_x + 10, dialog_y + 30))
    pygame.display.flip()

    while True:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()
            elif event.type == pygame.KEYDOWN:
                if event.key == pygame.K_y:
                    return True
                elif event.key == pygame.K_n:
                    return False


def draw_game_over_dialog(dialog_x, dialog_y, final_scores, reason, player_names):
    """Draw the game over dialog and return button rectangles."""
    pygame.draw.rect(screen, DIALOG_COLOR, (dialog_x, dialog_y, DIALOG_WIDTH, DIALOG_HEIGHT))
    pygame.draw.rect(screen, BLACK, (dialog_x, dialog_y, DIALOG_WIDTH, DIALOG_HEIGHT), 2)

    title_text = dialog_font.render(f"Game Over - {reason}", True, BLACK)
    p1_score_text = ui_font.render(f"{player_names[0]} Score: {final_scores[0]}", True, BLACK)
    p2_score_text = ui_font.render(f"{player_names[1]} Score: {final_scores[1]}", True, BLACK)
    save_text = button_font.render("Save (S)", True, BLACK)
    quit_text = button_font.render("Quit (Q)", True, BLACK)
    replay_text = button_font.render("Replay (R)", True, BLACK)
    play_again_text = button_font.render("Play Again (P)", True, BLACK)
    stats_text = button_font.render("Statistics", True, BLACK)  # Added new button text

    screen.blit(title_text, (dialog_x + 10, dialog_y + 20))
    screen.blit(p1_score_text, (dialog_x + 10, dialog_y + 60))
    screen.blit(p2_score_text, (dialog_x + 10, dialog_y + 90))

    # Calculate centered positions for two rows
    first_row_width = 3 * BUTTON_WIDTH + 2 * BUTTON_GAP  # 320 pixels
    first_row_start_x = dialog_x + (DIALOG_WIDTH - first_row_width) // 2  # dialog_x + 80
    second_row_width = 2 * BUTTON_WIDTH + BUTTON_GAP  # 210 pixels
    second_row_start_x = dialog_x + (DIALOG_WIDTH - second_row_width) // 2  # dialog_x + 135

    # First row: Save, Quit, Replay
    save_rect = pygame.Rect(first_row_start_x, dialog_y + 150, BUTTON_WIDTH, BUTTON_HEIGHT)
    quit_rect = pygame.Rect(first_row_start_x + BUTTON_WIDTH + BUTTON_GAP, dialog_y + 150, BUTTON_WIDTH, BUTTON_HEIGHT)
    replay_rect = pygame.Rect(first_row_start_x + 2 * (BUTTON_WIDTH + BUTTON_GAP), dialog_y + 150, BUTTON_WIDTH, BUTTON_HEIGHT)

    # Second row: Play Again, Statistics
    play_again_rect = pygame.Rect(second_row_start_x, dialog_y + 190, BUTTON_WIDTH, BUTTON_HEIGHT)
    stats_rect = pygame.Rect(second_row_start_x + BUTTON_WIDTH + BUTTON_GAP, dialog_y + 190, BUTTON_WIDTH, BUTTON_HEIGHT)

    # Draw buttons
    pygame.draw.rect(screen, BUTTON_COLOR, save_rect)
    pygame.draw.rect(screen, BUTTON_COLOR, quit_rect)
    pygame.draw.rect(screen, BUTTON_COLOR, replay_rect)
    pygame.draw.rect(screen, BUTTON_COLOR, play_again_rect)
    pygame.draw.rect(screen, BUTTON_COLOR, stats_rect)

    # Blit button texts
    screen.blit(save_text, save_text.get_rect(center=save_rect.center))
    screen.blit(quit_text, quit_text.get_rect(center=quit_rect.center))
    screen.blit(replay_text, replay_text.get_rect(center=replay_rect.center))
    screen.blit(play_again_text, play_again_text.get_rect(center=play_again_rect.center))
    screen.blit(stats_text, stats_text.get_rect(center=stats_rect.center))

    return save_rect, quit_rect, replay_rect, play_again_rect, stats_rect

def draw_score_row(screen, dialog_x, y_pos, final_scores):
    """Draw the score row for the statistics dialog."""
    score_label = ui_font.render("Score:", True, BLACK)
    p1_score_text = ui_font.render(str(final_scores[0]), True, BLACK)
    p2_score_text = ui_font.render(str(final_scores[1]), True, BLACK)
    screen.blit(score_label, (dialog_x + 10, y_pos))
    screen.blit(p1_score_text, (dialog_x + 120, y_pos))
    screen.blit(p2_score_text, (dialog_x + 230, y_pos))

# Function 11: calculate_moves_per_player (Updated)
def calculate_moves_per_player(move_history):
    """Calculate the number of moves made by each player from move_history."""
    moves_count = {1: 0, 2: 0}
    for move in move_history:
        player = move['player']
        # Only count actual plays, passes, or exchanges as moves
        if move['move_type'] in ['place', 'pass', 'exchange']:
            moves_count[player] += 1
    return moves_count[1], moves_count[2]


def calculate_bingos_per_player(move_history):
    bingo_count = {1: 0, 2: 0}
    for move in move_history:
        if move['move_type'] == 'place' and move.get('is_bingo', False):
            player = move['player']
            bingo_count[player] += 1
    return bingo_count[1], bingo_count[2]

def calculate_bingo_avg_per_player(move_history):
    bingo_scores = {1: [], 2: []}
    for move in move_history:
        if move['move_type'] == 'place' and move.get('is_bingo', False):
            player = move['player']
            bingo_scores[player].append(move['score'])
    avg_p1 = sum(bingo_scores[1]) / len(bingo_scores[1]) if bingo_scores[1] else 0.0
    avg_p2 = sum(bingo_scores[2]) / len(bingo_scores[2]) if bingo_scores[2] else 0.0
    return avg_p1, avg_p2

def draw_moves_row(screen, dialog_x, y_pos, moves_p1, moves_p2):
    """Draw the moves row for the statistics dialog."""
    moves_label = ui_font.render("Moves:", True, BLACK)
    p1_moves_text = ui_font.render(str(moves_p1), True, BLACK)
    p2_moves_text = ui_font.render(str(moves_p2), True, BLACK)
    screen.blit(moves_label, (dialog_x + 10, y_pos))
    screen.blit(p1_moves_text, (dialog_x + 120, y_pos))
    screen.blit(p2_moves_text, (dialog_x + 230, y_pos))

def draw_avg_score_row(screen, dialog_x, y_pos, avg_p1, avg_p2):
    """Draw the average score per move row for the statistics dialog."""
    avg_label = ui_font.render("Avg Score:", True, BLACK)
    p1_avg_text = ui_font.render(f"{avg_p1:.2f}", True, BLACK)
    p2_avg_text = ui_font.render(f"{avg_p2:.2f}", True, BLACK)
    screen.blit(avg_label, (dialog_x + 10, y_pos))
    screen.blit(p1_avg_text, (dialog_x + 120, y_pos))
    screen.blit(p2_avg_text, (dialog_x + 230, y_pos))

def draw_bingos_row(screen, dialog_x, y_pos, bingos_p1, bingos_p2):
    """Draw the bingos row for the statistics dialog."""
    bingos_label = ui_font.render("Bingos:", True, BLACK)
    p1_bingos_text = ui_font.render(str(bingos_p1), True, BLACK)
    p2_bingos_text = ui_font.render(str(bingos_p2), True, BLACK)
    screen.blit(bingos_label, (dialog_x + 10, y_pos))
    screen.blit(p1_bingos_text, (dialog_x + 120, y_pos))
    screen.blit(p2_bingos_text, (dialog_x + 230, y_pos))

def draw_bingo_avg_row(screen, dialog_x, y_pos, bingo_avg_p1, bingo_avg_p2, bingos_p1, bingos_p2):
    bingo_avg_label = ui_font.render("Bingo Avg:", True, BLACK)
    p1_text = "N/A" if bingos_p1 == 0 else f"{bingo_avg_p1:.2f}"
    p2_text = "N/A" if bingos_p2 == 0 else f"{bingo_avg_p2:.2f}"
    p1_bingo_avg_text = ui_font.render(p1_text, True, BLACK)
    p2_bingo_avg_text = ui_font.render(p2_text, True, BLACK)
    screen.blit(bingo_avg_label, (dialog_x + 10, y_pos))
    screen.blit(p1_bingo_avg_text, (dialog_x + 120, y_pos))
    screen.blit(p2_bingo_avg_text, (dialog_x + 230, y_pos))

# Function 12: calculate_blanks_per_player (Updated)
def calculate_blanks_per_player(move_history):
    blanks_p1 = 0
    blanks_p2 = 0
    for move in move_history:
        if move['move_type'] == 'place':
            player = move['player']
            # Ensure 'blanks' key exists and is iterable
            blanks_count = len(move.get('blanks', set()))
            if player == 1:
                blanks_p1 += blanks_count
            elif player == 2:
                blanks_p2 += blanks_count
    return blanks_p1, blanks_p2


def draw_blanks_row(screen, dialog_x, y_pos, blanks_p1, blanks_p2):
    blanks_label = ui_font.render("Blanks:", True, BLACK)
    p1_blanks_text = ui_font.render(str(blanks_p1), True, BLACK)
    p2_blanks_text = ui_font.render(str(blanks_p2), True, BLACK)
    screen.blit(blanks_label, (dialog_x + 10, y_pos))
    screen.blit(p1_blanks_text, (dialog_x + 120, y_pos))
    screen.blit(p2_blanks_text, (dialog_x + 230, y_pos))

def draw_stats_dialog(dialog_x, dialog_y, player_names, final_scores, tiles): # tiles might not be needed here
    stats_dialog_width, stats_dialog_height = 400, 360  # Increased height from 330 to 360
    pygame.draw.rect(screen, DIALOG_COLOR, (dialog_x, dialog_y, stats_dialog_width, stats_dialog_height))
    pygame.draw.rect(screen, BLACK, (dialog_x, dialog_y, stats_dialog_width, stats_dialog_height), 2)

    title_text = dialog_font.render("Game Statistics", True, BLACK)
    screen.blit(title_text, (dialog_x + 10, dialog_y + 10))

    # Draw player names as column headers
    p1_name_text = ui_font.render(player_names[0], True, BLACK)
    p2_name_text = ui_font.render(player_names[1], True, BLACK)
    screen.blit(p1_name_text, (dialog_x + 120, dialog_y + 40))
    screen.blit(p2_name_text, (dialog_x + 230, dialog_y + 40))

    # Draw score row
    draw_score_row(screen, dialog_x, dialog_y + 70, final_scores)

    # Calculate and draw moves row
    moves_p1, moves_p2 = calculate_moves_per_player(move_history) # Use global move_history
    draw_moves_row(screen, dialog_x, dialog_y + 100, moves_p1, moves_p2)

    # Use final_scores directly for average score calculation
    avg_p1 = final_scores[0] / moves_p1 if moves_p1 > 0 else 0
    avg_p2 = final_scores[1] / moves_p2 if moves_p2 > 0 else 0
    draw_avg_score_row(screen, dialog_x, dialog_y + 130, avg_p1, avg_p2)

    # Calculate and draw bingos row
    bingos_p1, bingos_p2 = calculate_bingos_per_player(move_history)
    draw_bingos_row(screen, dialog_x, dialog_y + 160, bingos_p1, bingos_p2)

    # Calculate and draw bingo averages row
    bingo_avg_p1, bingo_avg_p2 = calculate_bingo_avg_per_player(move_history)
    draw_bingo_avg_row(screen, dialog_x, dialog_y + 190, bingo_avg_p1, bingo_avg_p2, bingos_p1, bingos_p2)

    # Calculate and draw blanks row
    blanks_p1, blanks_p2 = calculate_blanks_per_player(move_history)
    draw_blanks_row(screen, dialog_x, dialog_y + 220, blanks_p1, blanks_p2)  # Shifted from 190 to 220

    # OK button
    ok_button_rect = pygame.Rect(dialog_x + stats_dialog_width - BUTTON_WIDTH - 10,
                                 dialog_y + stats_dialog_height - BUTTON_HEIGHT - 10,
                                 BUTTON_WIDTH, BUTTON_HEIGHT)
    hover = ok_button_rect.collidepoint(pygame.mouse.get_pos())
    color = BUTTON_HOVER if hover else BUTTON_COLOR
    pygame.draw.rect(screen, color, ok_button_rect)
    ok_text = button_font.render("OK", True, BLACK)
    ok_text_rect = ok_text.get_rect(center=ok_button_rect.center)
    screen.blit(ok_text, ok_text_rect)

    return ok_button_rect

# Function 13: show_power_tile_dialog (Updated)
def show_power_tile_dialog(message):
    """Display a dialog with a power tile message and an OK button, wrapping text to fit."""
    dialog_width, dialog_height = 400, 150
    dialog_x = (WINDOW_WIDTH - dialog_width) // 2
    dialog_y = (WINDOW_HEIGHT - dialog_height) // 2

    # Split message into words and wrap based on dialog width
    words = message.split(' ')
    lines = []
    current_line = ''
    for word in words:
        test_line = current_line + word + ' '
        if dialog_font.size(test_line)[0] < dialog_width - 20:  # 20px padding
            current_line = test_line
        else:
            lines.append(current_line.strip())
            current_line = word + ' '
    if current_line:
        lines.append(current_line.strip())

    # Need to redraw the background or underlying screen elements if this dialog overlaps
    # For simplicity, just draw the dialog on top
    pygame.draw.rect(screen, DIALOG_COLOR, (dialog_x, dialog_y, dialog_width, dialog_height))
    pygame.draw.rect(screen, BLACK, (dialog_x, dialog_y, dialog_width, dialog_height), 2)


    # Render each line
    y_offset = 10
    for i, line in enumerate(lines):
        text = dialog_font.render(line, True, BLACK)
        screen.blit(text, (dialog_x + 10, dialog_y + y_offset))
        y_offset += dialog_font.get_linesize() # Use font line size for spacing

    ok_button_rect = pygame.Rect(dialog_x + dialog_width - BUTTON_WIDTH - 10, dialog_y + dialog_height - BUTTON_HEIGHT - 10, BUTTON_WIDTH, BUTTON_HEIGHT)
    hover = ok_button_rect.collidepoint(pygame.mouse.get_pos())
    color = BUTTON_HOVER if hover else BUTTON_COLOR
    pygame.draw.rect(screen, color, ok_button_rect)
    ok_text = button_font.render("OK", True, BLACK)
    ok_text_rect = ok_text.get_rect(center=ok_button_rect.center)
    screen.blit(ok_text, ok_text_rect)

    pygame.display.flip() # Update only the dialog area? Or full screen? Full flip is safer.

    # Event loop specifically for this dialog
    dialog_running = True
    while dialog_running:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()
            elif event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
                 if ok_button_rect.collidepoint(event.pos):
                     return # Exit the dialog function
            elif event.type == pygame.KEYDOWN:
                 if event.key == pygame.K_RETURN or event.key == pygame.K_KP_ENTER:
                      return # Exit on Enter key


# End of Part 3

# Part 4

# Function 14: get_words_played (Updated)
def get_words_played(word_positions, tiles):
    """Get all words formed by a play."""
    if not word_positions:
        return []

    words = []
    new_positions_set = set((r, c) for r, c, _ in word_positions)
    rows = set(r for r, _, _ in word_positions)
    cols = set(c for _, c, _ in word_positions)

    # Determine primary orientation based on the newly placed tiles
    is_horizontal = len(rows) == 1 and len(cols) >= 1 # Allow single tile horizontal
    is_vertical = len(cols) == 1 and len(rows) >= 1 # Allow single tile vertical

    primary_word_str = ""
    cross_words_strs = []

    if is_horizontal:
        row = rows.pop()
        min_col = min(c for _, c, _ in word_positions)
        max_col = max(c for _, c, _ in word_positions)
        # Extend to capture full word including existing tiles
        while min_col > 0 and tiles[row][min_col - 1]: min_col -= 1
        while max_col < GRID_SIZE - 1 and tiles[row][max_col + 1]: max_col += 1
        primary_word_str = ''.join(tiles[row][c] for c in range(min_col, max_col + 1) if tiles[row][c])
        if len(primary_word_str) > 1: words.append(primary_word_str)

        # Find vertical cross words for each new tile
        for r_new, c_new, _ in word_positions:
            min_row_cross = r_new
            max_row_cross = r_new
            while min_row_cross > 0 and tiles[min_row_cross - 1][c_new]: min_row_cross -= 1
            while max_row_cross < GRID_SIZE - 1 and tiles[max_row_cross + 1][c_new]: max_row_cross += 1
            if max_row_cross > min_row_cross:
                cross_word_str = ''.join(tiles[r_cross][c_new] for r_cross in range(min_row_cross, max_row_cross + 1) if tiles[r_cross][c_new])
                if len(cross_word_str) > 1: words.append(cross_word_str)

    elif is_vertical:
        col = cols.pop()
        min_row = min(r for r, _, _ in word_positions)
        max_row = max(r for r, _, _ in word_positions)
        # Extend to capture full word including existing tiles
        while min_row > 0 and tiles[min_row - 1][col]: min_row -= 1
        while max_row < GRID_SIZE - 1 and tiles[max_row + 1][col]: max_row += 1
        primary_word_str = ''.join(tiles[r][col] for r in range(min_row, max_row + 1) if tiles[r][col])
        if len(primary_word_str) > 1: words.append(primary_word_str)

        # Find horizontal cross words for each new tile
        for r_new, c_new, _ in word_positions:
            min_col_cross = c_new
            max_col_cross = c_new
            while min_col_cross > 0 and tiles[r_new][min_col_cross - 1]: min_col_cross -= 1
            while max_col_cross < GRID_SIZE - 1 and tiles[r_new][max_col_cross + 1]: max_col_cross += 1
            if max_col_cross > min_col_cross:
                cross_word_str = ''.join(tiles[r_new][c_cross] for c_cross in range(min_col_cross, max_col_cross + 1) if tiles[r_new][c_cross])
                if len(cross_word_str) > 1: words.append(cross_word_str)

    # Remove duplicates that might arise from single tile plays forming both H and V words
    return list(set(words))

# Function 15: get_remaining_tiles (Updated)
def get_remaining_tiles(rack, tiles, blanks):
    """Calculate the remaining tiles in the bag and on racks, correctly handling blanks."""
    # Start with the total distribution
    remaining = {letter: count for letter, (count, _) in TILE_DISTRIBUTION.items()}

    # Subtract tiles currently in the player's rack
    rack_counter = Counter(rack)
    for tile, count in rack_counter.items():
        if tile in remaining:
            remaining[tile] -= count

    # Subtract tiles on the board
    for r in range(GRID_SIZE):
        for c in range(GRID_SIZE):
            if tiles[r][c]:
                if (r, c) in blanks:
                    # A blank tile on the board means one blank was used from the initial distribution
                    if ' ' in remaining:
                        remaining[' '] -= 1
                else:
                    # Non-blank tiles decrease their respective letter counts
                    letter = tiles[r][c]
                    if letter in remaining:
                        remaining[letter] -= 1

    # Ensure no negative counts
    for letter in remaining:
        remaining[letter] = max(0, remaining[letter])

    return remaining

# Function 16: draw_remaining_tiles (Updated)
def draw_remaining_tiles(remaining, turn):
    """Draw the list of remaining tiles, ensuring non-negative counts."""
    # Adjust x-position based on window width
    remaining_x = min(BOARD_SIZE + 70, WINDOW_WIDTH - 200)  # Ensure it fits within window
    if remaining_x < BOARD_SIZE + 10:  # If too close to board, reposition
        remaining_x = BOARD_SIZE + 10

    title_text = ui_font.render(f"P{turn}'s Unseen Tiles:", True, BLACK)
    screen.blit(title_text, (remaining_x, 10))

    y_pos = 40
    col_width = 60 # Approximate width for one column (e.g., "X: 1")
    col_count = 0
    max_y = WINDOW_HEIGHT - 100 # Limit height to avoid overlap with racks/buttons

    sorted_letters = sorted(remaining.keys())
    current_col_x = remaining_x
    items_in_col = 0
    max_items_per_col = (max_y - y_pos) // 20 # Estimate max items per column
    if max_items_per_col <= 0: max_items_per_col = 1 # Avoid division by zero or negative

    for letter in sorted_letters:
        if remaining[letter] > 0:
            display_letter = "?" if letter == " " else letter
            # Display as Letter: Count format for compactness
            text_str = f"{display_letter}: {remaining[letter]}"
            text = tile_count_font.render(text_str, True, BLACK)

            # Check if drawing this line exceeds max height, move to next column
            if items_in_col >= max_items_per_col:
                 y_pos = 40 # Reset y
                 current_col_x += col_width # Move to next column x
                 col_count += 1
                 items_in_col = 0
                 # Optional: Add check to prevent going off screen horizontally

            screen.blit(text, (current_col_x, y_pos))
            y_pos += 20 # Move down for next letter
            items_in_col += 1

    # Position summary below the columns
    summary_y_start = 40 + max_items_per_col * 20 + 20 # Start below the potential bottom of the first column
    summary_y_start = min(summary_y_start, max_y + 20) # Ensure it doesn't go too far down

    total_tiles = sum(remaining[letter] for letter in remaining if remaining[letter] > 0)
    vowels = sum(remaining[letter] for letter in 'AEIOU' if letter in remaining and remaining[letter] > 0)
    consonants = sum(remaining[letter] for letter in remaining if letter.isalpha() and letter not in 'AEIOU' and letter in remaining and remaining[letter] > 0)
    blanks_rem = remaining.get(' ', 0)

    text1 = tile_count_font.render(f"Tiles remaining: {total_tiles}", True, BLACK)
    text2 = tile_count_font.render(f"V: {vowels}  C: {consonants}  B: {blanks_rem}", True, BLACK)
    screen.blit(text1, (remaining_x - 20, summary_y_start))  # Use summary_y_start
    summary_y_start += 20
    screen.blit(text2, (remaining_x - 20, summary_y_start))

# Function 17: draw_arrow (Updated)
def draw_arrow(row, col, direction):
    """Draw an arrow indicating play direction."""
    center_x = 40 + col * SQUARE_SIZE + SQUARE_SIZE // 2
    center_y = 40 + row * SQUARE_SIZE + SQUARE_SIZE // 2

    arrow_length = SQUARE_SIZE * 0.4
    arrow_width = SQUARE_SIZE * 0.2

    if direction == "right":
        # Draw horizontal arrow body
        pygame.draw.line(screen, ARROW_COLOR, (center_x - arrow_length / 2, center_y), (center_x + arrow_length / 2, center_y), 3)
        # Draw arrowhead
        pygame.draw.polygon(screen, ARROW_COLOR, [
            (center_x + arrow_length / 2, center_y - arrow_width / 2),
            (center_x + arrow_length / 2, center_y + arrow_width / 2),
            (center_x + arrow_length / 2 + arrow_width, center_y) # Pointy end
        ])
    elif direction == "down":
         # Draw vertical arrow body
        pygame.draw.line(screen, ARROW_COLOR, (center_x, center_y - arrow_length / 2), (center_x, center_y + arrow_length / 2), 3)
        # Draw arrowhead
        pygame.draw.polygon(screen, ARROW_COLOR, [
            (center_x - arrow_width / 2, center_y + arrow_length / 2),
            (center_x + arrow_width / 2, center_y + arrow_length / 2),
            (center_x, center_y + arrow_length / 2 + arrow_width) # Pointy end
        ])

# Function 18: is_valid_play (Updated)
def is_valid_play(word_positions, tiles, is_first_play, initial_rack_size, original_tiles, rack):
    """Validate a potential play."""
    if not word_positions:
        # print("Validation Error: No tiles placed.") # Debug
        return False, False # Cannot play zero tiles

    newly_placed_positions = [(r, c) for r, c, _ in word_positions if not original_tiles[r][c]]
    if not newly_placed_positions:
         # This case might occur if only existing tiles were somehow selected? Invalid.
         # print("Validation Error: No new tiles were placed.") # Debug
         return False, False

    rows = sorted(set(r for r, _, _ in word_positions))
    cols = sorted(set(c for _, c, _ in word_positions))

    # Check alignment: all tiles must be in a single row or single column
    is_horizontal = len(rows) == 1
    is_vertical = len(cols) == 1

    if not (is_horizontal or is_vertical):
        # Check if it's just a single tile placement (can be valid if connects)
        if len(word_positions) == 1:
             pass # Single tile is okay alignment-wise, check connection later
        else:
             # print("Validation Error: Tiles not in a single row or column.") # Debug
             return False, False # Tiles not aligned

    # Check for gaps within the played word span (using the final 'tiles' state)
    if is_horizontal:
        r = rows[0]
        min_col = min(c for _, c, _ in word_positions)
        max_col = max(c for _, c, _ in word_positions)
        # Extend to check adjacent existing tiles as well
        temp_min_col = min_col
        while temp_min_col > 0 and original_tiles[r][temp_min_col - 1]: temp_min_col -= 1
        temp_max_col = max_col
        while temp_max_col < GRID_SIZE - 1 and original_tiles[r][temp_max_col + 1]: temp_max_col += 1

        for c in range(temp_min_col, temp_max_col + 1):
            # If a square within the full span (including adjacent) is empty, it's a gap
            if not tiles[r][c]:
                # print(f"Validation Error: Gap detected at ({r},{c}) in horizontal play.") # Debug
                return False, False
    elif is_vertical:
        c = cols[0]
        min_row = min(r for r, _, _ in word_positions)
        max_row = max(r for r, _, _ in word_positions)
        # Extend to check adjacent existing tiles as well
        temp_min_row = min_row
        while temp_min_row > 0 and original_tiles[temp_min_row - 1][c]: temp_min_row -= 1
        temp_max_row = max_row
        while temp_max_row < GRID_SIZE - 1 and original_tiles[temp_max_row + 1][c]: temp_max_row += 1

        for r in range(temp_min_row, temp_max_row + 1):
            # If a square within the full span (including adjacent) is empty, it's a gap
            if not tiles[r][c]:
                 # print(f"Validation Error: Gap detected at ({r},{c}) in vertical play.") # Debug
                 return False, False

    # Check word validity using DAWG
    formed_words = get_words_played(word_positions, tiles) # Use final tiles state
    if not formed_words:
         # This can happen if only a single letter is placed and doesn't connect to form a word > 1 letter
         if len(word_positions) == 1:
              # Check if the single tile connects to anything *originally* on the board
              r, c, _ = word_positions[0]
              connects = False
              for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
                   nr, nc = r + dr, c + dc
                   if 0 <= nr < GRID_SIZE and 0 <= nc < GRID_SIZE and original_tiles[nr][nc]:
                        connects = True
                        break
              if not connects and not is_first_play:
                   # print("Validation Error: Single tile placed does not connect.") # Debug
                   return False, False
              # If it's the first play, it must be on the center square
              if is_first_play and (r, c) != CENTER_SQUARE:
                   # print("Validation Error: First play not on center square.") # Debug
                   return False, False
              # If single tile connects or is first play on center, it's technically valid placement,
              # but forms no scorable words yet. get_words_played should return empty.
              # print("Validation Error: Play does not form any valid words of length 2 or more.") # Debug
              return False, False # Invalid if no words > 1 letter formed
         else:
              # print("Validation Error: No words formed by the play.") # Debug
              return False, False # Should not happen if alignment/gap checks passed

    for word in formed_words:
        node = DAWG.root
        valid_word = True
        for char in word:
            if char not in node.edges:
                valid_word = False
                break
            node = node.edges[char]
        if not valid_word or not node.is_terminal:
            # print(f"Validation Error: Word '{word}' not in dictionary.") # Debug
            return False, False # Word not found or not a complete word

    # Check connection to existing tiles or center square
    if is_first_play:
        if not any(r == CENTER_SQUARE[0] and c == CENTER_SQUARE[1] for r, c in newly_placed_positions):
            # print("Validation Error: First play must include the center square.") # Debug
            return False, False
    else: # Not the first play
        connects_to_existing = False
        for r, c in newly_placed_positions:
            # Check adjacent squares for tiles that were *originally* on the board
            for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < GRID_SIZE and 0 <= nc < GRID_SIZE and original_tiles[nr][nc]:
                    connects_to_existing = True
                    break
            if connects_to_existing:
                break
        if not connects_to_existing:
            # print("Validation Error: Play does not connect to existing tiles.") # Debug
            return False, False

    # Check if tiles used were available in the rack (this should be implicitly handled by placement logic)
    # We can add an explicit check if needed, comparing newly_placed_positions letters + blanks used vs rack content.

    # Calculate bingo bonus based on number of *newly placed* tiles from the rack
    tiles_played_from_rack = len(newly_placed_positions)
    is_bingo = (initial_rack_size == 7 and tiles_played_from_rack == 7)

    return True, is_bingo

# Function 19: get_anchor_points (Updated)
def get_anchor_points(tiles, is_first_play):
    """Get anchor points for valid moves."""
    anchors = set()
    if is_first_play:
        anchors.add(CENTER_SQUARE)
        return anchors

    for r in range(GRID_SIZE):
        for c in range(GRID_SIZE):
            if not tiles[r][c]: # Must be an empty square
                 is_anchor = False
                 # Check if adjacent to any existing tile
                 for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
                     nr, nc = r + dr, c + dc
                     if 0 <= nr < GRID_SIZE and 0 <= nc < GRID_SIZE and tiles[nr][nc]:
                         is_anchor = True
                         break
                 if is_anchor:
                     anchors.add((r, c))
    # If no anchors found adjacent to existing tiles (e.g., empty board after first play failed?),
    # the only valid anchor would be the center square if the board is truly empty.
    # However, the is_first_play check should handle the initial state.
    # If anchors is empty here, it means no moves are possible adjacent to existing tiles.
    if not anchors and sum(1 for row in tiles for t in row if t) == 0: # Check if board is actually empty
         anchors.add(CENTER_SQUARE) # Should only happen if first_play was somehow False incorrectly

    return anchors


# End of Part 4


# Part 5

# Function 20: generate_valid_moves (Updated - Complex, needs testing)
def generate_valid_moves(rack, tiles, board, blanks, valid_words_subset=None):
    """Generate all valid moves using a backtracking algorithm with a DAWG."""
    moves = []
    unique_moves = set() # Store tuples of sorted (r, c) positions to detect duplicates
    is_first_play = sum(1 for row in tiles for t in row if t) == 0

    anchors = get_anchor_points(tiles, is_first_play)
    if not anchors:
         # print("No anchors found.") # Debug
         return [] # No possible place to start a move

    # Precompute cross-checks for empty squares
    cross_checks = {} # Key: (r, c), Value: {'H': set_of_valid_letters, 'V': set_of_valid_letters}
    for r_empty in range(GRID_SIZE):
        for c_empty in range(GRID_SIZE):
            if not tiles[r_empty][c_empty]:
                valid_v = set() # Letters valid for vertical cross-check (when playing horizontally)
                up_word = ''
                rr = r_empty - 1
                while rr >= 0 and tiles[rr][c_empty]: up_word = tiles[rr][c_empty] + up_word; rr -= 1
                down_word = ''
                rr = r_empty + 1
                while rr < GRID_SIZE and tiles[rr][c_empty]: down_word += tiles[rr][c_empty]; rr += 1

                if not up_word and not down_word:
                    valid_v = set('ABCDEFGHIJKLMNOPQRSTUVWXYZ ') # Any letter is valid if no vertical connection
                else:
                    for letter in 'ABCDEFGHIJKLMNOPQRSTUVWXYZ':
                        test_word = up_word + letter + down_word
                        node = DAWG.root
                        is_valid = True
                        for char in test_word:
                            if char not in node.edges: is_valid = False; break
                            node = node.edges[char]
                        if is_valid and node.is_terminal: valid_v.add(letter)
                    # Allow blank only if at least one letter works for the cross-check
                    if valid_v: valid_v.add(' ')

                valid_h = set() # Letters valid for horizontal cross-check (when playing vertically)
                left_word = ''
                cc = c_empty - 1
                while cc >= 0 and tiles[r_empty][cc]: left_word = tiles[r_empty][cc] + left_word; cc -= 1
                right_word = ''
                cc = c_empty + 1
                while cc < GRID_SIZE and tiles[r_empty][cc]: right_word += tiles[r_empty][cc]; cc += 1

                if not left_word and not right_word:
                    valid_h = set('ABCDEFGHIJKLMNOPQRSTUVWXYZ ') # Any letter is valid if no horizontal connection
                else:
                    for letter in 'ABCDEFGHIJKLMNOPQRSTUVWXYZ':
                        test_word = left_word + letter + right_word
                        node = DAWG.root
                        is_valid = True
                        for char in test_word:
                            if char not in node.edges: is_valid = False; break
                            node = node.edges[char]
                        if is_valid and node.is_terminal: valid_h.add(letter)
                    # Allow blank only if at least one letter works for the cross-check
                    if valid_h: valid_h.add(' ')

                cross_checks[(r_empty, c_empty)] = {'V': valid_v, 'H': valid_h}


    rack_counter_orig = Counter(rack)

    # --- Helper function to finalize and add a valid move ---
    def finalize_move(placed_tiles_list, current_rack_counts):
        if not placed_tiles_list: return

        # Create temporary board state based on the placed tiles
        temp_tiles = [row[:] for row in tiles]
        temp_blanks = set(blanks)
        newly_placed_for_score = []
        original_tiles_for_val = [row[:] for row in tiles] # Original state for validation

        for pr, pc, letter, is_blank in placed_tiles_list:
            temp_tiles[pr][pc] = letter
            if is_blank: temp_blanks.add((pr, pc))
            if not original_tiles_for_val[pr][pc]:
                 newly_placed_for_score.append((pr, pc, letter))

        # Validate the play using the temporary state
        is_valid, is_bingo = is_valid_play(
            [(p[0], p[1], p[2]) for p in placed_tiles_list],
            temp_tiles,
            is_first_play,
            len(rack), # Initial rack size
            original_tiles_for_val,
            rack # Original rack for context
        )

        if is_valid:
            score = calculate_score(newly_placed_for_score, board, temp_tiles, temp_blanks)
            move_id = tuple(sorted((p[0], p[1]) for p in placed_tiles_list))

            if move_id not in unique_moves:
                unique_moves.add(move_id)

                # Determine start, direction, full word, leave etc.
                start_pos = min(placed_tiles_list, key=lambda p: (p[0], p[1]))
                start_r, start_c, _, _ = start_pos
                # Determine direction based on alignment
                rows_placed = set(p[0] for p in placed_tiles_list)
                cols_placed = set(p[1] for p in placed_tiles_list)
                direction = "right" if len(rows_placed) == 1 else "down"

                full_word_tiles, _ = find_main_word([(p[0], p[1], p[2]) for p in placed_tiles_list], temp_tiles)
                full_word_str = "".join(t[2] for t in full_word_tiles) if full_word_tiles else "ERROR"

                word_with_blanks_list = []
                placed_pos_set = set((p[0], p[1]) for p in placed_tiles_list)
                blanks_in_move = set((p[0], p[1]) for p in placed_tiles_list if p[3])
                for wr, wc, w_letter in full_word_tiles:
                     is_blank_in_word = (wr, wc) in placed_pos_set and (wr, wc) in blanks_in_move
                     word_with_blanks_list.append(w_letter.lower() if is_blank_in_word else w_letter.upper())
                word_with_blanks = "".join(word_with_blanks_list)

                # Calculate leave using the final rack counts from the recursive call
                leave = list(current_rack_counts.elements())

                moves.append({
                    'positions': [(p[0], p[1], p[2]) for p in placed_tiles_list],
                    'blanks': blanks_in_move,
                    'word': full_word_str,
                    'score': score,
                    'start': (start_r, start_c),
                    'direction': direction,
                    'leave': leave,
                    'is_bingo': is_bingo,
                    'word_with_blanks': word_with_blanks,
                    'newly_placed': newly_placed_for_score
                })

    # --- Recursive function to extend right/down ---
    def extend_right(r, c, direction, node, current_rack_counts, placed_tiles_so_far):
        # Check if the current square (r, c) is valid for placement
        if not (0 <= r < GRID_SIZE and 0 <= c < GRID_SIZE):
            return # Out of bounds

        # Case 1: Square is empty - try placing tiles from rack
        if not tiles[r][c]:
            # Check cross-check validity for this square
            valid_letters_for_cross = set()
            if (r, c) in cross_checks:
                check_dir = 'V' if direction == 'right' else 'H'
                valid_letters_for_cross = cross_checks[(r, c)][check_dir]
            else: # Should not happen if precomputation is correct
                 # print(f"Error: Missing cross-check for empty square ({r},{c})") # Debug
                 return

            # Try placing regular tiles
            for letter, count in list(current_rack_counts.items()):
                if count > 0 and letter != ' ' and letter in node.edges:
                    if letter in valid_letters_for_cross:
                        current_rack_counts[letter] -= 1
                        placed_tiles_so_far.append((r, c, letter, False))
                        # Check if this forms a valid word ending here
                        if node.edges[letter].is_terminal:
                            finalize_move(placed_tiles_so_far, current_rack_counts)
                        # Recurse to the next square
                        next_r, next_c = (r, c + 1) if direction == 'right' else (r + 1, c)
                        extend_right(next_r, next_c, direction, node.edges[letter], current_rack_counts, placed_tiles_so_far)
                        # Backtrack
                        placed_tiles_so_far.pop()
                        current_rack_counts[letter] += 1

            # Try placing a blank
            if current_rack_counts.get(' ', 0) > 0 and ' ' in valid_letters_for_cross:
                 current_rack_counts[' '] -= 1
                 for blank_char in 'ABCDEFGHIJKLMNOPQRSTUVWXYZ':
                      if blank_char in node.edges:
                           placed_tiles_so_far.append((r, c, blank_char, True))
                           if node.edges[blank_char].is_terminal:
                                finalize_move(placed_tiles_so_far, current_rack_counts)
                           next_r, next_c = (r, c + 1) if direction == 'right' else (r + 1, c)
                           extend_right(next_r, next_c, direction, node.edges[blank_char], current_rack_counts, placed_tiles_so_far)
                           placed_tiles_so_far.pop() # Backtrack blank placement
                 current_rack_counts[' '] += 1 # Backtrack blank count

        # Case 2: Square has an existing tile - follow it if compatible
        else:
            letter = tiles[r][c]
            if letter in node.edges:
                 # Move along DAWG, don't change rack or placed_tiles_so_far
                 next_r, next_c = (r, c + 1) if direction == 'right' else (r + 1, c)
                 # Pass a *copy* of placed_tiles_so_far if it shouldn't be modified by this path
                 extend_right(next_r, next_c, direction, node.edges[letter], current_rack_counts, placed_tiles_so_far)
            # Else: path blocked by incompatible existing tile, stop this branch

    # --- Recursive function to build left/up part ---
    # This function needs a way to traverse the DAWG backwards or use a GADDAG structure.
    # The current implementation is a placeholder and likely incorrect.
    def build_left(r, c, direction, node, current_rack_counts, placed_tiles_so_far):
        # Placeholder: This logic requires reverse DAWG traversal or GADDAG
        # For now, just call extend_right from the anchor immediately after this point
        anchor_r, anchor_c = (r, c + 1) if direction == 'right' else (r + 1, c)
        if 0 <= anchor_r < GRID_SIZE and 0 <= anchor_c < GRID_SIZE:
             extend_right(anchor_r, anchor_c, direction, node, current_rack_counts, placed_tiles_so_far)


    # --- Main Generation Loop ---
    for r_anchor, c_anchor in anchors:
        # Case 1: Anchor is the first letter of the word (extend right/down only)
        extend_right(r_anchor, c_anchor, "right", DAWG.root, rack_counter_orig.copy(), [])
        extend_right(r_anchor, c_anchor, "down", DAWG.root, rack_counter_orig.copy(), [])

        # Case 2: Build words ending at the anchor (build left/up)
        # This requires a more complex algorithm (like GADDAG) or reverse DAWG edges.
        # Skipping this part for now as the implementation is non-trivial.
        # build_left(r_anchor, c_anchor - 1, "right", DAWG.root, rack_counter_orig.copy(), [])
        # build_left(r_anchor - 1, c_anchor, "down", DAWG.root, rack_counter_orig.copy(), [])
        pass

    # Sort moves by score descending
    moves.sort(key=lambda m: m['score'], reverse=True)

    # print(f"Generated {len(moves)} raw moves, {len(unique_moves)} unique positions.") # Debug
    return moves

# Function 21: draw_hint_dialog (Updated)
def draw_hint_dialog(moves, selected_index):
    """Draw the hint dialog showing top 5 moves."""
    dialog_width, dialog_height = 400, 250
    dialog_x = (WINDOW_WIDTH - dialog_width) // 2
    dialog_y = (WINDOW_HEIGHT - dialog_height) // 2

    pygame.draw.rect(screen, DIALOG_COLOR, (dialog_x, dialog_y, dialog_width, dialog_height))
    pygame.draw.rect(screen, BLACK, (dialog_x, dialog_y, dialog_width, dialog_height), 2)

    title_text = dialog_font.render("Top 5 Moves" if moves else "No Moves Available", True, BLACK)
    screen.blit(title_text, (dialog_x + 10, dialog_y + 10))

    hint_rects = []
    y_pos = dialog_y + 40
    for i, move in enumerate(moves[:5]):
        color = HINT_SELECTED_COLOR if i == selected_index else HINT_NORMAL_COLOR
        rect = pygame.Rect(dialog_x + 10, y_pos, dialog_width - 20, 30)
        pygame.draw.rect(screen, color, rect)

        # Display move details (Word, Score, Position, Leave)
        word = move.get('word', 'N/A')
        score = move.get('score', 0)
        start_pos = move.get('start', (0,0))
        direction = move.get('direction', 'right')
        leave = move.get('leave', [])
        # blanks_used = move.get('blanks', set()) # Not directly shown here
        # positions = move.get('positions', []) # Not directly shown here

        coord = get_coord(start_pos, direction)
        leave_str = ''.join(sorted(l if l != ' ' else '?' for l in leave))

        # Use the pre-formatted word_with_blanks if available
        word_display = move.get('word_with_blanks', word.upper()) # Default to uppercase word

        text_str = f"{i+1}. {word_display} ({score} pts) at {coord} ({leave_str})"
        text = ui_font.render(text_str, True, BLACK)
        # Check text width and potentially truncate or use smaller font if needed
        max_text_width = rect.width - 10 # Allow padding
        if text.get_width() > max_text_width:
             # Simple truncation (could be smarter)
             # Estimate chars per pixel, truncate string, add "..."
             avg_char_width = text.get_width() / len(text_str) if len(text_str) > 0 else 10
             max_chars = int(max_text_width / avg_char_width) - 3
             if max_chars < 5: max_chars = 5 # Minimum display
             text_str = text_str[:max_chars] + "..."
             text = ui_font.render(text_str, True, BLACK)

        screen.blit(text, (dialog_x + 15, y_pos + 5))

        hint_rects.append(rect)
        y_pos += 30

    # Position buttons at the bottom
    button_y = dialog_y + dialog_height - BUTTON_HEIGHT - 10
    total_button_width = 3 * BUTTON_WIDTH + 2 * BUTTON_GAP
    button_start_x = dialog_x + (dialog_width - total_button_width) // 2

    play_button_rect = pygame.Rect(button_start_x, button_y, BUTTON_WIDTH, BUTTON_HEIGHT)
    all_words_button_rect = pygame.Rect(button_start_x + BUTTON_WIDTH + BUTTON_GAP, button_y, BUTTON_WIDTH, BUTTON_HEIGHT)
    ok_button_rect = pygame.Rect(button_start_x + 2 * (BUTTON_WIDTH + BUTTON_GAP), button_y, BUTTON_WIDTH, BUTTON_HEIGHT)


    # Draw Play button
    hover = play_button_rect.collidepoint(pygame.mouse.get_pos())
    color = BUTTON_HOVER if hover else BUTTON_COLOR
    pygame.draw.rect(screen, color, play_button_rect)
    play_text = button_font.render("Play", True, BLACK)
    play_text_rect = play_text.get_rect(center=play_button_rect.center)
    screen.blit(play_text, play_text_rect)

    # Draw All Words button
    hover = all_words_button_rect.collidepoint(pygame.mouse.get_pos())
    color = BUTTON_HOVER if hover else BUTTON_COLOR
    pygame.draw.rect(screen, color, all_words_button_rect)
    all_words_text = button_font.render("All Words", True, BLACK)
    all_words_text_rect = all_words_text.get_rect(center=all_words_button_rect.center)
    screen.blit(all_words_text, all_words_text_rect)

    # Draw OK button
    hover = ok_button_rect.collidepoint(pygame.mouse.get_pos())
    color = BUTTON_HOVER if hover else BUTTON_COLOR
    pygame.draw.rect(screen, color, ok_button_rect)
    ok_text = button_font.render("OK", True, BLACK)
    ok_text_rect = ok_text.get_rect(center=ok_button_rect.center)
    screen.blit(ok_text, ok_text_rect)

    return hint_rects, play_button_rect, ok_button_rect, all_words_button_rect


# End of Part 5

# Part 6

# Function 22: draw_all_words_dialog (Updated)
def draw_all_words_dialog(moves, selected_index, scroll_offset):
    """Draw the dialog showing all valid moves with scrolling."""
    dialog_x = (WINDOW_WIDTH - ALL_WORDS_DIALOG_WIDTH) // 2
    dialog_y = (WINDOW_HEIGHT - ALL_WORDS_DIALOG_HEIGHT) // 2

    # Draw dialog background
    pygame.draw.rect(screen, DIALOG_COLOR, (dialog_x, dialog_y, ALL_WORDS_DIALOG_WIDTH, ALL_WORDS_DIALOG_HEIGHT))
    pygame.draw.rect(screen, BLACK, (dialog_x, dialog_y, ALL_WORDS_DIALOG_WIDTH, ALL_WORDS_DIALOG_HEIGHT), 2)

    header_height = 40
    unique_words = len(set(move.get('word', '') for move in moves)) # Use .get for safety
    title_text = dialog_font.render(f"All Valid Moves ({unique_words} unique words, {len(moves)} plays)", True, BLACK)
    screen.blit(title_text, (dialog_x + 10, dialog_y + 10))


    # Create a surface for the scrollable content
    content_height = len(moves) * 30
    # Ensure content surface width is positive
    content_surface_width = max(1, ALL_WORDS_DIALOG_WIDTH - 20)
    content_surface = pygame.Surface((content_surface_width, content_height))
    content_surface.fill(DIALOG_COLOR)

    all_words_rects = [] # Store tuples of (screen_rect, move_index)
    item_height = 30
    button_area_height = BUTTON_HEIGHT + 30 # Space for buttons at bottom
    content_area_height = ALL_WORDS_DIALOG_HEIGHT - header_height - button_area_height # Available drawing height

    for i, move in enumerate(moves):
        y_pos_on_surface = i * item_height
        # Only draw if the item is potentially visible
        if y_pos_on_surface >= scroll_offset - item_height and y_pos_on_surface < scroll_offset + content_area_height:
            color = HINT_SELECTED_COLOR if i == selected_index else HINT_NORMAL_COLOR
            # Draw on the content surface
            rect_on_surface = pygame.Rect(10, y_pos_on_surface, content_surface_width - 20, item_height)
            pygame.draw.rect(content_surface, color, rect_on_surface)

            # Display move details
            word = move.get('word', 'N/A')
            score = move.get('score', 0)
            start_pos = move.get('start', (0,0))
            direction = move.get('direction', 'right')
            leave = move.get('leave', [])
            word_display = move.get('word_with_blanks', word.upper())

            coord = get_coord(start_pos, direction)
            leave_str = ''.join(sorted(l if l != ' ' else '?' for l in leave))
            text_str = f"{i+1}. {word_display} ({score} pts) at {coord} ({leave_str})"
            text = ui_font.render(text_str, True, BLACK)

            # Truncate text if too wide
            max_text_width = rect_on_surface.width - 10
            if text.get_width() > max_text_width:
                 avg_char_width = text.get_width() / len(text_str) if len(text_str) > 0 else 10
                 max_chars = int(max_text_width / avg_char_width) - 3
                 if max_chars < 5: max_chars = 5
                 text_str = text_str[:max_chars] + "..."
                 text = ui_font.render(text_str, True, BLACK)

            content_surface.blit(text, (15, y_pos_on_surface + 5))

            # Calculate screen rect for collision detection
            screen_y = dialog_y + header_height + y_pos_on_surface - scroll_offset
            screen_rect = pygame.Rect(dialog_x + 10, screen_y, content_surface_width - 20, item_height)
            # Clip the rect to the visible area
            visible_top = dialog_y + header_height
            visible_bottom = dialog_y + header_height + content_area_height
            screen_rect.top = max(visible_top, screen_rect.top)
            screen_rect.bottom = min(visible_bottom, screen_rect.bottom)
            if screen_rect.height > 0: # Only add if visible
                 all_words_rects.append((screen_rect, i))


    # Blit the relevant part of the content surface to the screen
    visible_area_on_surface = pygame.Rect(0, scroll_offset, content_surface_width, content_area_height)
    screen.blit(content_surface, (dialog_x + 10, dialog_y + header_height), visible_area_on_surface)

    # Position buttons at the bottom, centered
    total_button_width = 2 * BUTTON_WIDTH + BUTTON_GAP
    buttons_x = dialog_x + (ALL_WORDS_DIALOG_WIDTH - total_button_width) // 2 # Centered horizontally
    button_y = dialog_y + ALL_WORDS_DIALOG_HEIGHT - BUTTON_HEIGHT - 20 # Near the bottom

    play_button_x = buttons_x
    ok_button_x = buttons_x + BUTTON_WIDTH + BUTTON_GAP # Next to each other

    play_button_rect = pygame.Rect(play_button_x, button_y, BUTTON_WIDTH, BUTTON_HEIGHT)
    ok_button_rect = pygame.Rect(ok_button_x, button_y, BUTTON_WIDTH, BUTTON_HEIGHT)

    # Draw play button
    hover = play_button_rect.collidepoint(pygame.mouse.get_pos())
    color = BUTTON_HOVER if hover else BUTTON_COLOR
    pygame.draw.rect(screen, color, play_button_rect)
    play_text = button_font.render("Play", True, BLACK)
    play_text_rect = play_text.get_rect(center=play_button_rect.center)
    screen.blit(play_text, play_text_rect)

    # Draw OK button
    hover = ok_button_rect.collidepoint(pygame.mouse.get_pos())
    color = BUTTON_HOVER if hover else BUTTON_COLOR
    pygame.draw.rect(screen, color, ok_button_rect)
    ok_text = button_font.render("OK", True, BLACK)
    ok_text_rect = ok_text.get_rect(center=ok_button_rect.center)
    screen.blit(ok_text, ok_text_rect)

    return all_words_rects, play_button_rect, ok_button_rect

# Function 23: get_tile_under_mouse (Updated)
def get_tile_under_mouse(x, y, rack_start_x, rack_y, rack_len):
    """Determine which tile index (0 to rack_len-1) is under the mouse cursor."""
    for i in range(rack_len):
        tile_x = rack_start_x + i * (TILE_WIDTH + TILE_GAP)
        tile_rect = pygame.Rect(tile_x, rack_y, TILE_WIDTH, TILE_HEIGHT)
        if tile_rect.collidepoint(x, y):
            return i
    return None

# Function 24: get_insertion_index (Updated)
def get_insertion_index(x, rack_start_x, rack_len):
    """Determine the insertion index (0 to rack_len) based on mouse x-position."""
    # Check before the center of the first tile
    if x < rack_start_x + TILE_WIDTH // 2:
        return 0
    # Check between tiles (using the gap center)
    for i in range(rack_len):
        tile_left = rack_start_x + i * (TILE_WIDTH + TILE_GAP)
        tile_right = tile_left + TILE_WIDTH
        # Consider the midpoint between tile i and tile i+1 (or end of rack)
        gap_center = tile_right + TILE_GAP // 2
        if x < gap_center:
             return i + 1
    # If after the center of the last gap (or last tile if rack_len=7)
    return rack_len


def count_consecutive_existing(row, col, direction, tiles):
    """Count consecutive existing tiles in a direction."""
    count = 0
    if direction == "right":
        c = col
        while c < GRID_SIZE and tiles[row][c]:
            count += 1
            c += 1
    else: # down
        r = row
        while r < GRID_SIZE and tiles[r][col]:
            count += 1
            r += 1
    return count

# Function 25: play_hint_move (Updated)
def play_hint_move(move, tiles, racks, blanks, scores, turn, bag, board):
    """Plays a move selected from the hint/all words dialog."""
    player_idx = turn - 1
    current_rack = racks[player_idx]
    move_positions = move.get('positions', [])
    move_blanks = move.get('blanks', set()) # Set of (r, c) where blanks were used

    # 1. Verify tiles needed are in the rack (including blanks)
    needed_tiles = Counter()
    blanks_needed_count = 0
    original_tiles_on_board = [row[:] for row in tiles] # Snapshot before play

    for r, c, letter in move_positions:
        if not original_tiles_on_board[r][c]: # Only count tiles *placed* by this move
            if (r, c) in move_blanks:
                blanks_needed_count += 1
            else:
                needed_tiles[letter] += 1

    rack_counter = Counter(current_rack)
    blanks_available = rack_counter.get(' ', 0)

    if blanks_needed_count > blanks_available:
        print(f"Error playing hint: Needs {blanks_needed_count} blanks, only {blanks_available} available.")
        return turn, [], [] # Return original turn, no drawn tiles, no newly placed

    for letter, count in needed_tiles.items():
        if rack_counter.get(letter, 0) < count:
            print(f"Error playing hint: Needs {count} '{letter}', only {rack_counter.get(letter, 0)} available.")
            return turn, [], []

    # 2. Place tiles on board and update rack
    newly_placed_actual = [] # Store (r, c, letter) of tiles actually placed now
    rack_after_play = current_rack[:] # Copy rack to modify

    for r, c, letter in move_positions:
        if not original_tiles_on_board[r][c]: # Place only if square was empty
            tiles[r][c] = letter
            newly_placed_actual.append((r, c, letter))
            if (r, c) in move_blanks:
                if ' ' in rack_after_play:
                    rack_after_play.remove(' ')
                    blanks.add((r, c)) # Add to game's blank set
                else:
                    print("Error: Tried to play blank but none in rack_after_play!") # Should not happen after check
            else:
                if letter in rack_after_play:
                    rack_after_play.remove(letter)
                else:
                    print(f"Error: Tried to play '{letter}' but not in rack_after_play!") # Should not happen

    # 3. Calculate score (using the actual newly placed tiles)
    # The score from the 'move' dictionary might be pre-calculated, but recalculating is safer
    # Use the newly_placed_actual list for scoring
    new_score = calculate_score(newly_placed_actual, board, tiles, blanks)
    # Compare with pre-calculated score for debugging?
    # if new_score != move.get('score', -1):
    #     print(f"Warning: Recalculated score ({new_score}) differs from hint score ({move.get('score', -1)})")

    scores[player_idx] += new_score

    # 4. Draw new tiles
    num_to_draw = 7 - len(rack_after_play)
    drawn_tiles = [bag.pop() for _ in range(num_to_draw) if bag]
    rack_after_play.extend(drawn_tiles)
    # rack_after_play.sort() # Keep rack sorted? Optional.

    racks[player_idx] = rack_after_play # Update the main racks list

    # 5. Return next turn, drawn tiles, and newly placed tiles
    return 3 - turn, drawn_tiles, newly_placed_actual


# Function 26: ai_turn (Updated)
def ai_turn(turn, racks, tiles, board, blanks, scores, bag, first_play, pass_count, exchange_count, consecutive_zero_point_turns, player_names, dropdown_open=False, hinting=False, showing_all_words=False, letter_checks=None):
    print(f"AI Player {turn} turn started. Rack: {''.join(racks[turn-1])}")
    global last_word, last_score, last_start, last_direction, move_history, current_replay_turn, practice_mode

    # Handle 8-letter practice mode where P2 (AI) does nothing
    if practice_mode == "eight_letter" and turn == 2:
        print("Skipping AI turn 2 in 8-letter practice.")
        # Return state indicating no action taken, pass turn back? Or let game end?
        # Assuming P1 wins immediately after their turn in this mode.
        # For now, just return unchanged state, let game over logic handle it.
        return turn, first_play, pass_count, exchange_count, consecutive_zero_point_turns, [], dropdown_open, hinting, showing_all_words, False, None # False for paused_for_power_tile

    paused_for_power_tile = False
    current_power_tile = None # Track the specific power tile if paused

    # Generate moves
    all_moves = generate_valid_moves(racks[turn-1], tiles, board, blanks)
    if all_moves is None: all_moves = [] # Ensure it's a list

    print(f"AI Player {turn} generated {len(all_moves)} moves.")

    # Check for Power Tile Practice pause condition
    if practice_mode == "power_tiles" and letter_checks:
        checked_power_tiles = {letter for i, letter in enumerate(['J', 'Q', 'X', 'Z']) if letter_checks[i]}
        power_tiles_on_rack = [tile for tile in racks[turn-1] if tile in checked_power_tiles]

        if power_tiles_on_rack:
            current_power_tile = power_tiles_on_rack[0] # Pause for the first one found
            message = f"{current_power_tile} is on {player_names[turn-1]}'s rack.\nFind the highest scoring play with {current_power_tile}!"
            # Don't show dialog here, just set flag and return moves
            paused_for_power_tile = True
            print(f"AI turn paused for power tile: {current_power_tile}")
            # Return the generated moves so the human can interact via Hint/Play
            return turn, first_play, pass_count, exchange_count, consecutive_zero_point_turns, all_moves, dropdown_open, hinting, showing_all_words, paused_for_power_tile, current_power_tile


    # If bag and rack are empty, AI passes (game should end)
    if not racks[turn-1] and not bag:
        print(f"AI {turn} has empty rack and bag is empty. Passing.")
        move_type = 'pass'
        score = 0
        word = ''
        positions = []
        blanks_used = set()
        drawn_tiles = []
        coord = ''
        word_with_blanks = ''
        is_bingo = False
        consecutive_zero_point_turns += 1
        pass_count += 1
        exchange_count = 0
        next_turn = 3 - turn
        move_rack_before = racks[turn-1][:] # Empty rack
    # If moves are found, play the best one
    elif all_moves:
        best_move = all_moves[0] # Simple AI: choose highest score
        print(f"AI {turn} playing best move: {best_move.get('word','N/A')} for {best_move.get('score',0)} points.")

        move_rack_before = racks[turn-1][:] # Copy rack before playing

        # Use play_hint_move to execute the move and update state
        next_turn, drawn_tiles, newly_placed = play_hint_move(best_move, tiles, racks, blanks, scores, turn, bag, board)

        # Log the move details
        move_type = 'place'
        score = best_move.get('score', 0) # Use score from move dict
        word = best_move.get('word', 'N/A')
        positions = best_move.get('positions', [])
        blanks_used = best_move.get('blanks', set())
        start = best_move.get('start', (0,0))
        direction = best_move.get('direction', 'right')
        coord = get_coord(start, direction)
        word_with_blanks = best_move.get('word_with_blanks', '')
        is_bingo = best_move.get('is_bingo', False)

        first_play = False # A move was made
        consecutive_zero_point_turns = 0
        pass_count = 0
        exchange_count = 0

    # If no moves found, try to exchange or pass
    else:
        print(f"AI {turn} found no valid moves.")
        move_rack_before = racks[turn-1][:] # Copy rack before action
        if len(bag) >= 7: # Exchange if possible (simple strategy: exchange 3 tiles)
            print(f"AI {turn} exchanging tiles.")
            num_to_exchange = min(len(racks[turn-1]), 3) # Exchange up to 3
            # Simple exchange: just take first N tiles
            tiles_to_exchange = racks[turn-1][:num_to_exchange]
            drawn_tiles = [bag.pop() for _ in range(num_to_exchange) if bag] # Draw replacements

            # Update rack
            new_rack = racks[turn-1][num_to_exchange:] + drawn_tiles
            # new_rack.sort() # Optional sort
            racks[turn-1] = new_rack

            # Return exchanged tiles to bag
            bag.extend(tiles_to_exchange)
            random.shuffle(bag)

            move_type = 'exchange'
            score = 0
            word = ''
            positions = []
            blanks_used = set()
            coord = ''
            word_with_blanks = ''
            is_bingo = False
            consecutive_zero_point_turns += 1
            exchange_count += 1
            pass_count = 0
            next_turn = 3 - turn

        else: # Pass if exchange is not possible
            print(f"AI {turn} passing.")
            move_type = 'pass'
            score = 0
            word = ''
            positions = []
            blanks_used = set()
            drawn_tiles = []
            coord = ''
            word_with_blanks = ''
            is_bingo = False
            consecutive_zero_point_turns += 1
            pass_count += 1
            exchange_count = 0
            next_turn = 3 - turn

    # Record the move in history
    move_data = {
        'player': turn,
        'move_type': move_type,
        'rack': move_rack_before, # Rack *before* the move/action
        'score': score,
        'word': word,
        'positions': positions,
        'blanks': blanks_used,
        'drawn': drawn_tiles, # Tiles drawn *after* the move/action
        'coord': coord,
        'word_with_blanks': word_with_blanks,
        'is_bingo': is_bingo
    }
    if move_type == 'exchange':
         move_data['exchanged_tiles'] = tiles_to_exchange # Add exchanged tiles info

    move_history.append(move_data)
    current_replay_turn = len(move_history) # Update replay pointer

    # Return updated game state variables
    # Return empty list for all_moves as they were consumed/generated for this turn
    return next_turn, first_play, pass_count, exchange_count, consecutive_zero_point_turns, [], dropdown_open, hinting, showing_all_words, paused_for_power_tile, current_power_tile


def power_tile_practice():
    """Start AI vs AI mode until a power tile is drawn, then show a dialog."""
    # This function seems intended to set up the mode, but the actual pause logic
    # is now handled within ai_turn. We might not need this function anymore,
    # as selecting "Power Tiles" from the menu directly sets practice_mode="power_tiles"
    # and selected_mode=MODE_AVA.
    # global game_mode, is_ai, practice_mode
    # game_mode = MODE_AVA
    # is_ai = [True, True]
    # practice_mode = "power_tiles"
    print("Power tile practice setup (handled by mode selection).")


# End of Part 6

# Part 7

# Replay variables
move_history = []  # List to store all moves
replay_mode = False  # Flag to indicate replay mode
current_replay_turn = 0  # Current turn being displayed in replay

# Function 27: get_replay_state (Updated)
def get_replay_state(turn_idx, initial_racks):
    """Recreate the game state up to turn_idx, including racks."""
    # Start with initial state
    tiles_state = [['' for _ in range(GRID_SIZE)] for _ in range(GRID_SIZE)]
    blanks_state = set()
    scores_state = [0, 0]
    # IMPORTANT: Start with deep copies of the initial racks
    racks_state = [initial_racks[0][:], initial_racks[1][:]]

    # Apply moves sequentially up to turn_idx
    for i in range(turn_idx):
        if i >= len(move_history): # Safety check
             print(f"Warning: Replay index {i} out of bounds for move_history (len {len(move_history)})")
             break
        move = move_history[i]
        player_idx = move['player'] - 1 # 0-based index

        # Get the rack state *from the end of the previous iteration*
        current_rack_before_move = racks_state[player_idx][:] # Copy the rack state *before* this move 'i'

        if move['move_type'] == 'place':
            # Place tiles on board
            for r, c, letter in move.get('positions', []):
                tiles_state[r][c] = letter
                if (r, c) in move.get('blanks', set()):
                    blanks_state.add((r, c))
            # Update score
            scores_state[player_idx] += move.get('score', 0)

            # Update rack: remove played tiles, add drawn tiles
            rack_after_move = current_rack_before_move[:] # Work with a copy
            blanks_in_move = move.get('blanks', set())
            positions = move.get('positions', [])

            # Need the board state *before* this move to know which tiles were newly placed
            temp_tiles_before, _, _, _ = get_replay_state(i, initial_racks)

            for r, c, letter in positions:
                 if not temp_tiles_before[r][c]: # Tile was placed in this move
                      if (r,c) in blanks_in_move:
                           if ' ' in rack_after_move: rack_after_move.remove(' ')
                           else: print(f"Replay Warning: Tried to remove blank from rack for move {i}, but not found.")
                      else:
                           if letter in rack_after_move: rack_after_move.remove(letter)
                           else: print(f"Replay Warning: Tried to remove '{letter}' from rack for move {i}, but not found.")
            # Add drawn tiles
            rack_after_move.extend(move.get('drawn', []))
            racks_state[player_idx] = rack_after_move # Update the state rack for the *next* iteration

        elif move['move_type'] == 'exchange':
            # Update rack: remove exchanged, add drawn
            rack_after_move = current_rack_before_move[:] # Work with copy
            exchanged = move.get('exchanged_tiles', [])
            for tile in exchanged:
                 if tile in rack_after_move: rack_after_move.remove(tile)
                 else: print(f"Replay Warning: Tried to remove exchanged tile '{tile}' from rack for move {i}, but not found.")
            rack_after_move.extend(move.get('drawn', []))
            racks_state[player_idx] = rack_after_move

        elif move['move_type'] == 'pass':
            # No change to board, score, or rack content
            # Rack state remains racks_state[player_idx] = current_rack_before_move
            pass # racks_state[player_idx] is already correct for next iteration

    # Return the state *after* turn_idx moves have been applied
    return tiles_state, blanks_state, scores_state, racks_state

# Function 3: main (Updated)
def main():
    # Keep global declarations for variables potentially modified by practice modes if needed,
    # but prefer passing state back as done above.
    global bag, last_word, last_score, last_start, last_direction, move_history, replay_mode, current_replay_turn, game_mode, is_ai, practice_mode, board, tiles, racks, blanks, main_called

    # Check if this is the initial call or a restart
    if not main_called:
        main_called = True # Prevent re-entry issues if called again later

        # Call mode selection ONCE
        game_mode, player_names, human_player, practice_mode, letter_checks, practice_state = mode_selection_screen()

        # --- Game State Initialization ---
        if practice_state:
            # Load state from the 8-letter practice mode
            print("Loading state from 8-letter practice...")
            board = practice_state["board"]
            tiles = practice_state["tiles"]
            racks = practice_state["racks"]
            blanks = practice_state["blanks"]
            bag = practice_state["bag"]
            scores = practice_state["scores"]
            turn = practice_state["turn"]
            first_play = practice_state["first_play"]
            # Set AI based on the selected mode (MODE_AVA was set in mode_selection)
            is_ai = [True, True] # 8-letter practice currently forces AVA mode

        else:
            # Standard initialization for other modes (HVH, HVA, AVA, Power Tiles)
            print("Performing standard game initialization...")
            board, _, tiles = create_board() # <<<< Initialize board and tiles HERE
            # Bag is already global and populated, just shuffle
            # Ensure bag is reset if coming from a previous game
            bag = [letter for letter, (count, _) in TILE_DISTRIBUTION.items() for _ in range(count)]
            random.shuffle(bag)
            # Deal racks
            racks = [[], []] # Initialize empty first
            try:
                 racks[0] = [bag.pop() for _ in range(7)]
                 racks[1] = [bag.pop() for _ in range(7)]
            except IndexError:
                 print("Error: Not enough tiles in bag to deal initial racks.")
                 # Handle this error - maybe exit or allow starting with fewer tiles?
                 pygame.quit()
                 sys.exit()

            for rack in racks:
                rack.sort()
            scores = [0, 0]
            turn = 1
            blanks = set()
            first_play = True
            # Set AI based on the selected mode
            is_ai = [False, False] # Default to HVH
            if game_mode == MODE_HVA:
                is_ai[1 - human_player] = True # AI is the *other* player
            elif game_mode == MODE_AVA:
                is_ai = [True, True]
            # Override for Power Tiles Practice
            if practice_mode == "power_tiles":
                is_ai = [True, True]

        # --- Common Initializations (after specific setup) ---
        initial_racks = [rack[:] for rack in racks] # Store a copy regardless
        word_positions = [] # Current turn's word being built
        running = True
        dropdown_open = False
        return_to_mode_selection = False # Flag for restarting main loop for mode selection
        # ... reset other game loop variables ...
        all_words_ok_rect = None
        all_words_play_rect = None
        hint_rects = []
        hint_rect = None
        play_button_rect = None
        ok_button_rect = None
        all_words_button_rect = None
        tile_rects = []
        exchange_button_rect = None
        cancel_button_rect = None
        pass_count = 0
        exchange_count = 0
        consecutive_zero_point_turns = 0
        exchanging = False
        hinting = False
        showing_all_words = False
        selected_tiles = set()
        typing = False
        typing_start = None
        typing_direction = None
        current_r = None
        current_c = None
        last_left_click_time = 0
        last_left_click_pos = None
        hint_moves = []
        all_moves = []
        selected_hint_index = None
        scroll_offset = 0
        last_clicked_pos = None
        last_word = ""
        last_score = 0
        last_start = None
        last_direction = None
        human_played = False # Track if human made the last move (for AI trigger)
        dragged_tile = None # Tuple: (player_idx, tile_list_idx)
        drag_pos = None # Current mouse position during drag
        selected_square = None # Tuple: (row, col, direction) for typing start
        original_tiles = None # Used during typing to revert board state
        original_rack = None # Used during typing to revert rack state
        move_history = []  # Reset move history for a new game
        replay_mode = False
        current_replay_turn = 0
        previous_turn = 0 # Force move generation on first turn

        # Game over and dialog state variables
        game_over_state = False
        showing_stats = False
        dialog_x = (WINDOW_WIDTH - DIALOG_WIDTH) // 2 # Initial dialog position
        dialog_y = (WINDOW_HEIGHT - DIALOG_HEIGHT) // 2
        dragging = False # For dragging dialog
        drag_offset = (0, 0)
        final_scores = None
        reason = ""
        action = None
        scoreboard_height = WINDOW_HEIGHT - 80
        paused_for_power_tile = False
        current_power_tile = None # Track which power tile is paused for

        # --- Main Game Loop ---
        while running:
             # Ensure all_moves are generated at the start of a turn if needed
            if turn != previous_turn and not replay_mode and not game_over_state and not paused_for_power_tile:
                # Make sure racks[turn-1] exists and is valid before calling
                if racks and len(racks) > turn-1 and racks[turn-1] is not None:
                     # **** This is where the error occurred ****
                    print(f"Generating moves for Player {turn}. Rack: {''.join(racks[turn-1])}") # Debug
                    all_moves = generate_valid_moves(racks[turn-1], tiles, board, blanks)
                    if all_moves is None: # generate_valid_moves might return None on error? Ensure list.
                        all_moves = []
                    print(f"Generated {len(all_moves)} moves for player {turn}") # Debugging
                else:
                    print(f"Error: Invalid rack state for player {turn}. Racks: {racks}")
                    all_moves = [] # Prevent further errors
                previous_turn = turn
                human_played = False # Reset human played flag at start of turn


            # --- Event Handling Loop ---
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    running = False
                # --- Game Over Event Handling ---
                elif game_over_state:
                    if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
                        x, y = event.pos
                        # Check if clicking the draggable header (top 20 pixels)
                        if dialog_x <= x < dialog_x + DIALOG_WIDTH and dialog_y <= y < dialog_y + 20:
                            dragging = True
                            drag_offset = (x - dialog_x, y - dialog_y)
                        elif showing_stats:
                            # Need ok_button_rect defined from draw_stats_dialog
                            # Let's define it temporarily here, assuming draw_stats_dialog returns it
                            stats_dialog_width, stats_dialog_height = 400, 360
                            stats_dialog_actual_x = dialog_x + 20 # As passed to draw_stats_dialog
                            stats_dialog_actual_y = dialog_y + 20
                            temp_ok_rect = pygame.Rect(stats_dialog_actual_x + stats_dialog_width - BUTTON_WIDTH - 10,
                                                       stats_dialog_actual_y + stats_dialog_height - BUTTON_HEIGHT - 10,
                                                       BUTTON_WIDTH, BUTTON_HEIGHT)
                            if temp_ok_rect.collidepoint(x, y):
                                showing_stats = False  # Close the stats window
                        else:
                            # Need button rects defined from draw_game_over_dialog
                            temp_save_rect, temp_quit_rect, temp_replay_rect, temp_play_again_rect, temp_stats_rect = draw_game_over_dialog(dialog_x, dialog_y, final_scores if final_scores else [0,0], reason, player_names)

                            if temp_save_rect.collidepoint(x, y):
                                if final_scores: # Ensure scores exist before saving
                                    gcg_content = save_game_to_gcg(player_names, move_history, initial_racks, final_scores)
                                    try:
                                        with open("last_game.gcg", "w") as f:
                                            f.write(gcg_content)
                                        print("Game saved to last_game.gcg")
                                        # print("--- Saved GCG content ---")
                                        # print(gcg_content)
                                        # print("--- End of GCG content ---")
                                    except IOError as e:
                                        print(f"Error saving game: {e}")
                                else:
                                    print("Cannot save game: Final scores not calculated.")
                            elif temp_quit_rect.collidepoint(x, y):
                                running = False  # Exit the game loop
                            elif temp_replay_rect.collidepoint(x, y):
                                # Reset for replay
                                game_over_state = False
                                replay_mode = True
                                current_replay_turn = 0
                                practice_mode = None  # Disable practice mode during replay
                                paused_for_power_tile = False  # Reset power tile pause flag
                                showing_stats = False # Close stats if open
                            elif temp_play_again_rect.collidepoint(x, y):
                                running = False  # Exit inner loop to restart
                                return_to_mode_selection = True # Signal to restart main
                            elif temp_stats_rect.collidepoint(x, y):
                                showing_stats = True  # Open the stats window
                    elif event.type == pygame.MOUSEMOTION and dragging:
                        x, y = event.pos
                        dialog_x = x - drag_offset[0]
                        dialog_y = y - drag_offset[1]
                        # Constrain dialog within window bounds
                        dialog_x = max(0, min(dialog_x, WINDOW_WIDTH - DIALOG_WIDTH))
                        dialog_y = max(0, min(dialog_y, WINDOW_HEIGHT - DIALOG_HEIGHT))
                    elif event.type == pygame.MOUSEBUTTONUP and event.button == 1:
                        dragging = False
                    elif event.type == pygame.KEYDOWN:
                        if event.key == pygame.K_s:
                            if final_scores:
                                gcg_content = save_game_to_gcg(player_names, move_history, initial_racks, final_scores)
                                try:
                                    with open("last_game.gcg", "w") as f: f.write(gcg_content)
                                    print("Game saved to last_game.gcg")
                                except IOError as e: print(f"Error saving game: {e}")
                            else: print("Cannot save game: Final scores not calculated.")
                        elif event.key == pygame.K_q:
                            running = False
                        elif event.key == pygame.K_r:
                            game_over_state = False
                            replay_mode = True
                            current_replay_turn = 0
                            practice_mode = None
                            paused_for_power_tile = False
                            showing_stats = False
                        elif event.key == pygame.K_p:
                            running = False
                            return_to_mode_selection = True

                # --- Active Game / Replay Event Handling ---
                elif event.type == pygame.MOUSEBUTTONDOWN:
                    x, y = event.pos
                    current_time = pygame.time.get_ticks()

                    # --- Left Click Handling ---
                    if event.button == 1:
                        # Handle replay controls only when in replay mode
                        if replay_mode:
                            if replay_start_rect.collidepoint(x, y): current_replay_turn = 0
                            elif replay_prev_rect.collidepoint(x, y) and current_replay_turn > 0: current_replay_turn -= 1
                            elif replay_next_rect.collidepoint(x, y) and current_replay_turn < len(move_history): current_replay_turn += 1
                            elif replay_end_rect.collidepoint(x, y): current_replay_turn = len(move_history)
                            # Click elsewhere in replay mode does nothing else

                        # Handle active game clicks (if not in replay)
                        elif not replay_mode:
                            # Handle clicks on dialogs first if they are open
                            if exchanging:
                                # Need tile_rects, exchange_button_rect, cancel_button_rect defined
                                # Assume draw_exchange_dialog was called and returned them
                                clicked_in_dialog = False
                                if exchange_button_rect and exchange_button_rect.collidepoint(x, y) and selected_tiles and len(bag) >= len(selected_tiles):
                                    clicked_in_dialog = True
                                    move_rack = racks[turn-1][:] # Copy before modification
                                    tiles_to_exchange = [racks[turn-1][i] for i in sorted(selected_tiles, reverse=True)] # Get tiles before removing
                                    drawn_tiles = []
                                    # Remove selected tiles from rack
                                    temp_rack = []
                                    for i, tile in enumerate(racks[turn-1]):
                                         if i not in selected_tiles:
                                              temp_rack.append(tile)
                                    # Draw new tiles
                                    num_to_draw = len(tiles_to_exchange)
                                    drawn_tiles = [bag.pop() for _ in range(num_to_draw) if bag]
                                    temp_rack.extend(drawn_tiles)
                                    # temp_rack.sort() # Optional sort
                                    racks[turn-1] = temp_rack # Update actual rack

                                    # Add exchanged tiles back to bag
                                    bag.extend(tiles_to_exchange)
                                    random.shuffle(bag)

                                    consecutive_zero_point_turns += 1
                                    print(f"Player {turn} exchanged {len(tiles_to_exchange)} tiles")
                                    exchanging = False
                                    selected_tiles.clear()
                                    human_played = True # Human action taken
                                    exchange_count += 1
                                    pass_count = 0
                                    paused_for_power_tile = False # End pause on action
                                    # Record move
                                    move_history.append({
                                        'player': turn, # Player who initiated exchange
                                        'move_type': 'exchange',
                                        'rack': move_rack, # Rack before exchange
                                        'exchanged_tiles': tiles_to_exchange,
                                        'drawn': drawn_tiles,
                                        'score': 0, 'word': '', 'coord': '', 'blanks': set(), 'positions': [], 'is_bingo': False, 'word_with_blanks': ''
                                    })
                                    current_replay_turn = len(move_history)
                                    turn = 3 - turn # Switch turn

                                elif cancel_button_rect and cancel_button_rect.collidepoint(x, y):
                                    clicked_in_dialog = True
                                    exchanging = False
                                    selected_tiles.clear()
                                elif tile_rects: # Check tile clicks only if rects exist
                                    for i, rect in enumerate(tile_rects):
                                        if rect.collidepoint(x, y):
                                            clicked_in_dialog = True
                                            if i in selected_tiles: selected_tiles.remove(i)
                                            else: selected_tiles.add(i)
                                            break
                                # If click was inside dialog bounds but not on a button/tile, do nothing else
                                dialog_width, dialog_height = 400, 200
                                dialog_rect_exchange = pygame.Rect((WINDOW_WIDTH - dialog_width) // 2, (WINDOW_HEIGHT - dialog_height) // 2, dialog_width, dialog_height)
                                if dialog_rect_exchange.collidepoint(x,y) and not clicked_in_dialog:
                                     pass # Ignore click on dialog background

                            elif hinting:
                                # Need hint_rects, play_button_rect, ok_button_rect, all_words_button_rect
                                clicked_in_dialog = False
                                if play_button_rect and play_button_rect.collidepoint(x, y) and selected_hint_index is not None and selected_hint_index < len(hint_moves):
                                    clicked_in_dialog = True
                                    selected_move = hint_moves[selected_hint_index]
                                    move_rack = racks[turn-1][:] # Copy before play

                                    if paused_for_power_tile:
                                        # Validate if the selected move is the best power tile move
                                        power_moves_check = [m for m in all_moves if any(letter == current_power_tile for _, _, letter in m.get('newly_placed',[]))]
                                        max_power_score_check = max(m['score'] for m in power_moves_check) if power_moves_check else 0

                                        if selected_move['score'] >= max_power_score_check:
                                            # Play the move
                                            next_turn, drawn_tiles, newly_placed = play_hint_move(selected_move, tiles, racks, blanks, scores, turn, bag, board)
                                            human_played = True
                                            hinting = False
                                            paused_for_power_tile = False
                                            consecutive_zero_point_turns = 0 # Reset on valid play
                                            pass_count = 0
                                            exchange_count = 0
                                            # Record move
                                            move_history.append({
                                                'player': turn, 'move_type': 'place', 'rack': move_rack,
                                                'positions': selected_move.get('positions',[]), 'blanks': selected_move.get('blanks',set()),
                                                'score': selected_move.get('score',0), 'word': selected_move.get('word','N/A'),
                                                'drawn': drawn_tiles, 'coord': get_coord(selected_move.get('start',(0,0)), selected_move.get('direction','right')),
                                                'word_with_blanks': selected_move.get('word_with_blanks',''), 'is_bingo': selected_move.get('is_bingo',False)
                                            })
                                            current_replay_turn = len(move_history)
                                            turn = next_turn
                                        else:
                                            show_power_tile_dialog(f"This is not the highest scoring move with {current_power_tile}!")
                                            # Keep hinting dialog open
                                    else: # Normal hint play
                                        next_turn, drawn_tiles, newly_placed = play_hint_move(selected_move, tiles, racks, blanks, scores, turn, bag, board)
                                        human_played = True
                                        hinting = False
                                        paused_for_power_tile = False
                                        consecutive_zero_point_turns = 0
                                        pass_count = 0
                                        exchange_count = 0
                                        # Record move
                                        move_history.append({
                                            'player': turn, 'move_type': 'place', 'rack': move_rack,
                                            'positions': selected_move.get('positions',[]), 'blanks': selected_move.get('blanks',set()),
                                            'score': selected_move.get('score',0), 'word': selected_move.get('word','N/A'),
                                            'drawn': drawn_tiles, 'coord': get_coord(selected_move.get('start',(0,0)), selected_move.get('direction','right')),
                                            'word_with_blanks': selected_move.get('word_with_blanks',''), 'is_bingo': selected_move.get('is_bingo',False)
                                        })
                                        current_replay_turn = len(move_history)
                                        turn = next_turn

                                elif ok_button_rect and ok_button_rect.collidepoint(x, y):
                                    clicked_in_dialog = True
                                    hinting = False
                                elif all_words_button_rect and all_words_button_rect.collidepoint(x, y):
                                    clicked_in_dialog = True
                                    hinting = False
                                    showing_all_words = True
                                    selected_hint_index = 0 if all_moves else None # Reset selection for all words
                                    scroll_offset = 0
                                elif hint_rects:
                                    for i, rect in enumerate(hint_rects):
                                        if rect.collidepoint(x, y) and i < len(hint_moves):
                                            clicked_in_dialog = True
                                            selected_hint_index = i
                                            break
                                # Ignore click on dialog background
                                dialog_width, dialog_height = 400, 250
                                dialog_rect_hint = pygame.Rect((WINDOW_WIDTH - dialog_width) // 2, (WINDOW_HEIGHT - dialog_height) // 2, dialog_width, dialog_height)
                                if dialog_rect_hint.collidepoint(x,y) and not clicked_in_dialog:
                                     pass

                            elif showing_all_words:
                                # Need all_words_rects, all_words_play_rect, all_words_ok_rect
                                clicked_in_dialog = False
                                if all_words_play_rect and all_words_play_rect.collidepoint(x, y) and selected_hint_index is not None and selected_hint_index < len(all_moves):
                                    clicked_in_dialog = True
                                    selected_move = all_moves[selected_hint_index]
                                    move_rack = racks[turn-1][:] # Copy before play
                                    # Play the selected move (no special power tile logic here, assume user chose)
                                    next_turn, drawn_tiles, newly_placed = play_hint_move(selected_move, tiles, racks, blanks, scores, turn, bag, board)
                                    human_played = True
                                    showing_all_words = False
                                    paused_for_power_tile = False # End pause on action
                                    consecutive_zero_point_turns = 0
                                    pass_count = 0
                                    exchange_count = 0
                                    # Record move
                                    move_history.append({
                                        'player': turn, 'move_type': 'place', 'rack': move_rack,
                                        'positions': selected_move.get('positions',[]), 'blanks': selected_move.get('blanks',set()),
                                        'score': selected_move.get('score',0), 'word': selected_move.get('word','N/A'),
                                        'drawn': drawn_tiles, 'coord': get_coord(selected_move.get('start',(0,0)), selected_move.get('direction','right')),
                                        'word_with_blanks': selected_move.get('word_with_blanks',''), 'is_bingo': selected_move.get('is_bingo',False)
                                    })
                                    current_replay_turn = len(move_history)
                                    turn = next_turn

                                elif all_words_ok_rect and all_words_ok_rect.collidepoint(x, y):
                                    clicked_in_dialog = True
                                    showing_all_words = False
                                elif all_words_rects:
                                    for rect, idx in all_words_rects:
                                        if rect.collidepoint(x, y):
                                            clicked_in_dialog = True
                                            selected_hint_index = idx
                                            break
                                # Ignore click on dialog background
                                dialog_rect_all = pygame.Rect((WINDOW_WIDTH - ALL_WORDS_DIALOG_WIDTH) // 2, (WINDOW_HEIGHT - ALL_WORDS_DIALOG_HEIGHT) // 2, ALL_WORDS_DIALOG_WIDTH, ALL_WORDS_DIALOG_HEIGHT)
                                if dialog_rect_all.collidepoint(x,y) and not clicked_in_dialog:
                                     pass

                            # Handle clicks outside dialogs (board, rack, buttons)
                            # This block should only execute if no dialog handled the click
                            elif not (exchanging or hinting or showing_all_words):
                                # Options Menu
                                if options_rect.collidepoint(x, y):
                                    dropdown_open = not dropdown_open
                                elif dropdown_open:
                                    clicked_dropdown = False
                                    # dropdown_rects might contain None for disabled options
                                    for i, rect in enumerate(dropdown_rects):
                                        if rect and rect.collidepoint(x, y): # Check if rect is not None
                                            clicked_dropdown = True
                                            option_texts = ["Pass", "Exchange", "Main", "Quit"]
                                            selected_option = option_texts[i]

                                            if selected_option == "Pass":
                                                move_rack = racks[turn-1][:] # Copy before action
                                                consecutive_zero_point_turns += 1
                                                pass_count += 1
                                                exchange_count = 0
                                                print(f"Player {turn} passed")
                                                human_played = True
                                                paused_for_power_tile = False # End pause on action
                                                # Record move
                                                move_history.append({
                                                    'player': turn, 'move_type': 'pass', 'rack': move_rack,
                                                    'score': 0, 'word': '', 'coord': '', 'blanks': set(), 'positions': [], 'drawn': [], 'is_bingo': False, 'word_with_blanks': ''
                                                })
                                                current_replay_turn = len(move_history)
                                                turn = 3 - turn
                                            elif selected_option == "Exchange": # Already checked bag count in draw_options_menu
                                                exchanging = True
                                                selected_tiles.clear() # Clear selection for new exchange
                                            elif selected_option == "Main":
                                                return_to_mode_selection = True
                                                running = False # Exit current game loop
                                            elif selected_option == "Quit":
                                                if confirm_quit(): running = False
                                            dropdown_open = False # Close after selection
                                            break # Exit dropdown loop
                                    # If click was outside options, close dropdown
                                    if not clicked_dropdown:
                                         dropdown_open = False
                                # If click was outside options button and dropdown area, close dropdown
                                elif not options_rect.collidepoint(x,y):
                                     dropdown_open = False


                                # Suggest Button
                                # Ensure suggest_rect is defined (it might be None in replay)
                                if suggest_rect and suggest_rect.collidepoint(x, y) and (not is_ai[turn-1] or paused_for_power_tile):
                                    # Regenerate moves if needed (e.g., if rack changed)
                                    # all_moves should be up-to-date from start of turn or AI pause
                                    if paused_for_power_tile:
                                        # Filter for power tile moves for the hint dialog
                                        power_moves_hint = [m for m in all_moves if any(letter == current_power_tile for _, _, letter in m.get('newly_placed',[]))]
                                        hint_moves = sorted(power_moves_hint, key=lambda m: m['score'], reverse=True)[:5]
                                    else:
                                        hint_moves = all_moves[:5] # Top 5 normal moves
                                    hinting = True
                                    selected_hint_index = 0 if hint_moves else None

                                # Hint Button (only appears when paused)
                                # Ensure hint_rect is defined
                                elif hint_rect and hint_rect.collidepoint(x, y) and paused_for_power_tile:
                                     # Filter for power tile moves for the hint dialog
                                    power_moves_hint = [m for m in all_moves if any(letter == current_power_tile for _, _, letter in m.get('newly_placed',[]))]
                                    hint_moves = sorted(power_moves_hint, key=lambda m: m['score'], reverse=True)[:5]
                                    hinting = True
                                    selected_hint_index = 0 if hint_moves else None


                                # Rack Buttons (Alphabetize/Randomize)
                                # Need p1_alpha_rect etc. defined from draw_rack calls
                                current_player_idx = turn - 1
                                if not is_ai[current_player_idx] or paused_for_power_tile: # Only allow for human or paused AI
                                     if turn == 1:
                                          if p1_alpha_rect and p1_alpha_rect.collidepoint(x, y): racks[0].sort()
                                          elif p1_rand_rect and p1_rand_rect.collidepoint(x, y): random.shuffle(racks[0])
                                     elif turn == 2:
                                          # Ensure P2 buttons exist (not in 8-letter mode)
                                          if p2_alpha_rect and p2_alpha_rect.collidepoint(x, y): racks[1].sort()
                                          elif p2_rand_rect and p2_rand_rect.collidepoint(x, y): random.shuffle(racks[1])

                                # Rack Tile Drag Start
                                # Check if clicking on the current player's rack tiles
                                rack_y = BOARD_SIZE + 80 if turn == 1 else BOARD_SIZE + 150
                                # Recalculate rack_start_x based on current layout
                                rack_width_calc = 7 * (TILE_WIDTH + TILE_GAP) - TILE_GAP
                                rack_start_x_calc = max(OPTIONS_WIDTH + BUTTON_GAP + 10, (BOARD_SIZE - rack_width_calc) // 2)

                                if 0 <= current_player_idx < len(racks): # Check if rack exists
                                     rack_len = len(racks[current_player_idx])
                                     tile_idx = get_tile_under_mouse(x, y, rack_start_x_calc, rack_y, rack_len)
                                     if tile_idx is not None and not dragged_tile and (not is_ai[current_player_idx] or paused_for_power_tile):
                                         dragged_tile = (turn, tile_idx) # Store turn (1 or 2) and index
                                         drag_pos = (x, y)
                                         # Offset from tile top-left corner
                                         tile_abs_x = rack_start_x_calc + tile_idx * (TILE_WIDTH + TILE_GAP)
                                         drag_offset = (x - tile_abs_x, y - rack_y)


                                # Board Click (for typing start)
                                # Only if not dragging a tile and it's human turn or paused AI
                                if not dragged_tile and (not is_ai[turn-1] or paused_for_power_tile): # Use turn-1 for index
                                    col = (x - 40) // SQUARE_SIZE
                                    row = (y - 40) // SQUARE_SIZE
                                    if 0 <= row < GRID_SIZE and 0 <= col < GRID_SIZE and not tiles[row][col]: # Click on empty board square
                                        # Double-click logic
                                        is_double_click = (last_left_click_pos == (row, col) and current_time - last_left_click_time < DOUBLE_CLICK_TIME)

                                        if is_double_click:
                                            selected_square = None # Double-click deselects
                                            typing = False # Cancel typing if active
                                            # Restore board/rack if typing was cancelled
                                            if word_positions:
                                                 # Ensure original_tiles/rack exist before reverting
                                                 if original_tiles and original_rack:
                                                     for r_wp, c_wp, letter_wp in word_positions:
                                                          tiles[r_wp][c_wp] = original_tiles[r_wp][c_wp] # Revert board square
                                                     racks[turn-1] = original_rack[:] # Restore rack
                                                     # Remove blanks added during this typing attempt
                                                     blanks_to_remove = set((r_wp, c_wp) for r_wp, c_wp, _ in word_positions if (r_wp, c_wp) in blanks)
                                                     blanks.difference_update(blanks_to_remove)
                                                 word_positions = [] # Clear placed tiles
                                        elif selected_square is None or selected_square[:2] != (row, col):
                                            selected_square = (row, col, "right") # First click selects right
                                            typing = False # Ensure typing mode is off initially
                                            word_positions = [] # Clear any previous typing attempt
                                        elif selected_square[2] == "right":
                                            selected_square = (row, col, "down") # Second click selects down
                                        elif selected_square[2] == "down":
                                            selected_square = None # Third click deselects

                                        last_left_click_pos = (row, col)
                                        last_left_click_time = current_time
                                    else: # Click outside board or on occupied square
                                         selected_square = None # Deselect typing start
                                         # If typing was active, cancel it? Or allow finishing?
                                         # Let's not cancel typing on outside click, only Esc/Backspace/Enter/Right-click.


                    # --- Right Click Handling ---
                    elif event.button == 3:
                        selected_square = None # Deselect typing start/arrow
                        if typing:
                            # Cancel typing: Restore board and rack from original state
                            if original_tiles and original_rack:
                                for r_wp, c_wp, letter_wp in word_positions:
                                    tiles[r_wp][c_wp] = original_tiles[r_wp][c_wp] # Revert board
                                    # No need to manually return tiles, just restore the whole rack
                                racks[turn-1] = original_rack[:] # Restore rack
                                # Clear blanks added during this typing attempt
                                blanks_to_remove = set()
                                for r_b, c_b in blanks:
                                     is_from_this_typing = False
                                     for r_wp, c_wp, _ in word_positions:
                                          if r_b == r_wp and c_b == c_wp:
                                               is_from_this_typing = True
                                               break
                                     if is_from_this_typing:
                                          blanks_to_remove.add((r_b, c_b))
                                blanks.difference_update(blanks_to_remove)

                            typing = False
                            typing_start = None
                            typing_direction = None
                            word_positions = []
                            original_tiles = None
                            original_rack = None


                # --- Mouse Motion Handling ---
                elif event.type == pygame.MOUSEMOTION:
                    if dragged_tile and drag_pos: # Update position if dragging
                        drag_pos = event.pos
                    elif game_over_state and dragging: # Handle dialog drag
                        x, y = event.pos
                        dialog_x = x - drag_offset[0]
                        dialog_y = y - drag_offset[1]
                        dialog_x = max(0, min(dialog_x, WINDOW_WIDTH - DIALOG_WIDTH))
                        dialog_y = max(0, min(dialog_y, WINDOW_HEIGHT - DIALOG_HEIGHT))


                # --- Mouse Button Up Handling ---
                elif event.type == pygame.MOUSEBUTTONUP:
                    if event.button == 1: # Left button up
                        if game_over_state and dragging:
                             dragging = False # Stop dragging dialog
                        elif dragged_tile and (not is_ai[dragged_tile[0]-1] or paused_for_power_tile) and not replay_mode:
                            x, y = event.pos
                            player_idx = dragged_tile[0] - 1
                            rack_y = BOARD_SIZE + 80 if dragged_tile[0] == 1 else BOARD_SIZE + 150
                            # Recalculate rack_start_x
                            rack_width_calc = 7 * (TILE_WIDTH + TILE_GAP) - TILE_GAP
                            rack_start_x_calc = max(OPTIONS_WIDTH + BUTTON_GAP + 10, (BOARD_SIZE - rack_width_calc) // 2)

                            # Check if dropped back onto the rack area
                            rack_area_rect = pygame.Rect(rack_start_x_calc, rack_y, rack_width_calc, TILE_HEIGHT)
                            if rack_area_rect.collidepoint(x, y):
                                rack_len = len(racks[player_idx])
                                insert_idx = get_insertion_index(x, rack_start_x_calc, rack_len)
                                original_tile_idx = dragged_tile[1]

                                if 0 <= original_tile_idx < rack_len: # Check if original index is valid
                                    player_rack = racks[player_idx]
                                    tile_to_move = player_rack.pop(original_tile_idx)
                                    # Adjust insertion index if removing tile before it shifts indices
                                    if original_tile_idx < insert_idx:
                                        insert_idx -= 1
                                    # Clamp insert_idx to valid range [0, new_rack_len]
                                    insert_idx = max(0, min(insert_idx, len(player_rack)))
                                    player_rack.insert(insert_idx, tile_to_move)
                            # else: # Dropped somewhere else (e.g., board - handle placement?)
                                # For now, dropping outside rack just cancels drag
                            dragged_tile = None
                            drag_pos = None


                # --- Mouse Wheel Handling (Scrolling) ---
                elif event.type == pygame.MOUSEWHEEL:
                    mouse_x, mouse_y = pygame.mouse.get_pos()
                    # Scroll All Words dialog
                    if showing_all_words:
                         dialog_rect_all = pygame.Rect((WINDOW_WIDTH - ALL_WORDS_DIALOG_WIDTH) // 2, (WINDOW_HEIGHT - ALL_WORDS_DIALOG_HEIGHT) // 2, ALL_WORDS_DIALOG_WIDTH, ALL_WORDS_DIALOG_HEIGHT)
                         if dialog_rect_all.collidepoint(mouse_x, mouse_y):
                              scroll_offset -= event.y * SCROLL_SPEED
                              # Calculate max scroll based on content height
                              content_height = len(all_moves) * 30
                              header_height = 40
                              button_area_height = BUTTON_HEIGHT + 30
                              visible_content_height = ALL_WORDS_DIALOG_HEIGHT - header_height - button_area_height
                              max_scroll = max(0, content_height - visible_content_height)
                              scroll_offset = max(0, min(scroll_offset, max_scroll))
                    # Scroll Scoreboard
                    # Define scoreboard area rect
                    sb_x = BOARD_SIZE + 275
                    sb_y = 40
                    sb_w = max(200, WINDOW_WIDTH - BOARD_SIZE - 20)
                    sb_h = WINDOW_HEIGHT - 80
                    if sb_x + sb_w > WINDOW_WIDTH - 10: sb_w = WINDOW_WIDTH - sb_x - 10
                    if sb_w < 200: sb_x = WINDOW_WIDTH - 210; sb_w = 200
                    scoreboard_rect = pygame.Rect(sb_x, sb_y, sb_w, sb_h)

                    if scoreboard_rect.collidepoint(mouse_x, mouse_y):
                         # Determine which history to use for scroll calculation
                         history_len = current_replay_turn if replay_mode else len(move_history)
                         scroll_offset -= event.y * SCROLL_SPEED # Use same speed?
                         # Calculate max scroll
                         total_content_height = history_len * 20 # Each move takes ~20px height
                         if (game_over_state or (replay_mode and current_replay_turn == len(move_history))) and final_scores:
                              total_content_height += 40 # Add space for final score line
                         max_scroll = max(0, total_content_height - scoreboard_height)
                         scroll_offset = max(0, min(scroll_offset, max_scroll))


                # --- Keydown Handling (Typing) ---
                elif event.type == pygame.KEYDOWN and (not is_ai[turn-1] or paused_for_power_tile) and not replay_mode:
                    # Start typing if a letter is pressed while a square is selected
                    if selected_square and not typing and event.unicode.isalpha():
                        typing = True
                        original_tiles = [row[:] for row in tiles] # Snapshot board
                        original_rack = racks[turn-1][:]  # Snapshot rack
                        typing_start = selected_square[:2]
                        typing_direction = selected_square[2]
                        original_selected_square = selected_square # Save for potential cancel
                        selected_square = None # Hide arrow
                        word_positions = [] # Tiles placed in this typing sequence
                        current_r, current_c = typing_start

                        # Process the first letter typed
                        letter = event.unicode.upper()
                        if 0 <= current_r < GRID_SIZE and 0 <= current_c < GRID_SIZE and not tiles[current_r][current_c]:
                            placed = False
                            if letter in racks[turn-1]:
                                tiles[current_r][current_c] = letter
                                racks[turn-1].remove(letter)
                                word_positions.append((current_r, current_c, letter))
                                placed = True
                            elif ' ' in racks[turn-1]:
                                tiles[current_r][current_c] = letter
                                racks[turn-1].remove(' ')
                                blanks.add((current_r, current_c)) # Track blank placement
                                word_positions.append((current_r, current_c, letter))
                                placed = True

                            if placed:
                                # Move cursor to next logical empty square
                                if typing_direction == "right":
                                    current_c += 1
                                    while current_c < GRID_SIZE and tiles[current_r][current_c]: current_c += 1
                                elif typing_direction == "down":
                                    current_r += 1
                                    while current_r < GRID_SIZE and tiles[current_r][current_c]: current_r += 1
                                # If next position is off board, keep cursor at last valid pos? Or handle error?
                                current_r = min(current_r, GRID_SIZE - 1)
                                current_c = min(current_c, GRID_SIZE - 1)


                    # Handle keys during active typing
                    elif typing:
                        if event.key == pygame.K_RETURN or event.key == pygame.K_KP_ENTER:
                            if word_positions: # Only validate if tiles were placed
                                # Validate the play
                                valid, is_bingo = is_valid_play(word_positions, tiles, first_play, len(original_rack), original_tiles, original_rack) # Use original rack for validation context

                                if valid:
                                    # Calculate score using only the newly placed tiles
                                    score = calculate_score(word_positions, board, tiles, blanks)

                                    # Handle Power Tile Practice validation
                                    play_allowed = True
                                    if paused_for_power_tile:
                                        uses_power_tile = any(letter == current_power_tile for r_wp, c_wp, letter in word_positions if not original_tiles[r_wp][c_wp]) # Check placed tiles
                                        # Regenerate moves to find max score *with* the power tile
                                        power_moves_val = [m for m in all_moves if any(letter == current_power_tile for _, _, letter in m.get('newly_placed',[]))]
                                        max_power_score_val = max(m['score'] for m in power_moves_val) if power_moves_val else 0

                                        if not uses_power_tile:
                                             show_power_tile_dialog(f"Move must use the {current_power_tile} tile!")
                                             play_allowed = False
                                        elif score < max_power_score_val:
                                             show_power_tile_dialog(f"A higher scoring move exists with {current_power_tile} ({max_power_score_val} pts)!")
                                             play_allowed = False
                                        else: # Correct move found
                                             show_power_tile_dialog(f"Correct! You found the best move with {current_power_tile}.")
                                             paused_for_power_tile = False # Unpause

                                    if play_allowed:
                                        # Finalize play: update score, draw tiles, record history, switch turn
                                        scores[turn-1] += score
                                        first_play = False
                                        drawn_tiles = [bag.pop() for _ in range(len(word_positions)) if bag] # Draw for each tile placed
                                        racks[turn-1].extend(drawn_tiles) # Add drawn tiles to current rack state
                                        # racks[turn-1].sort() # Optional sort

                                        # Get full word and coordinate for history
                                        full_word_tiles_hist, _ = find_main_word(word_positions, tiles)
                                        full_word_hist = "".join(t[2] for t in full_word_tiles_hist) if full_word_tiles_hist else "ERROR"
                                        coord_hist = get_coord(typing_start, typing_direction) # Use original typing start/dir

                                        word_with_blanks_list_hist = []
                                        placed_pos_set_hist = set((p[0], p[1]) for p in word_positions)
                                        for wr, wc, w_letter in full_word_tiles_hist:
                                             is_blank_hist = (wr, wc) in placed_pos_set_hist and (wr, wc) in blanks
                                             word_with_blanks_list_hist.append(w_letter.lower() if is_blank_hist else w_letter.upper())
                                        word_with_blanks_hist = "".join(word_with_blanks_list_hist)


                                        move_history.append({
                                            'player': turn, 'move_type': 'place', 'rack': original_rack[:], # Rack before play
                                            'positions': [(p[0], p[1], p[2]) for p in word_positions], # Use only placed tiles for positions list
                                            'blanks': blanks.copy() & set((p[0], p[1]) for p in word_positions), # Blanks used in this move
                                            'score': score, 'word': full_word_hist, 'drawn': drawn_tiles,
                                            'coord': coord_hist, 'word_with_blanks': word_with_blanks_hist, 'is_bingo': is_bingo
                                        })
                                        current_replay_turn = len(move_history)

                                        print(f"Player {turn} played: {full_word_hist} at {coord_hist} for {score} points")
                                        consecutive_zero_point_turns = 0
                                        pass_count = 0
                                        exchange_count = 0
                                        human_played = True
                                        turn = 3 - turn # Switch turn

                                        # Reset typing state
                                        typing = False
                                        typing_start = None
                                        typing_direction = None
                                        word_positions = []
                                        original_tiles = None
                                        original_rack = None

                                    else: # Play not allowed (power tile practice fail)
                                         # Revert board and rack
                                         if original_tiles and original_rack:
                                             for r_wp, c_wp, letter_wp in word_positions: tiles[r_wp][c_wp] = original_tiles[r_wp][c_wp]
                                             racks[turn-1] = original_rack[:]
                                             blanks_to_remove = set((r_wp, c_wp) for r_wp, c_wp, _ in word_positions if (r_wp, c_wp) in blanks)
                                             blanks.difference_update(blanks_to_remove)
                                         # Keep typing active? Or reset? Resetting seems safer.
                                         typing = False
                                         typing_start = None
                                         typing_direction = None
                                         word_positions = []
                                         original_tiles = None
                                         original_rack = None
                                         selected_square = original_selected_square # Restore arrow


                                else: # Invalid play
                                    print(f"Invalid play.")
                                    # Revert board and rack
                                    if original_tiles and original_rack:
                                        for r_wp, c_wp, letter_wp in word_positions: tiles[r_wp][c_wp] = original_tiles[r_wp][c_wp]
                                        racks[turn-1] = original_rack[:]
                                        blanks_to_remove = set((r_wp, c_wp) for r_wp, c_wp, _ in word_positions if (r_wp, c_wp) in blanks)
                                        blanks.difference_update(blanks_to_remove)
                                    # Reset typing state and restore arrow
                                    typing = False
                                    typing_start = None
                                    typing_direction = None
                                    word_positions = []
                                    original_tiles = None
                                    original_rack = None
                                    selected_square = original_selected_square # Restore arrow

                            else: # Enter pressed with no tiles typed
                                 typing = False # Just exit typing mode
                                 selected_square = original_selected_square # Restore arrow


                        elif event.key == pygame.K_BACKSPACE:
                            if word_positions: # If there are tiles to remove
                                r_rem, c_rem, letter_rem = word_positions.pop() # Get last placed tile
                                tiles[r_rem][c_rem] = '' # Clear board square
                                # Return tile to rack
                                if (r_rem, c_rem) in blanks:
                                    blanks.remove((r_rem, c_rem))
                                    racks[turn-1].append(' ')
                                else:
                                    racks[turn-1].append(letter_rem)
                                # Move cursor back to the removed tile's position
                                current_r, current_c = r_rem, c_rem
                            else: # Backspace pressed with no tiles placed yet
                                typing = False # Cancel typing
                                selected_square = original_selected_square # Restore arrow
                                original_tiles = None
                                original_rack = None

                        elif event.key == pygame.K_ESCAPE:
                             # Cancel typing: Restore board and rack
                             if original_tiles and original_rack:
                                 for r_wp, c_wp, letter_wp in word_positions: tiles[r_wp][c_wp] = original_tiles[r_wp][c_wp]
                                 racks[turn-1] = original_rack[:]
                                 blanks_to_remove = set((r_wp, c_wp) for r_wp, c_wp, _ in word_positions if (r_wp, c_wp) in blanks)
                                 blanks.difference_update(blanks_to_remove)
                             typing = False
                             typing_start = None
                             typing_direction = None
                             word_positions = []
                             original_tiles = None
                             original_rack = None
                             selected_square = original_selected_square # Restore arrow


                        elif event.unicode.isalpha(): # Place next letter
                            letter = event.unicode.upper()
                            # Check if current cursor position is valid and empty
                            if 0 <= current_r < GRID_SIZE and 0 <= current_c < GRID_SIZE and not tiles[current_r][current_c]:
                                placed = False
                                if letter in racks[turn-1]:
                                    tiles[current_r][current_c] = letter
                                    racks[turn-1].remove(letter)
                                    word_positions.append((current_r, current_c, letter))
                                    placed = True
                                elif ' ' in racks[turn-1]:
                                    tiles[current_r][current_c] = letter
                                    racks[turn-1].remove(' ')
                                    blanks.add((current_r, current_c))
                                    word_positions.append((current_r, current_c, letter))
                                    placed = True

                                if placed:
                                    # Move cursor
                                    if typing_direction == "right":
                                        current_c += 1
                                        while current_c < GRID_SIZE and tiles[current_r][current_c]: current_c += 1
                                    elif typing_direction == "down":
                                        current_r += 1
                                        while current_r < GRID_SIZE and tiles[current_r][current_c]: current_r += 1
                                    current_r = min(current_r, GRID_SIZE - 1)
                                    current_c = min(current_c, GRID_SIZE - 1)
                            else:
                                 print("Cannot type here (occupied or off-board).")


            # --- AI Turn Logic ---
            # Trigger AI turn if it's AI's turn, not in replay, not game over, not paused, and human didn't just play
            if not game_over_state and not replay_mode and not paused_for_power_tile and is_ai[turn-1] and not human_played:
                 print(f"Triggering AI turn for Player {turn}")
                 # Call ai_turn and unpack all returned values
                 ai_result = ai_turn(
                    turn, racks, tiles, board, blanks, scores, bag, first_play, pass_count, exchange_count, consecutive_zero_point_turns, player_names,
                    dropdown_open, hinting, showing_all_words, letter_checks # Pass letter_checks here
                 )
                 # Ensure ai_result has the expected number of elements before unpacking
                 if len(ai_result) == 11:
                      turn, first_play, pass_count, exchange_count, consecutive_zero_point_turns, all_moves, dropdown_open, hinting, showing_all_words, paused_for_power_tile, current_power_tile = ai_result
                      # AI turn might change 'paused_for_power_tile' or 'current_power_tile'
                 else:
                      print(f"Error: AI turn returned unexpected number of values: {len(ai_result)}")
                      # Handle error state, maybe stop the game or skip AI turn?


            # --- Game Over Check ---
            if not replay_mode and not game_over_state: # Only check during active play
                game_ended = False
                # Condition 1: Bag empty and one player has no tiles
                if not bag and (not racks[0] or not racks[1]):
                    game_ended = True
                    reason = "Bag empty & rack empty"
                # Condition 2: Six consecutive zero-point turns (3 passes/exchanges by each player)
                elif consecutive_zero_point_turns >= 6:
                    game_ended = True
                    reason = "Six Consecutive Zero-Point Turns"

                if game_ended:
                    if not game_over_state: # Set reason only once
                         print(f"Game over check: Bag={len(bag)}, Racks={len(racks[0])},{len(racks[1])}, Zeros={consecutive_zero_point_turns}")
                         print(f"Game over triggered: {reason}")

                         # --- Final Score Calculation ---
                         rack_values = [sum(TILE_DISTRIBUTION[tile][1] for tile in rack if tile != ' ') for rack in racks] # Blanks have 0 value
                         final_scores = list(scores) # Start with current scores

                         p1_out = not racks[0] and not bag
                         p2_out = not racks[1] and not bag

                         if p1_out: # Player 1 went out
                             final_scores[0] += rack_values[1] # Add Player 2's remaining points to Player 1
                             final_scores[1] -= rack_values[1] # Subtract Player 2's remaining points
                         elif p2_out: # Player 2 went out
                             final_scores[1] += rack_values[0] # Add Player 1's remaining points to Player 2
                             final_scores[0] -= rack_values[0] # Subtract Player 1's remaining points
                         else: # Game ended due to passes/no moves with tiles left
                             final_scores[0] -= rack_values[0] # Both players lose points for remaining tiles
                             final_scores[1] -= rack_values[1]

                         game_over_state = True
                         # Reset other dialog flags
                         exchanging = False
                         hinting = False
                         showing_all_words = False
                         dropdown_open = False
                         dialog_x = (WINDOW_WIDTH - DIALOG_WIDTH) // 2 # Recenter dialog
                         dialog_y = (WINDOW_HEIGHT - DIALOG_HEIGHT) // 2

            # --- Drawing Logic ---
            screen.fill(WHITE)

            # Determine display state based on replay mode or active game
            if replay_mode:
                 # Ensure current_replay_turn is valid
                if 0 <= current_replay_turn <= len(move_history):
                    # Get state *after* the move at current_replay_turn - 1
                    tiles_to_display, blanks_to_display, scores_to_display, racks_to_display = get_replay_state(current_replay_turn, initial_racks)
                    # Determine whose turn it *is* now (after the displayed move)
                    if current_replay_turn == 0:
                        turn_to_display = 1
                    else:
                        # The player who made the last move was move_history[current_replay_turn - 1]['player']
                        # So the next turn belongs to the other player
                        turn_to_display = 3 - move_history[current_replay_turn - 1]['player']
                else:
                    # Handle invalid replay turn index (e.g., reset or show initial state)
                    tiles_to_display, blanks_to_display, scores_to_display, racks_to_display = get_replay_state(0, initial_racks)
                    turn_to_display = 1

            else: # Active game or game over state
                tiles_to_display, blanks_to_display, racks_to_display = tiles, blanks, racks
                scores_to_display = final_scores if game_over_state else scores # Show final scores if game over
                turn_to_display = turn # Show current player's turn

            # Draw Board
            for r in range(GRID_SIZE):
                for c in range(GRID_SIZE):
                    # Base square color
                    pygame.draw.rect(screen, board[r][c], (40 + c * SQUARE_SIZE, 40 + r * SQUARE_SIZE, SQUARE_SIZE, SQUARE_SIZE))
                    # Black border
                    pygame.draw.rect(screen, BLACK, (40 + c * SQUARE_SIZE, 40 + r * SQUARE_SIZE, SQUARE_SIZE, SQUARE_SIZE), 1)
                    # Draw tile if present
                    if tiles_to_display[r][c]:
                        tile_char = tiles_to_display[r][c]
                        is_blank_on_board = (r, c) in blanks_to_display

                        if is_blank_on_board:
                            # Draw blank tile representation (black circle with letter)
                            center = (40 + c * SQUARE_SIZE + SQUARE_SIZE // 2, 40 + r * SQUARE_SIZE + SQUARE_SIZE // 2)
                            radius = SQUARE_SIZE // 2 - 3 # Slightly smaller radius
                            pygame.draw.circle(screen, BLACK, center, radius)
                            text_surf = font.render(tile_char, True, WHITE) # White letter on black circle
                            text_rect = text_surf.get_rect(center=center)
                            screen.blit(text_surf, text_rect)
                        else:
                            # Draw regular tile representation (green square with letter)
                            tile_rect = pygame.Rect(40 + c * SQUARE_SIZE + 2, 40 + r * SQUARE_SIZE + 2, SQUARE_SIZE - 4, SQUARE_SIZE - 4)
                            pygame.draw.rect(screen, GREEN, tile_rect)
                            text_surf = font.render(tile_char, True, BLACK) # Black letter on green square
                            # Center the text within the green square
                            text_rect = text_surf.get_rect(center=tile_rect.center)
                            screen.blit(text_surf, text_rect)


            # Highlight last move in replay
            if replay_mode and current_replay_turn > 0:
                 last_move_data = move_history[current_replay_turn - 1]
                 if last_move_data['move_type'] == 'place' and 'positions' in last_move_data:
                    # Highlight only the *newly placed* tiles for clarity
                    original_replay_tiles, _, _, _ = get_replay_state(current_replay_turn - 1, initial_racks)
                    last_positions = set((r, c) for r, c, _ in last_move_data['positions'])
                    for r, c in last_positions:
                        # Check if the tile was actually placed in this move (not existing before)
                        if not original_replay_tiles[r][c]:
                             pygame.draw.rect(screen, YELLOW, (40 + c * SQUARE_SIZE, 40 + r * SQUARE_SIZE, SQUARE_SIZE, SQUARE_SIZE), 3) # Thick yellow border


            # Draw Row/Column Labels
            for r in range(GRID_SIZE):
                row_label = ui_font.render(str(r + 1), True, BLACK)
                screen.blit(row_label, (10, 40 + r * SQUARE_SIZE + (SQUARE_SIZE // 2 - row_label.get_height() // 2))) # Center vertically
            for c in range(GRID_SIZE):
                col_label = ui_font.render(LETTERS[c], True, BLACK)
                screen.blit(col_label, (40 + c * SQUARE_SIZE + (SQUARE_SIZE // 2 - col_label.get_width() // 2), 10)) # Center horizontally


            # Draw Racks, Scores, Buttons
            rack_width = 7 * (TILE_WIDTH + TILE_GAP) - TILE_GAP
            # Adjust rack_start_x calculation if needed based on your layout
            rack_start_x = max(OPTIONS_WIDTH + BUTTON_GAP + 10, (BOARD_SIZE - rack_width) // 2) # Ensure space for options

            # Draw Player 1 rack (always visible)
            # Ensure racks_to_display has enough elements
            p1_rack_to_draw = racks_to_display[0] if len(racks_to_display) > 0 else []
            p1_alpha_rect, p1_rand_rect = draw_rack(1, p1_rack_to_draw, scores_to_display, turn_to_display, player_names, dragged_tile if dragged_tile and dragged_tile[0] == 1 else None, drag_pos)

            # Draw Player 2 rack (conditionally)
            p2_alpha_rect, p2_rand_rect = None, None # Default to None
            if practice_mode != "eight_letter":
                 p2_rack_to_draw = racks_to_display[1] if len(racks_to_display) > 1 else []
                 p2_alpha_rect, p2_rand_rect = draw_rack(2, p2_rack_to_draw, scores_to_display, turn_to_display, player_names, dragged_tile if dragged_tile and dragged_tile[0] == 2 else None, drag_pos)


            # Draw Remaining Tiles List
            # Make sure to handle potential errors if racks_to_display is incomplete
            current_player_index = turn_to_display - 1
            if 0 <= current_player_index < len(racks_to_display):
                 remaining = get_remaining_tiles(racks_to_display[current_player_index], tiles_to_display, blanks_to_display)
                 draw_remaining_tiles(remaining, turn_to_display)
            else:
                 # Handle error case - maybe draw empty list or default
                 draw_remaining_tiles({}, turn_to_display)


            # Draw UI Buttons (Options, Suggest, Hint)
            options_rect, dropdown_rects = draw_options_menu(turn_to_display, dropdown_open, len(bag)) # Use turn_to_display
            suggest_rect = None # Initialize
            hint_rect = None # Initialize
            if not replay_mode: # Only show Suggest/Hint in active game
                 suggest_rect = draw_suggest_button()
                 # Show Hint button only if paused for power tile practice
                 if paused_for_power_tile and suggest_rect:
                     hint_x = suggest_rect.x
                     hint_y = suggest_rect.y + suggest_rect.height + BUTTON_GAP
                     hint_rect = pygame.Rect(hint_x, hint_y, OPTIONS_WIDTH, OPTIONS_HEIGHT)
                     hover = hint_rect.collidepoint(pygame.mouse.get_pos())
                     color = BUTTON_HOVER if hover else BUTTON_COLOR
                     pygame.draw.rect(screen, color, hint_rect)
                     hint_text = button_font.render("Hint", True, BLACK)
                     hint_text_rect = hint_text.get_rect(center=hint_rect.center)
                     screen.blit(hint_text, hint_text_rect)


            # Draw Scoreboard
            # Pass the correct move history slice for replay mode
            history_to_draw = move_history[:current_replay_turn] if replay_mode else move_history
            # Indicate game over status correctly for final score display
            is_final_turn_in_replay = replay_mode and current_replay_turn == len(move_history)
            draw_scoreboard(screen, history_to_draw, scroll_offset, scores_to_display, is_ai, final_scores=final_scores, game_over_state=game_over_state or is_final_turn_in_replay)


            # Draw Arrow for selected square (if typing start selected)
            if selected_square and not typing:
                draw_arrow(selected_square[0], selected_square[1], selected_square[2])
            # Draw cursor for active typing
            elif typing:
                 # Draw a blinking cursor or indicator at current_r, current_c
                 cursor_x = 40 + current_c * SQUARE_SIZE + SQUARE_SIZE // 2
                 cursor_y = 40 + current_r * SQUARE_SIZE + SQUARE_SIZE - 5 # Near bottom of square
                 # Simple blinking line cursor
                 if int(time.time() * 2) % 2 == 0: # Blink roughly every half second
                      pygame.draw.line(screen, BLACK, (cursor_x - 5, cursor_y), (cursor_x + 5, cursor_y), 2)


            # Draw Dialogs (Exchange, Hint, All Words) if active
            if exchanging:
                # Ensure racks[turn-1] is valid before drawing
                if 0 <= turn-1 < len(racks):
                    tile_rects, exchange_button_rect, cancel_button_rect = draw_exchange_dialog(racks[turn-1], selected_tiles)
            elif hinting:
                # Pass hint_moves which should be populated when hinting becomes True
                hint_rects, play_button_rect, ok_button_rect, all_words_button_rect = draw_hint_dialog(hint_moves, selected_hint_index)
            elif showing_all_words:
                 # Pass all_moves which should be populated before showing_all_words becomes True
                all_words_rects, all_words_play_rect, all_words_ok_rect = draw_all_words_dialog(all_moves, selected_hint_index, scroll_offset)


            # Draw Replay Buttons (only in replay mode)
            if replay_mode:
                # Icons seem reversed: Start should be <<, Prev <, Next >, End >>
                # Let's map icon type to button rect correctly
                replay_controls = [
                    (replay_start_rect, "start"), # << (Go to beginning)
                    (replay_prev_rect, "prev"),   # < (Previous move)
                    (replay_next_rect, "next"),   # > (Next move)
                    (replay_end_rect, "end")      # >> (Go to end)
                ]
                for rect, icon_type in replay_controls:
                    hover = rect.collidepoint(pygame.mouse.get_pos())
                    color = BUTTON_HOVER if hover else BUTTON_COLOR
                    pygame.draw.rect(screen, color, rect)
                    draw_replay_icon(screen, rect, icon_type) # draw_replay_icon handles drawing based on type


            # Draw Game Over Dialog / Stats Dialog
            if game_over_state:
                # Ensure final_scores is not None before drawing
                if final_scores is not None:
                    save_rect, quit_rect, replay_rect, play_again_rect, stats_rect = draw_game_over_dialog(dialog_x, dialog_y, final_scores, reason, player_names)
                    if showing_stats:
                         # Pass tiles_to_display for context if needed by stats, or maybe just use final board state 'tiles'
                        ok_button_rect = draw_stats_dialog(dialog_x + 20, dialog_y + 20, player_names, final_scores, tiles)
                else:
                    print("Error: Game over state but final_scores is None.") # Debugging


            # Update Display
            pygame.display.flip()


        # --- End of Game Loop ---
        # Handle return to mode selection or quit
        if return_to_mode_selection:
             main_called = False # Reset flag to allow re-entry
             main() # Call main again to show mode selection
        else:
             pygame.quit()
             sys.exit()

    # else: # This else corresponds to 'if not main_called:'
        # If main was already called, maybe just exit or log an error
        # print("main() called recursively or unexpectedly. Exiting.")
        # pygame.quit()
        # sys.exit()


if __name__ == "__main__":
    # Initialize Pygame here if not already done (it is at the top)
    # pygame.init()
    main_called = False # Ensure main_called is False before the first call
    main()

# End of Part 7

