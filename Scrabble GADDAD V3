

# python
#Stable 13APR24

# Part 1


import pygame
import random
import math
import sys
import time
import pickle
import os
from itertools import permutations, product
from collections import Counter

# --- GADDAG Node Definition (Add this to Scrabble Game.py) ---
class GaddagNode:
    """Represents a node in the GADDAG."""
    __slots__ = ['children', 'is_terminal'] # Memory optimization

    def __init__(self):
        self.children = {}  # Dictionary mapping letter -> GaddagNode
        self.is_terminal = False # True if a path ending here is a valid word/subword

# --- GADDAG Class Definition (Add this to Scrabble Game.py) ---
class Gaddag:
    """
    Represents the GADDAG data structure.
    This class definition is needed to correctly unpickle the object.
    The actual building happens in gaddag_builder.py.
    """
    SEPARATOR = '>' # Special character used in GADDAG paths

    def __init__(self):
        # The root node will be populated when loading from pickle
        self.root = GaddagNode()

    # No insert method needed here, as we load a pre-built structure.

# Initialize Pygame
pygame.init()
main_called = False # Flag to track if main() has been entered

# Constants
GADDAG_STRUCTURE = None
GRID_SIZE = 15
SQUARE_SIZE = 40
BOARD_SIZE = GRID_SIZE * SQUARE_SIZE
FONT_SIZE = SQUARE_SIZE // 2
TILE_WIDTH = 35
TILE_HEIGHT = 35
TILE_GAP = 5
BUTTON_WIDTH = 100
BUTTON_HEIGHT = 30
BUTTON_GAP = 10
CENTER_SQUARE = (7, 7)
OPTIONS_WIDTH = 100
OPTIONS_HEIGHT = 30
DROPDOWN_HEIGHT = 90
OPTIONS_Y = BOARD_SIZE + 60  # Adjusted from +40 to align with shifted UI
DOUBLE_CLICK_TIME = 300
SECOND_CLICK_TIME = 500  # Time window for second click
ALL_WORDS_DIALOG_WIDTH = 750
ALL_WORDS_DIALOG_HEIGHT = 600
SCROLL_SPEED = 20

# Dialog dimensions for game over dialog
DIALOG_WIDTH = 480
DIALOG_HEIGHT = 250
LETTERS = "ABCDEFGHIJKLMNO"  # For column labels

# Get screen resolution
display_info = pygame.display.Info()
# Set window size to fit within screen resolution (with padding for borders)
WINDOW_WIDTH = min(1400, display_info.current_w - 50)  # 50 pixels padding
WINDOW_HEIGHT = min(900, display_info.current_h - 50)  # 50 pixels padding

# Colors
WHITE = (255, 255, 255)
BLACK = (0, 0, 0)
RED = (255, 100, 100)
PINK = (255, 182, 193)
BLUE = (0, 102, 204)  # Darkened from (173, 216, 230) for TL
LIGHT_BLUE = (135, 206, 250)
HIGHLIGHT_BLUE = (191, 238, 255)
YELLOW = (255, 255, 153)
GRAY = (200, 200, 200)
GREEN = (144, 238, 144)
DARK_GREEN = (100, 200, 100)
BUTTON_COLOR = (180, 180, 180)
BUTTON_HOVER = (220, 220, 220)
TURN_INDICATOR_COLOR = (255, 215, 0)
DIALOG_COLOR = (150, 150, 150)
DROPDOWN_COLOR = (200, 200, 200)
SELECTED_TILE_COLOR = (255, 165, 0)
GRAYED_OUT_COLOR = (100, 100, 100)
ARROW_COLOR = (0, 0, 255)
HINT_NORMAL_COLOR = (220, 220, 220)
HINT_SELECTED_COLOR = (180, 180, 255)

# Setup display and font
screen = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))
pygame.display.set_caption("Scrabble Game")
font = pygame.font.SysFont("Arial", FONT_SIZE, bold=True)
ui_font = pygame.font.SysFont("Arial", 20)
button_font = pygame.font.SysFont("Arial", 16)
tile_count_font = pygame.font.SysFont("Arial", 14)
dialog_font = pygame.font.SysFont("Arial", 24)

# Tile bag and values (moved up to be defined before trie)
TILE_DISTRIBUTION = {
    'A': (9, 1), 'B': (2, 3), 'C': (2, 3), 'D': (4, 2), 'E': (12, 1), 'F': (2, 4),
    'G': (3, 2), 'H': (2, 4), 'I': (9, 1), 'J': (1, 8), 'K': (1, 5), 'L': (4, 1),
    'M': (2, 3), 'N': (6, 1), 'O': (8, 1), 'P': (2, 3), 'Q': (1, 10), 'R': (6, 1),
    'S': (4, 1), 'T': (6, 1), 'U': (4, 1), 'V': (2, 4), 'W': (2, 4), 'X': (1, 8),
    'Y': (2, 4), 'Z': (1, 10), ' ': (2, 0)
}
# Global bag - initialized properly in main() or practice setup
bag = []

POWER_TILES = {'J', 'Q', 'X', 'Z'}

# Global game state variables (will be initialized/reset in main)
board = None
tiles = None
racks = None
blanks = None
scores = None
turn = 1
first_play = True
game_mode = None
is_ai = None
practice_mode = None # Added to track practice modes like "eight_letter", "power_tiles"
move_history = []
replay_mode = False
current_replay_turn = 0
last_word = ""
last_score = 0
last_start = None
last_direction = None

def draw_checkbox(screen, x, y, checked):
    pygame.draw.rect(screen, BLACK, (x, y, 20, 20), 1)
    if checked:
        pygame.draw.line(screen, BLACK, (x+2, y+2), (x+18, y+18), 2)
        pygame.draw.line(screen, BLACK, (x+18, y+2), (x+2, y+18), 2)


# --- GCG Handling ---
def save_game_to_gcg(player_names, move_history, initial_racks, final_scores):
    """Save the game to GCG format using move_history directly."""
    gcg_lines = [
        "#",
        f"#player1 {player_names[0]}",
        f"#player2 {player_names[1]}"
    ]
    cumulative_scores = [0, 0]

    for move in move_history:
        player = move['player'] - 1  # 0-based index
        rack = ''.join(sorted(tile if tile != ' ' else '?' for tile in move['rack']))

        if move['move_type'] == 'place':
            # Use the stored full word with blanks
            word_with_blanks = move.get('word_with_blanks', move.get('word','').upper()) # Use getter for safety
            score = move['score']
            cumulative_scores[player] += score
            gcg_lines.append(
                f">{player_names[player]}: {rack} {move['coord']} {word_with_blanks} +{score} {cumulative_scores[player]}"
            )
        elif move['move_type'] == 'exchange':
            exchanged = ''.join(sorted(tile if tile != ' ' else '?' for tile in move.get('exchanged_tiles',[]))) # Use getter
            gcg_lines.append(
                f">{player_names[player]}: {rack} ({exchanged}) +0 {cumulative_scores[player]}"
            )
        elif move['move_type'] == 'pass':
            gcg_lines.append(
                f">{player_names[player]}: {rack} -- +0 {cumulative_scores[player]}"
            )

    gcg_lines.append(f"Final score: {player_names[0]} {final_scores[0]}, {player_names[1]} {final_scores[1]}")

    return '\n'.join(gcg_lines)

def load_game_from_gcg(filename):
    """Load a game from a GCG file, returning data to enter replay mode."""
    move_history = []
    player_names = ["Player1", "Player2"]
    final_scores = [0, 0]

    with open(filename, "r") as f:
        for line in f:
            line = line.strip()
            if line.startswith("#player1"):
                player_names[0] = line.split()[1]
            elif line.startswith("#player2"):
                player_names[1] = line.split()[1]
            elif line.startswith("Final score:"):
                parts = line.split()
                final_scores[0] = int(parts[2].strip(','))
                final_scores[1] = int(parts[4])
            elif line.startswith(">"):
                parts = line.split()
                player_name = parts[0][1:-1]  # Remove > and :
                player = 1 if player_name == player_names[0] else 2
                rack = parts[1]
                move_details = parts[2]
                score = int(parts[3][1:])
                cumulative_score = int(parts[4])

                if move_details == "--":
                    move_history.append({
                        'player': player,
                        'move_type': 'pass',
                        'score': score,
                        'word': '',
                        'coord': ''
                    })
                elif move_details.startswith("("):
                    exchanged = move_details[1:-1]
                    move_history.append({
                        'player': player,
                        'move_type': 'exchange',
                        'exchanged_tiles': list(exchanged),
                        'score': score,
                        'word': '',
                        'coord': ''
                    })
                else:
                    position = parts[2]
                    word = parts[3]
                    if position[0].isalpha():  # Vertical: e.g., H8
                        col = LETTERS.index(position[0])
                        row = int(position[1:]) - 1
                        direction = "down"
                    else:  # Horizontal: e.g., 8H
                        row = int(position[0]) - 1
                        col = LETTERS.index(position[1])
                        direction = "right"
                    positions = []
                    blanks = set()
                    for i, letter in enumerate(word):
                        r = row if direction == "right" else row + i
                        c = col + i if direction == "right" else col
                        positions.append((r, c, letter))
                        if letter.islower():  # GCG uses lowercase for blanks
                            blanks.add((r, c))
                    move_history.append({
                        'player': player,
                        'move_type': 'place',
                        'positions': positions,
                        'blanks': blanks,
                        'score': score,
                        'word': word.upper(),
                        'start': (row, col),
                        'direction': direction,
                        'coord': position
                    })

    return player_names, move_history, final_scores


# --- Trie/DAWG Setup ---
class TrieNode: # Keeping simple Trie for now, can replace with minimized DAWG later
    def __init__(self):
        self.children = {}
        self.is_end = False

class Dawg: # Renaming our existing Trie to Dawg for conceptual clarity
    def __init__(self):
        self.root = TrieNode()

    def insert(self, word):
        node = self.root
        for char in word:
            if char not in node.children:
                node.children[char] = TrieNode()
            node = node.children[char]
        node.is_end = True

    def search(self, word):
        """Check if a word exists in the DAWG."""
        node = self.root
        for char in word:
            if char not in node.children:
                return False
            node = node.children[char]
        return node.is_end

# Load the DAWG with words from "All Words 2023.txt"
DAWG = Dawg()
try:
    # Ensure the path is correct or adjust as needed
    with open("All Words 2023.txt", "r") as f:
        for word in (w.strip().upper() for w in f):
            if len(word) > 1: # Optionally filter out single-letter words if not needed
                DAWG.insert(word)
    print("DAWG loaded successfully.")
except FileNotFoundError:
    print("Error: 'All Words 2023.txt' not found. Word validation will not work.")


# --- Mode Selection Constants ---
MODE_HVH = "Human vs Human"
MODE_HVA = "Human vs AI"
MODE_AVA = "AI vs AI"

# --- Replay Button Positions ---
REPLAY_BUTTON_Y = OPTIONS_Y + OPTIONS_HEIGHT + 10
REPLAY_BUTTON_WIDTH = 50
REPLAY_BUTTON_HEIGHT = 30
REPLAY_BUTTON_GAP = 10
replay_start_rect = pygame.Rect(10, REPLAY_BUTTON_Y, REPLAY_BUTTON_WIDTH, REPLAY_BUTTON_HEIGHT)
replay_prev_rect = pygame.Rect(10 + REPLAY_BUTTON_WIDTH + REPLAY_BUTTON_GAP, REPLAY_BUTTON_Y, REPLAY_BUTTON_WIDTH, REPLAY_BUTTON_HEIGHT)
replay_next_rect = pygame.Rect(10 + 2 * (REPLAY_BUTTON_WIDTH + REPLAY_BUTTON_GAP), REPLAY_BUTTON_Y, REPLAY_BUTTON_WIDTH, REPLAY_BUTTON_HEIGHT)
replay_end_rect = pygame.Rect(10 + 3 * (REPLAY_BUTTON_WIDTH + REPLAY_BUTTON_GAP), REPLAY_BUTTON_Y, REPLAY_BUTTON_WIDTH, REPLAY_BUTTON_HEIGHT)


# --- Coordinate Handling ---
def get_coord(start, direction):
    row, col = start
    if direction == "right":
        return f"{row + 1}{LETTERS[col]}"
    else:  # "down"
        return f"{LETTERS[col]}{row + 1}"

def parse_coord(coord):
    """Parse a GCG coordinate (e.g., '8H' or 'H8') into (row, col) and direction."""
    if not coord: return None, None # Handle empty coord
    if coord[0].isalpha():  # Vertical: e.g., H8 or H10
        col_char = coord[0]
        row_str = coord[1:]
        if col_char not in LETTERS or not row_str.isdigit(): return None, None
        col = LETTERS.index(col_char)
        row = int(row_str) - 1
        direction = "down"
    else:  # Horizontal: e.g., 8H or 10A
        i = 0
        while i < len(coord) and coord[i].isdigit(): i += 1
        row_str = coord[:i]
        col_char = coord[i:]
        if not row_str.isdigit() or len(col_char) != 1 or col_char not in LETTERS: return None, None
        row = int(row_str) - 1
        col = LETTERS.index(col_char)
        direction = "right"

    if not (0 <= row < GRID_SIZE and 0 <= col < GRID_SIZE): return None, None # Bounds check
    return (row, col), direction

# --- Board Creation ---
def create_board():
    """Initialize the Scrabble board with special squares and labels."""
    board = [[WHITE for _ in range(GRID_SIZE)] for _ in range(GRID_SIZE)]
    labels = [['' for _ in range(GRID_SIZE)] for _ in range(GRID_SIZE)]
    tiles = [['' for _ in range(GRID_SIZE)] for _ in range(GRID_SIZE)]

    tw = [(0, 0), (0, 7), (0, 14), (7, 0), (7, 14), (14, 0), (14, 7), (14, 14)]
    dw = [(1, 1), (2, 2), (3, 3), (4, 4), (10, 10), (11, 11), (12, 12), (13, 13),
          (1, 13), (2, 12), (3, 11), (4, 10), (10, 4), (11, 3), (12, 2), (13, 1)]
    tl = [(1, 5), (1, 9), (5, 1), (5, 5), (5, 9), (5, 13), (9, 1), (9, 5),
          (9, 9), (9, 13), (13, 5), (13, 9)]
    dl = [(0, 3), (0, 11), (2, 6), (2, 8), (3, 0), (3, 7), (3, 14), (6, 2),
          (6, 6), (6, 8), (6, 12), (7, 3), (7, 11), (8, 2), (8, 6), (8, 8),
          (8, 12), (11, 0), (11, 7), (11, 14), (12, 6), (12, 8), (14, 3), (14, 11)]

    for r, c in tw: board[r][c] = RED
    for r, c in dw: board[r][c] = PINK
    for r, c in tl: board[r][c] = BLUE
    for r, c in dl: board[r][c] = LIGHT_BLUE
    board[7][7] = PINK # Center square

    return board, labels, tiles

# --- Drawing Functions ---
def draw_rack(player, rack, scores, turn, player_names, dragged_tile=None, drag_pos=None, display_scores=None):
    """Draw a player's rack with tiles, scores, and buttons."""
    global practice_mode # Access global practice_mode
    if not rack: return None, None
    if display_scores is None: display_scores = scores
    if practice_mode == "eight_letter" and player == 2: return None, None # Don't draw P2 rack

    rack_width = 7 * (TILE_WIDTH + TILE_GAP) - TILE_GAP
    # Calculate the rightmost extent of the replay buttons area
    # Replay buttons start at x=10, width=50, gap=10. 4 buttons total.
    replay_area_end_x = 10 + 4 * (REPLAY_BUTTON_WIDTH + REPLAY_BUTTON_GAP) # 10 + 4*(50+10) = 250
    # Minimum start x for the rack, considering replay buttons and star indicator offset (star is at start_x - 20)
    min_rack_start_x = replay_area_end_x + BUTTON_GAP + 20 # 250 + 10 + 20 = 280
    # Try to center the rack, but ensure it starts after the minimum x to avoid overlap
    start_x = max(min_rack_start_x, (BOARD_SIZE - rack_width) // 2)

    rack_y = BOARD_SIZE + 80 if player == 1 else BOARD_SIZE + 150

    if turn == player and (practice_mode != "eight_letter" or player == 1): # Draw turn indicator
        # Star indicator position depends on the calculated start_x
        center_x = start_x - 20; center_y = rack_y + TILE_HEIGHT // 2; radius = 10; points = []
        for i in range(10): angle = i * math.pi / 5; r = radius if i % 2 == 0 else radius / 2; x = center_x + r * math.cos(angle); y = center_y + r * math.sin(angle); points.append((x, y))
        pygame.draw.polygon(screen, TURN_INDICATOR_COLOR, points)

    for i, tile in enumerate(rack): # Draw tiles
        tile_x = start_x + i * (TILE_WIDTH + TILE_GAP)
        if dragged_tile == (player, i) and drag_pos: continue
        if tile == ' ':
            center = (tile_x + TILE_WIDTH // 2, rack_y + TILE_HEIGHT // 2); radius = TILE_WIDTH // 2 - 2
            pygame.draw.circle(screen, BLACK, center, radius); text = font.render('?', True, WHITE)
            text_rect = text.get_rect(center=center); screen.blit(text, text_rect)
        else:
            pygame.draw.rect(screen, GREEN, (tile_x, rack_y, TILE_WIDTH, TILE_HEIGHT)); text = font.render(tile, True, BLACK)
            screen.blit(text, (tile_x + 5, rack_y + 5))

    if dragged_tile and dragged_tile[0] == player and drag_pos: # Draw dragged tile
        tile_x, tile_y = drag_pos
        if 0 <= dragged_tile[1] < len(rack):
            tile = rack[dragged_tile[1]]
            if tile == ' ':
                center = (tile_x, tile_y); radius = TILE_WIDTH // 2 - 2; pygame.draw.circle(screen, BLACK, center, radius)
                text = font.render('?', True, WHITE); text_rect = text.get_rect(center=center); screen.blit(text, text_rect)
            else:
                pygame.draw.rect(screen, GREEN, (tile_x - TILE_WIDTH // 2, tile_y - TILE_HEIGHT // 2, TILE_WIDTH, TILE_HEIGHT))
                text = font.render(tile, True, BLACK); screen.blit(text, (tile_x - TILE_WIDTH // 2 + 5, tile_y - TILE_HEIGHT // 2 + 5))

    button_x = start_x + rack_width + BUTTON_GAP # Draw buttons
    alpha_button_rect = pygame.draw.rect(screen, BUTTON_COLOR, (button_x, rack_y, BUTTON_WIDTH, BUTTON_HEIGHT))
    rand_button_rect = pygame.draw.rect(screen, BUTTON_COLOR, (button_x + BUTTON_WIDTH + BUTTON_GAP, rack_y, BUTTON_WIDTH, BUTTON_HEIGHT))
    alpha_text = button_font.render("Alphabetize", True, BLACK); alpha_rect = alpha_text.get_rect(center=alpha_button_rect.center); screen.blit(alpha_text, alpha_rect)
    rand_text = button_font.render("Randomize", True, BLACK); rand_rect = rand_text.get_rect(center=rand_button_rect.center); screen.blit(rand_text, rand_rect)

    player_idx = player - 1 # Draw score
    if 0 <= player_idx < len(player_names) and 0 <= player_idx < len(display_scores):
        player_name_display = player_names[player_idx] if player_names[player_idx] else f"Player {player}"
        score_text = ui_font.render(f"{player_name_display} Score: {display_scores[player_idx]}", True, BLACK)
        screen.blit(score_text, (start_x, rack_y - 20))
    else: print(f"Warning: Invalid player index {player} for score display.")
    return alpha_button_rect, rand_button_rect

def draw_replay_icon(screen, rect, icon_type):
    """Draw centered replay control icons (arrows) on the buttons."""
    center_x, center_y = rect.center; arrow_size = 8
    if icon_type == "start": pygame.draw.polygon(screen, BLACK, [(center_x + 6, center_y - arrow_size), (center_x - 2, center_y), (center_x + 6, center_y + arrow_size)]); pygame.draw.polygon(screen, BLACK, [(center_x - 2, center_y - arrow_size), (center_x - 10, center_y), (center_x - 2, center_y + arrow_size)])
    elif icon_type == "prev": pygame.draw.polygon(screen, BLACK, [(center_x + 6, center_y - arrow_size), (center_x - 6, center_y), (center_x + 6, center_y + arrow_size)])
    elif icon_type == "next": pygame.draw.polygon(screen, BLACK, [(center_x - 6, center_y - arrow_size), (center_x + 6, center_y), (center_x - 6, center_y + arrow_size)])
    elif icon_type == "end": pygame.draw.polygon(screen, BLACK, [(center_x - 6, center_y - arrow_size), (center_x + 2, center_y), (center_x - 6, center_y + arrow_size)]); pygame.draw.polygon(screen, BLACK, [(center_x + 2, center_y - arrow_size), (center_x + 10, center_y), (center_x + 2, center_y + arrow_size)])

def draw_scoreboard(screen, move_history, scroll_offset, scores, is_ai, final_scores=None, game_over_state=False):
    """Draws the scrollable scoreboard."""
    scoreboard_x = BOARD_SIZE + 275; scoreboard_y = 40; scoreboard_width = max(200, WINDOW_WIDTH - BOARD_SIZE - 20); scoreboard_height = WINDOW_HEIGHT - 80
    if scoreboard_x + scoreboard_width > WINDOW_WIDTH - 10: scoreboard_width = WINDOW_WIDTH - scoreboard_x - 10
    if scoreboard_width < 200: scoreboard_x = WINDOW_WIDTH - 210; scoreboard_width = 200
    scoreboard_surface = pygame.Surface((scoreboard_width, scoreboard_height)); scoreboard_surface.fill(WHITE)
    running_scores = [0, 0]; y_pos = 10 - scroll_offset
    for i, move in enumerate(move_history):
        player_idx = move['player'] - 1; running_scores[player_idx] += move['score']
        player_label = "AI" if 0 <= player_idx < len(is_ai) and is_ai[player_idx] else f"P{move['player']}"
        display_score = running_scores[player_idx]
        if move['move_type'] == 'place': word = move.get('word', 'N/A'); coord = move.get('coord', 'N/A'); text = f"{i+1}: {player_label} - {word} at {coord} (+{move['score']}) Total: {display_score}"
        elif move['move_type'] == 'pass': text = f"{i+1}: {player_label} - Pass (+0) Total: {display_score}"
        elif move['move_type'] == 'exchange': text = f"{i+1}: {player_label} - Exchange (+0) Total: {display_score}"
        else: text = f"{i+1}: {player_label} - Unknown Move Type"
        text_surface = ui_font.render(text, True, BLACK)
        if y_pos < scoreboard_height and y_pos + 20 > 0:
            if (i // 2) % 2 == 0: rect_width = 10 + text_surface.get_width() + 10; highlight_rect = pygame.Rect(0, y_pos, rect_width, 20); pygame.draw.rect(scoreboard_surface, HIGHLIGHT_BLUE, highlight_rect)
            scoreboard_surface.blit(text_surface, (10, y_pos))
        y_pos += 20
    if game_over_state and final_scores is not None:
        y_pos += 20; final_text = f"Final Scores: P1: {final_scores[0]}, P2: {final_scores[1]}"; final_surface = ui_font.render(final_text, True, BLACK)
        if y_pos < scoreboard_height and y_pos + 20 > 0: scoreboard_surface.blit(final_surface, (10, y_pos))
    screen.blit(scoreboard_surface, (scoreboard_x, scoreboard_y))

# End of Part 1 (Includes basic drawing functions)

# Part 2 (Includes word finding, scoring, practice setup, mode selection, options menu)
# find_main_word, find_cross_word, find_all_words_formed (Unchanged from Part 2 provided previously)
def find_main_word(new_tiles, tiles):
    """Finds the primary word formed by newly placed tiles."""
    if not new_tiles: return [], None
    rows = set(r for r, c, _ in new_tiles); cols = set(c for r, c, _ in new_tiles)
    if len(rows) == 1: # Potential horizontal word
        orientation = "horizontal"; row = rows.pop(); min_col = min(c for r, c, _ in new_tiles if r == row); max_col = max(c for r, c, _ in new_tiles if r == row)
        while min_col > 0 and tiles[row][min_col - 1]: min_col -= 1
        while max_col < GRID_SIZE - 1 and tiles[row][max_col + 1]: max_col += 1
        main_word = [(row, c, tiles[row][c]) for c in range(min_col, max_col + 1) if tiles[row][c]]
        return (main_word, orientation) if len(main_word) > 1 else ([], None)
    elif len(cols) == 1: # Potential vertical word
        orientation = "vertical"; col = cols.pop(); min_row = min(r for r, c, _ in new_tiles if c == col); max_row = max(r for r, c, _ in new_tiles if c == col)
        while min_row > 0 and tiles[min_row - 1][col]: min_row -= 1
        while max_row < GRID_SIZE - 1 and tiles[max_row + 1][col]: max_row += 1
        main_word = [(r, col, tiles[r][col]) for r in range(min_row, max_row + 1) if tiles[r][col]]
        return (main_word, orientation) if len(main_word) > 1 else ([], None)
    else: return [], None

def find_cross_word(tile, tiles, main_orientation):
    """Finds a cross word formed by a single tile perpendicular to the main word."""
    r, c, _ = tile; cross_word = []
    if main_orientation == "horizontal": # Check vertically
        min_row = r;
        while min_row > 0 and tiles[min_row - 1][c]: min_row -= 1
        max_row = r;
        while max_row < GRID_SIZE - 1 and tiles[max_row + 1][c]: max_row += 1
        if max_row > min_row: cross_word = [(rr, c, tiles[rr][c]) for rr in range(min_row, max_row + 1) if tiles[rr][c]]
    elif main_orientation == "vertical": # Check horizontally
        min_col = c;
        while min_col > 0 and tiles[r][min_col - 1]: min_col -= 1
        max_col = c;
        while max_col < GRID_SIZE - 1 and tiles[r][max_col + 1]: max_col += 1
        if max_col > min_col: cross_word = [(r, cc, tiles[r][cc]) for cc in range(min_col, max_col + 1) if tiles[r][cc]]
    return cross_word if len(cross_word) > 1 else []

def find_all_words_formed(new_tiles, tiles):
    """Finds all words (main and cross) formed by a play."""
    words = [];
    if not new_tiles: return words
    new_positions_set = set((r, c) for r, c, _ in new_tiles)
    main_word_tiles, orientation = find_main_word(new_tiles, tiles)
    if main_word_tiles:
        words.append(main_word_tiles)
        for tile in new_tiles:
            if (tile[0], tile[1]) in new_positions_set:
                cross_word = find_cross_word(tile, tiles, orientation)
                if cross_word: words.append(cross_word)
    elif len(new_tiles) == 1: # Single tile placement check
        tile = new_tiles[0]
        cross_h = find_cross_word(tile, tiles, "vertical");   # Check H
        if cross_h: words.append(cross_h)
        cross_v = find_cross_word(tile, tiles, "horizontal"); # Check V
        if cross_v: words.append(cross_v)
    unique_word_tile_lists = []; seen_signatures = set()
    for word_tile_list in words:
        signature = tuple(sorted((r, c, l) for r, c, l in word_tile_list))
        if signature not in seen_signatures: unique_word_tile_lists.append(word_tile_list); seen_signatures.add(signature)
    return unique_word_tile_lists

# calculate_score (Unchanged from Part 2 provided previously)
def calculate_score(new_tiles, board, tiles, blanks):
    """Calculates the score for a play based on newly placed tiles."""
    total_score = 0; new_positions = set((r, c) for r, c, _ in new_tiles)
    words_formed_details = find_all_words_formed(new_tiles, tiles)
    for word_tiles in words_formed_details:
        word_score = 0; word_multiplier = 1
        for r, c, letter in word_tiles:
            if letter not in TILE_DISTRIBUTION: print(f"Warning: Invalid letter '{letter}' found in word during scoring at ({r},{c}). Skipping."); continue
            is_blank = (r, c) in blanks; letter_value = 0 if is_blank else TILE_DISTRIBUTION[letter][1]; letter_multiplier = 1
            if (r, c) in new_positions:
                square_color = board[r][c]
                if square_color == LIGHT_BLUE: letter_multiplier = 2 # DL
                elif square_color == BLUE: letter_multiplier = 3 # TL
                elif square_color == PINK: word_multiplier *= 2 # DW (Center is also Pink)
                elif square_color == RED: word_multiplier *= 3 # TW
            word_score += letter_value * letter_multiplier
        total_score += word_score * word_multiplier
    if len(new_tiles) == 7: total_score += 50 # Bingo bonus
    return total_score

# select_seven_letter_word, eight_letter_practice, mode_selection_screen, draw_options_menu (Unchanged from Part 2 provided previously)
def select_seven_letter_word(removed_letter, seven_letter_words):
    """Selects a random 7-letter word containing the removed letter."""
    candidates = [word for word in seven_letter_words if removed_letter in word]
    if not candidates: print(f"Warning: No 7-letter words contain '{removed_letter}'. Choosing random 7-letter word."); return random.choice(seven_letter_words) if seven_letter_words else None
    return random.choice(candidates)

def eight_letter_practice():
    """Handles the setup dialog and initialization for 8-Letter Bingo practice."""
    try:
        with open("7-letter-list.txt", "r") as seven_file, open("8-letter-list.txt", "r") as eight_file:
            seven_letter_words = [line.strip().upper() for line in seven_file.readlines()]; eight_letter_words = [line.strip().upper() for line in eight_file.readlines()]
    except FileNotFoundError: print("Error: Could not find 7-letter-list.txt or 8-letter-list.txt"); return False, None, None, None, None, None
    if not seven_letter_words or not eight_letter_words: print("Error: Word list files are empty."); return False, None, None, None, None, None
    dialog_width, dialog_height = 300, 150; dialog_x = (WINDOW_WIDTH - dialog_width) // 2; dialog_y = (WINDOW_HEIGHT - dialog_height) // 2
    proceed = False; text_box_active = False; probability_input = ""
    while True: # Dialog loop
        screen.fill(WHITE); pygame.draw.rect(screen, DIALOG_COLOR, (dialog_x, dialog_y, dialog_width, dialog_height)); pygame.draw.rect(screen, BLACK, (dialog_x, dialog_y, dialog_width, dialog_height), 2)
        title_text = dialog_font.render("8-Letter Bingo Options", True, BLACK); screen.blit(title_text, (dialog_x + 10, dialog_y + 10))
        prob_text = ui_font.render("Probability", True, BLACK); screen.blit(prob_text, (dialog_x + 20, dialog_y + 50))
        text_box_rect = pygame.Rect(dialog_x + 120, dialog_y + 45, 150, 30); pygame.draw.rect(screen, WHITE, text_box_rect); pygame.draw.rect(screen, BLACK, text_box_rect, 1)
        input_text = ui_font.render(probability_input, True, BLACK); screen.blit(input_text, (text_box_rect.x + 5, text_box_rect.y + 5))
        go_rect = pygame.Rect(dialog_x + 50, dialog_y + 100, 100, 30); cancel_rect = pygame.Rect(dialog_x + 160, dialog_y + 100, 100, 30)
        pygame.draw.rect(screen, BUTTON_COLOR, go_rect); pygame.draw.rect(screen, BUTTON_COLOR, cancel_rect)
        go_text = button_font.render("Go", True, BLACK); cancel_text = button_font.render("Cancel", True, BLACK)
        screen.blit(go_text, go_text.get_rect(center=go_rect.center)); screen.blit(cancel_text, cancel_text.get_rect(center=cancel_rect.center))
        for event in pygame.event.get():
            if event.type == pygame.QUIT: pygame.quit(); sys.exit()
            elif event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
                x, y = event.pos; text_box_active = text_box_rect.collidepoint(x, y)
                if go_rect.collidepoint(x, y):
                    max_index = len(eight_letter_words);
                    if probability_input.isdigit(): prob_val = int(probability_input); max_index = min(max(1, prob_val), len(eight_letter_words))
                    selected_eight = random.choice(eight_letter_words[:max_index]); print("Selected 8-letter word:", selected_eight)
                    remove_idx = random.randint(0, 7); removed_letter = selected_eight[remove_idx]; removed_eight = selected_eight[:remove_idx] + selected_eight[remove_idx + 1:]
                    print("Player 1 rack (7 letters):", removed_eight); print("Removed letter:", removed_letter)
                    selected_seven = select_seven_letter_word(removed_letter, seven_letter_words)
                    if selected_seven is None: print("Error: Could not find a suitable 7-letter word."); return False, None, None, None, None, None
                    print("Selected 7-letter word for board:", selected_seven)
                    board, _, tiles = create_board(); local_racks = [[], []]; local_blanks = set(); local_racks[0] = sorted(list(removed_eight)); local_racks[1] = []
                    center_r, center_c = CENTER_SQUARE; word_len = len(selected_seven); start_offset = word_len // 2; place_horizontally = random.choice([True, False]); placement_successful = False
                    if place_horizontally:
                        start_c_place = center_c - start_offset
                        if 0 <= start_c_place and start_c_place + word_len <= GRID_SIZE:
                            for i, letter in enumerate(selected_seven): tiles[center_r][start_c_place + i] = letter
                            placement_successful = True; print(f"Placed '{selected_seven}' horizontally at ({center_r},{start_c_place})")
                    if not placement_successful: # Try vertically
                        start_r_place = center_r - start_offset
                        if 0 <= start_r_place and start_r_place + word_len <= GRID_SIZE:
                            for i, letter in enumerate(selected_seven): tiles[start_r_place + i][center_c] = letter
                            placement_successful = True; print(f"Placed '{selected_seven}' vertically at ({start_r_place},{center_c})")
                    if not placement_successful: print("Error: Could not place 7-letter word centered H or V."); return False, None, None, None, None, None
                    local_bag = []; return True, board, tiles, local_racks, local_blanks, local_bag
                elif cancel_rect.collidepoint(x, y): return False, None, None, None, None, None
            elif event.type == pygame.KEYDOWN and text_box_active:
                if event.key == pygame.K_BACKSPACE: probability_input = probability_input[:-1]
                elif event.unicode.isdigit(): probability_input += event.unicode
        pygame.display.flip()
    return False, None, None, None, None, None # Should not be reached




def mode_selection_screen():
    """Display and handle the game mode selection screen."""
    print("--- mode_selection_screen() entered ---") # Keep diagnostic print
    global main_called
    try:
        print("--- mode_selection_screen(): Attempting to load background image... ---") # Keep diagnostic print
        image = pygame.image.load("Scrabble_S.png").convert_alpha(); content_width = WINDOW_WIDTH - 200; image = pygame.transform.scale(image, (content_width, WINDOW_HEIGHT)); image.set_alpha(128); content_left = (WINDOW_WIDTH - content_width) // 2
        print("--- mode_selection_screen(): Background image loaded and processed. ---") # Keep diagnostic print
    except pygame.error as e:
        print(f"--- mode_selection_screen(): WARNING - Could not load background image 'Scrabble_S.png': {e} ---")
        image = None; content_width = WINDOW_WIDTH; content_left = 0 # Ensure content_left is defined even if image fails
    modes = [MODE_HVH, MODE_HVA, MODE_AVA]; selected_mode = None; player_names = ["Player 1", "Player 2"]; human_player = 1; input_active = [False, False]; current_input = 0
    practice_mode = None; dropdown_open = False; showing_power_tiles_dialog = False; letter_checks = [True, True, True, True]; number_checks = [True, True, True, True, False, False]; practice_state = None

    print("--- mode_selection_screen(): Entering main loop (while selected_mode is None:)... ---") # Keep diagnostic print
    loop_count = 0
    while selected_mode is None:
        loop_count += 1
        if loop_count % 5000 == 0: # Print periodically if looping a lot
             print(f"--- mode_selection_screen(): Loop iteration {loop_count} ---")

        # --- Check for QUIT event explicitly (Optional but can leave for robustness) ---
        if pygame.event.peek(pygame.QUIT):
             print("--- mode_selection_screen(): QUIT event peeked. Exiting. ---")
             pygame.quit()
             sys.exit()

        # --- Pump Events Explicitly (Optional but can leave for robustness) ---
        pygame.event.pump()

        # --- Define positions INSIDE the loop ---
        option_rects = []
        name_rect_x = content_left + (content_width - 200) // 2 # Calculation moved inside loop
        p2_y_pos = 300 + 60

        # Check if dropdown is open for HVH mode
        if modes[current_input] == MODE_HVH and dropdown_open:
            dropdown_x = name_rect_x
            dropdown_button_y = p2_y_pos + BUTTON_HEIGHT + 10
            dropdown_y = dropdown_button_y + 30
            options = ["Power Tiles", "8-Letter Bingos", "End Game"]
            for i, option in enumerate(options):
                option_rect = pygame.Rect(dropdown_x, dropdown_y + 30 * i, 200, 30)
                option_rects.append(option_rect)

        # --- Event Handling ---
        event_handled = False
        for event in pygame.event.get():
            event_handled = True
            if event.type == pygame.QUIT:
                print("--- mode_selection_screen(): QUIT event received via get(). Exiting. ---")
                pygame.quit(); sys.exit()
            elif event.type == pygame.MOUSEBUTTONDOWN:
                x, y = event.pos
                if showing_power_tiles_dialog: # Power Tiles Dialog Handling
                    dialog_x = (WINDOW_WIDTH - 300) // 2; dialog_y = (WINDOW_HEIGHT - 250) // 2; letter_rects = [pygame.Rect(dialog_x + 20, dialog_y + 40 + i*30, 20, 20) for i in range(4)]; number_rects = [pygame.Rect(dialog_x + 150, dialog_y + 40 + i*30, 20, 20) for i in range(6)]
                    go_rect = pygame.Rect(dialog_x + 50, dialog_y + 220, 100, 30); cancel_rect = pygame.Rect(dialog_x + 160, dialog_y + 220, 100, 30)
                    for i, rect in enumerate(letter_rects):
                        if rect.collidepoint(x, y): letter_checks[i] = not letter_checks[i]
                    for i, rect in enumerate(number_rects):
                        if rect.collidepoint(x, y): number_checks[i] = not number_checks[i]
                    if go_rect.collidepoint(x, y): practice_mode = "power_tiles"; selected_mode = MODE_AVA; showing_power_tiles_dialog = False; print(f"--- mode_selection_screen(): Mode selected via Power Tiles Go: {selected_mode} ---"); break
                    elif cancel_rect.collidepoint(x, y): showing_power_tiles_dialog = False
                else: # Main Selection Screen Handling
                    for i, rect in enumerate(mode_rects): # Mode buttons
                        if rect.collidepoint(x, y):
                            current_input = i; dropdown_open = False
                            if i == 0: player_names = ["Player 1", "Player 2"]; input_active = [False, False]
                            elif i == 1: player_names = ["Player 1", "AI"] if human_player == 1 else ["AI", "Player 2"]; input_active = [True, False] if human_player == 1 else [False, True]
                            elif i == 2: player_names = ["AI 1", "AI 2"]; input_active = [False, False]
                            # Select mode immediately for HVH and AVA
                            if modes[current_input] in [MODE_HVH, MODE_AVA]:
                                selected_mode = modes[current_input]
                                print(f"--- mode_selection_screen(): Mode selected via click: {selected_mode} ---")
                                break # Exit event loop once mode selected
                    if selected_mode: break # Exit outer loop if mode selected
                    if play_later_rect.collidepoint(x, y):
                        print("--- mode_selection_screen(): Play Later clicked. Exiting. ---")
                        pygame.quit(); sys.exit() # Exit directly
                    clicked_name_input = False # Name input activation
                    if modes[current_input] == MODE_HVH:
                        if p1_name_rect.collidepoint(x, y): input_active = [True, False]; clicked_name_input = True
                        elif p2_name_rect.collidepoint(x, y): input_active = [False, True]; clicked_name_input = True
                    elif modes[current_input] == MODE_HVA:
                        if human_player == 1 and p1_name_rect.collidepoint(x, y): input_active = [True, False]; clicked_name_input = True
                        elif human_player == 2 and p2_name_rect.collidepoint(x, y): input_active = [False, True]; clicked_name_input = True
                    if modes[current_input] == MODE_HVA: # HVA Play As buttons
                        button_row_y = p2_y_pos + BUTTON_HEIGHT + 10; p1_rect_hva = pygame.Rect(content_left + (content_width - (BUTTON_WIDTH * 2 + 20)) // 2, button_row_y, BUTTON_WIDTH, BUTTON_HEIGHT); p2_rect_hva = pygame.Rect(content_left + (content_width - (BUTTON_WIDTH * 2 + 20)) // 2 + BUTTON_WIDTH + 20, button_row_y, BUTTON_WIDTH, BUTTON_HEIGHT)
                        if p1_rect_hva.collidepoint(x, y): human_player = 1; player_names = ["Player 1", "AI"]; input_active = [True, False]; selected_mode = MODE_HVA; print(f"--- mode_selection_screen(): Mode selected via click: {selected_mode} (Play as P1) ---"); break
                        elif p2_rect_hva.collidepoint(x, y): human_player = 2; player_names = ["AI", "Player 2"]; input_active = [False, True]; selected_mode = MODE_HVA; print(f"--- mode_selection_screen(): Mode selected via click: {selected_mode} (Play as P2) ---"); break
                    if modes[current_input] == MODE_HVH: # Practice Dropdown
                        dropdown_button_y = p2_y_pos + BUTTON_HEIGHT + 10; dropdown_rect = pygame.Rect(name_rect_x, dropdown_button_y, 200, 30)
                        if dropdown_rect.collidepoint(x, y): dropdown_open = not dropdown_open
                        elif dropdown_open:
                            clicked_option = False
                            for i, option_rect in enumerate(option_rects):
                                if option_rect.collidepoint(x, y):
                                    clicked_option = True; dropdown_open = False
                                    if i == 0: showing_power_tiles_dialog = True
                                    elif i == 1: # 8-Letter Bingos
                                        print("--- mode_selection_screen(): 8-Letter Bingo practice selected. Calling eight_letter_practice()... ---")
                                        proceed, p_board, p_tiles, p_racks, p_blanks, p_bag = eight_letter_practice()
                                        if proceed:
                                            practice_mode = "eight_letter"; selected_mode = MODE_HVH; player_names = ["Player 1", ""]; human_player = 1
                                            practice_state = {"board": p_board, "tiles": p_tiles, "racks": p_racks, "blanks": p_blanks, "bag": p_bag, "first_play": False, "scores": [0, 0], "turn": 1}
                                            print(f"--- mode_selection_screen(): 8-Letter practice setup successful. Selected mode: {selected_mode} ---")
                                            break # Exit inner event loop
                                        else:
                                             print("--- mode_selection_screen(): 8-Letter practice setup cancelled or failed. ---")
                                    elif i == 2: print("End Game practice selected - Not implemented yet")
                                    break # Exit options loop
                            if not clicked_option and not dropdown_rect.collidepoint(x,y): dropdown_open = False
                        elif not dropdown_rect.collidepoint(x,y): dropdown_open = False
                    if selected_mode: break # Break if practice selection set the mode
                    dropdown_button_y = p2_y_pos + BUTTON_HEIGHT + 10; dropdown_rect_check = pygame.Rect(name_rect_x, dropdown_button_y, 200, 30) if modes[current_input] == MODE_HVH else None # Deactivate name input check
                    if not clicked_name_input and not (dropdown_open and any(r.collidepoint(x,y) for r in option_rects)) and not p1_name_rect.collidepoint(x,y) and not (modes[current_input] == MODE_HVH and p2_name_rect.collidepoint(x,y)) and not (dropdown_rect_check and dropdown_rect_check.collidepoint(x,y)): input_active = [False, False]
            elif event.type == pygame.KEYDOWN: # Keyboard input for names
                 active_idx = -1
                 if input_active[0]: active_idx = 0
                 elif input_active[1] and modes[current_input] == MODE_HVH: active_idx = 1
                 elif input_active[1] and modes[current_input] == MODE_HVA and human_player == 2: active_idx = 1
                 if active_idx != -1:
                    if event.key == pygame.K_BACKSPACE: player_names[active_idx] = player_names[active_idx][:-1]
                    elif event.key == pygame.K_RETURN: input_active[active_idx] = False
                    elif event.unicode.isalnum() or event.unicode == ' ':
                        if len(player_names[active_idx]) < 15: player_names[active_idx] += event.unicode

        # --- Drawing Logic ---
        screen.fill(WHITE);
        if image: screen.blit(image, (content_left, 0))
        title_text = dialog_font.render("Select Game Mode", True, BLACK); title_x = content_left + (content_width - title_text.get_width()) // 2; screen.blit(title_text, (title_x, 50))
        mode_rects = []
        for i, mode in enumerate(modes):
            y_pos = 100 + i * 60; rect = pygame.Rect(content_left + (content_width - (BUTTON_WIDTH * 2 + 20)) // 2, y_pos, BUTTON_WIDTH * 2 + 20, BUTTON_HEIGHT); hover = rect.collidepoint(pygame.mouse.get_pos())
            color = BUTTON_HOVER if i == current_input or hover else BUTTON_COLOR; pygame.draw.rect(screen, color, rect)
            if i == current_input: pygame.draw.rect(screen, BLACK, rect, 2)
            text = button_font.render(mode, True, BLACK); text_rect = text.get_rect(center=rect.center); screen.blit(text, text_rect); mode_rects.append(rect)
        play_later_rect = pygame.Rect(WINDOW_WIDTH - BUTTON_WIDTH - 10, WINDOW_HEIGHT - BUTTON_HEIGHT - 10, BUTTON_WIDTH, BUTTON_HEIGHT); hover = play_later_rect.collidepoint(pygame.mouse.get_pos()); color = BUTTON_HOVER if hover else BUTTON_COLOR; pygame.draw.rect(screen, color, play_later_rect)
        play_later_text = button_font.render("Play Later", True, BLACK); play_later_text_rect = play_later_text.get_rect(center=play_later_rect.center); screen.blit(play_later_text, play_later_text_rect)

        # --- Name Input Drawing (Uses name_rect_x) ---
        name_y_start = 300; name_rect_width = 200; p1_y_pos = name_y_start; p1_label_text = "Player 1 Name:"; p1_label = ui_font.render(p1_label_text, True, BLACK);
        p1_name_rect = pygame.Rect(name_rect_x, p1_y_pos, name_rect_width, BUTTON_HEIGHT)
        p1_label_x = name_rect_x - p1_label.get_width() - 10; screen.blit(p1_label, (p1_label_x, p1_y_pos + 5)); p1_bg_color = LIGHT_BLUE if input_active[0] else (GRAY if modes[current_input] == MODE_AVA else WHITE); pygame.draw.rect(screen, p1_bg_color, p1_name_rect); pygame.draw.rect(screen, BLACK, p1_name_rect, 1)
        p1_name_text = ui_font.render(player_names[0], True, BLACK); screen.blit(p1_name_text, (p1_name_rect.x + 5, p1_name_rect.y + 5))

        if modes[current_input] == MODE_HVH:
            p2_label_text = "Player 2 Name:"; p2_label = ui_font.render(p2_label_text, True, BLACK); p2_name_rect = pygame.Rect(name_rect_x, p2_y_pos, name_rect_width, BUTTON_HEIGHT); p2_label_x = name_rect_x - p2_label.get_width() - 10; screen.blit(p2_label, (p2_label_x, p2_y_pos + 5))
            pygame.draw.rect(screen, WHITE if not input_active[1] else LIGHT_BLUE, p2_name_rect); pygame.draw.rect(screen, BLACK, p2_name_rect, 1); p2_name_text = ui_font.render(player_names[1], True, BLACK); screen.blit(p2_name_text, (p2_name_rect.x + 5, p2_name_rect.y + 5))
            dropdown_button_y = p2_y_pos + BUTTON_HEIGHT + 10; dropdown_rect = pygame.Rect(name_rect_x, dropdown_button_y, 200, 30); hover = dropdown_rect.collidepoint(pygame.mouse.get_pos()); color = BUTTON_HOVER if hover else BUTTON_COLOR; pygame.draw.rect(screen, color, dropdown_rect)
            text = button_font.render("Practice", True, BLACK); text_rect = text.get_rect(center=dropdown_rect.center); screen.blit(text, text_rect)
            if dropdown_open:
                for i, option_rect in enumerate(option_rects): hover = option_rect.collidepoint(pygame.mouse.get_pos()); color = BUTTON_HOVER if hover else DROPDOWN_COLOR; pygame.draw.rect(screen, color, option_rect); text = button_font.render(options[i], True, BLACK); text_rect = text.get_rect(center=option_rect.center); screen.blit(text, text_rect)
        elif modes[current_input] == MODE_HVA:
            p2_label_text = "AI Name:"; p2_label = ui_font.render(p2_label_text, True, BLACK); p2_name_rect = pygame.Rect(name_rect_x, p2_y_pos, name_rect_width, BUTTON_HEIGHT); p2_label_x = name_rect_x - p2_label.get_width() - 10; screen.blit(p2_label, (p2_label_x, p2_y_pos + 5))
            pygame.draw.rect(screen, GRAY, p2_name_rect); pygame.draw.rect(screen, BLACK, p2_name_rect, 1); p2_name_text = ui_font.render(player_names[1], True, BLACK); screen.blit(p2_name_text, (p2_name_rect.x + 5, p2_name_rect.y + 5))
            button_row_y = p2_y_pos + BUTTON_HEIGHT + 10; p1_rect = pygame.Rect(content_left + (content_width - (BUTTON_WIDTH * 2 + 20)) // 2, button_row_y, BUTTON_WIDTH, BUTTON_HEIGHT); p2_rect = pygame.Rect(content_left + (content_width - (BUTTON_WIDTH * 2 + 20)) // 2 + BUTTON_WIDTH + 20, button_row_y, BUTTON_WIDTH, BUTTON_HEIGHT)
            p1_hover = p1_rect.collidepoint(pygame.mouse.get_pos()); p2_hover = p2_rect.collidepoint(pygame.mouse.get_pos()); pygame.draw.rect(screen, BUTTON_HOVER if p1_hover else BUTTON_COLOR, p1_rect);
            if human_player == 1: pygame.draw.rect(screen, BLACK, p1_rect, 2)
            pygame.draw.rect(screen, BUTTON_HOVER if p2_hover else BUTTON_COLOR, p2_rect);
            if human_player == 2: pygame.draw.rect(screen, BLACK, p2_rect, 2)
            p1_text = button_font.render("Play as P1", True, BLACK); p2_text = button_font.render("Play as P2", True, BLACK); p1_text_rect = p1_text.get_rect(center=p1_rect.center); p2_text_rect = p2_text.get_rect(center=p2_rect.center); screen.blit(p1_text, p1_text_rect); screen.blit(p2_text, p2_text_rect)
        elif modes[current_input] == MODE_AVA:
            p2_label_text = "AI 2 Name:"; p2_label = ui_font.render(p2_label_text, True, BLACK); p2_name_rect = pygame.Rect(name_rect_x, p2_y_pos, name_rect_width, BUTTON_HEIGHT); p2_label_x = name_rect_x - p2_label.get_width() - 10; screen.blit(p2_label, (p2_label_x, p2_y_pos + 5))
            pygame.draw.rect(screen, GRAY, p2_name_rect); pygame.draw.rect(screen, BLACK, p2_name_rect, 1); p2_name_text = ui_font.render(player_names[1], True, BLACK); screen.blit(p2_name_text, (p2_name_rect.x + 5, p2_name_rect.y + 5))
            pygame.draw.rect(screen, GRAY, p1_name_rect); pygame.draw.rect(screen, BLACK, p1_name_rect, 1); p1_name_text = ui_font.render(player_names[0], True, BLACK); screen.blit(p1_name_text, (p1_name_rect.x + 5, p1_name_rect.y + 5))

        if showing_power_tiles_dialog: # Draw Power Tiles Dialog if active
            dialog_width, dialog_height = 300, 250; dialog_x = (WINDOW_WIDTH - dialog_width) // 2; dialog_y = (WINDOW_HEIGHT - dialog_height) // 2; pygame.draw.rect(screen, DIALOG_COLOR, (dialog_x, dialog_y, dialog_width, dialog_height)); pygame.draw.rect(screen, BLACK, (dialog_x, dialog_y, dialog_width, dialog_height), 2)
            title_text = dialog_font.render("Power Tiles Options", True, BLACK); screen.blit(title_text, (dialog_x + 10, dialog_y + 10)); letters = ['J', 'Q', 'X', 'Z']
            for i, letter in enumerate(letters): draw_checkbox(screen, dialog_x + 20, dialog_y + 40 + i*30, letter_checks[i]); text = ui_font.render(letter, True, BLACK); screen.blit(text, (dialog_x + 50, dialog_y + 40 + i*30))
            numbers = ['2', '3', '4', '5', '6', '7+']
            for i, num in enumerate(numbers): draw_checkbox(screen, dialog_x + 150, dialog_y + 40 + i*30, number_checks[i]); text = ui_font.render(num, True, BLACK); screen.blit(text, (dialog_x + 180, dialog_y + 40 + i*30))
            go_rect = pygame.Rect(dialog_x + 50, dialog_y + 220, 100, 30); cancel_rect = pygame.Rect(dialog_x + 160, dialog_y + 220, 100, 30); pygame.draw.rect(screen, BUTTON_COLOR, go_rect); pygame.draw.rect(screen, BUTTON_COLOR, cancel_rect)
            go_text = button_font.render("Go", True, BLACK); cancel_text = button_font.render("Cancel", True, BLACK); screen.blit(go_text, go_text.get_rect(center=go_rect.center)); screen.blit(cancel_text, cancel_text.get_rect(center=cancel_rect.center))

        # --- Display Update ---
        pygame.display.flip()

        # --- Exit Condition Check ---
        if selected_mode:
             print(f"--- mode_selection_screen(): Breaking loop because selected_mode is now {selected_mode} ---")
             break

    print(f"--- mode_selection_screen(): Exiting loop. Returning: mode={selected_mode}, practice={practice_mode} ---")
    return selected_mode, player_names, human_player, practice_mode, letter_checks if practice_mode == "power_tiles" else None, practice_state




def draw_options_menu(turn, dropdown_open, bag_count):
    """Draw the options menu with dropdown functionality."""
    global practice_mode # Access practice_mode
    options_x = 10; options_rect = pygame.Rect(options_x, OPTIONS_Y, OPTIONS_WIDTH, OPTIONS_HEIGHT)
    hover = options_rect.collidepoint(pygame.mouse.get_pos()); color = BUTTON_HOVER if hover else BUTTON_COLOR; pygame.draw.rect(screen, color, options_rect)
    options_text = button_font.render("Options", True, BLACK); options_text_rect = options_text.get_rect(center=(options_x + OPTIONS_WIDTH // 2, OPTIONS_Y + OPTIONS_HEIGHT // 2)); screen.blit(options_text, options_text_rect)
    dropdown_rects = []
    if dropdown_open:
        dropdown_y = OPTIONS_Y + OPTIONS_HEIGHT
        if practice_mode == "eight_letter": options = ["Give Up", "Main", "Quit"]
        else: options = ["Pass", "Exchange", "Main", "Quit"]
        for i, option in enumerate(options):
            rect = pygame.Rect(options_x, dropdown_y + i * OPTIONS_HEIGHT, OPTIONS_WIDTH, OPTIONS_HEIGHT)
            is_disabled = (practice_mode != "eight_letter" and option == "Exchange" and bag_count < 7)
            if is_disabled: pygame.draw.rect(screen, GRAYED_OUT_COLOR, rect); text = button_font.render(option, True, BLACK); dropdown_rects.append(None)
            else: hover = rect.collidepoint(pygame.mouse.get_pos()); color = BUTTON_HOVER if hover else DROPDOWN_COLOR; pygame.draw.rect(screen, color, rect); text = button_font.render(option, True, BLACK); dropdown_rects.append(rect)
            text_rect = text.get_rect(center=(options_x + OPTIONS_WIDTH // 2, dropdown_y + i * OPTIONS_HEIGHT + OPTIONS_HEIGHT // 2)); screen.blit(text, text_rect)
    return options_rect, dropdown_rects

# End of Part 2

# Part 3 (Includes dialogs, stats, message boxes)
# draw_suggest_button, draw_exchange_dialog, confirm_quit, draw_game_over_dialog, draw_score_row, calculate_moves_per_player, calculate_bingos_per_player, calculate_bingo_avg_per_player, draw_moves_row, draw_avg_score_row, draw_bingos_row, draw_bingo_avg_row, calculate_blanks_per_player, draw_blanks_row, draw_stats_dialog, show_message_dialog, draw_practice_end_dialog (Unchanged from Part 3 provided previously)
def draw_suggest_button():
    """Draw the suggest button."""
    suggest_x = 10 + OPTIONS_WIDTH + BUTTON_GAP; suggest_rect = pygame.Rect(suggest_x, OPTIONS_Y, OPTIONS_WIDTH, OPTIONS_HEIGHT)
    hover = suggest_rect.collidepoint(pygame.mouse.get_pos()); color = BUTTON_HOVER if hover else BUTTON_COLOR; pygame.draw.rect(screen, color, suggest_rect)
    suggest_text = button_font.render("Suggest", True, BLACK); suggest_text_rect = suggest_text.get_rect(center=(suggest_x + OPTIONS_WIDTH // 2, OPTIONS_Y + OPTIONS_HEIGHT // 2)); screen.blit(suggest_text, suggest_text_rect)
    return suggest_rect

def draw_exchange_dialog(rack, selected_tiles):
    """Draw the tile exchange dialog."""
    dialog_width, dialog_height = 400, 200; dialog_x = (WINDOW_WIDTH - dialog_width) // 2; dialog_y = (WINDOW_HEIGHT - dialog_height) // 2
    pygame.draw.rect(screen, DIALOG_COLOR, (dialog_x, dialog_y, dialog_width, dialog_height)); pygame.draw.rect(screen, BLACK, (dialog_x, dialog_y, dialog_width, dialog_height), 2)
    prompt_text = dialog_font.render("Select tiles to exchange:", True, BLACK); screen.blit(prompt_text, (dialog_x + 10, dialog_y + 10))
    tile_rects = []; rack_display_width = len(rack) * (TILE_WIDTH + TILE_GAP) - TILE_GAP; start_tile_x = dialog_x + (dialog_width - rack_display_width) // 2
    for i, tile in enumerate(rack):
        tile_x = start_tile_x + i * (TILE_WIDTH + TILE_GAP); tile_y = dialog_y + 50; rect = pygame.Rect(tile_x, tile_y, TILE_WIDTH, TILE_HEIGHT); tile_rects.append(rect)
        if tile == ' ':
            center = rect.center; radius = TILE_WIDTH // 2 - 2; pygame.draw.circle(screen, BLACK, center, radius)
            if i in selected_tiles: pygame.draw.circle(screen, SELECTED_TILE_COLOR, center, radius + 2, 2)
            text = font.render('?', True, WHITE); text_rect = text.get_rect(center=center); screen.blit(text, text_rect)
        else: color = SELECTED_TILE_COLOR if i in selected_tiles else GREEN; pygame.draw.rect(screen, color, rect); text = font.render(tile, True, BLACK); screen.blit(text, (tile_x + 5, tile_y + 5))
    total_button_width = BUTTON_WIDTH * 2 + BUTTON_GAP; button_start_x = dialog_x + (dialog_width - total_button_width) // 2; button_y = dialog_y + dialog_height - BUTTON_HEIGHT - 10
    exchange_button_rect = pygame.Rect(button_start_x, button_y, BUTTON_WIDTH, BUTTON_HEIGHT); cancel_button_rect = pygame.Rect(button_start_x + BUTTON_WIDTH + BUTTON_GAP, button_y, BUTTON_WIDTH, BUTTON_HEIGHT)
    hover = exchange_button_rect.collidepoint(pygame.mouse.get_pos()); color = BUTTON_HOVER if hover else BUTTON_COLOR; pygame.draw.rect(screen, color, exchange_button_rect)
    exchange_text = button_font.render("Exchange", True, BLACK); exchange_text_rect = exchange_text.get_rect(center=exchange_button_rect.center); screen.blit(exchange_text, exchange_text_rect)
    hover = cancel_button_rect.collidepoint(pygame.mouse.get_pos()); color = BUTTON_HOVER if hover else BUTTON_COLOR; pygame.draw.rect(screen, color, cancel_button_rect)
    cancel_text = button_font.render("Cancel", True, BLACK); cancel_text_rect = cancel_text.get_rect(center=cancel_button_rect.center); screen.blit(cancel_text, cancel_text_rect)
    return tile_rects, exchange_button_rect, cancel_button_rect

def confirm_quit():
    """Prompt the user to confirm quitting the game."""
    dialog_width, dialog_height = 300, 100; dialog_x = (WINDOW_WIDTH - dialog_width) // 2; dialog_y = (WINDOW_HEIGHT - dialog_height) // 2
    pygame.draw.rect(screen, DIALOG_COLOR, (dialog_x, dialog_y, dialog_width, dialog_height)); pygame.draw.rect(screen, BLACK, (dialog_x, dialog_y, dialog_width, dialog_height), 2)
    prompt_text = dialog_font.render("Quit game? (Y/N)", True, BLACK); screen.blit(prompt_text, (dialog_x + (dialog_width - prompt_text.get_width()) // 2, dialog_y + 30)); pygame.display.flip()
    while True:
        for event in pygame.event.get():
            if event.type == pygame.QUIT: pygame.quit(); sys.exit()
            elif event.type == pygame.KEYDOWN:
                if event.key == pygame.K_y: return True
                elif event.key == pygame.K_n: return False

def draw_game_over_dialog(dialog_x, dialog_y, final_scores, reason, player_names):
    """Draw the game over dialog and return button rectangles."""
    pygame.draw.rect(screen, DIALOG_COLOR, (dialog_x, dialog_y, DIALOG_WIDTH, DIALOG_HEIGHT)); pygame.draw.rect(screen, BLACK, (dialog_x, dialog_y, DIALOG_WIDTH, DIALOG_HEIGHT), 2)
    title_text = dialog_font.render(f"Game Over - {reason}", True, BLACK); p1_score_text = ui_font.render(f"{player_names[0]} Score: {final_scores[0]}", True, BLACK)
    p2_name_display = player_names[1] if player_names[1] else "Player 2"; p2_score_text = ui_font.render(f"{p2_name_display} Score: {final_scores[1]}", True, BLACK)
    save_text = button_font.render("Save (S)", True, BLACK); quit_text = button_font.render("Quit (Q)", True, BLACK); replay_text = button_font.render("Replay (R)", True, BLACK); play_again_text = button_font.render("Play Again (P)", True, BLACK); stats_text = button_font.render("Statistics", True, BLACK)
    screen.blit(title_text, (dialog_x + 10, dialog_y + 20)); screen.blit(p1_score_text, (dialog_x + 10, dialog_y + 60)); screen.blit(p2_score_text, (dialog_x + 10, dialog_y + 90))
    first_row_width = 3 * BUTTON_WIDTH + 2 * BUTTON_GAP; first_row_start_x = dialog_x + (DIALOG_WIDTH - first_row_width) // 2; second_row_width = 2 * BUTTON_WIDTH + BUTTON_GAP; second_row_start_x = dialog_x + (DIALOG_WIDTH - second_row_width) // 2
    save_rect = pygame.Rect(first_row_start_x, dialog_y + 150, BUTTON_WIDTH, BUTTON_HEIGHT); quit_rect = pygame.Rect(first_row_start_x + BUTTON_WIDTH + BUTTON_GAP, dialog_y + 150, BUTTON_WIDTH, BUTTON_HEIGHT); replay_rect = pygame.Rect(first_row_start_x + 2 * (BUTTON_WIDTH + BUTTON_GAP), dialog_y + 150, BUTTON_WIDTH, BUTTON_HEIGHT)
    play_again_rect = pygame.Rect(second_row_start_x, dialog_y + 190, BUTTON_WIDTH, BUTTON_HEIGHT); stats_rect = pygame.Rect(second_row_start_x + BUTTON_WIDTH + BUTTON_GAP, dialog_y + 190, BUTTON_WIDTH, BUTTON_HEIGHT)
    pygame.draw.rect(screen, BUTTON_COLOR, save_rect); pygame.draw.rect(screen, BUTTON_COLOR, quit_rect); pygame.draw.rect(screen, BUTTON_COLOR, replay_rect); pygame.draw.rect(screen, BUTTON_COLOR, play_again_rect); pygame.draw.rect(screen, BUTTON_COLOR, stats_rect)
    screen.blit(save_text, save_text.get_rect(center=save_rect.center)); screen.blit(quit_text, quit_text.get_rect(center=quit_rect.center)); screen.blit(replay_text, replay_text.get_rect(center=replay_rect.center)); screen.blit(play_again_text, play_again_text.get_rect(center=play_again_rect.center)); screen.blit(stats_text, stats_text.get_rect(center=stats_rect.center))
    return save_rect, quit_rect, replay_rect, play_again_rect, stats_rect

def draw_score_row(screen, dialog_x, y_pos, final_scores):
    """Draw the score row for the statistics dialog."""
    score_label = ui_font.render("Score:", True, BLACK); p1_score_text = ui_font.render(str(final_scores[0]), True, BLACK); p2_score_text = ui_font.render(str(final_scores[1]), True, BLACK)
    screen.blit(score_label, (dialog_x + 10, y_pos)); screen.blit(p1_score_text, (dialog_x + 120, y_pos)); screen.blit(p2_score_text, (dialog_x + 230, y_pos))

def calculate_moves_per_player(move_history):
    """Calculate the number of moves made by each player from move_history."""
    moves_count = {1: 0, 2: 0}
    for move in move_history:
        player = move['player']
        # --- CORRECTED INDENTATION START ---
        if move['move_type'] in ['place', 'pass', 'exchange']:
            moves_count[player] += 1
        # --- CORRECTED INDENTATION END ---
    return moves_count[1], moves_count[2]

def calculate_bingos_per_player(move_history):
    """Calculate the number of bingos played by each player."""
    bingo_count = {1: 0, 2: 0}
    for move in move_history:
        if move['move_type'] == 'place' and move.get('is_bingo', False): player = move['player']; bingo_count[player] += 1
    return bingo_count[1], bingo_count[2]

def calculate_bingo_avg_per_player(move_history):
    """Calculate the average score of bingos for each player."""
    bingo_scores = {1: [], 2: []}
    for move in move_history:
        if move['move_type'] == 'place' and move.get('is_bingo', False): player = move['player']; bingo_scores[player].append(move['score'])
    avg_p1 = sum(bingo_scores[1]) / len(bingo_scores[1]) if bingo_scores[1] else 0.0; avg_p2 = sum(bingo_scores[2]) / len(bingo_scores[2]) if bingo_scores[2] else 0.0
    return avg_p1, avg_p2

def draw_moves_row(screen, dialog_x, y_pos, moves_p1, moves_p2):
    """Draw the moves row for the statistics dialog."""
    moves_label = ui_font.render("Moves:", True, BLACK); p1_moves_text = ui_font.render(str(moves_p1), True, BLACK); p2_moves_text = ui_font.render(str(moves_p2), True, BLACK)
    screen.blit(moves_label, (dialog_x + 10, y_pos)); screen.blit(p1_moves_text, (dialog_x + 120, y_pos)); screen.blit(p2_moves_text, (dialog_x + 230, y_pos))

def draw_avg_score_row(screen, dialog_x, y_pos, avg_p1, avg_p2):
    """Draw the average score per move row for the statistics dialog."""
    avg_label = ui_font.render("Avg Score:", True, BLACK); p1_avg_text = ui_font.render(f"{avg_p1:.2f}", True, BLACK); p2_avg_text = ui_font.render(f"{avg_p2:.2f}", True, BLACK)
    screen.blit(avg_label, (dialog_x + 10, y_pos)); screen.blit(p1_avg_text, (dialog_x + 120, y_pos)); screen.blit(p2_avg_text, (dialog_x + 230, y_pos))

def draw_bingos_row(screen, dialog_x, y_pos, bingos_p1, bingos_p2):
    """Draw the bingos row for the statistics dialog."""
    bingos_label = ui_font.render("Bingos:", True, BLACK); p1_bingos_text = ui_font.render(str(bingos_p1), True, BLACK); p2_bingos_text = ui_font.render(str(bingos_p2), True, BLACK)
    screen.blit(bingos_label, (dialog_x + 10, y_pos)); screen.blit(p1_bingos_text, (dialog_x + 120, y_pos)); screen.blit(p2_bingos_text, (dialog_x + 230, y_pos))

def draw_bingo_avg_row(screen, dialog_x, y_pos, bingo_avg_p1, bingo_avg_p2, bingos_p1, bingos_p2):
    """Draw the average bingo score row."""
    bingo_avg_label = ui_font.render("Bingo Avg:", True, BLACK); p1_text = "N/A" if bingos_p1 == 0 else f"{bingo_avg_p1:.2f}"; p2_text = "N/A" if bingos_p2 == 0 else f"{bingo_avg_p2:.2f}"
    p1_bingo_avg_text = ui_font.render(p1_text, True, BLACK); p2_bingo_avg_text = ui_font.render(p2_text, True, BLACK)
    screen.blit(bingo_avg_label, (dialog_x + 10, y_pos)); screen.blit(p1_bingo_avg_text, (dialog_x + 120, y_pos)); screen.blit(p2_bingo_avg_text, (dialog_x + 230, y_pos))

def calculate_blanks_per_player(move_history):
    """Calculate the number of blanks played by each player."""
    blanks_p1 = 0; blanks_p2 = 0
    for move in move_history:
        if move['move_type'] == 'place': player = move['player']; blanks_count = len(move.get('blanks', set()))
        if player == 1: blanks_p1 += blanks_count
        elif player == 2: blanks_p2 += blanks_count
    return blanks_p1, blanks_p2

def draw_blanks_row(screen, dialog_x, y_pos, blanks_p1, blanks_p2):
    """Draw the blanks played row."""
    blanks_label = ui_font.render("Blanks:", True, BLACK); p1_blanks_text = ui_font.render(str(blanks_p1), True, BLACK); p2_blanks_text = ui_font.render(str(blanks_p2), True, BLACK)
    screen.blit(blanks_label, (dialog_x + 10, y_pos)); screen.blit(p1_blanks_text, (dialog_x + 120, y_pos)); screen.blit(p2_blanks_text, (dialog_x + 230, y_pos))

def draw_stats_dialog(dialog_x, dialog_y, player_names, final_scores, tiles):
    """Draw the complete statistics dialog."""
    stats_dialog_width, stats_dialog_height = 400, 360
    pygame.draw.rect(screen, DIALOG_COLOR, (dialog_x, dialog_y, stats_dialog_width, stats_dialog_height))
    pygame.draw.rect(screen, BLACK, (dialog_x, dialog_y, stats_dialog_width, stats_dialog_height), 2)

    title_text = dialog_font.render("Game Statistics", True, BLACK)
    screen.blit(title_text, (dialog_x + 10, dialog_y + 10))

    # Player Names Header
    p1_name_display = player_names[0] if player_names[0] else "Player 1"
    p2_name_display = player_names[1] if player_names[1] else "Player 2"
    p1_name_text = ui_font.render(p1_name_display, True, BLACK)
    p2_name_text = ui_font.render(p2_name_display, True, BLACK)
    screen.blit(p1_name_text, (dialog_x + 120, dialog_y + 40))
    screen.blit(p2_name_text, (dialog_x + 230, dialog_y + 40))

    # Calculate Stats
    moves_p1, moves_p2 = calculate_moves_per_player(move_history)
    avg_p1 = final_scores[0] / moves_p1 if moves_p1 > 0 else 0.00
    avg_p2 = final_scores[1] / moves_p2 if moves_p2 > 0 else 0.00
    bingos_p1, bingos_p2 = calculate_bingos_per_player(move_history)
    bingo_avg_p1, bingo_avg_p2 = calculate_bingo_avg_per_player(move_history)
    blanks_p1, blanks_p2 = calculate_blanks_per_player(move_history)

    # Draw Rows
    y = dialog_y + 70
    draw_score_row(screen, dialog_x, y, final_scores)
    y += 30
    draw_moves_row(screen, dialog_x, y, moves_p1, moves_p2)
    y += 30
    draw_avg_score_row(screen, dialog_x, y, avg_p1, avg_p2)
    y += 30
    draw_bingos_row(screen, dialog_x, y, bingos_p1, bingos_p2)
    y += 30
    draw_bingo_avg_row(screen, dialog_x, y, bingo_avg_p1, bingo_avg_p2, bingos_p1, bingos_p2)
    y += 30
    draw_blanks_row(screen, dialog_x, y, blanks_p1, blanks_p2)
    y += 30

    # OK Button
    ok_button_rect = pygame.Rect(dialog_x + stats_dialog_width - BUTTON_WIDTH - 10, dialog_y + stats_dialog_height - BUTTON_HEIGHT - 10, BUTTON_WIDTH, BUTTON_HEIGHT)
    hover = ok_button_rect.collidepoint(pygame.mouse.get_pos())
    color = BUTTON_HOVER if hover else BUTTON_COLOR
    pygame.draw.rect(screen, color, ok_button_rect)
    ok_text = button_font.render("OK", True, BLACK)
    ok_text_rect = ok_text.get_rect(center=ok_button_rect.center)
    screen.blit(ok_text, ok_text_rect)

    return ok_button_rect

def show_message_dialog(message, title="Message"):
    """Display a general message dialog with an OK button, wrapping text."""
    dialog_width, dialog_height = 400, 150; dialog_x = (WINDOW_WIDTH - dialog_width) // 2; dialog_y = (WINDOW_HEIGHT - dialog_height) // 2
    words = message.split(' '); lines = []; current_line = ''; max_line_width = dialog_width - 20
    for word in words: test_line = current_line + word + ' ';
    if ui_font.size(test_line)[0] < max_line_width: current_line = test_line
    else: lines.append(current_line.strip()); current_line = word + ' '
    if current_line: lines.append(current_line.strip())
    pygame.draw.rect(screen, DIALOG_COLOR, (dialog_x, dialog_y, dialog_width, dialog_height)); pygame.draw.rect(screen, BLACK, (dialog_x, dialog_y, dialog_width, dialog_height), 2)
    title_surf = dialog_font.render(title, True, BLACK); screen.blit(title_surf, (dialog_x + 10, dialog_y + 5))
    y_offset = 10 + dialog_font.get_linesize()
    for line in lines: text = ui_font.render(line, True, BLACK); screen.blit(text, (dialog_x + 10, dialog_y + y_offset)); y_offset += ui_font.get_linesize()
    ok_button_rect = pygame.Rect(dialog_x + dialog_width - BUTTON_WIDTH - 10, dialog_y + dialog_height - BUTTON_HEIGHT - 10, BUTTON_WIDTH, BUTTON_HEIGHT)
    hover = ok_button_rect.collidepoint(pygame.mouse.get_pos()); color = BUTTON_HOVER if hover else BUTTON_COLOR; pygame.draw.rect(screen, color, ok_button_rect)
    ok_text = button_font.render("OK", True, BLACK); ok_text_rect = ok_text.get_rect(center=ok_button_rect.center); screen.blit(ok_text, ok_text_rect)
    pygame.display.flip()
    dialog_running = True
    while dialog_running:
        for event in pygame.event.get():
            if event.type == pygame.QUIT: pygame.quit(); sys.exit()
            elif event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
                 if ok_button_rect.collidepoint(event.pos): return
            elif event.type == pygame.KEYDOWN:
                 if event.key == pygame.K_RETURN or event.key == pygame.K_KP_ENTER: return

def draw_practice_end_dialog(message):
    """Draw the dialog shown at the end of a practice puzzle."""
    dialog_width, dialog_height = 400, 180; dialog_x = (WINDOW_WIDTH - dialog_width) // 2; dialog_y = (WINDOW_HEIGHT - dialog_height) // 2
    pygame.draw.rect(screen, DIALOG_COLOR, (dialog_x, dialog_y, dialog_width, dialog_height)); pygame.draw.rect(screen, BLACK, (dialog_x, dialog_y, dialog_width, dialog_height), 2)
    words = message.split(' '); lines = []; current_line = ''; max_line_width = dialog_width - 20
    for word in words: test_line = current_line + word + ' ';
    if ui_font.size(test_line)[0] < max_line_width: current_line = test_line
    else: lines.append(current_line.strip()); current_line = word + ' '
    if current_line: lines.append(current_line.strip())
    y_offset = 15
    for line in lines: text_surf = ui_font.render(line, True, BLACK); screen.blit(text_surf, (dialog_x + 10, dialog_y + y_offset)); y_offset += ui_font.get_linesize()
    button_y = dialog_y + dialog_height - BUTTON_HEIGHT - 15; total_button_width = 3 * BUTTON_WIDTH + 2 * BUTTON_GAP; button_start_x = dialog_x + (dialog_width - total_button_width) // 2
    play_again_rect = pygame.Rect(button_start_x, button_y, BUTTON_WIDTH, BUTTON_HEIGHT); main_menu_rect = pygame.Rect(button_start_x + BUTTON_WIDTH + BUTTON_GAP, button_y, BUTTON_WIDTH, BUTTON_HEIGHT); quit_rect = pygame.Rect(button_start_x + 2 * (BUTTON_WIDTH + BUTTON_GAP), button_y, BUTTON_WIDTH, BUTTON_HEIGHT)
    pygame.draw.rect(screen, BUTTON_COLOR, play_again_rect); pygame.draw.rect(screen, BUTTON_COLOR, main_menu_rect); pygame.draw.rect(screen, BUTTON_COLOR, quit_rect)
    play_again_text = button_font.render("Play Again", True, BLACK); main_menu_text = button_font.render("Main Menu", True, BLACK); quit_text = button_font.render("Quit", True, BLACK)
    screen.blit(play_again_text, play_again_text.get_rect(center=play_again_rect.center)); screen.blit(main_menu_text, main_menu_text.get_rect(center=main_menu_rect.center)); screen.blit(quit_text, quit_text.get_rect(center=quit_rect.center))
    return play_again_rect, main_menu_rect, quit_rect

# End of Part 3

# Part 4 (Includes game logic helpers: get_words_played, remaining tiles, validation, anchors)
# get_words_played, get_remaining_tiles, draw_remaining_tiles, draw_arrow, is_valid_play, get_anchor_points (Unchanged from Part 4 provided previously)
def get_words_played(word_positions, tiles):
    """Get all word strings formed by a play based on tile positions."""
    if not word_positions: return []
    words_found = set(); rows_involved_list = []; cols_involved_list = []; valid_positions = True
    for item in word_positions:
        if isinstance(item, tuple) and len(item) >= 3: rows_involved_list.append(item[0]); cols_involved_list.append(item[1])
        else: print(f"Error in get_words_played: Invalid item format: {item}"); valid_positions = False; break
    if not valid_positions: return []
    rows_involved = set(rows_involved_list); cols_involved = set(cols_involved_list)
    if len(rows_involved) == 1: # Horizontal Check
        r = rows_involved.pop(); min_c = min(cols_involved_list); max_c = max(cols_involved_list)
        while min_c > 0 and tiles[r][min_c - 1]: min_c -= 1
        while max_c < GRID_SIZE - 1 and tiles[r][max_c + 1]: max_c += 1
        word_h = "".join(tiles[r][c] for c in range(min_c, max_c + 1) if tiles[r][c])
        if len(word_h) > 1: words_found.add(word_h)
    if len(cols_involved) == 1: # Vertical Check
        c = cols_involved.pop(); min_r = min(rows_involved_list); max_r = max(rows_involved_list)
        while min_r > 0 and tiles[min_r - 1][c]: min_r -= 1
        while max_r < GRID_SIZE - 1 and tiles[max_r + 1][c]: max_r += 1
        word_v = "".join(tiles[r][c] for r in range(min_r, max_r + 1) if tiles[r][c])
        if len(word_v) > 1: words_found.add(word_v)
    for r_new, c_new, _ in word_positions: # Cross Checks
        if len(rows_involved) == 1: # Vertical Cross
            min_r_cross = r_new; max_r_cross = r_new;
            while min_r_cross > 0 and tiles[min_r_cross - 1][c_new]: min_r_cross -= 1;
            while max_r_cross < GRID_SIZE - 1 and tiles[max_r_cross + 1][c_new]: max_r_cross += 1
            if max_r_cross > min_r_cross: cross_word_v = "".join(tiles[r][c_new] for r in range(min_r_cross, max_r_cross + 1) if tiles[r][c_new]);
            if len(cross_word_v) > 1: words_found.add(cross_word_v)
        if len(cols_involved) == 1: # Horizontal Cross
            min_c_cross = c_new; max_c_cross = c_new;
            while min_c_cross > 0 and tiles[r_new][min_c_cross - 1]: min_c_cross -= 1;
            while max_c_cross < GRID_SIZE - 1 and tiles[r_new][max_c_cross + 1]: max_c_cross += 1
            if max_c_cross > min_c_cross: cross_word_h = "".join(tiles[r_new][c] for c in range(min_c_cross, max_c_cross + 1) if tiles[r_new][c]);
            if len(cross_word_h) > 1: words_found.add(cross_word_h)
    return list(words_found)

def get_remaining_tiles(rack, tiles, blanks):
    """Calculate the remaining tiles (excluding those on board and current player's rack)."""
    remaining = {letter: count for letter, (count, _) in TILE_DISTRIBUTION.items()}
    rack_counter = Counter(rack)
    for tile, count in rack_counter.items():
        if tile in remaining: remaining[tile] -= count
    for r in range(GRID_SIZE):
        for c in range(GRID_SIZE):
            if tiles[r][c]:
                if (r, c) in blanks:
                    if ' ' in remaining: remaining[' '] -= 1
                else:
                    letter = tiles[r][c]
                    if letter in remaining: remaining[letter] -= 1
    for letter in remaining: remaining[letter] = max(0, remaining[letter])
    return remaining

def draw_remaining_tiles(remaining, turn):
    """Draw the list of remaining tiles."""
    global practice_mode
    if practice_mode == "eight_letter": return # Don't draw remaining tiles in this mode
    remaining_x = min(BOARD_SIZE + 70, WINDOW_WIDTH - 200);
    if remaining_x < BOARD_SIZE + 10: remaining_x = BOARD_SIZE + 10
    title_text = ui_font.render(f"P{turn}'s Unseen Tiles:", True, BLACK); screen.blit(title_text, (remaining_x, 10))
    y_pos = 40; col_width = 60; max_y = WINDOW_HEIGHT - 100; sorted_letters = sorted(remaining.keys()); current_col_x = remaining_x; items_in_col = 0; max_items_per_col = (max_y - y_pos) // 20
    if max_items_per_col <= 0: max_items_per_col = 1
    last_drawn_y = 40 # Initialize with starting y_pos in case list is empty
    last_drawn_col_x = remaining_x # Track the column x of the last item

    for letter in sorted_letters:
        count = remaining.get(letter, 0)
        if count > 0:
            display_letter = "?" if letter == " " else letter; text_str = f"{display_letter}: {count}"; text = tile_count_font.render(text_str, True, BLACK)
            if items_in_col >= max_items_per_col:
                y_pos = 40 # Reset y_pos for the new column
                current_col_x += col_width
                items_in_col = 0
            screen.blit(text, (current_col_x, y_pos))
            last_drawn_y = y_pos # Update the last drawn y position in the current column
            last_drawn_col_x = current_col_x # Update the column x
            y_pos += 20; items_in_col += 1

    # Calculate summary position directly below the last drawn item's position
    # Add the height of one line (20) to get the position below it, plus a small gap (e.g., 5)
    summary_y_start = last_drawn_y + 20 + 5
    # Ensure it doesn't go off screen
    summary_y_start = min(summary_y_start, max_y + 40) # Use max_y for clamping

    total_tiles = sum(remaining.values()); vowels = sum(remaining.get(letter, 0) for letter in 'AEIOU'); consonants = sum(remaining.get(letter, 0) for letter in remaining if letter.isalpha() and letter not in 'AEIOU '); blanks_rem = remaining.get(' ', 0)
    text1 = tile_count_font.render(f"Tiles remaining: {total_tiles}", True, BLACK); text2 = tile_count_font.render(f"V: {vowels}  C: {consonants}  B: {blanks_rem}", True, BLACK)

    # Align summary text x-coordinate with the start of the list columns
    summary_x = remaining_x
    screen.blit(text1, (summary_x, summary_y_start));
    screen.blit(text2, (summary_x, summary_y_start + 20)) # Draw second line below first

def draw_arrow(row, col, direction):
    """Draw an arrow indicating play direction."""
    center_x = 40 + col * SQUARE_SIZE + SQUARE_SIZE // 2; center_y = 40 + row * SQUARE_SIZE + SQUARE_SIZE // 2; arrow_length = SQUARE_SIZE * 0.4; arrow_width = SQUARE_SIZE * 0.2
    if direction == "right": pygame.draw.line(screen, ARROW_COLOR, (center_x - arrow_length / 2, center_y), (center_x + arrow_length / 2, center_y), 3); pygame.draw.polygon(screen, ARROW_COLOR, [(center_x + arrow_length / 2, center_y - arrow_width / 2), (center_x + arrow_length / 2, center_y + arrow_width / 2), (center_x + arrow_length / 2 + arrow_width, center_y)])
    elif direction == "down": pygame.draw.line(screen, ARROW_COLOR, (center_x, center_y - arrow_length / 2), (center_x, center_y + arrow_length / 2), 3); pygame.draw.polygon(screen, ARROW_COLOR, [(center_x - arrow_width / 2, center_y + arrow_length / 2), (center_x + arrow_width / 2, center_y + arrow_length / 2), (center_x, center_y + arrow_length / 2 + arrow_width)])

def is_valid_play(word_positions, tiles, is_first_play, initial_rack_size, original_tiles, rack):
    """Validate a potential play against game rules and dictionary."""
    # word_positions here is the list of newly placed tiles: [(r, c, letter), ...]
    if not word_positions:
        # print("DEBUG is_valid_play: No word_positions provided.")
        return False, False

    newly_placed_positions_coords = set((r, c) for r, c, _ in word_positions)
    if not newly_placed_positions_coords:
        # print("DEBUG is_valid_play: No new tiles identified.")
        return False, False # No new tiles placed

    # --- Alignment and Gap Checks (remain the same) ---
    rows = sorted(list(set(r for r, _, _ in word_positions))); cols = sorted(list(set(c for _, c, _ in word_positions)))
    is_horizontal = len(rows) == 1; is_vertical = len(cols) == 1
    if not (is_horizontal or is_vertical):
        # print(f"DEBUG is_valid_play: Not aligned. Rows: {rows}, Cols: {cols}")
        return False, False # Not aligned

    # Check for gaps within the main line of play
    if is_horizontal:
        r = rows[0]; min_col = min(cols); max_col = max(cols)
        # Extend bounds to include adjacent existing tiles
        temp_min_col = min_col; temp_max_col = max_col
        while temp_min_col > 0 and tiles[r][temp_min_col - 1]: temp_min_col -= 1
        while temp_max_col < GRID_SIZE - 1 and tiles[r][temp_max_col + 1]: temp_max_col += 1
        # Check for empty squares within these bounds
        for c in range(temp_min_col, temp_max_col + 1):
            if not tiles[r][c]:
                # print(f"DEBUG is_valid_play: Gap found horizontally at ({r},{c})")
                return False, False # Gap found
    elif is_vertical:
        c = cols[0]; min_row = min(rows); max_row = max(rows)
        # Extend bounds
        temp_min_row = min_row; temp_max_row = max_row
        while temp_min_row > 0 and tiles[temp_min_row - 1][c]: temp_min_row -= 1
        while temp_max_row < GRID_SIZE - 1 and tiles[temp_max_row + 1][c]: temp_max_row += 1
        # Check for gaps
        for r in range(temp_min_row, temp_max_row + 1):
            if not tiles[r][c]:
                # print(f"DEBUG is_valid_play: Gap found vertically at ({r},{c})")
                return False, False # Gap found

    # --- Word Validity Check (Use find_all_words_formed) ---
    # Use the more robust function to find all words based on the newly placed tiles
    # It correctly handles single-tile placements forming cross-words.
    all_words_details = find_all_words_formed(word_positions, tiles)

    if not all_words_details:
         # This might happen if only a single letter was placed and it didn't connect
         # to form any word of length 2+ (already checked by connection rule below)
         # Or if find_all_words_formed has a bug.
         # Let's assume connection rule handles the first case.
         # If this triggers otherwise, it indicates an issue.
         # print(f"DEBUG is_valid_play: find_all_words_formed returned empty list for {word_positions}")
         # We might need a connection check *before* this word check?
         pass # Continue to connection check

    formed_word_strings = ["".join(tile[2] for tile in word_detail) for word_detail in all_words_details]

    if not formed_word_strings and len(word_positions) > 1: # If multiple tiles placed but no words formed -> invalid
         # print(f"DEBUG is_valid_play: Multiple tiles placed but no words formed: {word_positions}")
         return False, False

    # Check each formed word string against the DAWG
    for word in formed_word_strings:
        if not DAWG.search(word):
            # print(f"DEBUG is_valid_play: Word '{word}' not in DAWG.")
            return False, False # Word not in dictionary

    # --- Connection Rules Check (remain the same) ---
    if is_first_play:
        if CENTER_SQUARE not in newly_placed_positions_coords:
            # print("DEBUG is_valid_play: First play not on center square.")
            return False, False
    else:
        connects = False
        for r, c in newly_placed_positions_coords:
            for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < GRID_SIZE and 0 <= nc < GRID_SIZE and original_tiles[nr][nc]:
                    connects = True; break
            if connects: break
        if not connects:
            # print("DEBUG is_valid_play: Play does not connect to existing tiles.")
            return False, False

    # --- Bingo Check (remains the same) ---
    tiles_played_from_rack = len(newly_placed_positions_coords)
    is_bingo = (initial_rack_size == 7 and tiles_played_from_rack == 7)

    # If all checks passed
    return True, is_bingo

def get_anchor_points(tiles, is_first_play):
    """Get anchor points (empty squares adjacent to existing tiles) for valid moves."""
    anchors = set()
    if is_first_play: anchors.add(CENTER_SQUARE); return anchors
    has_tiles = False
    for r in range(GRID_SIZE):
        for c in range(GRID_SIZE):
            if tiles[r][c]: has_tiles = True # Check if board has any tiles
            if not tiles[r][c]: # Must be an empty square
                 is_anchor = False
                 for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
                     nr, nc = r + dr, c + dc
                     if 0 <= nr < GRID_SIZE and 0 <= nc < GRID_SIZE and tiles[nr][nc]: is_anchor = True; break
                 if is_anchor: anchors.add((r, c))
    if not has_tiles and not is_first_play: anchors.add(CENTER_SQUARE) # Fallback if board empty but not first play
    return anchors

# End of Part 4

# python
# MODIFIED: 01APR24 - Implementing 8-Letter Bingo Practice Mode Fixes (Part 5 - Corrected Attribute Name)

# Part 5

# --- NEW Move Generation (Based on kamilmielnik/scrabble-solver principles) ---
# --- NEW Move Generation (Based on kamilmielnik/scrabble-solver principles - REVISED) ---

# --- GADDAG-Based Move Generation (Replaces generate_valid_moves_new) ---

# --- GADDAG-Based Move Generation (Replaces generate_valid_moves_new and its helpers) ---

# --- GADDAG-Based Move Generation (Replaces generate_valid_moves_new and its helpers) ---

# --- GADDAG-Based Move Generation (Replaces generate_valid_moves_new and its helpers) ---

# Function to Modify: _gaddag_traverse (Refined post-separator logic)

def _gaddag_traverse(
    anchor_pos, rack_counts, tiles, board, blanks, cross_check_sets, gaddag_node,
    current_word_tiles, is_reversed, current_axis, all_found_moves, unique_move_signatures,
    original_tiles_state, is_first_play, full_rack_size, max_len=GRID_SIZE,
    depth=0
):
    """ Recursive helper with refined post-separator logic """
    # Limit recursion depth for safety and logging
    if depth > 20: return

    # --- Base Cases and Pruning ---
    if not current_word_tiles: return
    if len(current_word_tiles) > max_len: return

    # Get the last tile added for step calculation (but might need anchor later)
    r_last, c_last, _, _, _ = current_word_tiles[-1]

    # --- Check if current path forms a valid move ---
    # (Validation logic remains the same as previous version with diagnostic prints)
    if gaddag_node.is_terminal and not is_reversed:
        # ... (validation code identical to previous response) ...
        # Find newly placed tiles
        newly_placed_list_details = [(r, c, l) for r, c, l, _, is_new in current_word_tiles if is_new]
        if newly_placed_list_details:
            new_tiles_sig = tuple(sorted(newly_placed_list_details))
            if new_tiles_sig not in unique_move_signatures:
                # Simulate placement for validation
                temp_tiles = [row[:] for row in original_tiles_state]
                temp_blanks = set(blanks); move_blanks_coords = set(); newly_placed_coords = set()
                for r, c, letter, is_blank, is_new in current_word_tiles:
                    if is_new:
                        if 0 <= r < GRID_SIZE and 0 <= c < GRID_SIZE:
                            temp_tiles[r][c] = letter; newly_placed_coords.add((r, c))
                            if is_blank: temp_blanks.add((r, c)); move_blanks_coords.add((r, c))

                # Use the ORIGINAL is_valid_play now (remove diagnostic version)
                is_valid, is_bingo = is_valid_play(newly_placed_list_details, temp_tiles, is_first_play, full_rack_size, original_tiles_state, rack_counts) # Pass original_tiles_state

                if is_valid:
                    unique_move_signatures.add(new_tiles_sig) # Mark as found
                    score = calculate_score(newly_placed_list_details, board, temp_tiles, temp_blanks)
                    all_words_formed_details = find_all_words_formed(newly_placed_list_details, temp_tiles)
                    # ... (rest of move detail extraction identical to previous response) ...
                    primary_word_tiles = []; primary_word_str = ""; start_pos = (0, 0); orientation = current_axis
                    if all_words_formed_details:
                        # ... (primary word finding logic) ...
                         found_primary = False
                         for word_detail in all_words_formed_details:
                             is_along_axis = False
                             if orientation == 'H' and len(set(r for r,c,l in word_detail)) == 1: is_along_axis = True
                             elif orientation == 'V' and len(set(c for r,c,l in word_detail)) == 1: is_along_axis = True
                             if is_along_axis and any((t[0], t[1]) in newly_placed_coords for t in word_detail):
                                 primary_word_tiles = word_detail; found_primary = True; break
                         if not found_primary: # Fallback
                              for word_detail in all_words_formed_details:
                                  if any((t[0], t[1]) in newly_placed_coords for t in word_detail):
                                       primary_word_tiles = word_detail
                                       if len(set(r for r,c,l in primary_word_tiles)) == 1: orientation = 'H'
                                       elif len(set(c for r,c,l in primary_word_tiles)) == 1: orientation = 'V'
                                       break
                         if not primary_word_tiles and all_words_formed_details: # Extreme fallback
                              primary_word_tiles = all_words_formed_details[0]
                              if len(set(r for r,c,l in primary_word_tiles)) == 1: orientation = 'H'
                              elif len(set(c for r,c,l in primary_word_tiles)) == 1: orientation = 'V'

                         if primary_word_tiles: # Check added
                             primary_word_str = "".join(t[2] for t in primary_word_tiles)
                             start_pos = (primary_word_tiles[0][0], primary_word_tiles[0][1])
                    # ... (word_with_blanks formatting) ...
                    word_with_blanks_list = []
                    for wr, wc, w_letter in primary_word_tiles:
                        is_blank_in_word = (wr, wc) in newly_placed_coords and (wr, wc) in move_blanks_coords
                        word_with_blanks_list.append(w_letter.lower() if is_blank_in_word else w_letter.upper())
                    word_with_blanks = "".join(word_with_blanks_list)
                    leave = list(rack_counts.elements()) # Current rack count is the leave
                    # ... (store move details) ...
                    move_details_dict = {
                        'positions': [(t[0], t[1], t[2]) for t in primary_word_tiles], 'blanks': move_blanks_coords,
                        'word': primary_word_str, 'score': score, 'start': start_pos, 'direction': orientation,
                        'leave': leave, 'is_bingo': is_bingo, 'word_with_blanks': word_with_blanks,
                        'newly_placed': newly_placed_list_details
                    }
                    all_found_moves.append(move_details_dict)


    # --- Explore Next Steps ---
    for letter, next_node in gaddag_node.children.items():
        if letter == Gaddag.SEPARATOR:
            if is_reversed:
                # When crossing the separator, the *anchor position* becomes the reference
                # for the next step calculation in the forward direction.
                # We pass the anchor_pos implicitly; the logic needs to use it.
                # We pass current_word_tiles as is, because it contains the history.
                _gaddag_traverse(
                    anchor_pos, rack_counts, tiles, board, blanks, cross_check_sets,
                    next_node, current_word_tiles, False, current_axis, # Switch is_reversed
                    all_found_moves, unique_move_signatures, original_tiles_state,
                    is_first_play, full_rack_size, max_len, depth + 1
                )
            continue # Move to next child

        # Determine next coordinates
        next_r, next_c = -1, -1
        if is_reversed:
             # Moving backward from the last placed tile (r_last, c_last)
            if current_axis == 'H': next_r, next_c = r_last, c_last - 1 # Left
            else:                   next_r, next_c = r_last - 1, c_last # Up
        else: # Moving forward
            # **** CORRECTED LOGIC ****
            # If current_word_tiles only contains the anchor tile (or tiles placed *before* it),
            # the first step *forward* must be relative to the anchor_pos.
            # Otherwise, step forward from the last placed tile (r_last, c_last).

            # Check if the anchor position is the last element added *or* if all tiles were placed before anchor
            # A simple check: is the anchor position the first tile in our list (and maybe the only one)?
            # A better check: find the tile actually placed *on* the anchor square.
            anchor_r, anchor_c = anchor_pos
            tile_on_anchor = None
            for t_r, t_c, t_l, t_b, t_n in current_word_tiles:
                 if t_r == anchor_r and t_c == anchor_c:
                      tile_on_anchor = (t_r, t_c)
                      break

            # If we haven't placed anything *after* the anchor yet, step from the anchor
            # This happens immediately after crossing the separator.
            # How to detect this? If the last tile added IS the tile_on_anchor
            # or if all tiles were added when is_reversed was True?
            # Let's use the anchor_pos directly as the reference point
            # for the first step in the forward direction.

            # Heuristic: If the last tile's coordinates are the same as the anchor,
            # then the next step must be the first step *away* from the anchor.
            # What if multiple tiles were placed reversed? The last tile isn't the anchor.
            # --> Need a robust way to know if we are taking the *first* step forward.

            # Let's track if we JUST crossed the separator. A simple way is if the last tile
            # added was before or at the anchor point based on axis and anchor coords.
            just_crossed_separator = False
            if len(current_word_tiles) > 0:
                if current_axis == 'H':
                    if c_last <= anchor_c: just_crossed_separator = True
                else: # Vertical
                    if r_last <= anchor_r: just_crossed_separator = True

            # Use anchor as reference ONLY if we just crossed separator, otherwise use last tile
            ref_r, ref_c = (anchor_r, anchor_c) if just_crossed_separator else (r_last, c_last)

            if current_axis == 'H': next_r, next_c = ref_r, ref_c + 1 # Move right
            else:                   next_r, next_c = ref_r + 1, ref_c # Move down
            # **** END CORRECTED LOGIC ****


        # Bounds check
        if not (0 <= next_r < GRID_SIZE and 0 <= next_c < GRID_SIZE): continue

        next_pos = (next_r, next_c)
        existing_tile = tiles[next_r][next_c]

        # Case 1: Square is empty
        # (Rest of logic for placing rack/blank or using existing tile remains the same)
        if not existing_tile:
            cross_axis = 'V' if current_axis == 'H' else 'H'
            allowed_letters = cross_check_sets.get(next_pos, {}).get(cross_axis, set())
            # Option 1a: Use regular tile
            if rack_counts[letter] > 0 and letter in allowed_letters:
                new_rack_counts = rack_counts.copy(); new_rack_counts[letter] -= 1
                if new_rack_counts[letter] == 0: del new_rack_counts[letter]
                _gaddag_traverse(
                    anchor_pos, new_rack_counts, tiles, board, blanks, cross_check_sets,
                    next_node, current_word_tiles + [(next_r, next_c, letter, False, True)],
                    is_reversed, current_axis, all_found_moves, unique_move_signatures,
                    original_tiles_state, is_first_play, full_rack_size, max_len, depth + 1
                )
            # Option 1b: Use blank tile
            if rack_counts[' '] > 0 and ' ' in allowed_letters:
                new_rack_counts = rack_counts.copy(); new_rack_counts[' '] -= 1
                if new_rack_counts[' '] == 0: del new_rack_counts[' ']
                _gaddag_traverse(
                    anchor_pos, new_rack_counts, tiles, board, blanks, cross_check_sets,
                    next_node, current_word_tiles + [(next_r, next_c, letter, True, True)],
                    is_reversed, current_axis, all_found_moves, unique_move_signatures,
                    original_tiles_state, is_first_play, full_rack_size, max_len, depth + 1
                )
        # Case 2: Square has matching existing tile
        elif existing_tile == letter:
            _gaddag_traverse(
                anchor_pos, rack_counts, tiles, board, blanks, cross_check_sets,
                next_node, current_word_tiles + [(next_r, next_c, letter, False, False)],
                is_reversed, current_axis, all_found_moves, unique_move_signatures,
                original_tiles_state, is_first_play, full_rack_size, max_len, depth + 1
            )

# Function to Replace: generate_all_moves_gaddag
# REASON: Includes corrected initiation logic for Strategy 2 (essential for general cases)
#         and reviewed logic for Strategy 1 (intended to handle first play).

def generate_all_moves_gaddag(rack, tiles, board, blanks, gaddag_root):
    """
    Generates ALL valid Scrabble moves using GADDAG traversal.
    Initiates the traversal from anchor points and adjacent existing tiles.
    Includes corrected Strategy 2 initiation.
    """
    print(f"--- generate_all_moves_gaddag called. Rack: {''.join(sorted(rack))} ---") # Sort rack for consistent logging
    if not gaddag_root:
        print("ERROR: GADDAG structure not loaded.")
        return []

    all_found_moves = []
    unique_move_signatures = set() # Tracks signatures (new_r, new_c, new_l) to avoid adding identical plays
    rack_counts = Counter(rack)
    is_first_play = sum(1 for row in tiles for t in row if t) == 0
    anchors = get_anchor_points(tiles, is_first_play)
    print(f"--- generate_all_moves_gaddag: Found anchors: {anchors} ---")
    original_tiles_state = [row[:] for row in tiles] # Keep a safe copy
    full_rack_size = len(rack) # Needed for bingo check

    # --- Precompute Cross-Check Sets ---
    print("--- generate_all_moves_gaddag: Generating cross-check sets... ---")
    cross_check_sets = {}
    for r in range(GRID_SIZE):
        for c in range(GRID_SIZE):
            if not tiles[r][c]: # Only needed for empty squares
                # Check Vertical context
                up_word = ""; rr = r - 1
                while rr >= 0 and tiles[rr][c]: up_word = tiles[rr][c] + up_word; rr -= 1
                down_word = ""; rr = r + 1
                while rr < GRID_SIZE and tiles[rr][c]: down_word += tiles[rr][c]; rr += 1
                allowed_letters_v = set()
                if not up_word and not down_word: allowed_letters_v = set('ABCDEFGHIJKLMNOPQRSTUVWXYZ ')
                else:
                    for letter in 'ABCDEFGHIJKLMNOPQRSTUVWXYZ':
                        if DAWG.search(up_word + letter + down_word): allowed_letters_v.add(letter)
                    if allowed_letters_v: allowed_letters_v.add(' ')

                # Check Horizontal context
                left_word = ""; cc = c - 1
                while cc >= 0 and tiles[r][cc]: left_word = tiles[r][cc] + left_word; cc -= 1
                right_word = ""; cc = c + 1
                while cc < GRID_SIZE and tiles[r][cc]: right_word += tiles[r][cc]; cc += 1
                allowed_letters_h = set()
                if not left_word and not right_word: allowed_letters_h = set('ABCDEFGHIJKLMNOPQRSTUVWXYZ ')
                else:
                    for letter in 'ABCDEFGHIJKLMNOPQRSTUVWXYZ':
                        if DAWG.search(left_word + letter + right_word): allowed_letters_h.add(letter)
                    if allowed_letters_h: allowed_letters_h.add(' ')

                cross_check_sets[(r, c)] = {'V': allowed_letters_v, 'H': allowed_letters_h}
    print("--- generate_all_moves_gaddag: Cross-check sets generated. ---")

    # --- Initiate Traversal from Each Anchor ---
    print("--- generate_all_moves_gaddag: Starting traversal... ---")
    processed_adjacent_starts = set() # Prevent redundant starts *from the same adjacent tile* for different anchors

    for r_anchor, c_anchor in anchors:
        anchor_pos = (r_anchor, c_anchor)

        # --- Strategy 1: Place the first letter *on* the anchor square itself ---
        # This is the primary strategy for the first move of the game.
        allowed_h = cross_check_sets.get(anchor_pos, {}).get('H', set())
        allowed_v = cross_check_sets.get(anchor_pos, {}).get('V', set())
        # Try placing regular tiles from rack onto the anchor
        for tile_letter, count in list(rack_counts.items()):
            if count > 0 and tile_letter != ' ':
                if tile_letter in gaddag_root.children:
                    next_node = gaddag_root.children[tile_letter]
                    # Create a fresh copy for each starting path
                    new_rack_counts = rack_counts.copy(); new_rack_counts[tile_letter] -= 1
                    if new_rack_counts[tile_letter] == 0: del new_rack_counts[tile_letter]
                    initial_tiles = [(r_anchor, c_anchor, tile_letter, False, True)]
                    # Initiate HORIZONTAL exploration (checks Vertical cross-check)
                    if tile_letter in allowed_v:
                         # Pass a copy of the rack counter
                         _gaddag_traverse(anchor_pos, new_rack_counts.copy(), tiles, board, blanks, cross_check_sets, next_node, initial_tiles, True, 'H', all_found_moves, unique_move_signatures, original_tiles_state, is_first_play, full_rack_size)
                    # Initiate VERTICAL exploration (checks Horizontal cross-check)
                    if tile_letter in allowed_h:
                         # Pass a copy of the rack counter
                         _gaddag_traverse(anchor_pos, new_rack_counts.copy(), tiles, board, blanks, cross_check_sets, next_node, initial_tiles, True, 'V', all_found_moves, unique_move_signatures, original_tiles_state, is_first_play, full_rack_size)
        # Try placing a blank tile from rack onto the anchor
        if rack_counts[' '] > 0:
            if ' ' in allowed_h and ' ' in allowed_v:
                # Create a base rack count with blank removed
                new_rack_counts_blank_base = rack_counts.copy(); new_rack_counts_blank_base[' '] -= 1
                if new_rack_counts_blank_base[' '] == 0: del new_rack_counts_blank_base[' ']

                for assigned_letter in 'ABCDEFGHIJKLMNOPQRSTUVWXYZ':
                    if assigned_letter in gaddag_root.children:
                        next_node = gaddag_root.children[assigned_letter]
                        initial_tiles = [(r_anchor, c_anchor, assigned_letter, True, True)]
                        # Initiate HORIZONTAL exploration
                        # Pass a copy for this branch
                        _gaddag_traverse(anchor_pos, new_rack_counts_blank_base.copy(), tiles, board, blanks, cross_check_sets, next_node, initial_tiles, True, 'H', all_found_moves, unique_move_signatures, original_tiles_state, is_first_play, full_rack_size)
                        # Initiate VERTICAL exploration
                        # Pass a copy for this branch
                        _gaddag_traverse(anchor_pos, new_rack_counts_blank_base.copy(), tiles, board, blanks, cross_check_sets, next_node, initial_tiles, True, 'V', all_found_moves, unique_move_signatures, original_tiles_state, is_first_play, full_rack_size)


        # --- Strategy 2: Start traversal from an *existing* tile adjacent to the anchor ---
        # This strategy only applies if not the first play (anchors != {(7,7)})
        if not is_first_play:
            for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]: # Check N, S, W, E neighbors
                nr, nc = r_anchor + dr, c_anchor + dc
                adj_pos = (nr, nc) # Position of the adjacent tile

                if 0 <= nr < GRID_SIZE and 0 <= nc < GRID_SIZE:
                    existing_tile_letter = tiles[nr][nc]
                    # Check if it's an existing tile AND we haven't already started traversals from this specific tile position
                    if existing_tile_letter and adj_pos not in processed_adjacent_starts:
                         # Mark this adjacent tile as processed FOR THIS generate_all_moves call
                         # to avoid redundant work if it's adjacent to multiple anchors.
                         processed_adjacent_starts.add(adj_pos)

                         if existing_tile_letter in gaddag_root.children:
                            next_node = gaddag_root.children[existing_tile_letter]
                            initial_tiles = [(nr, nc, existing_tile_letter, False, False)] # Existing tile is not blank, not new

                            # Determine the axis based on the direction *from* the existing tile *to* the anchor
                            start_axis = None
                            if dr != 0: start_axis = 'V' # Moved vertically to anchor, so word axis is Vertical
                            else:       start_axis = 'H' # Moved horizontally to anchor, so word axis is Horizontal

                            # **** Explore both directions from the adjacent tile ****
                            # Explore FORWARDS (away from existing tile, past the anchor)
                            _gaddag_traverse(
                                anchor_pos, rack_counts.copy(), tiles, board, blanks, cross_check_sets, # Pass copy of rack_counts
                                next_node, initial_tiles[:], False, start_axis, # is_reversed = False
                                all_found_moves, unique_move_signatures, original_tiles_state,
                                is_first_play, full_rack_size
                            )
                            # Explore BACKWARDS (towards where the existing tile came from - effectively extending the other way)
                            _gaddag_traverse(
                                anchor_pos, rack_counts.copy(), tiles, board, blanks, cross_check_sets, # Pass copy of rack_counts
                                next_node, initial_tiles[:], True, start_axis, # is_reversed = True
                                all_found_moves, unique_move_signatures, original_tiles_state,
                                is_first_play, full_rack_size
                            )


    print(f"--- generate_all_moves_gaddag: Traversal complete. Found {len(all_found_moves)} potential moves before sorting/final check. ---")

    # --- Post-processing ---
    all_found_moves.sort(key=lambda m: m['score'], reverse=True)
    final_unique_moves = []
    seen_final_signatures = set()
    for move in all_found_moves:
        # Signature includes sorted new tiles tuple + score
        sig_tuple = tuple(sorted(move['newly_placed'])) + (move['score'],)
        if sig_tuple not in seen_final_signatures:
            final_unique_moves.append(move)
            seen_final_signatures.add(sig_tuple)

    print(f"--- generate_all_moves_gaddag: Returning {len(final_unique_moves)} unique moves. ---")
    return final_unique_moves


# Corrected snippet for Part 5 - draw_hint_dialog

# --- Hint Dialog ---
def draw_hint_dialog(moves, selected_index):
    """Draw the hint dialog showing top 5 moves."""
    dialog_width, dialog_height = 400, 250
    dialog_x = (WINDOW_WIDTH - dialog_width) // 2
    dialog_y = (WINDOW_HEIGHT - dialog_height) // 2

    pygame.draw.rect(screen, DIALOG_COLOR, (dialog_x, dialog_y, dialog_width, dialog_height))
    pygame.draw.rect(screen, BLACK, (dialog_x, dialog_y, dialog_width, dialog_height), 2)

    title_text = dialog_font.render("Top 5 Moves" if moves else "No Moves Available", True, BLACK)
    screen.blit(title_text, (dialog_x + 10, dialog_y + 10))

    hint_rects = []
    y_pos = dialog_y + 40
    for i, move in enumerate(moves[:5]):
        color = HINT_SELECTED_COLOR if i == selected_index else HINT_NORMAL_COLOR
        rect = pygame.Rect(dialog_x + 10, y_pos, dialog_width - 20, 30)
        pygame.draw.rect(screen, color, rect)

        word = move.get('word', 'N/A')
        score = move.get('score', 0)
        start_pos = move.get('start', (0,0))
        direction = move.get('direction', 'right')
        leave = move.get('leave', [])
        word_display = move.get('word_with_blanks', word.upper()) # Use formatted word
        coord = get_coord(start_pos, direction)
        leave_str = ''.join(sorted(l if l != ' ' else '?' for l in leave))

        text_str = f"{i+1}. {word_display} ({score} pts) at {coord} ({leave_str})"
        text = ui_font.render(text_str, True, BLACK)

        # Truncate text if too wide
        max_text_width = rect.width - 10
        if text.get_width() > max_text_width:
             avg_char_width = text.get_width() / len(text_str) if len(text_str) > 0 else 10
             # Ensure avg_char_width is not zero to avoid division error
             if avg_char_width > 0:
                 max_chars = int(max_text_width / avg_char_width) - 3 # Calculate max_chars
                 # --- CORRECTED INDENTATION START ---
                 if max_chars < 5: # Check if max_chars is too small
                     max_chars = 5
                 text_str = text_str[:max_chars] + "..." # Truncate and add ellipsis
                 text = ui_font.render(text_str, True, BLACK) # Re-render the truncated text
                 # --- CORRECTED INDENTATION END ---
             # else: # Handle case where avg_char_width is 0 (e.g., empty text_str) - text won't be truncated anyway
             #    pass

        screen.blit(text, (dialog_x + 15, y_pos + 5))
        hint_rects.append(rect)
        y_pos += 30

    # Buttons
    button_y = dialog_y + dialog_height - BUTTON_HEIGHT - 10
    total_button_width = 3 * BUTTON_WIDTH + 2 * BUTTON_GAP
    button_start_x = dialog_x + (dialog_width - total_button_width) // 2

    play_button_rect = pygame.Rect(button_start_x, button_y, BUTTON_WIDTH, BUTTON_HEIGHT)
    all_words_button_rect = pygame.Rect(button_start_x + BUTTON_WIDTH + BUTTON_GAP, button_y, BUTTON_WIDTH, BUTTON_HEIGHT)
    ok_button_rect = pygame.Rect(button_start_x + 2 * (BUTTON_WIDTH + BUTTON_GAP), button_y, BUTTON_WIDTH, BUTTON_HEIGHT)

    # Draw buttons
    pygame.draw.rect(screen, BUTTON_COLOR, play_button_rect)
    pygame.draw.rect(screen, BUTTON_COLOR, all_words_button_rect)
    pygame.draw.rect(screen, BUTTON_COLOR, ok_button_rect)

    play_text = button_font.render("Play", True, BLACK)
    all_words_text = button_font.render("All Words", True, BLACK)
    ok_text = button_font.render("OK", True, BLACK)

    screen.blit(play_text, play_text.get_rect(center=play_button_rect.center))
    screen.blit(all_words_text, all_words_text.get_rect(center=all_words_button_rect.center))
    screen.blit(ok_text, ok_text.get_rect(center=ok_button_rect.center))

    return hint_rects, play_button_rect, ok_button_rect, all_words_button_rect

# End of Part 5

# python
# MODIFIED: 01APR24 - Implementing 8-Letter Bingo Practice Mode Fixes (Part 6)

# python
# MODIFIED: 01APR24 - Implementing 8-Letter Bingo Practice Mode Fixes (Part 6 - Corrected Function Call)

# Part 6

def draw_all_words_dialog(moves, selected_index, scroll_offset):
    """Draw the dialog showing all valid moves with scrolling."""
    dialog_x = (WINDOW_WIDTH - ALL_WORDS_DIALOG_WIDTH) // 2; dialog_y = (WINDOW_HEIGHT - ALL_WORDS_DIALOG_HEIGHT) // 2
    pygame.draw.rect(screen, DIALOG_COLOR, (dialog_x, dialog_y, ALL_WORDS_DIALOG_WIDTH, ALL_WORDS_DIALOG_HEIGHT)); pygame.draw.rect(screen, BLACK, (dialog_x, dialog_y, ALL_WORDS_DIALOG_WIDTH, ALL_WORDS_DIALOG_HEIGHT), 2)
    header_height = 40; unique_words_count = len(set(move.get('word', '') for move in moves if move.get('word'))); title_text = dialog_font.render(f"All Valid Moves ({unique_words_count} unique words, {len(moves)} plays)", True, BLACK); screen.blit(title_text, (dialog_x + 10, dialog_y + 10))
    content_area_y = dialog_y + header_height; button_area_height = BUTTON_HEIGHT + 30; content_area_height = ALL_WORDS_DIALOG_HEIGHT - header_height - button_area_height; content_area_rect = pygame.Rect(dialog_x, content_area_y, ALL_WORDS_DIALOG_WIDTH, content_area_height)
    content_height = len(moves) * 30; content_surface_width = max(1, ALL_WORDS_DIALOG_WIDTH - 20); content_surface = pygame.Surface((content_surface_width, content_height)); content_surface.fill(DIALOG_COLOR)
    all_words_rects = []; item_height = 30
    for i, move in enumerate(moves):
        y_pos_on_surface = i * item_height
        if y_pos_on_surface >= scroll_offset - item_height and y_pos_on_surface < scroll_offset + content_area_height:
            color = HINT_SELECTED_COLOR if i == selected_index else HINT_NORMAL_COLOR; rect_on_surface = pygame.Rect(10, y_pos_on_surface, content_surface_width - 20, item_height); pygame.draw.rect(content_surface, color, rect_on_surface)
            word = move.get('word', 'N/A'); score = move.get('score', 0); start_pos = move.get('start', (0,0)); direction = move.get('direction', 'right'); leave = move.get('leave', []); word_display = move.get('word_with_blanks', word.upper())
            coord = get_coord(start_pos, direction); leave_str = ''.join(sorted(l if l != ' ' else '?' for l in leave)); text_str = f"{i+1}. {word_display} ({score} pts) at {coord} ({leave_str})"; text = ui_font.render(text_str, True, BLACK)
            max_text_width = rect_on_surface.width - 10 # Truncate text

            # --- CORRECTED INDENTATION BLOCK START ---
            if text.get_width() > max_text_width:
                avg_char_width = text.get_width() / len(text_str) if len(text_str) > 0 else 10
                if avg_char_width > 0:
                    max_chars = int(max_text_width / avg_char_width) - 3
                    if max_chars < 5: max_chars = 5 # Ensure at least a few chars show
                    text_str = text_str[:max_chars] + "..."
                    text = ui_font.render(text_str, True, BLACK) # Re-render truncated text
                # else: # Handle case where avg_char_width is 0 (e.g., empty text_str) - text won't be truncated anyway
                #    pass
            # --- CORRECTED INDENTATION BLOCK END ---

            content_surface.blit(text, (15, y_pos_on_surface + 5))
            screen_y = content_area_y + y_pos_on_surface - scroll_offset; screen_rect = pygame.Rect(dialog_x + 10, screen_y, content_surface_width - 20, item_height)
            visible_top = content_area_y; visible_bottom = content_area_y + content_area_height; clipped_top = max(visible_top, screen_rect.top); clipped_bottom = min(visible_bottom, screen_rect.bottom)
            if clipped_bottom > clipped_top: clipped_rect = pygame.Rect(screen_rect.left, clipped_top, screen_rect.width, clipped_bottom - clipped_top); all_words_rects.append((clipped_rect, i))

    visible_area_on_surface = pygame.Rect(0, scroll_offset, content_surface_width, content_area_height); screen.blit(content_surface, (dialog_x + 10, content_area_y), visible_area_on_surface)
    pygame.draw.rect(screen, BLACK, (dialog_x + 10, content_area_y, content_surface_width, content_area_height), 1) # Optional border
    total_button_width = 2 * BUTTON_WIDTH + BUTTON_GAP; buttons_x = dialog_x + (ALL_WORDS_DIALOG_WIDTH - total_button_width) // 2; button_y = dialog_y + ALL_WORDS_DIALOG_HEIGHT - BUTTON_HEIGHT - 20
    play_button_rect = pygame.Rect(buttons_x, button_y, BUTTON_WIDTH, BUTTON_HEIGHT); ok_button_rect = pygame.Rect(buttons_x + BUTTON_WIDTH + BUTTON_GAP, button_y, BUTTON_WIDTH, BUTTON_HEIGHT)
    pygame.draw.rect(screen, BUTTON_COLOR, play_button_rect); pygame.draw.rect(screen, BUTTON_COLOR, ok_button_rect)
    play_text = button_font.render("Play", True, BLACK); ok_text = button_font.render("OK", True, BLACK)
    screen.blit(play_text, play_text.get_rect(center=play_button_rect.center)); screen.blit(ok_text, ok_text.get_rect(center=ok_button_rect.center))
    return all_words_rects, play_button_rect, ok_button_rect

# --- Mouse/Tile Interaction Helpers ---
# get_tile_under_mouse, get_insertion_index, count_consecutive_existing (Unchanged from Part 6 provided previously)
def get_tile_under_mouse(x, y, rack_start_x, rack_y, rack_len):
    """Determine which tile index (0 to rack_len-1) is under the mouse cursor."""
    # Iterate through each potential tile position on the rack
    for i in range(rack_len):
        # Calculate the x-coordinate for the current tile
        tile_x = rack_start_x + i * (TILE_WIDTH + TILE_GAP)
        # Create the rectangle for the current tile *inside* the loop
        tile_rect = pygame.Rect(tile_x, rack_y, TILE_WIDTH, TILE_HEIGHT)
        # Check if the mouse coordinates collide with this specific tile's rectangle *inside* the loop
        if tile_rect.collidepoint(x, y):
            return i # Return the index of the collided tile immediately
    # If the loop finishes without finding any collision (or if rack_len was 0), return None
    return None

def get_insertion_index(x, rack_start_x, rack_len):
    """Determine the insertion index (0 to rack_len) based on mouse x-position."""
    if x < rack_start_x + TILE_WIDTH // 2: return 0
    for i in range(rack_len): tile_left = rack_start_x + i * (TILE_WIDTH + TILE_GAP); gap_center = tile_left + TILE_WIDTH + TILE_GAP // 2;
    if x < gap_center: return i + 1
    return rack_len

def count_consecutive_existing(row, col, direction, tiles):
    """Count consecutive existing tiles in a direction (unused currently)."""
    count = 0
    if direction == "right": c = col;
    while c < GRID_SIZE and tiles[row][c]: count += 1; c += 1
    else: r = row;
    while r < GRID_SIZE and tiles[r][col]: count += 1; r += 1
    return count

# New function to handle end-of-game score adjustments
def calculate_final_scores(current_scores, racks, bag):
    """
    Calculates the final scores based on game end conditions and remaining tiles.

    Args:
        current_scores (list): List containing the scores of [Player1, Player2] before adjustments.
        racks (list): List containing the tile lists for [Player1's rack, Player2's rack].
        bag (list): The list representing the tile bag.

    Returns:
        list: A new list containing the final adjusted scores for [Player1, Player2].
    """
    final_scores = list(current_scores) # Start with a copy of current scores
    rack_values = [0, 0]

    # Calculate the value of tiles left on each rack (blanks count as 0)
    for i in range(2):
        if i < len(racks) and racks[i]: # Check if rack exists and is not None
             rack_values[i] = sum(TILE_DISTRIBUTION[tile][1] for tile in racks[i] if tile != ' ')
        # else: rack_values[i] remains 0

    # Determine if a player went out (must have empty rack AND bag must be empty)
    p1_out = (not racks[0]) and (not bag)
    p2_out = (not racks[1]) and (not bag)

    if p1_out:
        print("Final Score Adjust: P1 went out.")
        # Player 1 went out: Add double Player 2's remaining tile value to P1's score. P2 score unchanged.
        adjustment = 2 * rack_values[1]
        final_scores[0] += adjustment
        # final_scores[1] remains unchanged
        print(f"  P2 tiles value: {rack_values[1]}, P1 adjustment: +{adjustment}")
    elif p2_out:
        print("Final Score Adjust: P2 went out.")
        # Player 2 went out: Add double Player 1's remaining tile value to P2's score. P1 score unchanged.
        adjustment = 2 * rack_values[0]
        final_scores[1] += adjustment
        # final_scores[0] remains unchanged
        print(f"  P1 tiles value: {rack_values[0]}, P2 adjustment: +{adjustment}")
    else:
        # Neither player went out: Subtract each player's own remaining tile value from their score.
        print("Final Score Adjust: Neither player went out.")
        final_scores[0] -= rack_values[0]
        final_scores[1] -= rack_values[1]
        print(f"  P1 adjustment: -{rack_values[0]}, P2 adjustment: -{rack_values[1]}")

    print(f"  Scores before: {current_scores}, Scores after: {final_scores}")
    return final_scores


# --- Playing Moves ---
# Function to Modify: play_hint_move
# REASON: Added sorting of the rack *after* drawing new tiles.

def play_hint_move(move, tiles, racks, blanks, scores, turn, bag, board):
    """Plays a move (usually from hint/AI), updates state. Handles practice mode. Sorts rack."""
    global practice_mode, is_ai # Need is_ai to check if player is human

    player_idx = turn - 1
    if not (0 <= player_idx < len(racks)):
        print(f"Error: Invalid player index {player_idx} in play_hint_move.")
        return turn, [], []

    current_rack = racks[player_idx]
    move_positions = move.get('positions', [])
    move_blanks_coords = move.get('blanks', set())
    newly_placed_details = move.get('newly_placed', [])

    # --- Verification (no changes needed here) ---
    needed_tiles = Counter()
    blanks_needed_count = 0
    for r, c, letter in newly_placed_details:
        if (r, c) in move_blanks_coords: blanks_needed_count += 1
        else: needed_tiles[letter] += 1
    rack_counter = Counter(current_rack)
    if blanks_needed_count > rack_counter.get(' ', 0):
        print(f"Error playing move: Needs {blanks_needed_count} blanks, only {rack_counter.get(' ', 0)} available.")
        return turn, [], []
    for letter, count in needed_tiles.items():
        if rack_counter.get(letter, 0) < count:
            print(f"Error playing move: Needs {count} '{letter}', only {rack_counter.get(letter, 0)} available.")
            return turn, [], []
    # --- End Verification ---

    # Place tiles & update rack
    rack_after_play = current_rack[:] # Work with a copy
    for r, c, letter in newly_placed_details:
        tiles[r][c] = letter
        if (r, c) in move_blanks_coords:
            if ' ' in rack_after_play: rack_after_play.remove(' '); blanks.add((r, c))
            else: print("Error: Tried to play blank but none in rack_after_play!")
        else:
            if letter in rack_after_play: rack_after_play.remove(letter)
            else: print(f"Error: Tried to play '{letter}' but not in rack_after_play!")

    score = move.get('score', 0)
    scores[player_idx] += score # Update score

    # Draw new tiles (Skip in 8-letter practice)
    drawn_tiles = []
    if practice_mode != "eight_letter":
        num_to_draw = len(newly_placed_details)
        drawn_tiles = [bag.pop() for _ in range(num_to_draw) if bag]
        rack_after_play.extend(drawn_tiles)

    # --- ADDED SORTING ---
    # Sort the rack alphabetically if the player is human
    if not is_ai[player_idx]:
        rack_after_play.sort()
    # --- END ADDED SORTING ---

    racks[player_idx] = rack_after_play # Update main rack AFTER potential sort

    next_turn = turn if practice_mode == "eight_letter" else 3 - turn # Determine next turn
    return next_turn, drawn_tiles, newly_placed_details



# --- AI Logic ---
def ai_turn(turn, racks, tiles, board, blanks, scores, bag, first_play, pass_count, exchange_count, consecutive_zero_point_turns, player_names, dropdown_open=False, hinting=False, showing_all_words=False, letter_checks=None):
    """Handles the AI's turn, including pausing for Power Tile practice."""
    global last_word, last_score, last_start, last_direction, move_history, current_replay_turn, practice_mode, GADDAG_STRUCTURE

    # Skip AI turn entirely in 8-letter practice mode
    if practice_mode == "eight_letter":
        return turn, first_play, pass_count, exchange_count, consecutive_zero_point_turns, [], dropdown_open, hinting, showing_all_words, False, None

    print(f"AI Player {turn} turn started. Rack: {''.join(racks[turn-1])}")
    paused_for_power_tile = False
    current_power_tile = None # The specific power tile the player must use
    all_moves = [] # Initialize default

    # *** Generate moves using GADDAG ***
    if GADDAG_STRUCTURE:
        all_moves = generate_all_moves_gaddag(racks[turn-1], tiles, board, blanks, GADDAG_STRUCTURE.root)
    else:
        print("ERROR: AI cannot generate moves, GADDAG not loaded.")
        all_moves = []

    if all_moves is None: all_moves = []
    print(f"AI Player {turn} generated {len(all_moves)} moves.")

    # --- Power Tile Practice Pause Check ---
    if practice_mode == "power_tiles" and letter_checks:
        # Determine which power tiles are designated for practice
        checked_power_tiles = {letter for i, letter in enumerate(['J', 'Q', 'X', 'Z']) if letter_checks[i]}
        # Find which of *those* are actually on the current rack
        power_tiles_on_rack = sorted([tile for tile in racks[turn-1] if tile in checked_power_tiles]) # Sort alphabetically

        if power_tiles_on_rack:
            current_power_tile = power_tiles_on_rack[0] # Target the first one alphabetically
            paused_for_power_tile = True
            print(f"AI turn paused for power tile practice. Target: {current_power_tile}")
            # Return the generated moves so 'main' can use them for validation
            return turn, first_play, pass_count, exchange_count, consecutive_zero_point_turns, all_moves, dropdown_open, hinting, showing_all_words, paused_for_power_tile, current_power_tile

    # --- AI Action: Play, Exchange, or Pass (Only if not paused) ---
    move_rack_before = racks[turn-1][:]; exchanged_tiles_for_history = []
    if not racks[turn-1] and not bag: # Out of tiles
        print(f"AI {turn} passing (empty rack/bag)."); move_type = 'pass'; score = 0; word = ''; positions = []; blanks_used = set(); drawn_tiles = []; coord = ''; word_with_blanks = ''; is_bingo = False
        consecutive_zero_point_turns += 1; pass_count += 1; exchange_count = 0; next_turn = 3 - turn
    elif all_moves: # Play best move
        best_move = all_moves[0]; print(f"AI {turn} playing best move: {best_move.get('word','N/A')} for {best_move.get('score',0)} points.")
        next_turn, drawn_tiles, newly_placed = play_hint_move(best_move, tiles, racks, blanks, scores, turn, bag, board)
        move_type = 'place'; score = best_move.get('score', 0); word = best_move.get('word', 'N/A'); positions = best_move.get('positions', []); blanks_used = best_move.get('blanks', set())
        start = best_move.get('start', (0,0)); direction = best_move.get('direction', 'right'); coord = get_coord(start, direction); word_with_blanks = best_move.get('word_with_blanks', ''); is_bingo = best_move.get('is_bingo', False)
        first_play = False; consecutive_zero_point_turns = 0; pass_count = 0; exchange_count = 0
    elif len(bag) >= 7: # Exchange
        print(f"AI {turn} exchanging tiles."); num_to_exchange = min(len(racks[turn-1]), 3); tiles_to_exchange = racks[turn-1][:num_to_exchange]; exchanged_tiles_for_history = tiles_to_exchange[:]
        drawn_tiles = [bag.pop() for _ in range(num_to_exchange) if bag]; new_rack = racks[turn-1][num_to_exchange:] + drawn_tiles; racks[turn-1] = new_rack; bag.extend(tiles_to_exchange); random.shuffle(bag)
        move_type = 'exchange'; score = 0; word = ''; positions = []; blanks_used = set(); coord = ''; word_with_blanks = ''; is_bingo = False
        consecutive_zero_point_turns += 1; exchange_count += 1; pass_count = 0; next_turn = 3 - turn
    else: # Pass
        print(f"AI {turn} passing."); move_type = 'pass'; score = 0; word = ''; positions = []; blanks_used = set(); drawn_tiles = []; coord = ''; word_with_blanks = ''; is_bingo = False
        consecutive_zero_point_turns += 1; pass_count += 1; exchange_count = 0; next_turn = 3 - turn

    # Record Move
    move_data = {'player': turn, 'move_type': move_type, 'rack': move_rack_before, 'score': score, 'word': word, 'positions': positions, 'blanks': blanks_used, 'drawn': drawn_tiles, 'coord': coord, 'word_with_blanks': word_with_blanks, 'is_bingo': is_bingo}
    if move_type == 'exchange': move_data['exchanged_tiles'] = exchanged_tiles_for_history
    move_history.append(move_data); current_replay_turn = len(move_history)

    # Return updated state (return empty list for all_moves as AI turn consumed them if it played)
    return next_turn, first_play, pass_count, exchange_count, consecutive_zero_point_turns, [], dropdown_open, hinting, showing_all_words, paused_for_power_tile, current_power_tile



def power_tile_practice():
    """Placeholder function, logic moved elsewhere."""
    print("Power tile practice setup (handled by mode selection and AI turn).")

# End of Part 6

# python
# MODIFIED: 01APR24 - Implementing 8-Letter Bingo Practice Mode Fixes (Part 7)

# python
# MODIFIED: 01APR24 - Implementing 8-Letter Bingo Practice Mode Fixes (Part 7 - Corrected Function Call)

# python
# MODIFIED: 01APR24 - Implementing 8-Letter Bingo Practice Mode Fixes (Part 7 - Corrected Indentation)

# Part 7

def get_replay_state(turn_idx, initial_racks):
    """
    Recreate the game state up to turn_idx ITERATIVELY.
    Sorts the racks alphabetically before returning.
    """
    # Start with initial state (ensure deep copies)
    tiles_state = [['' for _ in range(GRID_SIZE)] for _ in range(GRID_SIZE)]
    blanks_state = set()
    scores_state = [0, 0]

    if not isinstance(initial_racks, list) or len(initial_racks) != 2 or \
       not isinstance(initial_racks[0], list) or not isinstance(initial_racks[1], list):
        print(f"Error: Invalid initial_racks format in get_replay_state: {initial_racks}")
        return tiles_state, blanks_state, scores_state, [[], []]

    racks_state = [initial_racks[0][:], initial_racks[1][:]]

    # Apply moves sequentially up to turn_idx
    for i in range(turn_idx):
        if i >= len(move_history):
             print(f"Warning: Replay index {i} out of bounds for move_history (len {len(move_history)})")
             break
        move = move_history[i]
        player_idx = move['player'] - 1

        # Get the rack state *before* applying this move's changes
        current_rack_before_move = racks_state[player_idx][:]
        rack_after_move = current_rack_before_move[:] # Work with a copy for this move

        if move['move_type'] == 'place':
            positions = move.get('positions', [])
            blanks_in_move = move.get('blanks', set())

            # Apply board changes and update rack based on *this* move
            for r, c, letter in positions:
                # Check if this square was empty *before* this move (using current tiles_state)
                is_newly_placed = (0 <= r < GRID_SIZE and 0 <= c < GRID_SIZE and not tiles_state[r][c])

                # Place tile on board state
                if 0 <= r < GRID_SIZE and 0 <= c < GRID_SIZE:
                    tiles_state[r][c] = letter
                    if (r, c) in blanks_in_move:
                        blanks_state.add((r, c))
                else:
                    print(f"Replay Warning: Invalid position ({r},{c}) in move {i}")
                    continue # Skip processing this invalid position

                # If it was newly placed, remove the corresponding tile from the rack_after_move
                if is_newly_placed:
                    if (r,c) in blanks_in_move:
                        if ' ' in rack_after_move: rack_after_move.remove(' ')
                        else: print(f"Replay Warning: Tried to remove blank from rack for move {i}, but not found.")
                    else:
                        if letter in rack_after_move: rack_after_move.remove(letter)
                        else: print(f"Replay Warning: Tried to remove '{letter}' from rack for move {i}, but not found.")

            # Update score
            scores_state[player_idx] += move.get('score', 0)
            # Add drawn tiles to the rack for the *next* turn's state
            rack_after_move.extend(move.get('drawn', []))
            racks_state[player_idx] = rack_after_move

        elif move['move_type'] == 'exchange':
            # Update rack: remove exchanged, add drawn
            exchanged = move.get('exchanged_tiles', [])
            for tile in exchanged:
                 if tile in rack_after_move: rack_after_move.remove(tile)
                 else: print(f"Replay Warning: Tried to remove exchanged tile '{tile}' from rack for move {i}, but not found.")
            rack_after_move.extend(move.get('drawn', []))
            racks_state[player_idx] = rack_after_move
            # Score doesn't change

        elif move['move_type'] == 'pass':
            # No change to board, score, or rack content needed for the state
            racks_state[player_idx] = rack_after_move # Rack state carries over

    # Sort racks alphabetically before returning for replay display
    for rack in racks_state:
        rack.sort() # In-place sort

    # Return the state *after* turn_idx moves have been applied
    return tiles_state, blanks_state, scores_state, racks_state


# Function to Replace: main()
# REASON: Added sorting lines for human player racks after completing
#         a typed play or an exchange.

def main():
    global bag, last_word, last_score, last_start, last_direction, move_history, replay_mode, current_replay_turn, game_mode, is_ai, practice_mode, board, tiles, racks, blanks, main_called, scores, GADDAG_STRUCTURE # Ensure GADDAG_STRUCTURE is global
    print("--- main() function entered ---")

    if not main_called:
        print("--- main(): 'if not main_called' block entered ---")
        main_called = True
        print("--- main(): Calling mode_selection_screen()... ---")
        game_mode, player_names, human_player, practice_mode, letter_checks, practice_state = mode_selection_screen()
        print(f"--- main(): mode_selection_screen() returned: mode={game_mode}, practice={practice_mode}, human_player={human_player} ---")

        # --- Load GADDAG Structure ---
        try:
            print("Attempting to load GADDAG structure from gaddag.pkl...")
            load_start = time.time()
            with open("gaddag.pkl", 'rb') as f_load:
                print("  File gaddag.pkl opened for reading...")
                GADDAG_STRUCTURE = pickle.load(f_load)
                print("  pickle.load() completed...")
            print(f"GADDAG loaded in {time.time() - load_start:.2f} seconds.")
            print("  Validating loaded GADDAG structure...")
            if not GADDAG_STRUCTURE: raise TypeError("Loaded object is None.")
            if not hasattr(GADDAG_STRUCTURE, 'root'): raise TypeError("Loaded object missing 'root'.")
            if not isinstance(GADDAG_STRUCTURE.root, GaddagNode): raise TypeError("Loaded object's root is not a GaddagNode.")
            print("  GADDAG structure validated successfully.")
        except FileNotFoundError:
            print("\n--- ERROR ---"); print("gaddag.pkl not found..."); print("-------------"); pygame.quit(); sys.exit()
        except (pickle.UnpicklingError, TypeError, AttributeError, EOFError) as e:
            print(f"\n--- ERROR ---"); print(f"Failed to load or validate gaddag.pkl: {e}"); print("-------------"); pygame.quit(); sys.exit()
        except MemoryError:
             print(f"\n--- ERROR ---"); print(f"MemoryError loading gaddag.pkl."); print("-------------"); pygame.quit(); sys.exit()
        except Exception as e:
             print(f"\n--- UNEXPECTED ERROR loading GADDAG ---"); print(f"{type(e).__name__}: {e}"); print("-------------"); pygame.quit(); sys.exit()
        print("GADDAG loading and validation block finished.")


        # --- Game State Initialization ---
        print("--- main(): Starting game state initialization... ---")
        if practice_state and practice_mode == "eight_letter":
            print("Loading state from 8-letter practice...")
            board, tiles, racks, blanks, bag, scores, turn, first_play = practice_state["board"], practice_state["tiles"], practice_state["racks"], practice_state["blanks"], practice_state["bag"], practice_state["scores"], practice_state["turn"], practice_state["first_play"]
            is_ai = [False, False] # Human plays practice
            print("--- main(): Loaded state from 8-letter practice. ---")
        elif practice_state: # Other practice modes
            print("Loading state from other practice mode...")
            board, tiles, racks, blanks, bag, scores, turn, first_play = practice_state["board"], practice_state["tiles"], practice_state["racks"], practice_state["blanks"], practice_state["bag"], practice_state["scores"], practice_state["turn"], practice_state["first_play"]
            is_ai = [False, False];
            if game_mode == MODE_HVA: is_ai[2 - human_player] = True
            elif game_mode == MODE_AVA or practice_mode == "power_tiles": is_ai = [True, True]
            print(f"--- main(): Loaded state from other practice mode. is_ai: {is_ai} ---")
        else: # Standard game initialization
            print("Performing standard game initialization...")
            board, _, tiles = create_board()
            bag = [letter for letter, (count, _) in TILE_DISTRIBUTION.items() for _ in range(count)]; random.shuffle(bag)
            racks = [[], []]
            try: racks[0] = [bag.pop() for _ in range(7)]; racks[1] = [bag.pop() for _ in range(7)]
            except IndexError: print("Error: Not enough tiles in bag."); pygame.quit(); sys.exit()
            # Initial sort for both players (optional, but good practice)
            for rack in racks: rack.sort()
            scores = [0, 0]; turn = 1; blanks = set(); first_play = True
            is_ai = [False, False]
            if game_mode == MODE_HVA: is_ai[2 - human_player] = True
            elif game_mode == MODE_AVA: is_ai = [True, True]
            print(f"--- main(): Performed standard game initialization. is_ai: {is_ai} ---")

        # --- Common Initializations & Resets ---
        initial_racks = [rack[:] for rack in racks] # Store initial racks for GCG saving/replay init
        word_positions = []; running = True; dropdown_open = False; return_to_mode_selection = False; all_words_ok_rect = None; all_words_play_rect = None
        hint_rects = []; hint_rect = None; play_button_rect = None; ok_button_rect = None; all_words_button_rect = None; tile_rects = []; exchange_button_rect = None
        cancel_button_rect = None; pass_count = 0; exchange_count = 0; consecutive_zero_point_turns = 0; exchanging = False; hinting = False
        showing_all_words = False; selected_tiles = set(); typing = False; typing_start = None; typing_direction = None; current_r = None; current_c = None
        last_left_click_time = 0; last_left_click_pos = None; hint_moves = []; all_moves = []; selected_hint_index = None; scroll_offset = 0
        last_clicked_pos = None; last_word = ""; last_score = 0; last_start = None; last_direction = None; human_played = False; dragged_tile = None; drag_pos = None
        selected_square = None; original_tiles = None; original_rack = None; move_history = []; replay_mode = False; current_replay_turn = 0; previous_turn = 0
        game_over_state = False; showing_stats = False; dialog_x = (WINDOW_WIDTH - DIALOG_WIDTH) // 2; dialog_y = (WINDOW_HEIGHT - DIALOG_HEIGHT) // 2; dragging = False; drag_offset = (0, 0)
        final_scores = None; reason = ""; action = None; scoreboard_height = WINDOW_HEIGHT - 80; paused_for_power_tile = False; current_power_tile = None
        power_tile_message_shown = False
        print("--- main(): Performed common variable resets. ---")

        # --- 8-Letter Practice Specific Initialization ---
        practice_target_moves = []
        practice_best_move = None
        practice_solved = False
        showing_practice_end_dialog = False
        practice_end_message = ""
        practice_play_again_rect = None
        practice_main_menu_rect = None
        practice_quit_rect = None

        if practice_mode == "eight_letter":
            print("--- main(): Performing 8-letter practice specific init... ---")
            print("Generating target moves for 8-letter practice...")
            if racks and len(racks) > 0 and racks[0] is not None and GADDAG_STRUCTURE:
                practice_target_moves = generate_all_moves_gaddag(racks[0], tiles, board, blanks, GADDAG_STRUCTURE.root)
                if practice_target_moves:
                    practice_best_move = practice_target_moves[0]
                    print(f"Best move found: {practice_best_move['word']} ({practice_best_move['score']} pts)")
                    all_moves = practice_target_moves # Use these for hint/validation
                else:
                    print("Error: No valid moves found for 8-letter practice setup!")
                    show_message_dialog("Error: No possible moves found for this setup.", "Practice Error")
                    return_to_mode_selection = True; running = False
            elif not GADDAG_STRUCTURE: print("Error: Cannot generate practice moves, GADDAG not loaded."); return_to_mode_selection = True; running = False
            else: print("Error: Invalid rack state for Player 1 in 8-letter practice."); return_to_mode_selection = True; running = False

        print("--- main(): Entering main game loop (while running:)... ---")
        # --- Main Game Loop ---
        while running:
            # Generate moves at start of turn (unless practice mode or paused)
            if turn != previous_turn and not replay_mode and not game_over_state and not paused_for_power_tile and practice_mode != "eight_letter":
                if racks and len(racks) > turn-1 and racks[turn-1] is not None and GADDAG_STRUCTURE:
                    print(f"Generating moves for Player {turn}. Rack: {''.join(racks[turn-1])}")
                    all_moves = generate_all_moves_gaddag(racks[turn-1], tiles, board, blanks, GADDAG_STRUCTURE.root)
                    if all_moves is None: all_moves = []
                    print(f"Generated {len(all_moves)} moves for player {turn}")
                elif not GADDAG_STRUCTURE: print("ERROR: Cannot generate moves, GADDAG not loaded."); all_moves = []
                else: print(f"Error: Invalid rack state for player {turn}. Racks: {racks}"); all_moves = []
                previous_turn = turn
                human_played = False # Reset flag indicating human action this turn
                power_tile_message_shown = False # Reset flag for power tile practice message

            # --- AI Turn Trigger ---
            if not game_over_state and not replay_mode and not paused_for_power_tile and \
               practice_mode != "eight_letter" and is_ai[turn-1] and not human_played:
                 print(f"Triggering AI turn for Player {turn}")
                 ai_result = ai_turn(turn, racks, tiles, board, blanks, scores, bag, first_play, pass_count, exchange_count, consecutive_zero_point_turns, player_names, dropdown_open, hinting, showing_all_words, letter_checks)
                 if len(ai_result) == 11:
                      # Unpack results from AI turn
                      turn, first_play, pass_count, exchange_count, consecutive_zero_point_turns, returned_moves, dropdown_open, hinting, showing_all_words, paused_for_power_tile, current_power_tile = ai_result
                      if paused_for_power_tile:
                           # If paused, AI returned moves for player validation
                           all_moves = returned_moves
                           if not power_tile_message_shown:
                                player_name = player_names[turn-1] if player_names[turn-1] else f"Player {turn}"
                                show_message_dialog(f"A {current_power_tile} is on {player_name}'s rack. Find the highest scoring play using {current_power_tile}.", "Power Tile Practice")
                                power_tile_message_shown = True
                 else:
                      print(f"Error: AI turn returned unexpected number of values: {len(ai_result)}")


            # --- Event Handling ---
            for event in pygame.event.get():
                if event.type == pygame.QUIT: running = False
                # --- Practice End Dialog Handling ---
                elif showing_practice_end_dialog:
                     if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
                         x, y = event.pos
                         if practice_play_again_rect and practice_play_again_rect.collidepoint(x,y): running = False; return_to_mode_selection = True # Go back to mode screen
                         elif practice_main_menu_rect and practice_main_menu_rect.collidepoint(x,y): running = False; return_to_mode_selection = True # Go back to mode screen
                         elif practice_quit_rect and practice_quit_rect.collidepoint(x,y): running = False # Quit entirely
                # --- Game Over Event Handling ---
                elif game_over_state:
                    if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
                        x, y = event.pos
                        # Allow dragging the dialog box
                        if dialog_x <= x < dialog_x + DIALOG_WIDTH and dialog_y <= y < dialog_y + 20: # Click in title bar area
                            dragging = True
                            drag_offset = (x - dialog_x, y - dialog_y)
                        elif showing_stats:
                            # Handle click on OK button in stats dialog
                            stats_dialog_width, stats_dialog_height = 400, 360
                            stats_dialog_actual_x = dialog_x + 20 # Assuming stats drawn relative to game over dialog pos
                            stats_dialog_actual_y = dialog_y + 20
                            temp_ok_rect = pygame.Rect(stats_dialog_actual_x + stats_dialog_width - BUTTON_WIDTH - 10, stats_dialog_actual_y + stats_dialog_height - BUTTON_HEIGHT - 10, BUTTON_WIDTH, BUTTON_HEIGHT)
                            if temp_ok_rect.collidepoint(x, y):
                                showing_stats = False
                        else:
                            # Handle clicks on game over buttons
                            # Need to get the current button rects as they depend on dialog_x, dialog_y
                            temp_save_rect, temp_quit_rect, temp_replay_rect, temp_play_again_rect, temp_stats_rect = draw_game_over_dialog(dialog_x, dialog_y, final_scores if final_scores else [0,0], reason, player_names)

                            if temp_save_rect.collidepoint(x, y):
                                if final_scores:
                                    gcg_content = save_game_to_gcg(player_names, move_history, initial_racks, final_scores);
                                    try:
                                        with open("last_game.gcg", "w") as f: f.write(gcg_content); print("Game saved to last_game.gcg");
                                    except IOError as e: print(f"Error saving game: {e}")
                                else: print("Cannot save game: Final scores not calculated.")
                            elif temp_quit_rect.collidepoint(x, y): running = False
                            elif temp_replay_rect.collidepoint(x, y):
                                game_over_state = False; replay_mode = True; current_replay_turn = 0; practice_mode = None; paused_for_power_tile = False; showing_stats = False
                            elif temp_play_again_rect.collidepoint(x, y):
                                running = False; return_to_mode_selection = True # Restart main to show mode selection
                            elif temp_stats_rect.collidepoint(x, y):
                                showing_stats = True

                    elif event.type == pygame.MOUSEMOTION and dragging:
                        x, y = event.pos
                        dialog_x = x - drag_offset[0]
                        dialog_y = y - drag_offset[1]
                        # Keep dialog on screen
                        dialog_x = max(0, min(dialog_x, WINDOW_WIDTH - DIALOG_WIDTH))
                        dialog_y = max(0, min(dialog_y, WINDOW_HEIGHT - DIALOG_HEIGHT))
                    elif event.type == pygame.MOUSEBUTTONUP and event.button == 1:
                        dragging = False
                    elif event.type == pygame.KEYDOWN:
                        # Keyboard shortcuts for game over options
                        if event.key == pygame.K_s:
                             if final_scores:
                                 gcg_content = save_game_to_gcg(player_names, move_history, initial_racks, final_scores);
                                 try:
                                     with open("last_game.gcg", "w") as f: f.write(gcg_content); print("Game saved to last_game.gcg");
                                 except IOError as e: print(f"Error saving game: {e}")
                             else: print("Cannot save game: Final scores not calculated.")
                        elif event.key == pygame.K_q: running = False
                        elif event.key == pygame.K_r:
                             game_over_state = False; replay_mode = True; current_replay_turn = 0; practice_mode = None; paused_for_power_tile = False; showing_stats = False
                        elif event.key == pygame.K_p:
                             running = False; return_to_mode_selection = True # Restart main

                # --- Active Game / Replay Event Handling ---
                elif event.type == pygame.MOUSEBUTTONDOWN:
                    x, y = event.pos
                    current_time = pygame.time.get_ticks() # For double-click detection

                    if event.button == 1: # Left Click
                        if replay_mode:
                            # Replay control clicks
                            if replay_start_rect.collidepoint(x, y): current_replay_turn = 0
                            elif replay_prev_rect.collidepoint(x, y) and current_replay_turn > 0: current_replay_turn -= 1
                            elif replay_next_rect.collidepoint(x, y) and current_replay_turn < len(move_history): current_replay_turn += 1
                            elif replay_end_rect.collidepoint(x, y): current_replay_turn = len(move_history)
                        elif not replay_mode: # Active game clicks
                            # --- Exchange Dialog Click Handling ---
                            if exchanging:
                                clicked_in_dialog = False
                                if exchange_button_rect and exchange_button_rect.collidepoint(x, y) and selected_tiles and len(bag) >= len(selected_tiles):
                                    clicked_in_dialog = True
                                    move_rack = racks[turn-1][:] # Store rack before exchange for history
                                    tiles_to_exchange = [racks[turn-1][i] for i in sorted(selected_tiles, reverse=True)]
                                    temp_rack = [tile for i, tile in enumerate(racks[turn-1]) if i not in selected_tiles]
                                    drawn_tiles = [bag.pop() for _ in range(len(tiles_to_exchange)) if bag]
                                    temp_rack.extend(drawn_tiles)
                                    racks[turn-1] = temp_rack # Update the main rack
                                    # ---- SORT RACK ON EXCHANGE (HUMAN ONLY) ----
                                    if not is_ai[turn-1]: racks[turn-1].sort() # Sort rack if human player
                                    # -------------------------------------------
                                    bag.extend(tiles_to_exchange)
                                    random.shuffle(bag)
                                    consecutive_zero_point_turns += 1
                                    print(f"Player {turn} exchanged {len(tiles_to_exchange)} tiles")
                                    exchanging = False
                                    selected_tiles.clear()
                                    human_played = True # Mark human action this turn
                                    exchange_count += 1
                                    pass_count = 0
                                    paused_for_power_tile = False # Exchanging resets pause
                                    # Add exchange move to history
                                    move_history.append({'player': turn, 'move_type': 'exchange', 'rack': move_rack, 'exchanged_tiles': tiles_to_exchange, 'drawn': drawn_tiles, 'score': 0, 'word': '', 'coord': '', 'blanks': set(), 'positions': [], 'is_bingo': False, 'word_with_blanks': ''})
                                    current_replay_turn = len(move_history)
                                    turn = 3 - turn # Next player's turn
                                elif cancel_button_rect and cancel_button_rect.collidepoint(x, y):
                                    clicked_in_dialog = True; exchanging = False; selected_tiles.clear()
                                elif tile_rects: # Clicks on tiles within exchange dialog
                                    for i, rect in enumerate(tile_rects):
                                        if rect.collidepoint(x, y):
                                            clicked_in_dialog = True; selected_tiles.symmetric_difference_update({i}); break
                                # Check if click was inside dialog but not on a button/tile (ignore)
                                dialog_width, dialog_height = 400, 200
                                dialog_rect_exchange = pygame.Rect((WINDOW_WIDTH - dialog_width) // 2, (WINDOW_HEIGHT - dialog_height) // 2, dialog_width, dialog_height)
                                if dialog_rect_exchange.collidepoint(x,y) and not clicked_in_dialog:
                                    pass # Click inside dialog background, do nothing

                            # --- Hint Dialog Click Handling ---
                            elif hinting:
                                clicked_in_dialog = False
                                if play_button_rect and play_button_rect.collidepoint(x, y) and selected_hint_index is not None and selected_hint_index < len(hint_moves):
                                    clicked_in_dialog = True
                                    selected_move = hint_moves[selected_hint_index]
                                    move_rack = racks[turn-1][:] # Rack before playing hint

                                    # Special check for Power Tile Practice mode when playing hint
                                    if paused_for_power_tile:
                                        power_moves_check = [m for m in all_moves if any(letter == current_power_tile for _, _, letter in m.get('newly_placed',[]))]
                                        max_power_score_check = max(m['score'] for m in power_moves_check) if power_moves_check else 0
                                        # Only allow playing the hint if it's the best power tile move
                                        if selected_move['score'] >= max_power_score_check:
                                            # Play the move, update state
                                            next_turn, drawn_tiles, newly_placed = play_hint_move(selected_move, tiles, racks, blanks, scores, turn, bag, board) # play_hint_move now sorts human rack
                                            human_played = True; hinting = False; paused_for_power_tile = False # Unpause
                                            consecutive_zero_point_turns = 0; pass_count = 0; exchange_count = 0
                                            # Record move
                                            move_history.append({'player': turn, 'move_type': 'place', 'rack': move_rack, 'positions': selected_move.get('positions',[]), 'blanks': selected_move.get('blanks',set()), 'score': selected_move.get('score',0), 'word': selected_move.get('word','N/A'), 'drawn': drawn_tiles, 'coord': get_coord(selected_move.get('start',(0,0)), selected_move.get('direction','right')), 'word_with_blanks': selected_move.get('word_with_blanks',''), 'is_bingo': selected_move.get('is_bingo',False)})
                                            current_replay_turn = len(move_history); turn = next_turn
                                        else:
                                            show_message_dialog(f"This is not the highest scoring move with {current_power_tile}!", "Incorrect Move")
                                            # Don't close hint dialog, don't play move
                                    else: # Normal hint play (non-paused)
                                        next_turn, drawn_tiles, newly_placed = play_hint_move(selected_move, tiles, racks, blanks, scores, turn, bag, board) # play_hint_move now sorts human rack
                                        human_played = True; hinting = False; paused_for_power_tile = False # Ensure unpaused
                                        consecutive_zero_point_turns = 0; pass_count = 0; exchange_count = 0
                                        if practice_mode != "eight_letter": # Don't record history/advance turn in 8-letter
                                            move_history.append({'player': turn, 'move_type': 'place', 'rack': move_rack, 'positions': selected_move.get('positions',[]), 'blanks': selected_move.get('blanks',set()), 'score': selected_move.get('score',0), 'word': selected_move.get('word','N/A'), 'drawn': drawn_tiles, 'coord': get_coord(selected_move.get('start',(0,0)), selected_move.get('direction','right')), 'word_with_blanks': selected_move.get('word_with_blanks',''), 'is_bingo': selected_move.get('is_bingo',False)})
                                            current_replay_turn = len(move_history); turn = next_turn
                                        else:
                                            # In 8-letter, just visually place, don't change state
                                            print("Hint played visually in 8-letter practice.")
                                            # Maybe add visual feedback? For now, just prints.
                                elif ok_button_rect and ok_button_rect.collidepoint(x, y):
                                    clicked_in_dialog = True; hinting = False
                                elif all_words_button_rect and all_words_button_rect.collidepoint(x, y):
                                     clicked_in_dialog = True; hinting = False; showing_all_words = True
                                     moves_for_all = practice_target_moves if practice_mode == "eight_letter" else all_moves
                                     selected_hint_index = 0 if moves_for_all else None # Default selection to first item
                                     scroll_offset = 0 # Reset scroll on open
                                elif hint_rects: # Clicks on hint move items
                                    for i, rect in enumerate(hint_rects):
                                        if rect.collidepoint(x, y) and i < len(hint_moves):
                                            clicked_in_dialog = True; selected_hint_index = i; break
                                # Click inside dialog background
                                dialog_width, dialog_height = 400, 250
                                dialog_rect_hint = pygame.Rect((WINDOW_WIDTH - dialog_width) // 2, (WINDOW_HEIGHT - dialog_height) // 2, dialog_width, dialog_height)
                                if dialog_rect_hint.collidepoint(x,y) and not clicked_in_dialog:
                                    pass # Ignore click on dialog background

                            # --- All Words Dialog Click Handling ---
                            elif showing_all_words:
                                clicked_in_dialog = False
                                moves_for_all = practice_target_moves if practice_mode == "eight_letter" else all_moves
                                if all_words_play_rect and all_words_play_rect.collidepoint(x, y) and selected_hint_index is not None and selected_hint_index < len(moves_for_all):
                                    clicked_in_dialog = True
                                    selected_move = moves_for_all[selected_hint_index]
                                    move_rack = racks[turn-1][:] # Rack before play
                                    # Play move - play_hint_move handles sorting human racks now
                                    next_turn, drawn_tiles, newly_placed = play_hint_move(selected_move, tiles, racks, blanks, scores, turn, bag, board)
                                    human_played = True; showing_all_words = False; paused_for_power_tile = False # Playing resets pause
                                    consecutive_zero_point_turns = 0; pass_count = 0; exchange_count = 0
                                    if practice_mode != "eight_letter": # Don't record/advance in 8-letter
                                        move_history.append({'player': turn, 'move_type': 'place', 'rack': move_rack, 'positions': selected_move.get('positions',[]), 'blanks': selected_move.get('blanks',set()), 'score': selected_move.get('score',0), 'word': selected_move.get('word','N/A'), 'drawn': drawn_tiles, 'coord': get_coord(selected_move.get('start',(0,0)), selected_move.get('direction','right')), 'word_with_blanks': selected_move.get('word_with_blanks',''), 'is_bingo': selected_move.get('is_bingo',False)})
                                        current_replay_turn = len(move_history); turn = next_turn
                                    else:
                                        print("Move played visually from All Words in 8-letter practice.")
                                elif all_words_ok_rect and all_words_ok_rect.collidepoint(x, y):
                                    clicked_in_dialog = True; showing_all_words = False
                                elif all_words_rects: # Click on a specific move in the list
                                    for rect, idx in all_words_rects:
                                        if rect.collidepoint(x, y):
                                            clicked_in_dialog = True; selected_hint_index = idx; break
                                # Click inside dialog background
                                dialog_rect_all = pygame.Rect((WINDOW_WIDTH - ALL_WORDS_DIALOG_WIDTH) // 2, (WINDOW_HEIGHT - ALL_WORDS_DIALOG_HEIGHT) // 2, ALL_WORDS_DIALOG_WIDTH, ALL_WORDS_DIALOG_HEIGHT)
                                if dialog_rect_all.collidepoint(x,y) and not clicked_in_dialog:
                                    pass # Ignore

                            # --- Clicks outside dialogs (Main UI) ---
                            elif not (exchanging or hinting or showing_all_words):
                                # Options Menu Click Handling
                                options_rect_base, dropdown_rects_base = draw_options_menu(turn, dropdown_open, len(bag)) # Get rects for collision check
                                if options_rect_base.collidepoint(x, y):
                                    dropdown_open = not dropdown_open
                                elif dropdown_open:
                                    clicked_dropdown = False
                                    current_options = ["Give Up", "Main", "Quit"] if practice_mode == "eight_letter" else ["Pass", "Exchange", "Main", "Quit"]
                                    for i, rect in enumerate(dropdown_rects_base):
                                        if rect and rect.collidepoint(x, y): # Ensure rect is not None (handles disabled options)
                                            clicked_dropdown = True
                                            selected_option = current_options[i]
                                            dropdown_open = False # Close dropdown after selection

                                            if selected_option == "Pass":
                                                move_rack = racks[turn-1][:] # Rack before pass
                                                consecutive_zero_point_turns += 1; pass_count += 1; exchange_count = 0
                                                print(f"Player {turn} passed"); human_played = True; paused_for_power_tile = False # Passing resets pause
                                                move_history.append({'player': turn, 'move_type': 'pass', 'rack': move_rack, 'score': 0, 'word': '', 'coord': '', 'blanks': set(), 'positions': [], 'drawn': [], 'is_bingo': False, 'word_with_blanks': ''})
                                                current_replay_turn = len(move_history); turn = 3 - turn # Next player
                                            elif selected_option == "Exchange":
                                                exchanging = True; selected_tiles.clear()
                                            elif selected_option == "Give Up": # 8-letter practice specific
                                                if practice_best_move: practice_end_message = f"Best: {practice_best_move['word_with_blanks']} ({practice_best_move['score']} pts)"
                                                else: practice_end_message = "No best move found."
                                                practice_solved = True; showing_practice_end_dialog = True
                                            elif selected_option == "Main":
                                                running = False; return_to_mode_selection = True # Go back to mode select
                                            elif selected_option == "Quit":
                                                if confirm_quit(): running = False # Quit entirely
                                            break # Exit options loop once one is clicked
                                    # If click was outside any dropdown option, close the dropdown
                                    if not clicked_dropdown:
                                        dropdown_open = False
                                elif not options_rect_base.collidepoint(x,y): # Click outside options button when dropdown closed
                                     dropdown_open = False # Ensure dropdown closes

                                # Suggest Button Click Handling
                                suggest_rect_base = draw_suggest_button() # Get rect for collision
                                if suggest_rect_base and suggest_rect_base.collidepoint(x, y) and (not is_ai[turn-1] or paused_for_power_tile): # Only humans or paused AI can use Suggest
                                    moves_to_hint = practice_target_moves if practice_mode == "eight_letter" else all_moves
                                    # Filter for power tiles if paused
                                    if paused_for_power_tile and current_power_tile:
                                         power_moves_hint = [m for m in moves_to_hint if any(letter == current_power_tile for _, _, letter in m.get('newly_placed',[]))]
                                         hint_moves = sorted(power_moves_hint, key=lambda m: m['score'], reverse=True)[:5]
                                    else: # Standard hint
                                         hint_moves = moves_to_hint[:5]
                                    hinting = True
                                    selected_hint_index = 0 if hint_moves else None # Select first hint by default

                                # Hint button (only appears when paused)
                                if paused_for_power_tile and hint_rect and hint_rect.collidepoint(x, y):
                                     power_moves_hint = [m for m in all_moves if any(letter == current_power_tile for _, _, letter in m.get('newly_placed',[]))]
                                     hint_moves = sorted(power_moves_hint, key=lambda m: m['score'], reverse=True)[:5]
                                     hinting = True
                                     selected_hint_index = 0 if hint_moves else None

                                # Rack Button Click Handling (Alphabetize/Randomize)
                                current_player_idx = turn - 1
                                if not is_ai[current_player_idx] or paused_for_power_tile: # Only for human or paused AI turns
                                     # Get button rects for the current player
                                     p1_alpha_rect, p1_rand_rect = None, None # Need to recalculate based on current draw state potentially
                                     p2_alpha_rect, p2_rand_rect = None, None
                                     if len(racks) > 0: p1_alpha_rect, p1_rand_rect = draw_rack(1, racks[0], scores, turn, player_names)
                                     if len(racks) > 1 and practice_mode != "eight_letter": p2_alpha_rect, p2_rand_rect = draw_rack(2, racks[1], scores, turn, player_names)

                                     if turn == 1:
                                          if p1_alpha_rect and p1_alpha_rect.collidepoint(x, y): racks[0].sort()
                                          elif p1_rand_rect and p1_rand_rect.collidepoint(x, y): random.shuffle(racks[0])
                                     elif turn == 2 and practice_mode != "eight_letter":
                                          if p2_alpha_rect and p2_alpha_rect.collidepoint(x, y): racks[1].sort()
                                          elif p2_rand_rect and p2_rand_rect.collidepoint(x, y): random.shuffle(racks[1])

                                # Rack Tile Drag Start Handling
                                rack_y = BOARD_SIZE + 80 if turn == 1 else BOARD_SIZE + 150
                                # Calculate rack start X dynamically (consistent with draw_rack)
                                rack_width_calc = 7 * (TILE_WIDTH + TILE_GAP) - TILE_GAP
                                replay_area_end_x = 10 + 4 * (REPLAY_BUTTON_WIDTH + REPLAY_BUTTON_GAP)
                                min_rack_start_x = replay_area_end_x + BUTTON_GAP + 20
                                rack_start_x_calc = max(min_rack_start_x, (BOARD_SIZE - rack_width_calc) // 2)

                                if 0 <= current_player_idx < len(racks):
                                     rack_len = len(racks[current_player_idx])
                                     tile_idx = get_tile_under_mouse(x, y, rack_start_x_calc, rack_y, rack_len) # Check if click is on a rack tile
                                     if tile_idx is not None and not dragged_tile and (not is_ai[current_player_idx] or paused_for_power_tile): # Start dragging
                                          dragged_tile = (turn, tile_idx) # Store (player, index)
                                          drag_pos = (x, y)
                                          # Calculate offset relative to tile top-left for smooth drag
                                          tile_abs_x = rack_start_x_calc + tile_idx * (TILE_WIDTH + TILE_GAP)
                                          drag_offset = (x - tile_abs_x, y - rack_y)

                                # Board Click Handling (Typing Start / Arrow Selection)
                                if not dragged_tile and (not is_ai[turn-1] or paused_for_power_tile): # Only if not dragging
                                    col = (x - 40) // SQUARE_SIZE
                                    row = (y - 40) // SQUARE_SIZE
                                    if 0 <= row < GRID_SIZE and 0 <= col < GRID_SIZE and not tiles[row][col]: # Click on empty board square
                                        is_double_click = (last_left_click_pos == (row, col) and current_time - last_left_click_time < DOUBLE_CLICK_TIME)

                                        if is_double_click:
                                             # Cancel typing if active
                                             selected_square = None # Remove arrow
                                             typing = False
                                             if word_positions and original_tiles and original_rack: # Revert any partially typed word
                                                  for r_wp, c_wp, _ in word_positions: tiles[r_wp][c_wp] = original_tiles[r_wp][c_wp]
                                                  racks[turn-1] = original_rack[:]; blanks_to_remove = set((r_wp, c_wp) for r_wp, c_wp, _ in word_positions if (r_wp, c_wp) in blanks); blanks.difference_update(blanks_to_remove); word_positions = []
                                                  original_tiles = None; original_rack = None
                                        elif selected_square is None or selected_square[:2] != (row, col): # First click or click on new square
                                             selected_square = (row, col, "right") # Default to right arrow
                                             typing = False; word_positions = [] # Cancel previous selection/typing
                                        elif selected_square[2] == "right": # Second click on same square
                                             selected_square = (row, col, "down") # Change arrow to down
                                        elif selected_square[2] == "down": # Third click on same square
                                             selected_square = None # Deselect

                                        last_left_click_pos = (row, col) # Store for double-click detection
                                        last_left_click_time = current_time
                                    else: # Click outside board or on occupied square
                                         selected_square = None # Deselect arrow if clicking elsewhere
                                         # Consider canceling typing here too? Usually right-click cancels.

                    elif event.button == 3: # Right Click
                        # Cancel arrow selection and any active typing
                        selected_square = None
                        if typing:
                            if original_tiles and original_rack: # Revert board and rack
                                for r_wp, c_wp, _ in word_positions: tiles[r_wp][c_wp] = original_tiles[r_wp][c_wp]
                                racks[turn-1] = original_rack[:]
                                blanks_to_remove = set((r_wp, c_wp) for r_wp, c_wp, _ in word_positions if (r_wp, c_wp) in blanks); blanks.difference_update(blanks_to_remove)
                            typing = False; typing_start = None; typing_direction = None; word_positions = []; original_tiles = None; original_rack = None

                # --- Mouse Motion ---
                elif event.type == pygame.MOUSEMOTION:
                    if dragged_tile and drag_pos: # Update position if dragging a tile
                        drag_pos = event.pos
                    elif game_over_state and dragging: # Handle dragging the game over dialog
                        x, y = event.pos; dialog_x = x - drag_offset[0]; dialog_y = y - drag_offset[1]; dialog_x = max(0, min(dialog_x, WINDOW_WIDTH - DIALOG_WIDTH)); dialog_y = max(0, min(dialog_y, WINDOW_HEIGHT - DIALOG_HEIGHT))

                # --- Mouse Button Up ---
                elif event.type == pygame.MOUSEBUTTONUP:
                    if event.button == 1: # Left button up
                        if game_over_state and dragging: dragging = False # Stop dragging game over dialog
                        elif dragged_tile and (not is_ai[dragged_tile[0]-1] or paused_for_power_tile) and not replay_mode: # Finish dragging a tile
                            x, y = event.pos
                            player_idx = dragged_tile[0] - 1
                            rack_y = BOARD_SIZE + 80 if dragged_tile[0] == 1 else BOARD_SIZE + 150
                            # Calculate rack area dynamically (consistent with draw_rack)
                            rack_width_calc = 7 * (TILE_WIDTH + TILE_GAP) - TILE_GAP
                            replay_area_end_x = 10 + 4 * (REPLAY_BUTTON_WIDTH + REPLAY_BUTTON_GAP)
                            min_rack_start_x = replay_area_end_x + BUTTON_GAP + 20
                            rack_start_x_calc = max(min_rack_start_x, (BOARD_SIZE - rack_width_calc) // 2)
                            rack_area_rect = pygame.Rect(rack_start_x_calc, rack_y, rack_width_calc, TILE_HEIGHT)

                            if rack_area_rect.collidepoint(x, y): # Dropped back on the rack area
                                rack_len = len(racks[player_idx])
                                insert_idx = get_insertion_index(x, rack_start_x_calc, rack_len) # Find insertion point
                                original_tile_idx = dragged_tile[1]

                                if 0 <= original_tile_idx < rack_len:
                                    player_rack = racks[player_idx]
                                    tile_to_move = player_rack.pop(original_tile_idx) # Remove from old position
                                    # Adjust insertion index if original index was before insertion point
                                    if original_tile_idx < insert_idx: insert_idx -= 1
                                    insert_idx = max(0, min(insert_idx, len(player_rack))) # Clamp index
                                    player_rack.insert(insert_idx, tile_to_move) # Insert at new position

                            # Always stop dragging after mouse up
                            dragged_tile = None
                            drag_pos = None

                # --- Mouse Wheel (Scrolling) ---
                elif event.type == pygame.MOUSEWHEEL:
                    mouse_x, mouse_y = pygame.mouse.get_pos()
                    # Scroll All Words Dialog
                    if showing_all_words:
                         dialog_rect_all = pygame.Rect((WINDOW_WIDTH - ALL_WORDS_DIALOG_WIDTH) // 2, (WINDOW_HEIGHT - ALL_WORDS_DIALOG_HEIGHT) // 2, ALL_WORDS_DIALOG_WIDTH, ALL_WORDS_DIALOG_HEIGHT)
                         if dialog_rect_all.collidepoint(mouse_x, mouse_y):
                              moves_for_scroll = practice_target_moves if practice_mode == "eight_letter" else all_moves
                              content_height = len(moves_for_scroll) * 30 # Assuming item height of 30
                              header_height = 40; button_area_height = BUTTON_HEIGHT + 30
                              visible_content_height = ALL_WORDS_DIALOG_HEIGHT - header_height - button_area_height
                              if content_height > visible_content_height: # Only scroll if content exceeds visible area
                                   max_scroll = content_height - visible_content_height
                                   scroll_offset -= event.y * SCROLL_SPEED
                                   scroll_offset = max(0, min(scroll_offset, max_scroll)) # Clamp scroll
                              else:
                                   scroll_offset = 0 # No scroll needed if content fits
                    # Scroll Scoreboard
                    else:
                        # Calculate scoreboard dimensions dynamically (like in drawing)
                        sb_x = BOARD_SIZE + 275; sb_y = 40; sb_w = max(200, WINDOW_WIDTH - BOARD_SIZE - 20); sb_h = WINDOW_HEIGHT - 80
                        if sb_x + sb_w > WINDOW_WIDTH - 10: sb_w = WINDOW_WIDTH - sb_x - 10
                        if sb_w < 200: sb_x = WINDOW_WIDTH - 210; sb_w = 200
                        scoreboard_rect = pygame.Rect(sb_x, sb_y, sb_w, sb_h)

                        if scoreboard_rect.collidepoint(mouse_x, mouse_y):
                             history_len = current_replay_turn if replay_mode else len(move_history)
                             total_content_height = history_len * 20 # Assuming line height of 20
                             # Add height for final score line if applicable
                             is_final_turn_in_replay = replay_mode and current_replay_turn == len(move_history)
                             if (game_over_state or is_final_turn_in_replay) and final_scores is not None:
                                  total_content_height += 40 # Add space for final scores display
                             if total_content_height > scoreboard_height: # Only scroll if needed
                                  max_scroll = total_content_height - scoreboard_height
                                  scroll_offset -= event.y * SCROLL_SPEED
                                  scroll_offset = max(0, min(scroll_offset, max_scroll)) # Clamp scroll
                             else:
                                  scroll_offset = 0

                # --- Keydown Handling (Typing & General) ---
                elif event.type == pygame.KEYDOWN:
                    is_human_turn_or_paused = not replay_mode and (not is_ai[turn-1] or paused_for_power_tile)

                    if is_human_turn_or_paused:
                        # --- Start Typing Logic ---
                        if selected_square and not typing and event.unicode.isalpha():
                            typing = True
                            original_tiles = [row[:] for row in tiles] # Store board state
                            original_rack = racks[turn-1][:] # Store rack state
                            typing_start = selected_square[:2] # (r, c)
                            typing_direction = selected_square[2] # 'right' or 'down'
                            original_selected_square = selected_square # Keep track of arrow to restore
                            selected_square = None # Hide arrow while typing
                            word_positions = [] # Track letters placed in this sequence
                            current_r, current_c = typing_start # Initial cursor position

                            letter = event.unicode.upper()
                            # Try placing the first letter
                            if 0 <= current_r < GRID_SIZE and 0 <= current_c < GRID_SIZE and not tiles[current_r][current_c]:
                                placed = False
                                if letter in racks[turn-1]: # Use regular tile
                                    tiles[current_r][current_c] = letter
                                    racks[turn-1].remove(letter)
                                    word_positions.append((current_r, current_c, letter))
                                    placed = True
                                elif ' ' in racks[turn-1]: # Use blank
                                    tiles[current_r][current_c] = letter
                                    racks[turn-1].remove(' ')
                                    blanks.add((current_r, current_c)) # Track placed blank
                                    word_positions.append((current_r, current_c, letter))
                                    placed = True

                                if placed: # Advance cursor if letter was placed
                                    if typing_direction == "right":
                                        current_c += 1
                                        # Skip over existing tiles
                                        while current_c < GRID_SIZE and tiles[current_r][current_c]:
                                            current_c += 1
                                    elif typing_direction == "down":
                                        current_r += 1
                                        # Skip over existing tiles
                                        while current_r < GRID_SIZE and tiles[current_r][current_c]:
                                            current_r += 1
                                    # Keep cursor within bounds
                                    current_r = min(current_r, GRID_SIZE - 1)
                                    current_c = min(current_c, GRID_SIZE - 1)
                            else: # Cannot start typing here (occupied or off-board)
                                 typing = False # Cancel typing start
                                 selected_square = original_selected_square # Restore arrow

                        # --- Active Typing Logic ---
                        elif typing:
                            if event.key == pygame.K_RETURN or event.key == pygame.K_KP_ENTER:
                                play_finalized_normally = False # Flag for normal game progression
                                if word_positions: # Only process if tiles were typed
                                    # Create temporary board state *including* the typed tiles for validation
                                    temp_tiles_val = [row[:] for row in original_tiles] # Start from state before typing
                                    for r_wp, c_wp, l_wp in word_positions:
                                        if 0 <= r_wp < GRID_SIZE and 0 <= c_wp < GRID_SIZE:
                                             temp_tiles_val[r_wp][c_wp] = l_wp # Add typed letters

                                    # Validate the potential play using the temporary board
                                    valid, is_bingo = is_valid_play(word_positions, temp_tiles_val, first_play, len(original_rack), original_tiles, original_rack)

                                    if valid:
                                        # Play is valid, calculate score based on *final* board state (tiles variable)
                                        score = calculate_score(word_positions, board, tiles, blanks)
                                        print(f"DEBUG: Valid play typed, score: {score}")

                                        # --- Practice Mode Specific Logic ---
                                        if practice_mode == "eight_letter":
                                            print("DEBUG: Checking 8-letter practice logic...")
                                            if practice_best_move and score == practice_best_move['score']:
                                                practice_end_message = f"Congratulations! Best: {practice_best_move['word_with_blanks']} ({score} pts)"
                                                practice_solved = True; showing_practice_end_dialog = True
                                            elif practice_best_move:
                                                show_message_dialog(f"Try again. There is another word that scores {practice_best_move['score']}.", "Incorrect")
                                                # Revert board/rack since it was incorrect
                                                if original_tiles and original_rack:
                                                    for r_wp, c_wp, _ in word_positions: tiles[r_wp][c_wp] = original_tiles[r_wp][c_wp]
                                                    racks[turn-1] = original_rack[:]
                                                    blanks_to_remove = set((r_wp, c_wp) for r_wp, c_wp, _ in word_positions if (r_wp, c_wp) in blanks); blanks.difference_update(blanks_to_remove)
                                            else: # Error case if no best move stored
                                                show_message_dialog("Error: No best move data available.", "Error")
                                                return_to_mode_selection = True; running = False
                                            # Reset typing state after attempt (unless game ends/restarts)
                                            typing = False; typing_start = None; typing_direction = None; word_positions = []; original_tiles = None; original_rack = None
                                            if not practice_solved and not return_to_mode_selection: selected_square = original_selected_square # Restore arrow if retrying

                                        elif practice_mode == "power_tiles" and paused_for_power_tile:
                                             print(f"DEBUG: Checking Power Tile ({current_power_tile}) practice logic...")
                                             uses_power = any(letter == current_power_tile for r_wp, c_wp, letter in word_positions)
                                             power_moves = [m for m in all_moves if any(pt[2] == current_power_tile for pt in m.get('newly_placed', []))]
                                             max_power_score = max(m['score'] for m in power_moves) if power_moves else 0
                                             print(f"DEBUG: Player used power tile: {uses_power}. Player score: {score}. Max power score: {max_power_score}")

                                             if not uses_power:
                                                  show_message_dialog(f"Move must use the {current_power_tile}!", "Incorrect")
                                                  # Revert board/rack
                                                  if original_tiles and original_rack:
                                                      for r_wp, c_wp, _ in word_positions: tiles[r_wp][c_wp] = original_tiles[r_wp][c_wp]
                                                      racks[turn-1] = original_rack[:]
                                                      blanks_to_remove = set((r_wp, c_wp) for r_wp, c_wp, _ in word_positions if (r_wp, c_wp) in blanks); blanks.difference_update(blanks_to_remove)
                                                  typing = False; typing_start = None; typing_direction = None; word_positions = []; original_tiles = None; original_rack = None; selected_square = original_selected_square
                                             elif score < max_power_score:
                                                  show_message_dialog(f"Try again. There is another word that scores {max_power_score}.", "Higher Score Exists")
                                                  # Revert board/rack
                                                  if original_tiles and original_rack:
                                                      for r_wp, c_wp, _ in word_positions: tiles[r_wp][c_wp] = original_tiles[r_wp][c_wp]
                                                      racks[turn-1] = original_rack[:]
                                                      blanks_to_remove = set((r_wp, c_wp) for r_wp, c_wp, _ in word_positions if (r_wp, c_wp) in blanks); blanks.difference_update(blanks_to_remove)
                                                  typing = False; typing_start = None; typing_direction = None; word_positions = []; original_tiles = None; original_rack = None; selected_square = original_selected_square
                                             else: # Correct power tile play!
                                                  show_message_dialog("That's correct! Great job.", "Correct!")
                                                  paused_for_power_tile = False # Unpause
                                                  power_tile_message_shown = False
                                                  play_finalized_normally = True # Allow normal turn progression

                                        else: # Not a special practice mode turn, finalize normally
                                            play_finalized_normally = True

                                    else: # Invalid play
                                        print(f"Invalid play.")
                                        # Revert board and rack to state before typing started
                                        if original_tiles and original_rack:
                                            for r_wp, c_wp, _ in word_positions: tiles[r_wp][c_wp] = original_tiles[r_wp][c_wp]
                                            racks[turn-1] = original_rack[:]
                                            blanks_to_remove = set((r_wp, c_wp) for r_wp, c_wp, _ in word_positions if (r_wp, c_wp) in blanks); blanks.difference_update(blanks_to_remove)
                                        # Reset typing state and restore arrow
                                        typing = False; typing_start = None; typing_direction = None; word_positions = []; original_tiles = None; original_rack = None; selected_square = original_selected_square

                                else: # Enter pressed with no tiles typed
                                     typing = False; selected_square = original_selected_square # Just restore arrow

                                # --- Normal Play Finalization (if not handled by practice logic and valid) ---
                                if play_finalized_normally:
                                    scores[turn-1] += score # Add score calculated earlier
                                    first_play = False # Mark first play as done
                                    # Draw new tiles
                                    drawn_tiles = [bag.pop() for _ in range(len(word_positions)) if bag]
                                    racks[turn-1].extend(drawn_tiles) # Add drawn tiles to rack (already had letters removed)
                                    # ---- SORT RACK ON PLAY (HUMAN ONLY) ----
                                    if not is_ai[turn-1]: racks[turn-1].sort() # Sort rack if human player
                                    # ----------------------------------------
                                    # Get details for move history
                                    full_word_tiles_hist, _ = find_main_word(word_positions, tiles) # Use final board state
                                    full_word_hist = "".join(t[2] for t in full_word_tiles_hist) if full_word_tiles_hist else "ERROR"
                                    coord_hist = get_coord(typing_start, typing_direction)
                                    word_with_blanks_list_hist = []
                                    placed_pos_set_hist = set((p[0], p[1]) for p in word_positions)
                                    blanks_in_play = blanks.copy() & placed_pos_set_hist # Find which blanks were part of this play
                                    for wr, wc, w_letter in full_word_tiles_hist:
                                        is_blank_hist = (wr, wc) in blanks_in_play
                                        word_with_blanks_list_hist.append(w_letter.lower() if is_blank_hist else w_letter.upper())
                                    word_with_blanks_hist = "".join(word_with_blanks_list_hist)
                                    # Record move
                                    move_history.append({
                                        'player': turn, 'move_type': 'place', 'rack': original_rack[:], # Rack before play
                                        'positions': [(p[0], p[1], p[2]) for p in word_positions], # Newly placed tiles only
                                        'blanks': blanks_in_play, # Newly placed blanks only
                                        'score': score, 'word': full_word_hist, 'drawn': drawn_tiles,
                                        'coord': coord_hist, 'word_with_blanks': word_with_blanks_hist, 'is_bingo': is_bingo
                                    })
                                    current_replay_turn = len(move_history)
                                    print(f"Player {turn} played: {full_word_hist} at {coord_hist} for {score} points")
                                    # Reset turn counters, advance turn
                                    consecutive_zero_point_turns = 0; pass_count = 0; exchange_count = 0
                                    human_played = True # Mark human action this turn
                                    turn = 3 - turn # Next player
                                    # Reset typing state completely
                                    typing = False; typing_start = None; typing_direction = None; word_positions = []; original_tiles = None; original_rack = None; selected_square = None

                            elif event.key == pygame.K_BACKSPACE:
                                if word_positions: # Only backspace if letters have been typed
                                    r_rem, c_rem, letter_rem = word_positions.pop() # Get last placed tile info
                                    tiles[r_rem][c_rem] = '' # Clear board square
                                    # Return tile to rack (handle blanks correctly)
                                    if (r_rem, c_rem) in blanks:
                                        blanks.remove((r_rem, c_rem))
                                        racks[turn-1].append(' ')
                                    else:
                                        racks[turn-1].append(letter_rem)
                                    # Move cursor back to the cleared square
                                    current_r, current_c = r_rem, c_rem
                                    # Skip cursor backwards over existing tiles if needed
                                    if typing_direction == "right":
                                         while current_c > 0 and tiles[current_r][current_c-1]: current_c -=1
                                    elif typing_direction == "down":
                                         while current_r > 0 and tiles[current_r-1][current_c]: current_r -=1
                                else: # Backspace pressed when no letters typed yet
                                    typing = False # Cancel typing mode
                                    selected_square = original_selected_square # Restore arrow
                                    original_tiles = None; original_rack = None # Clear saved state

                            elif event.key == pygame.K_ESCAPE:
                                 # Cancel typing and revert board/rack
                                 if original_tiles and original_rack:
                                     for r_wp, c_wp, _ in word_positions: tiles[r_wp][c_wp] = original_tiles[r_wp][c_wp]
                                     racks[turn-1] = original_rack[:]
                                     blanks_to_remove = set((r_wp, c_wp) for r_wp, c_wp, _ in word_positions if (r_wp, c_wp) in blanks); blanks.difference_update(blanks_to_remove)
                                 # Reset typing state and restore arrow
                                 typing = False; typing_start = None; typing_direction = None; word_positions = []; original_tiles = None; original_rack = None; selected_square = original_selected_square

                            elif event.unicode.isalpha(): # Typing subsequent letters
                                letter = event.unicode.upper()
                                if 0 <= current_r < GRID_SIZE and 0 <= current_c < GRID_SIZE and not tiles[current_r][current_c]: # Check if cursor position is valid and empty
                                    placed = False
                                    if letter in racks[turn-1]: # Use regular tile
                                        tiles[current_r][current_c] = letter
                                        racks[turn-1].remove(letter)
                                        word_positions.append((current_r, current_c, letter))
                                        placed = True
                                    elif ' ' in racks[turn-1]: # Use blank
                                        tiles[current_r][current_c] = letter
                                        racks[turn-1].remove(' ')
                                        blanks.add((current_r, current_c))
                                        word_positions.append((current_r, current_c, letter))
                                        placed = True

                                    if placed: # Advance cursor if letter was placed
                                        if typing_direction == "right":
                                            current_c += 1
                                            while current_c < GRID_SIZE and tiles[current_r][current_c]: current_c += 1
                                        elif typing_direction == "down":
                                            current_r += 1
                                            while current_r < GRID_SIZE and tiles[current_r][current_c]: current_r += 1
                                        current_r = min(current_r, GRID_SIZE - 1)
                                        current_c = min(current_c, GRID_SIZE - 1)
                                else:
                                     print("Cannot type here (occupied or off-board).")


            # --- Game Over Check ---
            if not replay_mode and not game_over_state and practice_mode != "eight_letter":
                game_ended = False; reason = ""
                # Condition 1: Bag empty and one player has no tiles
                if not bag and (not racks[0] or not racks[1]):
                    game_ended = True; reason = "Bag empty & rack empty"
                # Condition 2: Six consecutive zero-point turns (3 passes/exchanges by each player)
                elif consecutive_zero_point_turns >= 6:
                    game_ended = True; reason = "Six Consecutive Zero-Point Turns"

                if game_ended:
                    print(f"Game over triggered: {reason}");
                    # Calculate final scores using the helper function
                    final_scores = calculate_final_scores(scores, racks, bag) # Use the dedicated function

                    # Set game over state and reset UI states
                    game_over_state = True; exchanging = False; hinting = False; showing_all_words = False
                    dropdown_open = False; dragging = False; typing = False; selected_square = None
                    dialog_x = (WINDOW_WIDTH - DIALOG_WIDTH) // 2 # Reset dialog position
                    dialog_y = (WINDOW_HEIGHT - DIALOG_HEIGHT) // 2


            # --- Drawing Logic ---
            screen.fill(WHITE)
            # Determine which state to display (live or replay)
            if replay_mode:
                if 0 <= current_replay_turn <= len(move_history):
                    # Get the board/rack state *after* the current_replay_turn-th move
                    tiles_to_display, blanks_to_display, scores_to_display, racks_to_display = get_replay_state(current_replay_turn, initial_racks)
                    # Determine whose turn it *would* be next
                    turn_to_display = 1 if current_replay_turn == 0 else (3 - move_history[current_replay_turn - 1]['player'])
                else: # Should not happen, but default to initial state
                    tiles_to_display, blanks_to_display, scores_to_display, racks_to_display = get_replay_state(0, initial_racks)
                    turn_to_display = 1
            else: # Live game state
                tiles_to_display, blanks_to_display, racks_to_display = tiles, blanks, racks
                scores_to_display = final_scores if game_over_state else scores
                turn_to_display = turn

            # Draw Board and Tiles
            for r in range(GRID_SIZE):
                for c in range(GRID_SIZE):
                    # Draw square background color
                    pygame.draw.rect(screen, board[r][c], (40 + c * SQUARE_SIZE, 40 + r * SQUARE_SIZE, SQUARE_SIZE, SQUARE_SIZE))
                    # Draw grid lines
                    pygame.draw.rect(screen, BLACK, (40 + c * SQUARE_SIZE, 40 + r * SQUARE_SIZE, SQUARE_SIZE, SQUARE_SIZE), 1)
                    # Draw tile if present
                    if tiles_to_display[r][c]:
                        tile_char = tiles_to_display[r][c]; is_blank_on_board = (r, c) in blanks_to_display
                        if is_blank_on_board: # Draw blank tile (circle with letter)
                            center = (40 + c * SQUARE_SIZE + SQUARE_SIZE // 2, 40 + r * SQUARE_SIZE + SQUARE_SIZE // 2); radius = SQUARE_SIZE // 2 - 3
                            pygame.draw.circle(screen, BLACK, center, radius); text_surf = font.render(tile_char, True, WHITE); text_rect = text_surf.get_rect(center=center); screen.blit(text_surf, text_rect)
                        else: # Draw regular tile (square with letter)
                            tile_rect = pygame.Rect(40 + c * SQUARE_SIZE + 2, 40 + r * SQUARE_SIZE + 2, SQUARE_SIZE - 4, SQUARE_SIZE - 4); pygame.draw.rect(screen, GREEN, tile_rect); text_surf = font.render(tile_char, True, BLACK); text_rect = text_surf.get_rect(center=tile_rect.center); screen.blit(text_surf, text_rect)

            # Highlight last played tiles in Replay mode
            if replay_mode and current_replay_turn > 0:
                 last_move_data = move_history[current_replay_turn - 1]
                 if last_move_data['move_type'] == 'place' and 'positions' in last_move_data:
                     # Get the board state *before* the last move to know which tiles were new
                     original_replay_tiles, _, _, _ = get_replay_state(current_replay_turn - 1, initial_racks)
                     placed_coords_in_move = last_move_data.get('newly_placed', []) # Use 'newly_placed' if available
                     if not placed_coords_in_move: # Fallback if 'newly_placed' isn't stored
                          placed_coords_in_move = [(p[0], p[1], p[2]) for p in last_move_data.get('positions', []) if not original_replay_tiles[p[0]][p[1]]]

                     for r, c, _ in placed_coords_in_move:
                          if 0 <= r < GRID_SIZE and 0 <= c < GRID_SIZE: # Check bounds just in case
                               pygame.draw.rect(screen, YELLOW, (40 + c * SQUARE_SIZE, 40 + r * SQUARE_SIZE, SQUARE_SIZE, SQUARE_SIZE), 3) # Highlight border

            # Draw Row/Column Labels
            for r in range(GRID_SIZE): row_label = ui_font.render(str(r + 1), True, BLACK); screen.blit(row_label, (10, 40 + r * SQUARE_SIZE + (SQUARE_SIZE // 2 - row_label.get_height() // 2)))
            for c in range(GRID_SIZE): col_label = ui_font.render(LETTERS[c], True, BLACK); screen.blit(col_label, (40 + c * SQUARE_SIZE + (SQUARE_SIZE // 2 - col_label.get_width() // 2), 10))

            # Draw Racks (pass correct drag info)
            p1_rack_to_draw = racks_to_display[0] if len(racks_to_display) > 0 else []
            p1_drag_info = dragged_tile if dragged_tile and dragged_tile[0] == 1 else None
            p1_alpha_rect, p1_rand_rect = draw_rack(1, p1_rack_to_draw, scores_to_display, turn_to_display, player_names, p1_drag_info, drag_pos)

            p2_alpha_rect, p2_rand_rect = None, None
            if practice_mode != "eight_letter": # Don't draw P2 rack in 8-letter practice
                p2_rack_to_draw = racks_to_display[1] if len(racks_to_display) > 1 else []
                p2_drag_info = dragged_tile if dragged_tile and dragged_tile[0] == 2 else None
                p2_alpha_rect, p2_rand_rect = draw_rack(2, p2_rack_to_draw, scores_to_display, turn_to_display, player_names, p2_drag_info, drag_pos)

            # Draw Remaining Tiles (if not 8-letter practice)
            if practice_mode != "eight_letter":
                current_player_index = turn_to_display - 1
                if 0 <= current_player_index < len(racks_to_display):
                    remaining = get_remaining_tiles(racks_to_display[current_player_index], tiles_to_display, blanks_to_display)
                    draw_remaining_tiles(remaining, turn_to_display)
                else: # Handle case where racks might not be fully initialized yet
                    draw_remaining_tiles({}, turn_to_display)

            # Draw UI Buttons (Options, Suggest, Hint)
            options_rect, dropdown_rects = draw_options_menu(turn_to_display, dropdown_open, len(bag))
            suggest_rect = None; hint_rect = None
            if not replay_mode: # Suggest only available in live game
                 suggest_rect = draw_suggest_button()
                 # Draw Hint button only if paused for power tile practice
                 if paused_for_power_tile and suggest_rect:
                      hint_x = suggest_rect.x; hint_y = suggest_rect.y + suggest_rect.height + BUTTON_GAP
                      hint_rect = pygame.Rect(hint_x, hint_y, OPTIONS_WIDTH, OPTIONS_HEIGHT)
                      hover = hint_rect.collidepoint(pygame.mouse.get_pos()); color = BUTTON_HOVER if hover else BUTTON_COLOR
                      pygame.draw.rect(screen, color, hint_rect); hint_text = button_font.render("Hint", True, BLACK)
                      hint_text_rect = hint_text.get_rect(center=hint_rect.center); screen.blit(hint_text, hint_text_rect)

            # Draw Scoreboard
            history_to_draw = move_history[:current_replay_turn] if replay_mode else move_history
            is_final_turn_in_replay = replay_mode and current_replay_turn == len(move_history)
            draw_scoreboard(screen, history_to_draw, scroll_offset, scores_to_display, is_ai, final_scores=final_scores, game_over_state=game_over_state or is_final_turn_in_replay)

            # Draw Typing Arrow / Cursor
            if selected_square and not typing: # Show direction arrow if square selected
                draw_arrow(selected_square[0], selected_square[1], selected_square[2])
            elif typing: # Show typing cursor
                 if current_r is not None and current_c is not None: # Ensure cursor pos is valid
                     cursor_x = 40 + current_c * SQUARE_SIZE + SQUARE_SIZE // 2
                     cursor_y = 40 + current_r * SQUARE_SIZE + SQUARE_SIZE - 5 # Position at bottom-center
                     # Blinking cursor effect
                     if int(time.time() * 2) % 2 == 0: # Blink roughly twice per second
                          pygame.draw.line(screen, BLACK, (cursor_x - 5, cursor_y), (cursor_x + 5, cursor_y), 2)

            # Draw Dialogs (if active) - Draw these last to overlay others
            if exchanging: tile_rects, exchange_button_rect, cancel_button_rect = draw_exchange_dialog(racks[turn-1], selected_tiles)
            elif hinting: hint_rects, play_button_rect, ok_button_rect, all_words_button_rect = draw_hint_dialog(hint_moves, selected_hint_index)
            elif showing_all_words:
                moves_for_all = practice_target_moves if practice_mode == "eight_letter" else all_moves
                all_words_rects, all_words_play_rect, all_words_ok_rect = draw_all_words_dialog(moves_for_all, selected_hint_index, scroll_offset)
            elif showing_practice_end_dialog:
                practice_play_again_rect, practice_main_menu_rect, practice_quit_rect = draw_practice_end_dialog(practice_end_message)

            # Draw Replay Controls (if active)
            if replay_mode:
                replay_controls = [(replay_start_rect, "start"), (replay_prev_rect, "prev"), (replay_next_rect, "next"), (replay_end_rect, "end")]
                for rect, icon_type in replay_controls:
                    hover = rect.collidepoint(pygame.mouse.get_pos())
                    color = BUTTON_HOVER if hover else BUTTON_COLOR
                    pygame.draw.rect(screen, color, rect)
                    draw_replay_icon(screen, rect, icon_type)

            # Draw Game Over Dialog / Stats Dialog (if active)
            if game_over_state:
                if final_scores is not None: # Ensure scores are calculated
                     save_rect, quit_rect, replay_rect, play_again_rect, stats_rect = draw_game_over_dialog(dialog_x, dialog_y, final_scores, reason, player_names)
                if showing_stats and final_scores:
                     ok_button_rect = draw_stats_dialog(dialog_x + 20, dialog_y + 20, player_names, final_scores, tiles) # Assuming stats dialog is drawn relative

            # Draw dragged tile last so it's on top
            if dragged_tile and drag_pos:
                # Need to redraw the specific player's rack temporarily without the dragged tile
                # then draw the dragged tile at mouse position
                player_idx_drag = dragged_tile[0]-1
                rack_to_draw_temp = racks[player_idx_drag][:]
                tile_val = None
                if 0 <= dragged_tile[1] < len(rack_to_draw_temp):
                    tile_val = rack_to_draw_temp.pop(dragged_tile[1]) # Remove for redraw

                # Redraw rack background for that player (optional, but cleaner)
                # Simplified redraw - just draw the tile at the cursor
                if tile_val:
                    temp_rack = [tile_val] # Single tile rack
                    # Use draw_rack logic to draw just this tile at drag_pos
                    tile_x_drag, tile_y_drag = drag_pos
                    if tile_val == ' ':
                         center = (tile_x_drag, tile_y_drag); radius = TILE_WIDTH // 2 - 2
                         pygame.draw.circle(screen, BLACK, center, radius); text = font.render('?', True, WHITE)
                         text_rect = text.get_rect(center=center); screen.blit(text, text_rect)
                    else:
                         # Adjust position based on drag offset for centered dragging feel
                         draw_x = tile_x_drag - drag_offset[0]
                         draw_y = tile_y_drag - drag_offset[1]
                         pygame.draw.rect(screen, GREEN, (draw_x, draw_y, TILE_WIDTH, TILE_HEIGHT))
                         text = font.render(tile_val, True, BLACK); screen.blit(text, (draw_x + 5, draw_y + 5))


            pygame.display.flip() # Update the full display

        # --- End of Main Game Loop ---
        print("--- main(): Exited main game loop. ---")
        if return_to_mode_selection:
            print("--- main(): Returning to mode selection... ---")
            main_called = False # Reset flag to allow re-entry into mode selection
            main() # Call main again to restart the process
        else:
            print("--- main(): Quitting pygame and exiting. ---")
            pygame.quit(); sys.exit()

# --- Program Entry Point ---
if __name__ == "__main__":
    print("--- Script execution started (__name__ == '__main__') ---")
    main_called = False # Ensure flag is reset before first call
    main()
