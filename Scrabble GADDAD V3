# python
# Stable 13APR24
# MODIFIED: 14APR24 - Replaced move generation with anchor-based algorithm

# Part 1: Imports, Constants, Classes, Setup

import pygame
import random
import math
import sys
import time
import pickle
import os
from itertools import permutations, product
from collections import Counter

# --- GADDAG Node Definition ---
class GaddagNode:
    """Represents a node in the GADDAG."""
    __slots__ = ['children', 'is_terminal'] # Memory optimization

    def __init__(self):
        self.children = {}  # Dictionary mapping letter -> GaddagNode
        self.is_terminal = False # True if a path ending here is a valid word/subword

# --- GADDAG Class Definition ---
class Gaddag:
    """
    Represents the GADDAG data structure.
    This class definition is needed to correctly unpickle the object.
    The actual building happens in gaddag_builder.py.
    """
    SEPARATOR = '>' # Special character used in GADDAG paths

    def __init__(self):
        # The root node will be populated when loading from pickle
        self.root = GaddagNode()

    # No insert method needed here, as we load a pre-built structure.

# --- Trie/DAWG Node Definition (for basic dictionary lookup) ---
class TrieNode:
    def __init__(self):
        self.children = {}
        self.is_end = False

# --- Dawg Class Definition (for basic dictionary lookup) ---
class Dawg: # Renaming our existing Trie to Dawg for conceptual clarity
    def __init__(self):
        self.root = TrieNode()

    def insert(self, word):
        node = self.root
        for char in word:
            if char not in node.children:
                node.children[char] = TrieNode()
            node = node.children[char]
        node.is_end = True

    def search(self, word):
        """Check if a word exists in the DAWG."""
        node = self.root
        for char in word:
            if char not in node.children:
                return False
            node = node.children[char]
        return node.is_end

    def is_prefix(self, prefix):
        """Check if a prefix exists in the DAWG."""
        node = self.root
        for char in prefix:
            if char not in node.children:
                return False
            node = node.children[char]
        return True # It's a prefix if we reached the end of the string

# Initialize Pygame
pygame.init()
main_called = False # Flag to track if main() has been entered

# Constants
GADDAG_STRUCTURE = None
DAWG = None # Initialize DAWG global
GRID_SIZE = 15
SQUARE_SIZE = 40
BOARD_SIZE = GRID_SIZE * SQUARE_SIZE
FONT_SIZE = SQUARE_SIZE // 2
TILE_WIDTH = 35
TILE_HEIGHT = 35
TILE_GAP = 5
BUTTON_WIDTH = 100
BUTTON_HEIGHT = 30
BUTTON_GAP = 10
CENTER_SQUARE = (7, 7)
OPTIONS_WIDTH = 100
OPTIONS_HEIGHT = 30
DROPDOWN_HEIGHT = 90
OPTIONS_Y = BOARD_SIZE + 60
DOUBLE_CLICK_TIME = 300
SECOND_CLICK_TIME = 500
ALL_WORDS_DIALOG_WIDTH = 750
ALL_WORDS_DIALOG_HEIGHT = 600
SCROLL_SPEED = 20
DIALOG_WIDTH = 480
DIALOG_HEIGHT = 250
LETTERS = "ABCDEFGHIJKLMNO"

# Get screen resolution
display_info = pygame.display.Info()
WINDOW_WIDTH = min(1400, display_info.current_w - 50)
WINDOW_HEIGHT = min(900, display_info.current_h - 50)

# Colors
WHITE = (255, 255, 255)
BLACK = (0, 0, 0)
RED = (255, 100, 100)
PINK = (255, 182, 193)
BLUE = (0, 102, 204)
LIGHT_BLUE = (135, 206, 250)
HIGHLIGHT_BLUE = (191, 238, 255)
YELLOW = (255, 255, 153)
GRAY = (200, 200, 200)
GREEN = (144, 238, 144)
DARK_GREEN = (100, 200, 100)
BUTTON_COLOR = (180, 180, 180)
BUTTON_HOVER = (220, 220, 220)
TURN_INDICATOR_COLOR = (255, 215, 0)
DIALOG_COLOR = (150, 150, 150)
DROPDOWN_COLOR = (200, 200, 200)
SELECTED_TILE_COLOR = (255, 165, 0)
GRAYED_OUT_COLOR = (100, 100, 100)
ARROW_COLOR = (0, 0, 255)
HINT_NORMAL_COLOR = (220, 220, 220)
HINT_SELECTED_COLOR = (180, 180, 255)

# Setup display and font
screen = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))
pygame.display.set_caption("Scrabble Game")
font = pygame.font.SysFont("Arial", FONT_SIZE, bold=True)
ui_font = pygame.font.SysFont("Arial", 20)
button_font = pygame.font.SysFont("Arial", 16)
tile_count_font = pygame.font.SysFont("Arial", 14)
dialog_font = pygame.font.SysFont("Arial", 24)

# Tile bag and values
TILE_DISTRIBUTION = {
    'A': (9, 1), 'B': (2, 3), 'C': (2, 3), 'D': (4, 2), 'E': (12, 1), 'F': (2, 4),
    'G': (3, 2), 'H': (2, 4), 'I': (9, 1), 'J': (1, 8), 'K': (1, 5), 'L': (4, 1),
    'M': (2, 3), 'N': (6, 1), 'O': (8, 1), 'P': (2, 3), 'Q': (1, 10), 'R': (6, 1),
    'S': (4, 1), 'T': (6, 1), 'U': (4, 1), 'V': (2, 4), 'W': (2, 4), 'X': (1, 8),
    'Y': (2, 4), 'Z': (1, 10), ' ': (2, 0)
}
POWER_TILES = {'J', 'Q', 'X', 'Z'}

# Global bag - initialized properly in main() or practice setup
bag = []

# Global game state variables (will be initialized/reset in main)
board = None # This will store board colors
tiles = None # This will store letters on the board
racks = None
blanks = None
scores = None
turn = 1
first_play = True
game_mode = None
is_ai = None
practice_mode = None
move_history = []
replay_mode = False
current_replay_turn = 0
last_word = ""
last_score = 0
last_start = None
last_direction = None
initial_racks = [] # Store initial racks for replay/saving

# --- GCG Handling ---
def save_game_to_gcg(player_names, move_history, initial_racks_arg, final_scores):
    """Save the game to GCG format using move_history directly."""
    # Use initial_racks_arg passed to the function
    gcg_lines = [
        "#",
        f"#player1 {player_names[0]}",
        f"#player2 {player_names[1]}"
    ]
    # Add initial racks if available
    if initial_racks_arg and len(initial_racks_arg) == 2:
         gcg_lines.append(f"#rack1 {''.join(sorted(tile if tile != ' ' else '?' for tile in initial_racks_arg[0]))}")
         gcg_lines.append(f"#rack2 {''.join(sorted(tile if tile != ' ' else '?' for tile in initial_racks_arg[1]))}")

    cumulative_scores = [0, 0]

    for move in move_history:
        player = move['player'] - 1  # 0-based index
        # Use the rack state *before* the move for the GCG line
        rack_before_move = ''.join(sorted(tile if tile != ' ' else '?' for tile in move['rack']))

        if move['move_type'] == 'place':
            word_with_blanks = move.get('word_with_blanks', move.get('word','').upper())
            score = move['score']
            cumulative_scores[player] += score
            gcg_lines.append(
                f">{player_names[player]}: {rack_before_move} {move['coord']} {word_with_blanks} +{score} {cumulative_scores[player]}"
            )
        elif move['move_type'] == 'exchange':
            exchanged = ''.join(sorted(tile if tile != ' ' else '?' for tile in move.get('exchanged_tiles',[])))
            cumulative_scores[player] += move['score'] # Should be 0
            gcg_lines.append(
                f">{player_names[player]}: {rack_before_move} ({exchanged}) +{move['score']} {cumulative_scores[player]}"
            )
        elif move['move_type'] == 'pass':
            cumulative_scores[player] += move['score'] # Should be 0
            gcg_lines.append(
                f">{player_names[player]}: {rack_before_move} -- +{move['score']} {cumulative_scores[player]}"
            )

    gcg_lines.append(f"Final score: {player_names[0]} {final_scores[0]}, {player_names[1]} {final_scores[1]}")

    return '\n'.join(gcg_lines)

def load_game_from_gcg(filename):
    """Load a game from a GCG file, returning data to enter replay mode."""
    loaded_move_history = []
    player_names = ["Player1", "Player2"]
    final_scores = [0, 0]
    loaded_initial_racks = [[], []] # Store loaded initial racks

    try:
        with open(filename, "r") as f:
            lines = f.readlines()
    except FileNotFoundError:
        print(f"Error: GCG file not found: {filename}")
        return None, None, None, None # Indicate failure

    # First pass: Get player names and initial racks
    for line in lines:
        line = line.strip()
        if line.startswith("#player1"):
            player_names[0] = line.split(maxsplit=1)[1]
        elif line.startswith("#player2"):
            player_names[1] = line.split(maxsplit=1)[1]
        elif line.startswith("#rack1"):
            rack_str = line.split(maxsplit=1)[1]
            loaded_initial_racks[0] = [c if c != '?' else ' ' for c in rack_str]
        elif line.startswith("#rack2"):
            rack_str = line.split(maxsplit=1)[1]
            loaded_initial_racks[1] = [c if c != '?' else ' ' for c in rack_str]

    # Second pass: Process moves (requires player names)
    temp_bag = [letter for letter, (count, _) in TILE_DISTRIBUTION.items() for _ in range(count)]
    temp_racks = [loaded_initial_racks[0][:], loaded_initial_racks[1][:]] # Start with initial racks
    # Remove initial rack tiles from temp_bag
    for tile in temp_racks[0] + temp_racks[1]:
        if tile in temp_bag:
            temp_bag.remove(tile)
        else:
            # Allow loading even if initial rack doesn't match standard distribution
            print(f"Warning: Initial rack tile '{tile}' not found in standard bag distribution during GCG load.")
    random.shuffle(temp_bag) # Shuffle remaining bag

    for line_num, line in enumerate(lines):
        line = line.strip()
        if line.startswith("Final score:"):
            parts = line.split()
            try:
                final_scores[0] = int(parts[2].strip(','))
                final_scores[1] = int(parts[4])
            except (IndexError, ValueError):
                print(f"Warning: Could not parse final score line: {line}")
                final_scores = [0, 0] # Default if parsing fails
        elif line.startswith(">"):
            parts = line.split(maxsplit=4) # Split max 4 times
            if len(parts) < 5:
                print(f"Warning: Skipping malformed GCG move line {line_num+1}: {line}")
                continue

            player_name = parts[0][1:-1]  # Remove > and :
            player = 1 if player_name == player_names[0] else 2
            player_idx = player - 1
            rack_before_str = parts[1]
            move_details = parts[2]
            score_str = parts[3]
            # cumulative_score_str = parts[4] # We don't strictly need this

            try:
                score = int(score_str.lstrip('+'))
                # cumulative_score = int(cumulative_score_str)
            except ValueError:
                print(f"Warning: Could not parse score/cumulative score in GCG line {line_num+1}: {line}")
                continue

            rack_before_list = [c if c != '?' else ' ' for c in rack_before_str]
            move_data = {'player': player, 'rack': rack_before_list, 'score': score, 'drawn': []} # Base move data

            if move_details == "--": # Pass
                move_data.update({'move_type': 'pass', 'word': '', 'coord': '', 'blanks': set(), 'positions': [], 'is_bingo': False, 'word_with_blanks': ''})
                # No tiles drawn or removed
            elif move_details.startswith("("): # Exchange
                exchanged_str = move_details[1:-1]
                exchanged_list = [c if c != '?' else ' ' for c in exchanged_str]
                num_exchanged = len(exchanged_list)
                drawn_tiles = [temp_bag.pop() for _ in range(num_exchanged) if temp_bag]
                move_data.update({'move_type': 'exchange', 'exchanged_tiles': exchanged_list, 'drawn': drawn_tiles, 'word': '', 'coord': '', 'blanks': set(), 'positions': [], 'is_bingo': False, 'word_with_blanks': ''})
                # Update temp rack state for next move's bag calculation
                temp_rack_copy = temp_racks[player_idx][:]
                for tile in exchanged_list:
                    if tile in temp_rack_copy: temp_rack_copy.remove(tile)
                    else: print(f"GCG Load Warning: Move {len(loaded_move_history)+1} tried to exchange '{tile}', not found in temp rack.")
                temp_rack_copy.extend(drawn_tiles)
                temp_racks[player_idx] = temp_rack_copy
                # Add exchanged back to bag
                temp_bag.extend(exchanged_list)
                random.shuffle(temp_bag)
            else: # Place word
                position = parts[2]
                word_played = parts[3] # This includes lowercase for blanks
                start_pos, direction = parse_coord(position)
                if start_pos is None:
                    print(f"Warning: Could not parse position '{position}' in GCG line {line_num+1}: {line}")
                    continue
                row, col = start_pos

                positions_list = [] # Tiles placed in this move (r, c, letter)
                blanks_set = set()    # Coords of blanks placed in this move {(r, c)}
                tiles_placed_count = 0
                temp_rack_copy = temp_racks[player_idx][:] # Work with a copy

                # Simulate placing the word to determine which tiles came from the rack
                # This requires a temporary board state as well
                temp_board_tiles = [['' for _ in range(GRID_SIZE)] for _ in range(GRID_SIZE)]
                # Populate temp board from previous moves
                for prev_move in loaded_move_history:
                     if prev_move['move_type'] == 'place':
                          for r_pm, c_pm, l_pm in prev_move.get('positions', []):
                               if 0 <= r_pm < GRID_SIZE and 0 <= c_pm < GRID_SIZE:
                                    temp_board_tiles[r_pm][c_pm] = l_pm

                for i, letter_played in enumerate(word_played):
                    r_tile = row if direction == "right" else row + i
                    c_tile = col + i if direction == "right" else col
                    actual_letter = letter_played.upper()
                    is_blank = letter_played.islower()

                    # Check if the square was empty *before* this move
                    if 0 <= r_tile < GRID_SIZE and 0 <= c_tile < GRID_SIZE:
                        if not temp_board_tiles[r_tile][c_tile]: # Tile was placed by player
                            positions_list.append((r_tile, c_tile, actual_letter))
                            if is_blank:
                                blanks_set.add((r_tile, c_tile))
                                if ' ' in temp_rack_copy:
                                     temp_rack_copy.remove(' ')
                                     tiles_placed_count += 1
                                else: print(f"GCG Load Warning: Move {len(loaded_move_history)+1} needed blank, not found in temp rack.")
                            else:
                                if actual_letter in temp_rack_copy:
                                     temp_rack_copy.remove(actual_letter)
                                     tiles_placed_count += 1
                                else: print(f"GCG Load Warning: Move {len(loaded_move_history)+1} needed '{actual_letter}', not found in temp rack.")
                        # Update temp board for subsequent checks within the same move (unlikely needed for GCG)
                        temp_board_tiles[r_tile][c_tile] = actual_letter
                    else:
                         print(f"GCG Load Warning: Invalid coordinate ({r_tile},{c_tile}) for move {len(loaded_move_history)+1}")


                drawn_tiles = [temp_bag.pop() for _ in range(tiles_placed_count) if temp_bag]
                temp_rack_copy.extend(drawn_tiles)
                temp_racks[player_idx] = temp_rack_copy # Update rack for next turn

                is_bingo = (tiles_placed_count == 7)

                move_data.update({
                    'move_type': 'place',
                    'positions': positions_list, # Store newly placed only
                    'blanks': blanks_set,
                    'word': word_played.upper(), # Store uppercase version
                    'start': start_pos,
                    'direction': direction,
                    'coord': position,
                    'drawn': drawn_tiles,
                    'word_with_blanks': word_played, # Keep original case for this field
                    'is_bingo': is_bingo
                })

            loaded_move_history.append(move_data)

    return player_names, loaded_move_history, final_scores, loaded_initial_racks


# --- Coordinate Handling ---
def get_coord(start, direction):
    """Convert (row, col), direction into GCG coordinate string."""
    row, col = start
    if direction == "right":
        return f"{row + 1}{LETTERS[col]}"
    elif direction == "down": # Explicitly check for down
        return f"{LETTERS[col]}{row + 1}"
    else: # Should not happen with valid moves
        print(f"Warning: Invalid direction '{direction}' in get_coord")
        return f"{row+1}?{col+1}"


def parse_coord(coord):
    """Parse a GCG coordinate (e.g., '8H' or 'H8') into (row, col) and direction."""
    if not coord: return None, None # Handle empty coord
    if coord[0].isalpha():  # Vertical: e.g., H8 or H10
        col_char = coord[0]
        row_str = coord[1:]
        if col_char not in LETTERS or not row_str.isdigit(): return None, None
        col = LETTERS.index(col_char)
        row = int(row_str) - 1
        direction = "down"
    else:  # Horizontal: e.g., 8H or 10A
        i = 0
        while i < len(coord) and coord[i].isdigit(): i += 1
        row_str = coord[:i]
        col_char = coord[i:]
        if not row_str.isdigit() or len(col_char) != 1 or col_char not in LETTERS: return None, None
        row = int(row_str) - 1
        col = LETTERS.index(col_char)
        direction = "right"

    if not (0 <= row < GRID_SIZE and 0 <= col < GRID_SIZE): return None, None # Bounds check
    return (row, col), direction

# --- Board Creation ---
def create_board():
    """Initialize the Scrabble board with special squares and labels."""
    board_colors = [[WHITE for _ in range(GRID_SIZE)] for _ in range(GRID_SIZE)]
    # labels are not used currently, tiles holds the letters
    tiles_on_board = [['' for _ in range(GRID_SIZE)] for _ in range(GRID_SIZE)]

    tw = [(0, 0), (0, 7), (0, 14), (7, 0), (7, 14), (14, 0), (14, 7), (14, 14)]
    dw = [(1, 1), (2, 2), (3, 3), (4, 4), (10, 10), (11, 11), (12, 12), (13, 13),
          (1, 13), (2, 12), (3, 11), (4, 10), (10, 4), (11, 3), (12, 2), (13, 1)]
    tl = [(1, 5), (1, 9), (5, 1), (5, 5), (5, 9), (5, 13), (9, 1), (9, 5),
          (9, 9), (9, 13), (13, 5), (13, 9)]
    dl = [(0, 3), (0, 11), (2, 6), (2, 8), (3, 0), (3, 7), (3, 14), (6, 2),
          (6, 6), (6, 8), (6, 12), (7, 3), (7, 11), (8, 2), (8, 6), (8, 8),
          (8, 12), (11, 0), (11, 7), (11, 14), (12, 6), (12, 8), (14, 3), (14, 11)]

    for r, c in tw: board_colors[r][c] = RED
    for r, c in dw: board_colors[r][c] = PINK
    for r, c in tl: board_colors[r][c] = BLUE
    for r, c in dl: board_colors[r][c] = LIGHT_BLUE
    board_colors[7][7] = PINK # Center square

    # Return the color grid and the empty tile grid
    return board_colors, tiles_on_board

# --- Load DAWG ---
# Moved DAWG loading here to ensure it happens before potential use
try:
    DAWG = Dawg() # Initialize DAWG object
    # Ensure the path is correct or adjust as needed
    with open("All Words 2023.txt", "r") as f:
        for word in (w.strip().upper() for w in f):
            if len(word) > 1: # Optionally filter out single-letter words if not needed
                DAWG.insert(word)
    print("DAWG loaded successfully from text file.")
except FileNotFoundError:
    print("Error: 'All Words 2023.txt' not found. Word validation will not work.")
    DAWG = None # Ensure DAWG is None if loading fails
except Exception as e:
    print(f"Error loading DAWG from text file: {e}")
    DAWG = None

# GADDAG loading happens in main() after mode selection

# --- Mode Selection Constants ---
MODE_HVH = "Human vs Human"
MODE_HVA = "Human vs AI"
MODE_AVA = "AI vs AI"

# --- Replay Button Positions ---
REPLAY_BUTTON_Y = OPTIONS_Y + OPTIONS_HEIGHT + 10
REPLAY_BUTTON_WIDTH = 50
REPLAY_BUTTON_HEIGHT = 30
REPLAY_BUTTON_GAP = 10
replay_start_rect = pygame.Rect(10, REPLAY_BUTTON_Y, REPLAY_BUTTON_WIDTH, REPLAY_BUTTON_HEIGHT)
replay_prev_rect = pygame.Rect(10 + REPLAY_BUTTON_WIDTH + REPLAY_BUTTON_GAP, REPLAY_BUTTON_Y, REPLAY_BUTTON_WIDTH, REPLAY_BUTTON_HEIGHT)
replay_next_rect = pygame.Rect(10 + 2 * (REPLAY_BUTTON_WIDTH + REPLAY_BUTTON_GAP), REPLAY_BUTTON_Y, REPLAY_BUTTON_WIDTH, REPLAY_BUTTON_HEIGHT)
replay_end_rect = pygame.Rect(10 + 3 * (REPLAY_BUTTON_WIDTH + REPLAY_BUTTON_GAP), REPLAY_BUTTON_Y, REPLAY_BUTTON_WIDTH, REPLAY_BUTTON_HEIGHT)

# Part 2: Drawing Functions

def draw_rack(player, rack, scores, turn, player_names, dragged_tile=None, drag_pos=None, display_scores=None):
    """Draw a player's rack with tiles, scores, and buttons."""
    global practice_mode, replay_mode # Access global flags

    if not rack: return None, None, [], 0 # Return Nones and empty list/zero if no rack
    if display_scores is None: display_scores = scores
    if practice_mode == "eight_letter" and player == 2: return None, None, [], 0 # Don't draw P2 rack

    rack_width = 7 * (TILE_WIDTH + TILE_GAP) - TILE_GAP
    # Calculate the rightmost extent of the replay buttons area if they are visible
    replay_area_end_x = 0
    if replay_mode: # Only consider replay buttons if in replay mode
        replay_area_end_x = 10 + 4 * (REPLAY_BUTTON_WIDTH + REPLAY_BUTTON_GAP) # 10 + 4*(50+10) = 250

    # Calculate minimum start x for the rack
    # Consider options/suggest buttons (start at 10, width 100, gap 10 -> ends at 10+100+10+100 = 220)
    # Consider replay buttons if visible
    # Add gap and star indicator offset (star is at start_x - 20)
    min_rack_start_x = max(220, replay_area_end_x) + BUTTON_GAP + 20

    # Try to center the rack, but ensure it starts after the minimum x to avoid overlap
    start_x = max(min_rack_start_x, (BOARD_SIZE - rack_width) // 2)

    rack_y = BOARD_SIZE + 80 if player == 1 else BOARD_SIZE + 150

    # Draw turn indicator (star)
    if turn == player and (practice_mode != "eight_letter" or player == 1):
        center_x = start_x - 20
        center_y = rack_y + TILE_HEIGHT // 2
        radius = 10
        points = []
        for i in range(10):
            angle = i * math.pi / 5
            r = radius if i % 2 == 0 else radius / 2
            x_star = center_x + r * math.cos(angle - math.pi / 2) # Adjust angle for point up
            y_star = center_y + r * math.sin(angle - math.pi / 2)
            points.append((x_star, y_star))
        pygame.draw.polygon(screen, TURN_INDICATOR_COLOR, points)

    # Draw tiles on rack
    tile_rects_on_rack = [] # Store rects for drag detection
    for i, tile in enumerate(rack):
        tile_x = start_x + i * (TILE_WIDTH + TILE_GAP)
        tile_rect = pygame.Rect(tile_x, rack_y, TILE_WIDTH, TILE_HEIGHT)
        tile_rects_on_rack.append(tile_rect)

        if dragged_tile == (player, i) and drag_pos: continue # Don't draw if being dragged

        if tile == ' ': # Draw blank tile
            center = tile_rect.center
            radius = TILE_WIDTH // 2 - 2
            pygame.draw.circle(screen, BLACK, center, radius)
            # text = font.render('?', True, WHITE) # Optional: draw '?' on blank
            # text_rect = text.get_rect(center=center)
            # screen.blit(text, text_rect)
        else: # Draw regular tile
            pygame.draw.rect(screen, GREEN, tile_rect)
            text = font.render(tile, True, BLACK)
            text_rect = text.get_rect(center=tile_rect.center) # Center text
            screen.blit(text, text_rect)

    # Draw dragged tile (if any for this player)
    if dragged_tile and dragged_tile[0] == player and drag_pos:
        tile_x_drag, tile_y_drag = drag_pos
        if 0 <= dragged_tile[1] < len(rack):
            tile = rack[dragged_tile[1]]
            drag_rect = pygame.Rect(tile_x_drag - TILE_WIDTH // 2, tile_y_drag - TILE_HEIGHT // 2, TILE_WIDTH, TILE_HEIGHT)
            if tile == ' ':
                center = drag_rect.center
                radius = TILE_WIDTH // 2 - 2
                pygame.draw.circle(screen, BLACK, center, radius)
                # text = font.render('?', True, WHITE)
                # text_rect = text.get_rect(center=center)
                # screen.blit(text, text_rect)
            else:
                pygame.draw.rect(screen, DARK_GREEN, drag_rect) # Slightly darker when dragged
                text = font.render(tile, True, BLACK)
                text_rect = text.get_rect(center=drag_rect.center)
                screen.blit(text, text_rect)

    # Draw Buttons (Alphabetize/Randomize) - only if not in replay mode
    alpha_button_rect = None
    rand_button_rect = None
    if not replay_mode:
        button_x = start_x + rack_width + BUTTON_GAP
        alpha_button_rect = pygame.Rect(button_x, rack_y, BUTTON_WIDTH, BUTTON_HEIGHT)
        rand_button_rect = pygame.Rect(button_x + BUTTON_WIDTH + BUTTON_GAP, rack_y, BUTTON_WIDTH, BUTTON_HEIGHT)

        # Hover effect
        mouse_pos = pygame.mouse.get_pos()
        alpha_color = BUTTON_HOVER if alpha_button_rect.collidepoint(mouse_pos) else BUTTON_COLOR
        rand_color = BUTTON_HOVER if rand_button_rect.collidepoint(mouse_pos) else BUTTON_COLOR

        pygame.draw.rect(screen, alpha_color, alpha_button_rect)
        pygame.draw.rect(screen, rand_color, rand_button_rect)

        alpha_text = button_font.render("Alphabetize", True, BLACK)
        alpha_rect = alpha_text.get_rect(center=alpha_button_rect.center)
        screen.blit(alpha_text, alpha_rect)

        rand_text = button_font.render("Randomize", True, BLACK)
        rand_rect = rand_text.get_rect(center=rand_button_rect.center)
        screen.blit(rand_text, rand_rect)

    # Draw Score
    player_idx = player - 1
    if 0 <= player_idx < len(player_names) and 0 <= player_idx < len(display_scores):
        player_name_display = player_names[player_idx] if player_names[player_idx] else f"Player {player}"
        score_text = ui_font.render(f"{player_name_display} Score: {display_scores[player_idx]}", True, BLACK)
        screen.blit(score_text, (start_x, rack_y - 25)) # Position score above rack
    else: print(f"Warning: Invalid player index {player} or scores length mismatch for score display.")

    # Return button rects (or None if in replay) and tile rects for drag detection, and rack start x
    return alpha_button_rect, rand_button_rect, tile_rects_on_rack, start_x


def draw_replay_icon(screen, rect, icon_type):
    """Draw centered replay control icons (arrows) on the buttons."""
    center_x, center_y = rect.center
    arrow_size = 8
    if icon_type == "start": # <<
        pygame.draw.polygon(screen, BLACK, [(center_x + 6, center_y - arrow_size), (center_x - 2, center_y), (center_x + 6, center_y + arrow_size)])
        pygame.draw.polygon(screen, BLACK, [(center_x - 2, center_y - arrow_size), (center_x - 10, center_y), (center_x - 2, center_y + arrow_size)])
    elif icon_type == "prev": # <
        pygame.draw.polygon(screen, BLACK, [(center_x + 6, center_y - arrow_size), (center_x - 6, center_y), (center_x + 6, center_y + arrow_size)])
    elif icon_type == "next": # >
        pygame.draw.polygon(screen, BLACK, [(center_x - 6, center_y - arrow_size), (center_x + 6, center_y), (center_x - 6, center_y + arrow_size)])
    elif icon_type == "end": # >>
        pygame.draw.polygon(screen, BLACK, [(center_x - 6, center_y - arrow_size), (center_x + 2, center_y), (center_x - 6, center_y + arrow_size)])
        pygame.draw.polygon(screen, BLACK, [(center_x + 2, center_y - arrow_size), (center_x + 10, center_y), (center_x + 2, center_y + arrow_size)])


def draw_scoreboard(screen, move_history_to_draw, scroll_offset, scores_to_display, is_ai_list, final_scores=None, game_over_state=False):
    """Draws the scrollable scoreboard."""
    # Scoreboard dimensions and position
    scoreboard_x = BOARD_SIZE + 20 # Adjusted position slightly left
    scoreboard_y = 40
    scoreboard_width = WINDOW_WIDTH - scoreboard_x - 20 # Use remaining width with padding
    scoreboard_height = WINDOW_HEIGHT - scoreboard_y - 20 # Use remaining height with padding
    scoreboard_width = max(250, scoreboard_width) # Ensure minimum width
    scoreboard_height = max(200, scoreboard_height) # Ensure minimum height

    # Create surface for scoreboard content
    # Check if dimensions are valid before creating surface
    if scoreboard_width <= 0 or scoreboard_height <= 0:
        print(f"Warning: Invalid scoreboard dimensions ({scoreboard_width}x{scoreboard_height}). Skipping draw.")
        return

    scoreboard_surface = pygame.Surface((scoreboard_width, scoreboard_height))
    scoreboard_surface.fill(WHITE)
    pygame.draw.rect(scoreboard_surface, BLACK, (0, 0, scoreboard_width, scoreboard_height), 1) # Border

    # Content drawing parameters
    line_height = 20
    text_x_offset = 10
    y_pos = 10 - scroll_offset # Start position adjusted by scroll

    # Calculate cumulative scores up to the point being displayed
    running_scores = [0, 0]
    for i, move in enumerate(move_history_to_draw):
        player_idx = move['player'] - 1
        # Ensure player_idx is valid before accessing scores or is_ai_list
        if not (0 <= player_idx < len(running_scores)):
             print(f"Warning: Invalid player index {player_idx+1} in move {i+1}. Skipping scoreboard entry.")
             continue

        running_scores[player_idx] += move['score']
        player_label = "AI" if 0 <= player_idx < len(is_ai_list) and is_ai_list[player_idx] else f"P{move['player']}"
        display_score = running_scores[player_idx]

        # Format move text
        if move['move_type'] == 'place':
            word = move.get('word_with_blanks', move.get('word', 'N/A')) # Show blanks
            coord = move.get('coord', 'N/A')
            text = f"{i+1}: {player_label} - {word} at {coord} (+{move['score']}) Total: {display_score}"
        elif move['move_type'] == 'pass':
            text = f"{i+1}: {player_label} - Pass (+0) Total: {display_score}"
        elif move['move_type'] == 'exchange':
            exchanged_count = len(move.get('exchanged_tiles', []))
            text = f"{i+1}: {player_label} - Exchange {exchanged_count} (+0) Total: {display_score}"
        else:
            text = f"{i+1}: {player_label} - Unknown Move Type"

        # Render text
        try:
            text_surface = ui_font.render(text, True, BLACK)
        except pygame.error as e:
            print(f"Warning: Error rendering scoreboard text '{text}': {e}")
            text_surface = ui_font.render(f"{i+1}: Error rendering move", True, RED) # Show error indicator

        # Draw highlight for alternating turns (pairs of moves)
        if (i // 2) % 2 == 0:
             highlight_rect = pygame.Rect(0, y_pos, scoreboard_width, line_height)
             pygame.draw.rect(scoreboard_surface, HIGHLIGHT_BLUE, highlight_rect)

        # Blit text if visible within the current scroll view
        if y_pos < scoreboard_height and y_pos + line_height > 0:
            scoreboard_surface.blit(text_surface, (text_x_offset, y_pos))

        y_pos += line_height # Move to next line

    # Draw final scores if game is over
    if game_over_state and final_scores is not None:
        y_pos += 10 # Add some space
        final_text = f"Final Scores: P1: {final_scores[0]}, P2: {final_scores[1]}"
        final_surface = ui_font.render(final_text, True, BLACK)
        if y_pos < scoreboard_height and y_pos + line_height > 0:
            scoreboard_surface.blit(final_surface, (text_x_offset, y_pos))

    # Blit the scoreboard surface onto the main screen
    screen.blit(scoreboard_surface, (scoreboard_x, scoreboard_y))


def draw_checkbox(screen, x, y, checked):
    """Draws a simple checkbox."""
    pygame.draw.rect(screen, BLACK, (x, y, 20, 20), 1)
    if checked:
        pygame.draw.line(screen, BLACK, (x+2, y+2), (x+18, y+18), 2)
        pygame.draw.line(screen, BLACK, (x+18, y+2), (x+2, y+18), 2)

# Part 3: Word Finding, Scoring, Practice, Mode Selection, Options (Corrected)

def find_main_word(new_tiles, tiles):
    """
    Finds the primary word formed by newly placed tiles.
    Input: new_tiles = list of (r, c, letter) tuples for *only* the newly placed tiles.
           tiles = the complete current board state grid.
    Returns: (list_of_main_word_tiles, orientation) or ([], None)
             list_of_main_word_tiles = [(r, c, letter), ...] for the full main word
    """
    if not new_tiles: return [], None

    rows = set(r for r, c, _ in new_tiles)
    cols = set(c for r, c, _ in new_tiles)

    if len(rows) == 1: # Potential horizontal word
        orientation = "right" # Use "right" for horizontal consistently
        row = rows.pop()
        min_col = min(c for r, c, _ in new_tiles if r == row)
        max_col = max(c for r, c, _ in new_tiles if r == row)

        # Extend left and right to include adjacent existing tiles
        while min_col > 0 and tiles[row][min_col - 1]:
            min_col -= 1
        while max_col < GRID_SIZE - 1 and tiles[row][max_col + 1]:
            max_col += 1

        # Collect all tiles in the full horizontal word
        main_word = [(row, c, tiles[row][c]) for c in range(min_col, max_col + 1) if tiles[row][c]]
        return (main_word, orientation) if len(main_word) > 1 else ([], None)

    elif len(cols) == 1: # Potential vertical word
        orientation = "down" # Use "down" for vertical consistently
        col = cols.pop()
        min_row = min(r for r, c, _ in new_tiles if c == col)
        max_row = max(r for r, c, _ in new_tiles if c == col)

        # Extend up and down to include adjacent existing tiles
        while min_row > 0 and tiles[min_row - 1][col]:
            min_row -= 1
        while max_row < GRID_SIZE - 1 and tiles[max_row + 1][col]:
            max_row += 1

        # Collect all tiles in the full vertical word
        main_word = [(r, col, tiles[r][col]) for r in range(min_row, max_row + 1) if tiles[r][col]]
        return (main_word, orientation) if len(main_word) > 1 else ([], None)

    else: # Tiles not in a single line - invalid placement (should be caught earlier)
        return [], None


def find_cross_word(tile_pos, tiles, main_orientation):
    """
    Finds a cross word formed by a single tile perpendicular to the main word.
    Input: tile_pos = (r, c) of the newly placed tile.
           tiles = the complete current board state grid.
           main_orientation = "right" or "down".
    Returns: list_of_cross_word_tiles = [(r, c, letter), ...] or []
    """
    r, c = tile_pos
    cross_word = []

    if main_orientation == "right": # Main word is horizontal, check vertically
        min_row = r
        while min_row > 0 and tiles[min_row - 1][c]:
            min_row -= 1
        max_row = r
        while max_row < GRID_SIZE - 1 and tiles[max_row + 1][c]:
            max_row += 1
        # Only form word if it spans more than one tile
        if max_row > min_row:
            cross_word = [(rr, c, tiles[rr][c]) for rr in range(min_row, max_row + 1) if tiles[rr][c]]

    elif main_orientation == "down": # Main word is vertical, check horizontally
        min_col = c
        while min_col > 0 and tiles[r][min_col - 1]:
            min_col -= 1
        max_col = c
        while max_col < GRID_SIZE - 1 and tiles[r][max_col + 1]:
            max_col += 1
        # Only form word if it spans more than one tile
        if max_col > min_col:
            cross_word = [(r, cc, tiles[r][cc]) for cc in range(min_col, max_col + 1) if tiles[r][cc]]

    # Return the word only if it has length > 1 (already implicitly handled by range checks)
    return cross_word # Will be empty if no cross word > 1 letter is formed


def find_all_words_formed(new_tiles, tiles):
    """
    Finds all words (main and cross) formed by a play.
    Input: new_tiles = list of (r, c, letter) tuples for *only* the newly placed tiles.
           tiles = the complete current board state grid.
    Returns: list_of_word_lists, where each inner list is [(r, c, letter), ...]
    """
    words = []
    if not new_tiles: return words

    new_positions_set = set((r, c) for r, c, _ in new_tiles)

    # 1. Find the main word (if any)
    main_word_tiles, orientation = find_main_word(new_tiles, tiles)

    if main_word_tiles:
        words.append(main_word_tiles)
        # 2. Find cross words for each new tile *if* a main word exists
        for r_new, c_new, _ in new_tiles:
            # Check if this new tile is part of the main word line
            # (This check might be redundant if find_main_word is correct)
            # if (orientation == "right" and r_new == main_word_tiles[0][0]) or \
            #    (orientation == "down" and c_new == main_word_tiles[0][1]):
                cross_word = find_cross_word((r_new, c_new), tiles, orientation)
                if cross_word:
                    words.append(cross_word)
    elif len(new_tiles) == 1:
        # 3. Handle single tile placement (no main word, check both directions)
        r_new, c_new, _ = new_tiles[0]
        # Check horizontally (as if main word was vertical)
        cross_h = find_cross_word((r_new, c_new), tiles, "down")
        if cross_h: words.append(cross_h)
        # Check vertically (as if main word was horizontal)
        cross_v = find_cross_word((r_new, c_new), tiles, "right")
        if cross_v: words.append(cross_v)

    # 4. Remove duplicate words (can happen if a cross word *is* the main word)
    unique_word_tile_lists = []
    seen_signatures = set()
    for word_tile_list in words:
        # Create a unique signature for the word based on its tile positions and letters
        signature = tuple(sorted((r, c, l) for r, c, l in word_tile_list))
        if signature not in seen_signatures:
            unique_word_tile_lists.append(word_tile_list)
            seen_signatures.add(signature)

    return unique_word_tile_lists


def calculate_score(new_tiles, board_colors, tiles, blanks):
    """
    Calculates the score for a play based on newly placed tiles.
    Input: new_tiles = list of (r, c, letter) tuples for *only* the newly placed tiles.
           board_colors = grid of special square colors.
           tiles = the complete current board state grid.
           blanks = set of (r, c) tuples for tiles that are blanks.
    Returns: integer score.
    """
    total_score = 0
    new_positions = set((r, c) for r, c, _ in new_tiles)

    # Find all unique words formed by this play
    words_formed_details = find_all_words_formed(new_tiles, tiles)

    for word_tiles in words_formed_details:
        word_score = 0
        word_multiplier = 1
        for r, c, letter in word_tiles:
            if letter not in TILE_DISTRIBUTION:
                print(f"Warning: Invalid letter '{letter}' found in word during scoring at ({r},{c}). Skipping.")
                continue # Skip this invalid letter

            is_blank = (r, c) in blanks
            letter_value = 0 if is_blank else TILE_DISTRIBUTION[letter][1]
            letter_multiplier = 1

            # Apply letter/word multipliers ONLY if the tile is newly placed
            if (r, c) in new_positions:
                square_color = board_colors[r][c]
                if square_color == LIGHT_BLUE: # DL
                    letter_multiplier = 2
                elif square_color == BLUE: # TL
                    letter_multiplier = 3
                elif square_color == PINK: # DW (Center is also Pink)
                    word_multiplier *= 2
                elif square_color == RED: # TW
                    word_multiplier *= 3

            word_score += letter_value * letter_multiplier

        total_score += word_score * word_multiplier

    # Add Bingo bonus if 7 new tiles were placed
    if len(new_tiles) == 7:
        total_score += 50

    return total_score


def select_seven_letter_word(removed_letter, seven_letter_words):
    """Selects a random 7-letter word containing the removed letter."""
    candidates = [word for word in seven_letter_words if removed_letter in word]
    if not candidates:
        print(f"Warning: No 7-letter words contain '{removed_letter}'. Choosing random 7-letter word.")
        return random.choice(seven_letter_words) if seven_letter_words else None
    return random.choice(candidates)


def eight_letter_practice():
    """Handles the setup dialog and initialization for 8-Letter Bingo practice."""
    try:
        # Ensure paths are correct relative to where the script is run
        with open("7-letter-list.txt", "r") as seven_file, open("8-letter-list.txt", "r") as eight_file:
            seven_letter_words = [line.strip().upper() for line in seven_file.readlines()]
            eight_letter_words = [line.strip().upper() for line in eight_file.readlines()]
    except FileNotFoundError:
        print("Error: Could not find 7-letter-list.txt or 8-letter-list.txt")
        return False, None, None, None, None, None
    if not seven_letter_words or not eight_letter_words:
        print("Error: Word list files are empty.")
        return False, None, None, None, None, None

    dialog_width, dialog_height = 300, 150
    dialog_x = (WINDOW_WIDTH - dialog_width) // 2
    dialog_y = (WINDOW_HEIGHT - dialog_height) // 2
    proceed = False
    text_box_active = False
    probability_input = "" # Default to using all 8-letter words

    while True: # Dialog loop
        screen.fill(WHITE) # Clear screen for dialog
        pygame.draw.rect(screen, DIALOG_COLOR, (dialog_x, dialog_y, dialog_width, dialog_height))
        pygame.draw.rect(screen, BLACK, (dialog_x, dialog_y, dialog_width, dialog_height), 2)

        title_text = dialog_font.render("8-Letter Bingo Options", True, BLACK)
        screen.blit(title_text, (dialog_x + 10, dialog_y + 10))

        prob_text = ui_font.render("Max Word Rank:", True, BLACK) # Changed label
        screen.blit(prob_text, (dialog_x + 10, dialog_y + 50))

        text_box_rect = pygame.Rect(dialog_x + 140, dialog_y + 45, 140, 30) # Adjusted position
        pygame.draw.rect(screen, WHITE, text_box_rect)
        pygame.draw.rect(screen, BLACK, text_box_rect, 1)
        input_text = ui_font.render(probability_input, True, BLACK)
        screen.blit(input_text, (text_box_rect.x + 5, text_box_rect.y + 5))

        go_rect = pygame.Rect(dialog_x + 50, dialog_y + 100, 100, 30)
        cancel_rect = pygame.Rect(dialog_x + 160, dialog_y + 100, 100, 30)
        pygame.draw.rect(screen, BUTTON_COLOR, go_rect)
        pygame.draw.rect(screen, BUTTON_COLOR, cancel_rect)
        go_text = button_font.render("Go", True, BLACK)
        cancel_text = button_font.render("Cancel", True, BLACK)
        screen.blit(go_text, go_text.get_rect(center=go_rect.center))
        screen.blit(cancel_text, cancel_text.get_rect(center=cancel_rect.center))

        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()
            elif event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
                x, y = event.pos
                text_box_active = text_box_rect.collidepoint(x, y)
                if go_rect.collidepoint(x, y):
                    max_index = len(eight_letter_words) # Default to all words
                    if probability_input.isdigit():
                        prob_val = int(probability_input)
                        # Use input as max index (1-based), clamp to valid range
                        max_index = min(max(1, prob_val), len(eight_letter_words))

                    # Select from the first `max_index` words
                    selected_eight = random.choice(eight_letter_words[:max_index])
                    print("Selected 8-letter word:", selected_eight)

                    # Remove one letter to form the rack
                    remove_idx = random.randint(0, 7)
                    removed_letter = selected_eight[remove_idx]
                    removed_eight = selected_eight[:remove_idx] + selected_eight[remove_idx + 1:]
                    print("Player 1 rack (7 letters):", removed_eight)
                    print("Removed letter:", removed_letter)

                    # Select a 7-letter word containing the removed letter for the board
                    selected_seven = select_seven_letter_word(removed_letter, seven_letter_words)
                    if selected_seven is None:
                        print("Error: Could not find a suitable 7-letter word.")
                        return False, None, None, None, None, None
                    print("Selected 7-letter word for board:", selected_seven)

                    # Setup board state
                    local_board_colors, local_tiles = create_board()
                    local_racks = [[], []]
                    local_blanks = set()
                    local_racks[0] = sorted(list(removed_eight)) # Player 1 gets the 7 letters
                    local_racks[1] = [] # Player 2 rack is empty
                    local_bag = [] # No bag in this mode

                    # Place the 7-letter word on the board (try center H, then V)
                    center_r, center_c = CENTER_SQUARE
                    word_len = len(selected_seven)
                    start_offset = word_len // 2
                    place_horizontally = random.choice([True, False])
                    placement_successful = False

                    if place_horizontally:
                        start_c_place = center_c - start_offset
                        # Check if placement is within bounds
                        if 0 <= start_c_place and start_c_place + word_len <= GRID_SIZE:
                            for i, letter in enumerate(selected_seven):
                                local_tiles[center_r][start_c_place + i] = letter
                            placement_successful = True
                            print(f"Placed '{selected_seven}' horizontally at ({center_r},{start_c_place})")

                    if not placement_successful: # Try vertically if horizontal failed or wasn't chosen
                        start_r_place = center_r - start_offset
                        # Check if placement is within bounds
                        if 0 <= start_r_place and start_r_place + word_len <= GRID_SIZE:
                            for i, letter in enumerate(selected_seven):
                                local_tiles[start_r_place + i][center_c] = letter
                            placement_successful = True
                            print(f"Placed '{selected_seven}' vertically at ({start_r_place},{center_c})")

                    if not placement_successful:
                        print("Error: Could not place 7-letter word centered H or V.")
                        return False, None, None, None, None, None

                    # Return the prepared state
                    return True, local_board_colors, local_tiles, local_racks, local_blanks, local_bag

                elif cancel_rect.collidepoint(x, y):
                    return False, None, None, None, None, None # Cancelled
                elif not text_box_rect.collidepoint(x, y):
                     text_box_active = False # Deactivate if clicking outside

            elif event.type == pygame.KEYDOWN and text_box_active:
                if event.key == pygame.K_BACKSPACE:
                    probability_input = probability_input[:-1]
                elif event.unicode.isdigit():
                    probability_input += event.unicode
                elif event.key == pygame.K_RETURN or event.key == pygame.K_KP_ENTER:
                     text_box_active = False # Deactivate on enter

        pygame.display.flip() # Update display within the dialog loop

    # This part should not be reached if Go or Cancel is clicked
    return False, None, None, None, None, None


def mode_selection_screen():
    """Display and handle the game mode selection screen."""
    print("--- mode_selection_screen() entered ---")
    global main_called # To prevent recursive calls if something goes wrong
    try:
        print("--- mode_selection_screen(): Attempting to load background image... ---")
        image = pygame.image.load("Scrabble_S.png").convert_alpha()
        content_width = WINDOW_WIDTH - 200 # Adjust width for potential sidebars
        image = pygame.transform.scale(image, (content_width, WINDOW_HEIGHT))
        image.set_alpha(128) # Make it semi-transparent
        content_left = (WINDOW_WIDTH - content_width) // 2
        print("--- mode_selection_screen(): Background image loaded and processed. ---")
    except pygame.error as e:
        print(f"--- mode_selection_screen(): WARNING - Could not load background image 'Scrabble_S.png': {e} ---")
        image = None
        content_width = WINDOW_WIDTH # Use full width if no image
        content_left = 0

    modes = [MODE_HVH, MODE_HVA, MODE_AVA]
    selected_mode = None
    player_names = ["Player 1", "Player 2"]
    human_player = 1 # Default for HVA
    input_active = [False, False] # Which name input box is active
    current_input = 0 # Index of the currently selected mode button

    practice_mode_local = None # Local variable for practice mode selection
    dropdown_open = False
    showing_power_tiles_dialog = False
    letter_checks = [True, True, True, True] # JQXZ default
    number_checks = [True, True, True, True, False, False] # 2-5 default
    practice_state_local = None # To store state from practice setup

    print("--- mode_selection_screen(): Entering main loop (while selected_mode is None:)... ---")
    loop_count = 0
    while selected_mode is None:
        loop_count += 1
        if loop_count % 10000 == 0: # Print periodically if looping a lot
             print(f"--- mode_selection_screen(): Loop iteration {loop_count} ---")

        # --- Define positions INSIDE the loop ---
        option_rects = [] # Rects for practice dropdown options
        name_rect_x = content_left + (content_width - 200) // 2 # Center name inputs
        p1_y_pos = 300
        p2_y_pos = p1_y_pos + 40 # Space between name inputs

        # Calculate practice dropdown rects if needed
        dropdown_button_y = p2_y_pos + BUTTON_HEIGHT + 10
        dropdown_rect = pygame.Rect(name_rect_x, dropdown_button_y, 200, 30)
        if modes[current_input] == MODE_HVH and dropdown_open:
            dropdown_y = dropdown_button_y + 30 # Below the button
            options = ["Power Tiles", "8-Letter Bingos", "End Game"] # Practice options
            for i, option in enumerate(options):
                option_rect = pygame.Rect(name_rect_x, dropdown_y + 30 * i, 200, 30)
                option_rects.append(option_rect)

        # --- Event Handling ---
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                print("--- mode_selection_screen(): QUIT event received. Exiting. ---")
                pygame.quit(); sys.exit()

            elif event.type == pygame.MOUSEBUTTONDOWN:
                x, y = event.pos
                if showing_power_tiles_dialog: # Power Tiles Dialog Handling
                    dialog_x_pt = (WINDOW_WIDTH - 300) // 2; dialog_y_pt = (WINDOW_HEIGHT - 250) // 2
                    letter_rects_pt = [pygame.Rect(dialog_x_pt + 20, dialog_y_pt + 40 + i*30, 20, 20) for i in range(4)]
                    number_rects_pt = [pygame.Rect(dialog_x_pt + 150, dialog_y_pt + 40 + i*30, 20, 20) for i in range(6)]
                    go_rect_pt = pygame.Rect(dialog_x_pt + 50, dialog_y_pt + 220, 100, 30)
                    cancel_rect_pt = pygame.Rect(dialog_x_pt + 160, dialog_y_pt + 220, 100, 30)

                    clicked_inside_pt_dialog = False
                    for i, rect in enumerate(letter_rects_pt):
                        if rect.collidepoint(x, y): letter_checks[i] = not letter_checks[i]; clicked_inside_pt_dialog = True
                    for i, rect in enumerate(number_rects_pt):
                        if rect.collidepoint(x, y): number_checks[i] = not number_checks[i]; clicked_inside_pt_dialog = True

                    if go_rect_pt.collidepoint(x, y):
                        practice_mode_local = "power_tiles"
                        selected_mode = MODE_AVA # Power tile practice forces AvA for now
                        showing_power_tiles_dialog = False
                        print(f"--- mode_selection_screen(): Mode selected via Power Tiles Go: {selected_mode} ---")
                        # No practice_state needed here, setup happens in main game loop
                        break # Exit event loop
                    elif cancel_rect_pt.collidepoint(x, y):
                        showing_power_tiles_dialog = False; clicked_inside_pt_dialog = True
                    # If click was inside the dialog area but not on a control, do nothing else
                    pt_dialog_rect = pygame.Rect(dialog_x_pt, dialog_y_pt, 300, 250)
                    if pt_dialog_rect.collidepoint(x,y) and not clicked_inside_pt_dialog:
                         pass # Ignore click on dialog background

                else: # Main Selection Screen Handling (not power tile dialog)
                    # Mode buttons
                    mode_button_y_start = 100
                    mode_button_height = 50 # Make buttons taller
                    mode_button_width = BUTTON_WIDTH * 2 + 20
                    mode_button_x = content_left + (content_width - mode_button_width) // 2
                    mode_rects = [pygame.Rect(mode_button_x, mode_button_y_start + i * (mode_button_height + 10), mode_button_width, mode_button_height) for i in range(len(modes))]

                    clicked_mode_button = False
                    for i, rect in enumerate(mode_rects):
                        if rect.collidepoint(x, y):
                            current_input = i; dropdown_open = False; clicked_mode_button = True
                            if i == 0: # HVH
                                player_names = ["Player 1", "Player 2"]; input_active = [False, False]
                                # Don't select mode yet, allow name input/practice selection
                            elif i == 1: # HVA
                                # Determine names based on human_player choice, activate correct input
                                if human_player == 1: player_names = ["Player 1", "AI"]; input_active = [True, False]
                                else: player_names = ["AI", "Player 2"]; input_active = [False, True]
                                # Don't select mode yet, allow name input/play as choice
                            elif i == 2: # AVA
                                player_names = ["AI 1", "AI 2"]; input_active = [False, False]
                                selected_mode = MODE_AVA # Select AvA immediately
                                print(f"--- mode_selection_screen(): Mode selected via click: {selected_mode} ---")
                            break # Stop checking mode buttons

                    if selected_mode: break # Exit outer loop if mode selected (e.g., AvA)

                    # Play Later Button
                    play_later_rect = pygame.Rect(WINDOW_WIDTH - BUTTON_WIDTH - 10, WINDOW_HEIGHT - BUTTON_HEIGHT - 10, BUTTON_WIDTH, BUTTON_HEIGHT)
                    if play_later_rect.collidepoint(x, y):
                        print("--- mode_selection_screen(): Play Later clicked. Exiting. ---")
                        pygame.quit(); sys.exit() # Exit directly

                    # Name Input Activation
                    p1_name_rect = pygame.Rect(name_rect_x, p1_y_pos, 200, BUTTON_HEIGHT)
                    p2_name_rect = pygame.Rect(name_rect_x, p2_y_pos, 200, BUTTON_HEIGHT)
                    clicked_name_input = False
                    if modes[current_input] == MODE_HVH:
                        if p1_name_rect.collidepoint(x, y): input_active = [True, False]; clicked_name_input = True
                        elif p2_name_rect.collidepoint(x, y): input_active = [False, True]; clicked_name_input = True
                    elif modes[current_input] == MODE_HVA:
                        if human_player == 1 and p1_name_rect.collidepoint(x, y): input_active = [True, False]; clicked_name_input = True
                        elif human_player == 2 and p2_name_rect.collidepoint(x, y): input_active = [False, True]; clicked_name_input = True

                    # HVA "Play As" Buttons / Final Selection
                    if modes[current_input] == MODE_HVA:
                        hva_button_y = p2_y_pos + BUTTON_HEIGHT + 10
                        hva_button_width = BUTTON_WIDTH
                        hva_total_width = hva_button_width * 2 + 20
                        hva_start_x = content_left + (content_width - hva_total_width) // 2
                        p1_rect_hva = pygame.Rect(hva_start_x, hva_button_y, hva_button_width, BUTTON_HEIGHT)
                        p2_rect_hva = pygame.Rect(hva_start_x + hva_button_width + 20, hva_button_y, hva_button_width, BUTTON_HEIGHT)
                        if p1_rect_hva.collidepoint(x, y):
                            human_player = 1; player_names = ["Player 1", "AI"]; input_active = [True, False]
                            selected_mode = MODE_HVA # Final selection for HVA
                            print(f"--- mode_selection_screen(): Mode selected via click: {selected_mode} (Play as P1) ---")
                            break
                        elif p2_rect_hva.collidepoint(x, y):
                            human_player = 2; player_names = ["AI", "Player 2"]; input_active = [False, True]
                            selected_mode = MODE_HVA # Final selection for HVA
                            print(f"--- mode_selection_screen(): Mode selected via click: {selected_mode} (Play as P2) ---")
                            break

                    # HVH "Play" Button / Practice Dropdown
                    if modes[current_input] == MODE_HVH:
                        # Practice Button
                        if dropdown_rect.collidepoint(x, y):
                            dropdown_open = not dropdown_open
                        elif dropdown_open: # Check dropdown options if open
                            clicked_option = False
                            for i, option_rect in enumerate(option_rects):
                                if option_rect.collidepoint(x, y):
                                    clicked_option = True; dropdown_open = False
                                    if i == 0: # Power Tiles
                                        showing_power_tiles_dialog = True
                                    elif i == 1: # 8-Letter Bingos
                                        print("--- mode_selection_screen(): 8-Letter Bingo practice selected. Calling eight_letter_practice()... ---")
                                        # Call setup function which returns initial state
                                        proceed, p_board, p_tiles, p_racks, p_blanks, p_bag = eight_letter_practice()
                                        if proceed:
                                            practice_mode_local = "eight_letter"
                                            selected_mode = MODE_HVH # Still HVH technically, but with practice setup
                                            player_names = ["Player 1", ""] # No P2 name needed
                                            human_player = 1 # Human always plays practice
                                            # Store the generated state
                                            practice_state_local = {"board": p_board, "tiles": p_tiles, "racks": p_racks, "blanks": p_blanks, "bag": p_bag, "first_play": False, "scores": [0, 0], "turn": 1}
                                            print(f"--- mode_selection_screen(): 8-Letter practice setup successful. Selected mode: {selected_mode} ---")
                                            break # Exit event loop
                                        else:
                                             print("--- mode_selection_screen(): 8-Letter practice setup cancelled or failed. ---")
                                             # Stay on mode selection screen
                                    elif i == 2: # End Game
                                        print("End Game practice selected - Not implemented yet")
                                        # Implement End Game setup here if needed
                                    break # Exit options loop
                            # If click was outside dropdown options while it was open, close it
                            if not clicked_option and not dropdown_rect.collidepoint(x,y):
                                dropdown_open = False
                        else: # Dropdown closed or click outside practice button
                             dropdown_open = False
                             # Check HVH Play button (only if not clicking practice)
                             hvh_play_button_y = dropdown_button_y + 40 # Below practice button
                             hvh_play_rect = pygame.Rect(name_rect_x, hvh_play_button_y, 200, BUTTON_HEIGHT)
                             if hvh_play_rect.collidepoint(x,y):
                                  selected_mode = MODE_HVH # Final selection for HVH
                                  print(f"--- mode_selection_screen(): Mode selected via Play button: {selected_mode} ---")
                                  break

                    if selected_mode: break # Break outer loop if practice selection set the mode

                    # Deactivate name input if clicking elsewhere
                    clicked_control = clicked_mode_button or clicked_name_input or play_later_rect.collidepoint(x,y)
                    if modes[current_input] == MODE_HVH:
                         hvh_play_rect_check = pygame.Rect(name_rect_x, dropdown_button_y + 40, 200, BUTTON_HEIGHT)
                         clicked_control = clicked_control or dropdown_rect.collidepoint(x,y) or hvh_play_rect_check.collidepoint(x,y) or (dropdown_open and any(r.collidepoint(x,y) for r in option_rects))
                    elif modes[current_input] == MODE_HVA:
                         hva_button_y = p2_y_pos + BUTTON_HEIGHT + 10
                         hva_button_width = BUTTON_WIDTH
                         hva_total_width = hva_button_width * 2 + 20
                         hva_start_x = content_left + (content_width - hva_total_width) // 2
                         p1_rect_hva_check = pygame.Rect(hva_start_x, hva_button_y, hva_button_width, BUTTON_HEIGHT)
                         p2_rect_hva_check = pygame.Rect(hva_start_x + hva_button_width + 20, hva_button_y, hva_button_width, BUTTON_HEIGHT)
                         clicked_control = clicked_control or p1_rect_hva_check.collidepoint(x,y) or p2_rect_hva_check.collidepoint(x,y)

                    if not clicked_control:
                        input_active = [False, False]


            elif event.type == pygame.KEYDOWN: # Keyboard input for names
                 active_idx = -1
                 if input_active[0]: active_idx = 0
                 elif input_active[1] and modes[current_input] == MODE_HVH: active_idx = 1
                 elif input_active[1] and modes[current_input] == MODE_HVA and human_player == 2: active_idx = 1

                 if active_idx != -1:
                    if event.key == pygame.K_BACKSPACE:
                        player_names[active_idx] = player_names[active_idx][:-1]
                    elif event.key == pygame.K_RETURN or event.key == pygame.K_KP_ENTER:
                        input_active[active_idx] = False # Deactivate on enter
                    elif event.unicode.isalnum() or event.unicode == ' ': # Allow spaces
                        if len(player_names[active_idx]) < 15: # Limit name length
                            player_names[active_idx] += event.unicode

        # --- Drawing Logic ---
        screen.fill(WHITE)
        if image: screen.blit(image, (content_left, 0)) # Draw background if loaded

        # Title
        title_text = dialog_font.render("Select Game Mode", True, BLACK)
        title_x = content_left + (content_width - title_text.get_width()) // 2
        screen.blit(title_text, (title_x, 50))

        # Mode Buttons
        mode_button_y_start = 100
        mode_button_height = 50
        mode_button_width = BUTTON_WIDTH * 2 + 20
        mode_button_x = content_left + (content_width - mode_button_width) // 2
        mode_rects = [] # Store rects for click detection later
        for i, mode in enumerate(modes):
            y_pos = mode_button_y_start + i * (mode_button_height + 10)
            rect = pygame.Rect(mode_button_x, y_pos, mode_button_width, mode_button_height)
            mode_rects.append(rect)
            hover = rect.collidepoint(pygame.mouse.get_pos())
            color = BUTTON_HOVER if i == current_input or hover else BUTTON_COLOR
            pygame.draw.rect(screen, color, rect)
            if i == current_input: # Highlight selected mode button
                pygame.draw.rect(screen, BLACK, rect, 2)
            text = button_font.render(mode, True, BLACK)
            text_rect = text.get_rect(center=rect.center)
            screen.blit(text, text_rect)

        # Play Later Button
        play_later_rect = pygame.Rect(WINDOW_WIDTH - BUTTON_WIDTH - 10, WINDOW_HEIGHT - BUTTON_HEIGHT - 10, BUTTON_WIDTH, BUTTON_HEIGHT)
        hover = play_later_rect.collidepoint(pygame.mouse.get_pos())
        color = BUTTON_HOVER if hover else BUTTON_COLOR
        pygame.draw.rect(screen, color, play_later_rect)
        play_later_text = button_font.render("Play Later", True, BLACK)
        play_later_text_rect = play_later_text.get_rect(center=play_later_rect.center)
        screen.blit(play_later_text, play_later_text_rect)

        # --- Name Input Drawing ---
        p1_name_rect = pygame.Rect(name_rect_x, p1_y_pos, 200, BUTTON_HEIGHT)
        p2_name_rect = pygame.Rect(name_rect_x, p2_y_pos, 200, BUTTON_HEIGHT)

        # Player 1 Name
        p1_label_text = "Player 1 Name:"
        p1_label = ui_font.render(p1_label_text, True, BLACK)
        p1_label_x = name_rect_x - p1_label.get_width() - 10
        screen.blit(p1_label, (p1_label_x, p1_y_pos + 5))
        p1_bg_color = LIGHT_BLUE if input_active[0] else (GRAY if modes[current_input] == MODE_AVA else WHITE)
        pygame.draw.rect(screen, p1_bg_color, p1_name_rect)
        pygame.draw.rect(screen, BLACK, p1_name_rect, 1)
        p1_name_text = ui_font.render(player_names[0], True, BLACK)
        screen.blit(p1_name_text, (p1_name_rect.x + 5, p1_name_rect.y + 5))

        # Player 2 Name / AI Name / Controls
        if modes[current_input] == MODE_HVH:
            p2_label_text = "Player 2 Name:"
            p2_label = ui_font.render(p2_label_text, True, BLACK)
            p2_label_x = name_rect_x - p2_label.get_width() - 10
            screen.blit(p2_label, (p2_label_x, p2_y_pos + 5))
            p2_bg_color = LIGHT_BLUE if input_active[1] else WHITE
            pygame.draw.rect(screen, p2_bg_color, p2_name_rect)
            pygame.draw.rect(screen, BLACK, p2_name_rect, 1)
            p2_name_text = ui_font.render(player_names[1], True, BLACK)
            screen.blit(p2_name_text, (p2_name_rect.x + 5, p2_name_rect.y + 5))

            # Practice Button
            hover = dropdown_rect.collidepoint(pygame.mouse.get_pos())
            color = BUTTON_HOVER if hover else BUTTON_COLOR
            pygame.draw.rect(screen, color, dropdown_rect)
            text = button_font.render("Practice...", True, BLACK) # Add ellipsis
            text_rect = text.get_rect(center=dropdown_rect.center)
            screen.blit(text, text_rect)
            # Draw dropdown options if open
            if dropdown_open:
                for i, option_rect in enumerate(option_rects):
                    hover = option_rect.collidepoint(pygame.mouse.get_pos())
                    color = BUTTON_HOVER if hover else DROPDOWN_COLOR
                    pygame.draw.rect(screen, color, option_rect)
                    text = button_font.render(options[i], True, BLACK)
                    text_rect = text.get_rect(center=option_rect.center)
                    screen.blit(text, text_rect)

            # HVH Play Button
            hvh_play_button_y = dropdown_button_y + 40 # Below practice button
            hvh_play_rect = pygame.Rect(name_rect_x, hvh_play_button_y, 200, BUTTON_HEIGHT)
            hover = hvh_play_rect.collidepoint(pygame.mouse.get_pos())
            color = BUTTON_HOVER if hover else BUTTON_COLOR
            pygame.draw.rect(screen, color, hvh_play_rect)
            hvh_play_text_surf = button_font.render("Play HVH", True, BLACK)
            hvh_play_text_rect = hvh_play_text_surf.get_rect(center=hvh_play_rect.center)
            screen.blit(hvh_play_text_surf, hvh_play_text_rect)


        elif modes[current_input] == MODE_HVA:
            # Determine which name box is for the human
            human_name_label = "Player Name:" if human_player == 1 else "Player Name:"
            ai_name_label = "AI Name:"
            human_name_y = p1_y_pos if human_player == 1 else p2_y_pos
            ai_name_y = p2_y_pos if human_player == 1 else p1_y_pos
            human_name_rect = p1_name_rect if human_player == 1 else p2_name_rect
            ai_name_rect = p2_name_rect if human_player == 1 else p1_name_rect
            human_name_idx = 0 if human_player == 1 else 1
            ai_name_idx = 1 if human_player == 1 else 0

            # Draw Human Name Input
            h_label = ui_font.render(human_name_label, True, BLACK)
            h_label_x = name_rect_x - h_label.get_width() - 10
            screen.blit(h_label, (h_label_x, human_name_y + 5))
            h_bg_color = LIGHT_BLUE if input_active[human_name_idx] else WHITE
            pygame.draw.rect(screen, h_bg_color, human_name_rect)
            pygame.draw.rect(screen, BLACK, human_name_rect, 1)
            h_name_text = ui_font.render(player_names[human_name_idx], True, BLACK)
            screen.blit(h_name_text, (human_name_rect.x + 5, human_name_rect.y + 5))

            # Draw AI Name (disabled)
            ai_label = ui_font.render(ai_name_label, True, BLACK)
            ai_label_x = name_rect_x - ai_label.get_width() - 10
            screen.blit(ai_label, (ai_label_x, ai_name_y + 5))
            pygame.draw.rect(screen, GRAY, ai_name_rect) # Grayed out
            pygame.draw.rect(screen, BLACK, ai_name_rect, 1)
            ai_name_text = ui_font.render(player_names[ai_name_idx], True, BLACK)
            screen.blit(ai_name_text, (ai_name_rect.x + 5, ai_name_rect.y + 5))

            # "Play As" Buttons
            hva_button_y = p2_y_pos + BUTTON_HEIGHT + 10 # Below name boxes
            hva_button_width = BUTTON_WIDTH
            hva_total_width = hva_button_width * 2 + 20
            hva_start_x = content_left + (content_width - hva_total_width) // 2
            p1_rect_hva = pygame.Rect(hva_start_x, hva_button_y, hva_button_width, BUTTON_HEIGHT)
            p2_rect_hva = pygame.Rect(hva_start_x + hva_button_width + 20, hva_button_y, hva_button_width, BUTTON_HEIGHT)

            p1_hover = p1_rect_hva.collidepoint(pygame.mouse.get_pos())
            p2_hover = p2_rect_hva.collidepoint(pygame.mouse.get_pos())
            pygame.draw.rect(screen, BUTTON_HOVER if p1_hover else BUTTON_COLOR, p1_rect_hva)
            if human_player == 1: pygame.draw.rect(screen, BLACK, p1_rect_hva, 2) # Highlight selected
            pygame.draw.rect(screen, BUTTON_HOVER if p2_hover else BUTTON_COLOR, p2_rect_hva)
            if human_player == 2: pygame.draw.rect(screen, BLACK, p2_rect_hva, 2) # Highlight selected

            p1_text = button_font.render("Play as P1", True, BLACK)
            p2_text = button_font.render("Play as P2", True, BLACK)
            p1_text_rect = p1_text.get_rect(center=p1_rect_hva.center)
            p2_text_rect = p2_text.get_rect(center=p2_rect_hva.center)
            screen.blit(p1_text, p1_text_rect)
            screen.blit(p2_text, p2_text_rect)

        elif modes[current_input] == MODE_AVA:
            # AI 1 Name (disabled)
            p1_label_text = "AI 1 Name:"
            p1_label = ui_font.render(p1_label_text, True, BLACK)
            p1_label_x = name_rect_x - p1_label.get_width() - 10
            screen.blit(p1_label, (p1_label_x, p1_y_pos + 5))
            pygame.draw.rect(screen, GRAY, p1_name_rect)
            pygame.draw.rect(screen, BLACK, p1_name_rect, 1)
            p1_name_text = ui_font.render(player_names[0], True, BLACK)
            screen.blit(p1_name_text, (p1_name_rect.x + 5, p1_name_rect.y + 5))
            # AI 2 Name (disabled)
            p2_label_text = "AI 2 Name:"
            p2_label = ui_font.render(p2_label_text, True, BLACK)
            p2_label_x = name_rect_x - p2_label.get_width() - 10
            screen.blit(p2_label, (p2_label_x, p2_y_pos + 5))
            pygame.draw.rect(screen, GRAY, p2_name_rect)
            pygame.draw.rect(screen, BLACK, p2_name_rect, 1)
            p2_name_text = ui_font.render(player_names[1], True, BLACK)
            screen.blit(p2_name_text, (p2_name_rect.x + 5, p2_name_rect.y + 5))

        # Draw Power Tiles Dialog if active
        if showing_power_tiles_dialog:
            dialog_width_pt, dialog_height_pt = 300, 250
            dialog_x_pt = (WINDOW_WIDTH - dialog_width_pt) // 2
            dialog_y_pt = (WINDOW_HEIGHT - dialog_height_pt) // 2
            pygame.draw.rect(screen, DIALOG_COLOR, (dialog_x_pt, dialog_y_pt, dialog_width_pt, dialog_height_pt))
            pygame.draw.rect(screen, BLACK, (dialog_x_pt, dialog_y_pt, dialog_width_pt, dialog_height_pt), 2)
            title_text_pt = dialog_font.render("Power Tiles Options", True, BLACK)
            screen.blit(title_text_pt, (dialog_x_pt + 10, dialog_y_pt + 10))
            letters_pt = ['J', 'Q', 'X', 'Z']
            for i, letter in enumerate(letters_pt):
                draw_checkbox(screen, dialog_x_pt + 20, dialog_y_pt + 40 + i*30, letter_checks[i])
                text = ui_font.render(letter, True, BLACK)
                screen.blit(text, (dialog_x_pt + 50, dialog_y_pt + 40 + i*30))
            numbers_pt = ['2', '3', '4', '5', '6', '7+']
            for i, num in enumerate(numbers_pt):
                draw_checkbox(screen, dialog_x_pt + 150, dialog_y_pt + 40 + i*30, number_checks[i])
                text = ui_font.render(num, True, BLACK)
                screen.blit(text, (dialog_x_pt + 180, dialog_y_pt + 40 + i*30))
            go_rect_pt = pygame.Rect(dialog_x_pt + 50, dialog_y_pt + 220, 100, 30)
            cancel_rect_pt = pygame.Rect(dialog_x_pt + 160, dialog_y_pt + 220, 100, 30)
            pygame.draw.rect(screen, BUTTON_COLOR, go_rect_pt)
            pygame.draw.rect(screen, BUTTON_COLOR, cancel_rect_pt)
            go_text_pt = button_font.render("Go", True, BLACK)
            cancel_text_pt = button_font.render("Cancel", True, BLACK)
            screen.blit(go_text_pt, go_text_pt.get_rect(center=go_rect_pt.center))
            screen.blit(cancel_text_pt, cancel_text_pt.get_rect(center=cancel_rect_pt.center))

        # --- Display Update ---
        pygame.display.flip()

        # --- Exit Condition Check (moved after drawing) ---
        if selected_mode:
             print(f"--- mode_selection_screen(): Breaking loop because selected_mode is now {selected_mode} ---")
             break

    print(f"--- mode_selection_screen(): Exiting loop. Returning: mode={selected_mode}, practice={practice_mode_local} ---")
    # Return the locally determined practice mode and state
    return selected_mode, player_names, human_player, practice_mode_local, letter_checks if practice_mode_local == "power_tiles" else None, practice_state_local


def draw_options_menu(turn, dropdown_open, bag_count):
    """Draw the options menu with dropdown functionality."""
    global practice_mode # Access practice_mode
    options_x = 10
    options_rect = pygame.Rect(options_x, OPTIONS_Y, OPTIONS_WIDTH, OPTIONS_HEIGHT)
    hover = options_rect.collidepoint(pygame.mouse.get_pos())
    color = BUTTON_HOVER if hover else BUTTON_COLOR
    pygame.draw.rect(screen, color, options_rect)
    options_text = button_font.render("Options", True, BLACK)
    options_text_rect = options_text.get_rect(center=(options_x + OPTIONS_WIDTH // 2, OPTIONS_Y + OPTIONS_HEIGHT // 2))
    screen.blit(options_text, options_text_rect)

    dropdown_rects = []
    if dropdown_open:
        dropdown_y = OPTIONS_Y + OPTIONS_HEIGHT
        if practice_mode == "eight_letter":
            options = ["Give Up", "Main", "Quit"]
        else:
            options = ["Pass", "Exchange", "Main", "Quit"]

        for i, option in enumerate(options):
            rect = pygame.Rect(options_x, dropdown_y + i * OPTIONS_HEIGHT, OPTIONS_WIDTH, OPTIONS_HEIGHT)
            # Disable Exchange if bag < 7 (and not 8-letter practice)
            is_disabled = (practice_mode != "eight_letter" and option == "Exchange" and bag_count < 7)

            if is_disabled:
                pygame.draw.rect(screen, GRAYED_OUT_COLOR, rect)
                text = button_font.render(option, True, BLACK)
                dropdown_rects.append(None) # Append None for disabled options
            else:
                hover = rect.collidepoint(pygame.mouse.get_pos())
                color = BUTTON_HOVER if hover else DROPDOWN_COLOR
                pygame.draw.rect(screen, color, rect)
                text = button_font.render(option, True, BLACK)
                dropdown_rects.append(rect) # Append the rect for clickable options

            text_rect = text.get_rect(center=(options_x + OPTIONS_WIDTH // 2, dropdown_y + i * OPTIONS_HEIGHT + OPTIONS_HEIGHT // 2))
            screen.blit(text, text_rect)

    return options_rect, dropdown_rects

# Part 4: Dialogs, Stats, Message Boxes

def draw_suggest_button():
    """Draw the suggest button."""
    suggest_x = 10 + OPTIONS_WIDTH + BUTTON_GAP
    suggest_rect = pygame.Rect(suggest_x, OPTIONS_Y, OPTIONS_WIDTH, OPTIONS_HEIGHT)
    hover = suggest_rect.collidepoint(pygame.mouse.get_pos())
    color = BUTTON_HOVER if hover else BUTTON_COLOR
    pygame.draw.rect(screen, color, suggest_rect)
    suggest_text = button_font.render("Suggest", True, BLACK)
    suggest_text_rect = suggest_text.get_rect(center=(suggest_x + OPTIONS_WIDTH // 2, OPTIONS_Y + OPTIONS_HEIGHT // 2))
    screen.blit(suggest_text, suggest_text_rect)
    return suggest_rect


def draw_exchange_dialog(rack, selected_tiles):
    """Draw the tile exchange dialog."""
    dialog_width, dialog_height = 400, 200
    dialog_x = (WINDOW_WIDTH - dialog_width) // 2
    dialog_y = (WINDOW_HEIGHT - dialog_height) // 2

    pygame.draw.rect(screen, DIALOG_COLOR, (dialog_x, dialog_y, dialog_width, dialog_height))
    pygame.draw.rect(screen, BLACK, (dialog_x, dialog_y, dialog_width, dialog_height), 2)

    prompt_text = dialog_font.render("Select tiles to exchange:", True, BLACK)
    screen.blit(prompt_text, (dialog_x + 10, dialog_y + 10))

    tile_rects = []
    rack_display_width = len(rack) * (TILE_WIDTH + TILE_GAP) - TILE_GAP
    start_tile_x = dialog_x + (dialog_width - rack_display_width) // 2

    for i, tile in enumerate(rack):
        tile_x = start_tile_x + i * (TILE_WIDTH + TILE_GAP)
        tile_y = dialog_y + 50
        rect = pygame.Rect(tile_x, tile_y, TILE_WIDTH, TILE_HEIGHT)
        tile_rects.append(rect)

        if tile == ' ': # Draw blank
            center = rect.center
            radius = TILE_WIDTH // 2 - 2
            pygame.draw.circle(screen, BLACK, center, radius)
            if i in selected_tiles: # Highlight if selected
                pygame.draw.circle(screen, SELECTED_TILE_COLOR, center, radius + 2, 2)
            # text = font.render('?', True, WHITE)
            # text_rect = text.get_rect(center=center)
            # screen.blit(text, text_rect)
        else: # Draw regular tile
            color = SELECTED_TILE_COLOR if i in selected_tiles else GREEN
            pygame.draw.rect(screen, color, rect)
            text = font.render(tile, True, BLACK)
            text_rect = text.get_rect(center=rect.center)
            screen.blit(text, text_rect)

    # Buttons
    total_button_width = BUTTON_WIDTH * 2 + BUTTON_GAP
    button_start_x = dialog_x + (dialog_width - total_button_width) // 2
    button_y = dialog_y + dialog_height - BUTTON_HEIGHT - 10
    exchange_button_rect = pygame.Rect(button_start_x, button_y, BUTTON_WIDTH, BUTTON_HEIGHT)
    cancel_button_rect = pygame.Rect(button_start_x + BUTTON_WIDTH + BUTTON_GAP, button_y, BUTTON_WIDTH, BUTTON_HEIGHT)

    # Hover effect
    mouse_pos = pygame.mouse.get_pos()
    exchange_color = BUTTON_HOVER if exchange_button_rect.collidepoint(mouse_pos) else BUTTON_COLOR
    cancel_color = BUTTON_HOVER if cancel_button_rect.collidepoint(mouse_pos) else BUTTON_COLOR

    pygame.draw.rect(screen, exchange_color, exchange_button_rect)
    exchange_text = button_font.render("Exchange", True, BLACK)
    exchange_text_rect = exchange_text.get_rect(center=exchange_button_rect.center)
    screen.blit(exchange_text, exchange_text_rect)

    pygame.draw.rect(screen, cancel_color, cancel_button_rect)
    cancel_text = button_font.render("Cancel", True, BLACK)
    cancel_text_rect = cancel_text.get_rect(center=cancel_button_rect.center)
    screen.blit(cancel_text, cancel_text_rect)

    return tile_rects, exchange_button_rect, cancel_button_rect


def confirm_quit():
    """Prompt the user to confirm quitting the game."""
    dialog_width, dialog_height = 300, 100
    dialog_x = (WINDOW_WIDTH - dialog_width) // 2
    dialog_y = (WINDOW_HEIGHT - dialog_height) // 2

    # Dim background slightly (optional)
    dim_surface = pygame.Surface(screen.get_size(), pygame.SRCALPHA)
    dim_surface.fill((0, 0, 0, 128))
    screen.blit(dim_surface, (0, 0))

    pygame.draw.rect(screen, DIALOG_COLOR, (dialog_x, dialog_y, dialog_width, dialog_height))
    pygame.draw.rect(screen, BLACK, (dialog_x, dialog_y, dialog_width, dialog_height), 2)

    prompt_text = dialog_font.render("Quit game? (Y/N)", True, BLACK)
    screen.blit(prompt_text, (dialog_x + (dialog_width - prompt_text.get_width()) // 2, dialog_y + 30))
    pygame.display.flip() # Show the dialog immediately

    while True:
        for event in pygame.event.get():
            if event.type == pygame.QUIT: # Allow closing window during confirm
                pygame.quit()
                sys.exit()
            elif event.type == pygame.KEYDOWN:
                if event.key == pygame.K_y:
                    return True
                elif event.key == pygame.K_n:
                    return False
            # Ignore mouse clicks during this confirmation


def draw_game_over_dialog(dialog_x, dialog_y, final_scores, reason, player_names):
    """Draw the game over dialog and return button rectangles."""
    pygame.draw.rect(screen, DIALOG_COLOR, (dialog_x, dialog_y, DIALOG_WIDTH, DIALOG_HEIGHT))
    pygame.draw.rect(screen, BLACK, (dialog_x, dialog_y, DIALOG_WIDTH, DIALOG_HEIGHT), 2)

    title_text = dialog_font.render(f"Game Over - {reason}", True, BLACK)
    p1_score_text = ui_font.render(f"{player_names[0]} Score: {final_scores[0]}", True, BLACK)
    p2_name_display = player_names[1] if player_names[1] else "Player 2"
    p2_score_text = ui_font.render(f"{p2_name_display} Score: {final_scores[1]}", True, BLACK)

    save_text = button_font.render("Save (S)", True, BLACK)
    quit_text = button_font.render("Quit (Q)", True, BLACK)
    replay_text = button_font.render("Replay (R)", True, BLACK)
    play_again_text = button_font.render("Play Again (P)", True, BLACK)
    stats_text = button_font.render("Statistics", True, BLACK)

    screen.blit(title_text, (dialog_x + 10, dialog_y + 20))
    screen.blit(p1_score_text, (dialog_x + 10, dialog_y + 60))
    screen.blit(p2_score_text, (dialog_x + 10, dialog_y + 90))

    # Button layout
    first_row_width = 3 * BUTTON_WIDTH + 2 * BUTTON_GAP
    first_row_start_x = dialog_x + (DIALOG_WIDTH - first_row_width) // 2
    second_row_width = 2 * BUTTON_WIDTH + BUTTON_GAP
    second_row_start_x = dialog_x + (DIALOG_WIDTH - second_row_width) // 2

    save_rect = pygame.Rect(first_row_start_x, dialog_y + 150, BUTTON_WIDTH, BUTTON_HEIGHT)
    quit_rect = pygame.Rect(first_row_start_x + BUTTON_WIDTH + BUTTON_GAP, dialog_y + 150, BUTTON_WIDTH, BUTTON_HEIGHT)
    replay_rect = pygame.Rect(first_row_start_x + 2 * (BUTTON_WIDTH + BUTTON_GAP), dialog_y + 150, BUTTON_WIDTH, BUTTON_HEIGHT)
    play_again_rect = pygame.Rect(second_row_start_x, dialog_y + 190, BUTTON_WIDTH, BUTTON_HEIGHT)
    stats_rect = pygame.Rect(second_row_start_x + BUTTON_WIDTH + BUTTON_GAP, dialog_y + 190, BUTTON_WIDTH, BUTTON_HEIGHT)

    # Draw buttons with hover
    mouse_pos = pygame.mouse.get_pos()
    pygame.draw.rect(screen, BUTTON_HOVER if save_rect.collidepoint(mouse_pos) else BUTTON_COLOR, save_rect)
    pygame.draw.rect(screen, BUTTON_HOVER if quit_rect.collidepoint(mouse_pos) else BUTTON_COLOR, quit_rect)
    pygame.draw.rect(screen, BUTTON_HOVER if replay_rect.collidepoint(mouse_pos) else BUTTON_COLOR, replay_rect)
    pygame.draw.rect(screen, BUTTON_HOVER if play_again_rect.collidepoint(mouse_pos) else BUTTON_COLOR, play_again_rect)
    pygame.draw.rect(screen, BUTTON_HOVER if stats_rect.collidepoint(mouse_pos) else BUTTON_COLOR, stats_rect)

    # Draw button text
    screen.blit(save_text, save_text.get_rect(center=save_rect.center))
    screen.blit(quit_text, quit_text.get_rect(center=quit_rect.center))
    screen.blit(replay_text, replay_text.get_rect(center=replay_rect.center))
    screen.blit(play_again_text, play_again_text.get_rect(center=play_again_rect.center))
    screen.blit(stats_text, stats_text.get_rect(center=stats_rect.center))

    return save_rect, quit_rect, replay_rect, play_again_rect, stats_rect


def draw_score_row(screen, dialog_x, y_pos, final_scores):
    """Draw the score row for the statistics dialog."""
    score_label = ui_font.render("Score:", True, BLACK)
    p1_score_text = ui_font.render(str(final_scores[0]), True, BLACK)
    p2_score_text = ui_font.render(str(final_scores[1]), True, BLACK)
    screen.blit(score_label, (dialog_x + 10, y_pos))
    screen.blit(p1_score_text, (dialog_x + 120, y_pos))
    screen.blit(p2_score_text, (dialog_x + 230, y_pos))


def calculate_moves_per_player(move_history):
    """Calculate the number of moves made by each player from move_history."""
    moves_count = {1: 0, 2: 0}
    for move in move_history:
        player = move['player']
        # Count place, pass, and exchange as moves
        if move['move_type'] in ['place', 'pass', 'exchange']:
            moves_count[player] += 1
    return moves_count[1], moves_count[2]


def calculate_bingos_per_player(move_history):
    """Calculate the number of bingos played by each player."""
    bingo_count = {1: 0, 2: 0}
    for move in move_history:
        # Check the 'is_bingo' flag stored in the move history
        if move['move_type'] == 'place' and move.get('is_bingo', False):
            player = move['player']
            bingo_count[player] += 1
    return bingo_count[1], bingo_count[2]


def calculate_bingo_avg_per_player(move_history):
    """Calculate the average score of bingos for each player."""
    bingo_scores = {1: [], 2: []}
    for move in move_history:
        if move['move_type'] == 'place' and move.get('is_bingo', False):
            player = move['player']
            bingo_scores[player].append(move['score'])
    avg_p1 = sum(bingo_scores[1]) / len(bingo_scores[1]) if bingo_scores[1] else 0.0
    avg_p2 = sum(bingo_scores[2]) / len(bingo_scores[2]) if bingo_scores[2] else 0.0
    return avg_p1, avg_p2


def draw_moves_row(screen, dialog_x, y_pos, moves_p1, moves_p2):
    """Draw the moves row for the statistics dialog."""
    moves_label = ui_font.render("Moves:", True, BLACK)
    p1_moves_text = ui_font.render(str(moves_p1), True, BLACK)
    p2_moves_text = ui_font.render(str(moves_p2), True, BLACK)
    screen.blit(moves_label, (dialog_x + 10, y_pos))
    screen.blit(p1_moves_text, (dialog_x + 120, y_pos))
    screen.blit(p2_moves_text, (dialog_x + 230, y_pos))


def draw_avg_score_row(screen, dialog_x, y_pos, avg_p1, avg_p2):
    """Draw the average score per move row for the statistics dialog."""
    avg_label = ui_font.render("Avg Score:", True, BLACK)
    p1_avg_text = ui_font.render(f"{avg_p1:.2f}", True, BLACK)
    p2_avg_text = ui_font.render(f"{avg_p2:.2f}", True, BLACK)
    screen.blit(avg_label, (dialog_x + 10, y_pos))
    screen.blit(p1_avg_text, (dialog_x + 120, y_pos))
    screen.blit(p2_avg_text, (dialog_x + 230, y_pos))


def draw_bingos_row(screen, dialog_x, y_pos, bingos_p1, bingos_p2):
    """Draw the bingos row for the statistics dialog."""
    bingos_label = ui_font.render("Bingos:", True, BLACK)
    p1_bingos_text = ui_font.render(str(bingos_p1), True, BLACK)
    p2_bingos_text = ui_font.render(str(bingos_p2), True, BLACK)
    screen.blit(bingos_label, (dialog_x + 10, y_pos))
    screen.blit(p1_bingos_text, (dialog_x + 120, y_pos))
    screen.blit(p2_bingos_text, (dialog_x + 230, y_pos))


def draw_bingo_avg_row(screen, dialog_x, y_pos, bingo_avg_p1, bingo_avg_p2, bingos_p1, bingos_p2):
    """Draw the average bingo score row."""
    bingo_avg_label = ui_font.render("Bingo Avg:", True, BLACK)
    p1_text = "N/A" if bingos_p1 == 0 else f"{bingo_avg_p1:.2f}"
    p2_text = "N/A" if bingos_p2 == 0 else f"{bingo_avg_p2:.2f}"
    p1_bingo_avg_text = ui_font.render(p1_text, True, BLACK)
    p2_bingo_avg_text = ui_font.render(p2_text, True, BLACK)
    screen.blit(bingo_avg_label, (dialog_x + 10, y_pos))
    screen.blit(p1_bingo_avg_text, (dialog_x + 120, y_pos))
    screen.blit(p2_bingo_avg_text, (dialog_x + 230, y_pos))


def calculate_blanks_per_player(move_history):
    """Calculate the number of blanks played by each player."""
    blanks_p1 = 0
    blanks_p2 = 0
    for move in move_history:
        if move['move_type'] == 'place':
            player = move['player']
            # Count blanks based on the 'blanks' set stored in the move history
            blanks_count = len(move.get('blanks', set()))
            if player == 1:
                blanks_p1 += blanks_count
            elif player == 2:
                blanks_p2 += blanks_count
    return blanks_p1, blanks_p2


def draw_blanks_row(screen, dialog_x, y_pos, blanks_p1, blanks_p2):
    """Draw the blanks played row."""
    blanks_label = ui_font.render("Blanks:", True, BLACK)
    p1_blanks_text = ui_font.render(str(blanks_p1), True, BLACK)
    p2_blanks_text = ui_font.render(str(blanks_p2), True, BLACK)
    screen.blit(blanks_label, (dialog_x + 10, y_pos))
    screen.blit(p1_blanks_text, (dialog_x + 120, y_pos))
    screen.blit(p2_blanks_text, (dialog_x + 230, y_pos))


def draw_stats_dialog(dialog_x, dialog_y, player_names, final_scores, tiles): # tiles arg not used currently
    """Draw the complete statistics dialog."""
    stats_dialog_width, stats_dialog_height = 400, 360 # Increased height slightly
    pygame.draw.rect(screen, DIALOG_COLOR, (dialog_x, dialog_y, stats_dialog_width, stats_dialog_height))
    pygame.draw.rect(screen, BLACK, (dialog_x, dialog_y, stats_dialog_width, stats_dialog_height), 2)

    title_text = dialog_font.render("Game Statistics", True, BLACK)
    screen.blit(title_text, (dialog_x + 10, dialog_y + 10))

    # Player Names Header
    p1_name_display = player_names[0] if player_names[0] else "Player 1"
    p2_name_display = player_names[1] if player_names[1] else "Player 2"
    p1_name_text = ui_font.render(p1_name_display, True, BLACK)
    p2_name_text = ui_font.render(p2_name_display, True, BLACK)
    screen.blit(p1_name_text, (dialog_x + 120, dialog_y + 40))
    screen.blit(p2_name_text, (dialog_x + 230, dialog_y + 40))

    # Calculate Stats
    moves_p1, moves_p2 = calculate_moves_per_player(move_history)
    avg_p1 = final_scores[0] / moves_p1 if moves_p1 > 0 else 0.00
    avg_p2 = final_scores[1] / moves_p2 if moves_p2 > 0 else 0.00
    bingos_p1, bingos_p2 = calculate_bingos_per_player(move_history)
    bingo_avg_p1, bingo_avg_p2 = calculate_bingo_avg_per_player(move_history)
    blanks_p1, blanks_p2 = calculate_blanks_per_player(move_history)

    # Draw Rows
    y = dialog_y + 70
    draw_score_row(screen, dialog_x, y, final_scores)
    y += 30
    draw_moves_row(screen, dialog_x, y, moves_p1, moves_p2)
    y += 30
    draw_avg_score_row(screen, dialog_x, y, avg_p1, avg_p2)
    y += 30
    draw_bingos_row(screen, dialog_x, y, bingos_p1, bingos_p2)
    y += 30
    draw_bingo_avg_row(screen, dialog_x, y, bingo_avg_p1, bingo_avg_p2, bingos_p1, bingos_p2)
    y += 30
    draw_blanks_row(screen, dialog_x, y, blanks_p1, blanks_p2)
    # y += 30 # No more rows for now

    # OK Button
    ok_button_rect = pygame.Rect(dialog_x + stats_dialog_width - BUTTON_WIDTH - 10, dialog_y + stats_dialog_height - BUTTON_HEIGHT - 10, BUTTON_WIDTH, BUTTON_HEIGHT)
    hover = ok_button_rect.collidepoint(pygame.mouse.get_pos())
    color = BUTTON_HOVER if hover else BUTTON_COLOR
    pygame.draw.rect(screen, color, ok_button_rect)
    ok_text = button_font.render("OK", True, BLACK)
    ok_text_rect = ok_text.get_rect(center=ok_button_rect.center)
    screen.blit(ok_text, ok_text_rect)

    return ok_button_rect


def show_message_dialog(message, title="Message"):
    """Display a general message dialog with an OK button, wrapping text."""
    dialog_width, dialog_height = 400, 150
    dialog_x = (WINDOW_WIDTH - dialog_width) // 2
    dialog_y = (WINDOW_HEIGHT - dialog_height) // 2

    # Text wrapping
    words = message.split(' ')
    lines = []
    current_line = ''
    max_line_width = dialog_width - 20 # Padding
    for word in words:
        test_line = current_line + word + ' '
        # Check width using ui_font
        if ui_font.size(test_line)[0] < max_line_width:
            current_line = test_line
        else:
            lines.append(current_line.strip())
            current_line = word + ' '
    if current_line: # Add the last line
        lines.append(current_line.strip())

    # Adjust dialog height if needed based on number of lines
    needed_height = 10 + dialog_font.get_linesize() + len(lines) * ui_font.get_linesize() + BUTTON_HEIGHT + 30
    dialog_height = max(dialog_height, needed_height)
    # Recalculate y if height changed
    dialog_y = (WINDOW_HEIGHT - dialog_height) // 2

    # Dim background (optional)
    dim_surface = pygame.Surface(screen.get_size(), pygame.SRCALPHA)
    dim_surface.fill((0, 0, 0, 128))
    screen.blit(dim_surface, (0, 0))

    # Draw dialog box
    pygame.draw.rect(screen, DIALOG_COLOR, (dialog_x, dialog_y, dialog_width, dialog_height))
    pygame.draw.rect(screen, BLACK, (dialog_x, dialog_y, dialog_width, dialog_height), 2)

    # Draw title
    title_surf = dialog_font.render(title, True, BLACK)
    screen.blit(title_surf, (dialog_x + 10, dialog_y + 5))

    # Draw message lines
    y_offset = 10 + dialog_font.get_linesize() # Start below title
    for line in lines:
        text = ui_font.render(line, True, BLACK)
        screen.blit(text, (dialog_x + 10, dialog_y + y_offset))
        y_offset += ui_font.get_linesize()

    # Draw OK button
    ok_button_rect = pygame.Rect(dialog_x + dialog_width - BUTTON_WIDTH - 10, dialog_y + dialog_height - BUTTON_HEIGHT - 10, BUTTON_WIDTH, BUTTON_HEIGHT)
    hover = ok_button_rect.collidepoint(pygame.mouse.get_pos())
    color = BUTTON_HOVER if hover else BUTTON_COLOR
    pygame.draw.rect(screen, color, ok_button_rect)
    ok_text = button_font.render("OK", True, BLACK)
    ok_text_rect = ok_text.get_rect(center=ok_button_rect.center)
    screen.blit(ok_text, ok_text_rect)

    pygame.display.flip() # Show dialog

    # Wait for OK click or Enter key
    dialog_running = True
    while dialog_running:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()
            elif event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
                 if ok_button_rect.collidepoint(event.pos):
                     dialog_running = False
            elif event.type == pygame.KEYDOWN:
                 if event.key == pygame.K_RETURN or event.key == pygame.K_KP_ENTER:
                     dialog_running = False


def draw_practice_end_dialog(message):
    """Draw the dialog shown at the end of a practice puzzle."""
    dialog_width, dialog_height = 400, 180
    dialog_x = (WINDOW_WIDTH - dialog_width) // 2
    dialog_y = (WINDOW_HEIGHT - dialog_height) // 2

    # Dim background (optional)
    dim_surface = pygame.Surface(screen.get_size(), pygame.SRCALPHA)
    dim_surface.fill((0, 0, 0, 128))
    screen.blit(dim_surface, (0, 0))

    pygame.draw.rect(screen, DIALOG_COLOR, (dialog_x, dialog_y, dialog_width, dialog_height))
    pygame.draw.rect(screen, BLACK, (dialog_x, dialog_y, dialog_width, dialog_height), 2)

    # Text wrapping
    words = message.split(' ')
    lines = []
    current_line = ''
    max_line_width = dialog_width - 20
    for word in words:
        test_line = current_line + word + ' '
        if ui_font.size(test_line)[0] < max_line_width:
            current_line = test_line
        else:
            lines.append(current_line.strip())
            current_line = word + ' '
    if current_line:
        lines.append(current_line.strip())

    # Draw message lines
    y_offset = 15
    for line in lines:
        text_surf = ui_font.render(line, True, BLACK)
        # Center text horizontally
        text_rect = text_surf.get_rect(centerx=dialog_x + dialog_width // 2)
        screen.blit(text_surf, (text_rect.left, dialog_y + y_offset))
        y_offset += ui_font.get_linesize()

    # Buttons
    button_y = dialog_y + dialog_height - BUTTON_HEIGHT - 15
    total_button_width = 3 * BUTTON_WIDTH + 2 * BUTTON_GAP
    button_start_x = dialog_x + (dialog_width - total_button_width) // 2

    play_again_rect = pygame.Rect(button_start_x, button_y, BUTTON_WIDTH, BUTTON_HEIGHT)
    main_menu_rect = pygame.Rect(button_start_x + BUTTON_WIDTH + BUTTON_GAP, button_y, BUTTON_WIDTH, BUTTON_HEIGHT)
    quit_rect = pygame.Rect(button_start_x + 2 * (BUTTON_WIDTH + BUTTON_GAP), button_y, BUTTON_WIDTH, BUTTON_HEIGHT)

    # Draw buttons with hover
    mouse_pos = pygame.mouse.get_pos()
    pygame.draw.rect(screen, BUTTON_HOVER if play_again_rect.collidepoint(mouse_pos) else BUTTON_COLOR, play_again_rect)
    pygame.draw.rect(screen, BUTTON_HOVER if main_menu_rect.collidepoint(mouse_pos) else BUTTON_COLOR, main_menu_rect)
    pygame.draw.rect(screen, BUTTON_HOVER if quit_rect.collidepoint(mouse_pos) else BUTTON_COLOR, quit_rect)

    play_again_text = button_font.render("Play Again", True, BLACK)
    main_menu_text = button_font.render("Main Menu", True, BLACK)
    quit_text = button_font.render("Quit", True, BLACK)

    screen.blit(play_again_text, play_again_text.get_rect(center=play_again_rect.center))
    screen.blit(main_menu_text, main_menu_text.get_rect(center=main_menu_rect.center))
    screen.blit(quit_text, quit_text.get_rect(center=quit_rect.center))

    return play_again_rect, main_menu_rect, quit_rect

# Part 5: Game Logic Helpers

def get_words_played(word_positions, tiles):
    """
    Get all word strings formed by a play based on tile positions.
    DEPRECATED - Use find_all_words_formed instead for scoring/validation.
    This function might be useful for simpler checks if needed later.
    """
    if not word_positions: return []
    words_found = set()
    rows_involved_list = []
    cols_involved_list = []
    valid_positions = True

    # Ensure input format is correct
    for item in word_positions:
        if isinstance(item, tuple) and len(item) >= 3:
            rows_involved_list.append(item[0])
            cols_involved_list.append(item[1])
        else:
            print(f"Error in get_words_played: Invalid item format: {item}")
            valid_positions = False
            break
    if not valid_positions: return []

    rows_involved = set(rows_involved_list)
    cols_involved = set(cols_involved_list)

    # Check main horizontal word
    if len(rows_involved) == 1:
        r = rows_involved.pop()
        min_c = min(cols_involved_list)
        max_c = max(cols_involved_list)
        # Extend to include adjacent existing tiles
        while min_c > 0 and tiles[r][min_c - 1]: min_c -= 1
        while max_c < GRID_SIZE - 1 and tiles[r][max_c + 1]: max_c += 1
        word_h = "".join(tiles[r][c] for c in range(min_c, max_c + 1) if tiles[r][c])
        if len(word_h) > 1: words_found.add(word_h)
        # Restore row for potential cross-checks if needed later
        rows_involved.add(r)


    # Check main vertical word
    if len(cols_involved) == 1:
        c = cols_involved.pop()
        min_r = min(rows_involved_list)
        max_r = max(rows_involved_list)
        # Extend to include adjacent existing tiles
        while min_r > 0 and tiles[min_r - 1][c]: min_r -= 1
        while max_r < GRID_SIZE - 1 and tiles[max_r + 1][c]: max_r += 1
        word_v = "".join(tiles[r][c] for r in range(min_r, max_r + 1) if tiles[r][c])
        if len(word_v) > 1: words_found.add(word_v)
        # Restore col for potential cross-checks if needed later
        cols_involved.add(c)

    # Cross Checks (only needed if a main word was formed)
    if len(rows_involved) == 1 or len(cols_involved) == 1:
        for r_new, c_new, _ in word_positions:
            # Check vertical cross word if main word was horizontal
            if len(rows_involved) == 1:
                min_r_cross = r_new
                max_r_cross = r_new
                while min_r_cross > 0 and tiles[min_r_cross - 1][c_new]: min_r_cross -= 1
                while max_r_cross < GRID_SIZE - 1 and tiles[max_r_cross + 1][c_new]: max_r_cross += 1
                if max_r_cross > min_r_cross: # Check length > 1
                    cross_word_v = "".join(tiles[r][c_new] for r in range(min_r_cross, max_r_cross + 1) if tiles[r][c_new])
                    if len(cross_word_v) > 1: words_found.add(cross_word_v)

            # Check horizontal cross word if main word was vertical
            if len(cols_involved) == 1:
                min_c_cross = c_new
                max_c_cross = c_new
                while min_c_cross > 0 and tiles[r_new][min_c_cross - 1]: min_c_cross -= 1
                while max_c_cross < GRID_SIZE - 1 and tiles[r_new][max_c_cross + 1]: max_c_cross += 1
                if max_c_cross > min_c_cross: # Check length > 1
                    cross_word_h = "".join(tiles[r_new][c] for c in range(min_c_cross, max_c_cross + 1) if tiles[r_new][c])
                    if len(cross_word_h) > 1: words_found.add(cross_word_h)

    return list(words_found)


def get_remaining_tiles(rack, tiles, blanks):
    """Calculate the remaining tiles (excluding those on board and current player's rack)."""
    remaining = {letter: count for letter, (count, _) in TILE_DISTRIBUTION.items()}

    # Subtract tiles on the current player's rack
    rack_counter = Counter(rack)
    for tile, count in rack_counter.items():
        if tile in remaining:
            remaining[tile] -= count
        else: # Should not happen with valid tiles
            print(f"Warning: Tile '{tile}' from rack not in TILE_DISTRIBUTION.")

    # Subtract tiles on the board
    for r in range(GRID_SIZE):
        for c in range(GRID_SIZE):
            if tiles[r][c]:
                if (r, c) in blanks: # It's a blank on the board
                    if ' ' in remaining:
                        remaining[' '] -= 1
                    else:
                        print(f"Warning: Blank at ({r},{c}) found, but no blanks left in distribution count.")
                else: # It's a letter tile on the board
                    letter = tiles[r][c]
                    if letter in remaining:
                        remaining[letter] -= 1
                    else: # Should not happen with valid tiles
                         print(f"Warning: Tile '{letter}' at ({r},{c}) not in TILE_DISTRIBUTION count.")

    # Ensure counts don't go below zero
    for letter in remaining:
        remaining[letter] = max(0, remaining[letter])

    return remaining


def draw_remaining_tiles(remaining, turn):
    """Draw the list of remaining tiles."""
    global practice_mode
    if practice_mode == "eight_letter": return # Don't draw remaining tiles in this mode

    # Position the remaining tiles list
    remaining_x = BOARD_SIZE + 20 # Align with scoreboard start
    remaining_y_start = BOARD_SIZE + 220 # Position below racks
    title_text = ui_font.render(f"P{turn}'s Unseen Tiles:", True, BLACK)
    screen.blit(title_text, (remaining_x, remaining_y_start))

    y_pos = remaining_y_start + 30
    col_width = 60
    max_y = WINDOW_HEIGHT - 40 # Limit drawing height
    sorted_letters = sorted(remaining.keys())
    current_col_x = remaining_x
    items_in_col = 0
    max_items_per_col = (max_y - y_pos) // 20 # Calculate max items based on available height
    if max_items_per_col <= 0: max_items_per_col = 1 # Avoid division by zero or negative

    last_drawn_y = y_pos # Initialize with starting y_pos
    last_drawn_col_x = remaining_x # Track the column x of the last item

    # Draw individual tile counts
    for letter in sorted_letters:
        count = remaining.get(letter, 0)
        if count > 0:
            display_letter = "?" if letter == " " else letter
            text_str = f"{display_letter}: {count}"
            text = tile_count_font.render(text_str, True, BLACK)

            # Check if we need to wrap to the next column
            if items_in_col >= max_items_per_col:
                y_pos = remaining_y_start + 30 # Reset y_pos for the new column
                current_col_x += col_width
                items_in_col = 0

            # Check if drawing exceeds window height
            if y_pos + 20 > WINDOW_HEIGHT - 10: # Check before drawing
                 break # Stop drawing if out of bounds

            screen.blit(text, (current_col_x, y_pos))
            last_drawn_y = y_pos # Update the last drawn y position in the current column
            last_drawn_col_x = current_col_x # Update the column x
            y_pos += 20
            items_in_col += 1

    # Calculate summary position below the last drawn item's column
    summary_y_start = last_drawn_y + 20 + 5 # Position below last item + gap
    # Ensure summary doesn't go off screen
    summary_y_start = min(summary_y_start, WINDOW_HEIGHT - 40)

    # Calculate summary stats
    total_tiles = sum(remaining.values())
    vowels = sum(remaining.get(letter, 0) for letter in 'AEIOU')
    consonants = sum(remaining.get(letter, 0) for letter in remaining if letter.isalpha() and letter not in 'AEIOU ')
    blanks_rem = remaining.get(' ', 0)

    # Render summary text
    text1 = tile_count_font.render(f"Tiles remaining: {total_tiles}", True, BLACK)
    text2 = tile_count_font.render(f"V: {vowels}  C: {consonants}  B: {blanks_rem}", True, BLACK)

    # Draw summary text aligned with the start of the list columns
    summary_x = remaining_x
    screen.blit(text1, (summary_x, summary_y_start))
    # Ensure second line doesn't go off screen
    if summary_y_start + 20 < WINDOW_HEIGHT - 10:
        screen.blit(text2, (summary_x, summary_y_start + 20))


def draw_arrow(row, col, direction):
    """Draw an arrow indicating play direction."""
    center_x = 40 + col * SQUARE_SIZE + SQUARE_SIZE // 2
    center_y = 40 + row * SQUARE_SIZE + SQUARE_SIZE // 2
    arrow_length = SQUARE_SIZE * 0.4
    arrow_width = SQUARE_SIZE * 0.2 # Width of the arrowhead base

    if direction == "right":
        # Line part
        pygame.draw.line(screen, ARROW_COLOR, (center_x - arrow_length / 2, center_y), (center_x + arrow_length / 2, center_y), 3)
        # Arrowhead
        pygame.draw.polygon(screen, ARROW_COLOR, [
            (center_x + arrow_length / 2, center_y - arrow_width / 2), # Top point
            (center_x + arrow_length / 2, center_y + arrow_width / 2), # Bottom point
            (center_x + arrow_length / 2 + arrow_width, center_y)      # Tip point
        ])
    elif direction == "down":
        # Line part
        pygame.draw.line(screen, ARROW_COLOR, (center_x, center_y - arrow_length / 2), (center_x, center_y + arrow_length / 2), 3)
        # Arrowhead
        pygame.draw.polygon(screen, ARROW_COLOR, [
            (center_x - arrow_width / 2, center_y + arrow_length / 2), # Left point
            (center_x + arrow_width / 2, center_y + arrow_length / 2), # Right point
            (center_x, center_y + arrow_length / 2 + arrow_width)      # Tip point
        ])


def is_valid_play(word_positions, tiles, is_first_play, initial_rack_size, original_tiles, rack_counter):
    """
    Validate a potential play against game rules and dictionary.
    Input: word_positions = list of (r, c, letter) for *only* newly placed tiles.
           tiles = the complete board state *after* placing the tiles.
           is_first_play = boolean.
           initial_rack_size = original number of tiles on rack (for bingo check).
           original_tiles = board state *before* placing the tiles (for connection check).
           rack_counter = Counter object of the player's rack *before* the play (optional, for debugging).
    Returns: (is_valid, is_bingo)
    """
    if not word_positions:
        # print("DEBUG is_valid_play: No word_positions provided.")
        return False, False

    newly_placed_positions_coords = set((r, c) for r, c, _ in word_positions)
    if not newly_placed_positions_coords:
        # print("DEBUG is_valid_play: No new tiles identified.")
        return False, False # No new tiles placed

    # --- Alignment and Gap Checks ---
    rows = sorted(list(set(r for r, _, _ in word_positions)))
    cols = sorted(list(set(c for _, c, _ in word_positions)))
    is_horizontal = len(rows) == 1
    is_vertical = len(cols) == 1

    if not (is_horizontal or is_vertical):
        # If only one tile placed, it's considered both H and V for checks below
        if len(word_positions) != 1:
            # print(f"DEBUG is_valid_play: Not aligned. Rows: {rows}, Cols: {cols}")
            return False, False # Not aligned

    # Check for gaps within the main line of play using the *final* board state
    if is_horizontal:
        r = rows[0]
        min_col_placed = min(cols)
        max_col_placed = max(cols)
        # Extend bounds to include adjacent existing tiles in the final state
        temp_min_col = min_col_placed
        temp_max_col = max_col_placed
        while temp_min_col > 0 and tiles[r][temp_min_col - 1]: temp_min_col -= 1
        while temp_max_col < GRID_SIZE - 1 and tiles[r][temp_max_col + 1]: temp_max_col += 1
        # Check for empty squares within these bounds in the final state
        for c in range(temp_min_col, temp_max_col + 1):
            if not tiles[r][c]:
                # print(f"DEBUG is_valid_play: Gap found horizontally at ({r},{c}) in final state")
                return False, False # Gap found
    elif is_vertical: # Check vertical gaps
        c = cols[0]
        min_row_placed = min(rows)
        max_row_placed = max(rows)
        # Extend bounds
        temp_min_row = min_row_placed
        temp_max_row = max_row_placed
        while temp_min_row > 0 and tiles[temp_min_row - 1][c]: temp_min_row -= 1
        while temp_max_row < GRID_SIZE - 1 and tiles[temp_max_row + 1][c]: temp_max_row += 1
        # Check for gaps
        for r in range(temp_min_row, temp_max_row + 1):
            if not tiles[r][c]:
                # print(f"DEBUG is_valid_play: Gap found vertically at ({r},{c}) in final state")
                return False, False # Gap found

    # --- Word Validity Check ---
    # Use find_all_words_formed on the *final* board state
    all_words_details = find_all_words_formed(word_positions, tiles)

    if not all_words_details:
         # This can happen if only one tile was placed and it didn't form any word > 1 letter
         if len(word_positions) == 1:
              pass # Single tile validity depends on connection check below
         else:
              # Multiple tiles placed but no words formed -> invalid
              # print(f"DEBUG is_valid_play: Multiple tiles placed but no words formed: {word_positions}")
              return False, False

    # Check each formed word string against the DAWG
    formed_word_strings = ["".join(tile[2] for tile in word_detail) for word_detail in all_words_details]
    if not DAWG:
         print("CRITICAL ERROR: DAWG not loaded, cannot validate words.")
         return False, False # Cannot validate without dictionary

    for word in formed_word_strings:
        if not DAWG.search(word):
            # print(f"DEBUG is_valid_play: Word '{word}' not in DAWG.")
            return False, False # Word not in dictionary

    # --- Connection Rules Check ---
    if is_first_play:
        # First play must cover the center square
        if CENTER_SQUARE not in newly_placed_positions_coords:
            # print("DEBUG is_valid_play: First play not on center square.")
            return False, False
        # First play must form at least one word of length > 1
        if not formed_word_strings:
             # print("DEBUG is_valid_play: First play formed no words > 1 letter.")
             return False, False
    else: # Not the first play
        # Must connect to at least one existing tile
        connects = False
        for r, c in newly_placed_positions_coords:
            for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
                nr, nc = r + dr, c + dc
                # Check against the board state *before* the move
                if 0 <= nr < GRID_SIZE and 0 <= nc < GRID_SIZE and original_tiles[nr][nc]:
                    connects = True
                    break # Found connection for this tile
            if connects:
                break # Found connection for the whole play
        if not connects:
            # print("DEBUG is_valid_play: Play does not connect to existing tiles.")
            return False, False
        # Also ensure at least one word was formed (already checked above)
        if not formed_word_strings:
             # print("DEBUG is_valid_play: Non-first play formed no words > 1 letter.")
             return False, False


    # --- Bingo Check ---
    tiles_played_from_rack = len(newly_placed_positions_coords)
    # Use the initial rack size passed to the function
    is_bingo = (initial_rack_size == 7 and tiles_played_from_rack == 7)

    # If all checks passed
    return True, is_bingo


def get_anchor_points(tiles, is_first_play):
    """Get anchor points (empty squares adjacent to existing tiles) for valid moves."""
    anchors = set()
    if is_first_play:
        anchors.add(CENTER_SQUARE)
        return anchors

    has_tiles = False
    for r in range(GRID_SIZE):
        for c in range(GRID_SIZE):
            if tiles[r][c]:
                has_tiles = True # Check if board has any tiles at all
                # Add adjacent empty squares as anchors
                for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < GRID_SIZE and 0 <= nc < GRID_SIZE and not tiles[nr][nc]:
                        anchors.add((nr, nc))

    # If the board is empty but it's *not* the first play (e.g., after exchanges/passes)
    # the only valid anchor is the center square.
    if not has_tiles and not is_first_play:
        anchors.add(CENTER_SQUARE)

    return anchors

# Part 6: Move Generation (Anchor-Based Algorithm)

def _get_cross_check_sets(tiles, dawg):
    """
    Precomputes sets of allowed letters for empty squares based on perpendicular words.
    Returns a dictionary: {(r, c): {'H': {allowed_letters}, 'V': {allowed_letters}}}
    ' ' is included in allowed_letters if any letter is allowed (representing a blank).
    Requires the DAWG object for word validation.
    """
    cross_check_sets = {}
    all_letters_blank = set('ABCDEFGHIJKLMNOPQRSTUVWXYZ ') # Precompute for efficiency

    if not dawg: # Check if DAWG is loaded
        print("Error: DAWG not available for cross-check set generation.")
        return cross_check_sets # Return empty if no DAWG

    for r in range(GRID_SIZE):
        for c in range(GRID_SIZE):
            if not tiles[r][c]: # Only for empty squares
                # --- Vertical Check (for Horizontal Play) ---
                up_word = ""
                rr = r - 1
                while rr >= 0 and tiles[rr][c]:
                    up_word = tiles[rr][c] + up_word
                    rr -= 1

                down_word = ""
                rr = r + 1
                while rr < GRID_SIZE and tiles[rr][c]:
                    down_word += tiles[rr][c]
                    rr += 1

                allowed_letters_v = set()
                if not up_word and not down_word:
                    # If no vertical neighbors, any letter is potentially allowed vertically
                    # No DAWG check needed here, but cross-check still applies later
                    allowed_letters_v = all_letters_blank.copy() # Use copy
                else:
                    # Check which letters form a valid word vertically using DAWG
                    for letter in 'ABCDEFGHIJKLMNOPQRSTUVWXYZ':
                        if dawg.search(up_word + letter + down_word):
                            allowed_letters_v.add(letter)
                    if allowed_letters_v: # If any real letter works, a blank could work
                        allowed_letters_v.add(' ')

                # --- Horizontal Check (for Vertical Play) ---
                left_word = ""
                cc = c - 1
                while cc >= 0 and tiles[r][cc]:
                    left_word = tiles[r][cc] + left_word
                    cc -= 1

                right_word = ""
                cc = c + 1
                while cc < GRID_SIZE and tiles[r][cc]:
                    right_word += tiles[r][cc]
                    cc += 1

                allowed_letters_h = set()
                if not left_word and not right_word:
                    # If no horizontal neighbors, any letter is potentially allowed horizontally
                    allowed_letters_h = all_letters_blank.copy() # Use copy
                else:
                    # Check which letters form a valid word horizontally using DAWG
                    for letter in 'ABCDEFGHIJKLMNOPQRSTUVWXYZ':
                        if dawg.search(left_word + letter + right_word):
                            allowed_letters_h.add(letter)
                    if allowed_letters_h: # If any real letter works, a blank could work
                        allowed_letters_h.add(' ')

                # Store the results for this empty square
                # Only store if there's some restriction (avoids storing full sets everywhere)
                # if allowed_letters_h != all_letters_blank or allowed_letters_v != all_letters_blank:
                cross_check_sets[(r, c)] = {'V': allowed_letters_v, 'H': allowed_letters_h}

    return cross_check_sets


def _extend_right(anchor_r, anchor_c, tiles, board_colors, rack_counts, cross_checks, gaddag_node, moves, is_first_play, original_tiles_state, full_rack_size):
    """
    Generates horizontal moves starting from an anchor square.
    Explores placing tiles to the left of the anchor first, then extends right.
    Uses GADDAG node for prefix validation during extension.
    """
    # --- Try extending left first ---
    # Start with empty left part, use root GADDAG node
    _left_part(anchor_r, anchor_c, "", rack_counts, gaddag_node, tiles, board_colors, cross_checks, gaddag_node, moves, is_first_play, original_tiles_state, full_rack_size)

    # --- Start directly from the anchor extending right ---
    # Check if anchor is empty
    if not tiles[anchor_r][anchor_c]:
        # Try placing each rack tile onto the anchor
        for tile, count in list(rack_counts.items()):
            if count > 0:
                letter_to_try = tile
                is_blank = (tile == ' ')
                possible_letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' if is_blank else [letter_to_try]

                for actual_letter in possible_letters:
                    # 1. Cross-check validation (Vertical check for Horizontal play)
                    allowed_v = cross_checks.get((anchor_r, anchor_c), {}).get('V', set())
                    if actual_letter not in allowed_v and ' ' not in allowed_v:
                        continue

                    # 2. GADDAG validation
                    if actual_letter in gaddag_node.children:
                        next_gaddag_node = gaddag_node.children[actual_letter]
                        new_rack_counts = rack_counts.copy()
                        new_rack_counts[tile] -= 1
                        if new_rack_counts[tile] == 0:
                            del new_rack_counts[tile]

                        placed_anchor_tile = [(anchor_r, anchor_c, actual_letter, is_blank, True)]
                        # Now extend right from the position *after* the anchor
                        _go_right(anchor_r, anchor_c, "", new_rack_counts, next_gaddag_node, tiles, board_colors, cross_checks, gaddag_node, moves, is_first_play, original_tiles_state, full_rack_size, anchor_r, anchor_c + 1, placed_anchor_tile)


def _left_part(anchor_r, anchor_c, partial_word, current_rack_counts, current_gaddag_node, tiles, board_colors, cross_checks, gaddag_root, moves, is_first_play, original_tiles_state, full_rack_size, limit=7):
    """
    Recursive helper to build the part of a word to the LEFT of an anchor.
    Uses the GADDAG root for subsequent rightward extension.
    partial_word is built reversed (e.g., if building "CAT" leftwards from anchor at 'T', partial_word becomes "AC").
    """
    # --- Try extending right using the current left part ---
    # The GADDAG node passed here corresponds to the *reversed* left part.
    # We need the forward node to start the right extension. This requires finding the node for `partial_word[::-1]`.
    # Let's simplify: _go_right will handle the full word check using the combined parts.
    # We pass the GADDAG root to _go_right, which will traverse based on `left_part[::-1] + right_part`.
    _go_right(anchor_r, anchor_c, partial_word[::-1], current_rack_counts, gaddag_root, # Pass reversed left part and root node
              tiles, board_colors, cross_checks, gaddag_root, moves, is_first_play, original_tiles_state, full_rack_size,
              anchor_r, anchor_c, []) # Start _go_right at the anchor

    # --- Try extending further left ---
    if len(partial_word) < limit:
        current_c = anchor_c - len(partial_word) - 1
        if current_c >= 0 and not tiles[anchor_r][current_c]: # Check if square is empty and within bounds
            # Iterate through available tiles in the rack
            for tile, count in list(current_rack_counts.items()):
                if count > 0:
                    letter_to_try = tile
                    is_blank = (tile == ' ')
                    possible_letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' if is_blank else [letter_to_try]

                    for actual_letter in possible_letters:
                        # 1. Cross-check validation (Vertical check for Horizontal play)
                        allowed_v = cross_checks.get((anchor_r, current_c), {}).get('V', set())
                        if actual_letter not in allowed_v and ' ' not in allowed_v:
                            continue

                        # 2. GADDAG validation (Optional: check if reversed prefix is valid)
                        # This adds complexity. Let's rely on the _go_right check for now.

                        new_rack_counts = current_rack_counts.copy()
                        new_rack_counts[tile] -= 1
                        if new_rack_counts[tile] == 0:
                            del new_rack_counts[tile]

                        # Recurse, adding the new letter to the *end* of the reversed partial_word
                        _left_part(anchor_r, anchor_c, partial_word + actual_letter, new_rack_counts, current_gaddag_node, # Pass node (needs update if checking prefix)
                                   tiles, board_colors, cross_checks, gaddag_root, moves, is_first_play, original_tiles_state, full_rack_size, limit)


def _go_right(anchor_r, anchor_c, left_part_str, current_rack_counts, current_gaddag_node, tiles, board_colors, cross_checks, gaddag_root, moves, is_first_play, original_tiles_state, full_rack_size, current_r, current_c, placed_tiles_list):
    """
    Recursive helper to extend a word to the right from a starting position (anchor_c).
    `left_part_str` is the part of the word to the left of anchor_c (already validated somewhat by _left_part).
    `current_gaddag_node` is the node corresponding to `left_part_str`.
    `placed_tiles_list` tracks tuples: (r, c, letter, is_blank, is_new) for tiles placed *in this specific path*.
    `current_r`, `current_c` is the position we are considering placing a tile *next*.
    """
    # --- Check if placing a tile at the anchor is needed ---
    if current_c == anchor_c and not tiles[anchor_r][anchor_c]: # If we are at the anchor and it's empty
        # Try placing each rack tile onto the anchor
        for tile, count in list(current_rack_counts.items()):
            if count > 0:
                letter_to_try = tile
                is_blank = (tile == ' ')
                possible_letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' if is_blank else [letter_to_try]

                for actual_letter in possible_letters:
                    # 1. Cross-check validation (Vertical check for Horizontal play)
                    allowed_v = cross_checks.get((anchor_r, anchor_c), {}).get('V', set())
                    if actual_letter not in allowed_v and ' ' not in allowed_v:
                        continue

                    # 2. GADDAG validation (Check if left_part + actual_letter is a valid prefix)
                    if actual_letter in current_gaddag_node.children:
                        next_gaddag_node = current_gaddag_node.children[actual_letter]
                        new_rack_counts = current_rack_counts.copy()
                        new_rack_counts[tile] -= 1
                        if new_rack_counts[tile] == 0:
                            del new_rack_counts[tile]

                        new_placed_list = placed_tiles_list + [(anchor_r, anchor_c, actual_letter, is_blank, True)]

                        # Check if this placement forms a valid word *by itself*
                        if next_gaddag_node.is_end:
                            _record_move(left_part_str + actual_letter, new_placed_list, anchor_r, anchor_c - len(left_part_str), "right",
                                         new_rack_counts, board_colors, tiles, is_first_play, original_tiles_state, full_rack_size, moves)

                        # Recurse to extend further right
                        _go_right(anchor_r, anchor_c, left_part_str, new_rack_counts, next_gaddag_node,
                                  tiles, board_colors, cross_checks, gaddag_root, moves, is_first_play, original_tiles_state, full_rack_size,
                                  current_r, current_c + 1, new_placed_list)
        # After trying all tiles on the anchor, return (don't proceed with empty anchor)
        return

    # --- If anchor was already filled or we are past it ---
    # Check bounds
    if current_c >= GRID_SIZE:
        return

    existing_tile = tiles[current_r][current_c]

    if not existing_tile: # Square is empty, try placing from rack
        for tile, count in list(current_rack_counts.items()):
            if count > 0:
                letter_to_try = tile
                is_blank = (tile == ' ')
                possible_letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' if is_blank else [letter_to_try]

                for actual_letter in possible_letters:
                    # 1. Cross-check
                    allowed_v = cross_checks.get((current_r, current_c), {}).get('V', set())
                    if actual_letter not in allowed_v and ' ' not in allowed_v:
                        continue

                    # 2. GADDAG check
                    if actual_letter in current_gaddag_node.children:
                        next_gaddag_node = current_gaddag_node.children[actual_letter]
                        new_rack_counts = current_rack_counts.copy()
                        new_rack_counts[tile] -= 1
                        if new_rack_counts[tile] == 0: del new_rack_counts[tile]

                        new_placed_list = placed_tiles_list + [(current_r, current_c, actual_letter, is_blank, True)]

                        # Check if valid word formed
                        if next_gaddag_node.is_end:
                             _record_move(left_part_str + "".join(p[2] for p in new_placed_list), new_placed_list, anchor_r, anchor_c - len(left_part_str), "right",
                                          new_rack_counts, board_colors, tiles, is_first_play, original_tiles_state, full_rack_size, moves)

                        # Recurse
                        _go_right(anchor_r, anchor_c, left_part_str, new_rack_counts, next_gaddag_node,
                                  tiles, board_colors, cross_checks, gaddag_root, moves, is_first_play, original_tiles_state, full_rack_size,
                                  current_r, current_c + 1, new_placed_list)

    else: # Square has an existing tile
        actual_letter = existing_tile
        # 1. Cross-check implicitly OK.
        # 2. GADDAG check
        if actual_letter in current_gaddag_node.children:
            next_gaddag_node = current_gaddag_node.children[actual_letter]
            # Rack counts don't change
            new_placed_list = placed_tiles_list + [(current_r, current_c, actual_letter, False, False)] # Mark as not new

            # Check if valid word formed (using the existing tile)
            if next_gaddag_node.is_end:
                 _record_move(left_part_str + "".join(p[2] for p in new_placed_list), new_placed_list, anchor_r, anchor_c - len(left_part_str), "right",
                              current_rack_counts, board_colors, tiles, is_first_play, original_tiles_state, full_rack_size, moves)

            # Recurse
            _go_right(anchor_r, anchor_c, left_part_str, current_rack_counts, next_gaddag_node,
                      tiles, board_colors, cross_checks, gaddag_root, moves, is_first_play, original_tiles_state, full_rack_size,
                      current_r, current_c + 1, new_placed_list)


# --- Vertical Extension Functions (Analogous to Horizontal) ---

def _extend_down(anchor_r, anchor_c, tiles, board_colors, rack_counts, cross_checks, gaddag_node, moves, is_first_play, original_tiles_state, full_rack_size):
    """Generates vertical moves starting from an anchor square."""
    _up_part(anchor_r, anchor_c, "", rack_counts, gaddag_node, tiles, board_colors, cross_checks, gaddag_node, moves, is_first_play, original_tiles_state, full_rack_size)
    if not tiles[anchor_r][anchor_c]:
        for tile, count in list(rack_counts.items()):
            if count > 0:
                letter_to_try = tile
                is_blank = (tile == ' ')
                possible_letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' if is_blank else [letter_to_try]
                for actual_letter in possible_letters:
                    allowed_h = cross_checks.get((anchor_r, anchor_c), {}).get('H', set())
                    if actual_letter not in allowed_h and ' ' not in allowed_h: continue
                    if actual_letter in gaddag_node.children:
                        next_gaddag_node = gaddag_node.children[actual_letter]
                        new_rack_counts = rack_counts.copy()
                        new_rack_counts[tile] -= 1
                        if new_rack_counts[tile] == 0: del new_rack_counts[tile]
                        placed_anchor_tile = [(anchor_r, anchor_c, actual_letter, is_blank, True)]
                        _go_down(anchor_r, anchor_c, "", new_rack_counts, next_gaddag_node, tiles, board_colors, cross_checks, gaddag_node, moves, is_first_play, original_tiles_state, full_rack_size, anchor_r + 1, anchor_c, placed_anchor_tile)


def _up_part(anchor_r, anchor_c, partial_word, current_rack_counts, current_gaddag_node, tiles, board_colors, cross_checks, gaddag_root, moves, is_first_play, original_tiles_state, full_rack_size, limit=7):
    """Recursive helper to build the part of a word ABOVE an anchor."""
    _go_down(anchor_r, anchor_c, partial_word[::-1], current_rack_counts, gaddag_root,
             tiles, board_colors, cross_checks, gaddag_root, moves, is_first_play, original_tiles_state, full_rack_size,
             anchor_r, anchor_c, [])

    if len(partial_word) < limit:
        current_r = anchor_r - len(partial_word) - 1
        if current_r >= 0 and not tiles[current_r][anchor_c]:
            for tile, count in list(current_rack_counts.items()):
                if count > 0:
                    letter_to_try = tile
                    is_blank = (tile == ' ')
                    possible_letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' if is_blank else [letter_to_try]
                    for actual_letter in possible_letters:
                        allowed_h = cross_checks.get((current_r, anchor_c), {}).get('H', set())
                        if actual_letter not in allowed_h and ' ' not in allowed_h: continue
                        new_rack_counts = current_rack_counts.copy()
                        new_rack_counts[tile] -= 1
                        if new_rack_counts[tile] == 0: del new_rack_counts[tile]
                        _up_part(anchor_r, anchor_c, partial_word + actual_letter, new_rack_counts, current_gaddag_node,
                                 tiles, board_colors, cross_checks, gaddag_root, moves, is_first_play, original_tiles_state, full_rack_size, limit)


def _go_down(anchor_r, anchor_c, up_part_str, current_rack_counts, current_gaddag_node, tiles, board_colors, cross_checks, gaddag_root, moves, is_first_play, original_tiles_state, full_rack_size, current_r, current_c, placed_tiles_list):
    """Recursive helper to extend a word downwards."""
    if current_r == anchor_r and not tiles[anchor_r][anchor_c]:
        for tile, count in list(current_rack_counts.items()):
            if count > 0:
                letter_to_try = tile
                is_blank = (tile == ' ')
                possible_letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' if is_blank else [letter_to_try]
                for actual_letter in possible_letters:
                    allowed_h = cross_checks.get((anchor_r, anchor_c), {}).get('H', set())
                    if actual_letter not in allowed_h and ' ' not in allowed_h: continue
                    if actual_letter in current_gaddag_node.children:
                        next_gaddag_node = current_gaddag_node.children[actual_letter]
                        new_rack_counts = current_rack_counts.copy()
                        new_rack_counts[tile] -= 1
                        if new_rack_counts[tile] == 0: del new_rack_counts[tile]
                        new_placed_list = placed_tiles_list + [(anchor_r, anchor_c, actual_letter, is_blank, True)]
                        if next_gaddag_node.is_end:
                            _record_move(up_part_str + actual_letter, new_placed_list, anchor_r - len(up_part_str), anchor_c, "down",
                                         new_rack_counts, board_colors, tiles, is_first_play, original_tiles_state, full_rack_size, moves)
                        _go_down(anchor_r, anchor_c, up_part_str, new_rack_counts, next_gaddag_node,
                                 tiles, board_colors, cross_checks, gaddag_root, moves, is_first_play, original_tiles_state, full_rack_size,
                                 current_r + 1, current_c, new_placed_list)
        return

    if current_r >= GRID_SIZE: return

    existing_tile = tiles[current_r][current_c]
    if not existing_tile:
        for tile, count in list(current_rack_counts.items()):
            if count > 0:
                letter_to_try = tile
                is_blank = (tile == ' ')
                possible_letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' if is_blank else [letter_to_try]
                for actual_letter in possible_letters:
                    allowed_h = cross_checks.get((current_r, current_c), {}).get('H', set())
                    if actual_letter not in allowed_h and ' ' not in allowed_h: continue
                    if actual_letter in current_gaddag_node.children:
                        next_gaddag_node = current_gaddag_node.children[actual_letter]
                        new_rack_counts = current_rack_counts.copy()
                        new_rack_counts[tile] -= 1
                        if new_rack_counts[tile] == 0: del new_rack_counts[tile]
                        new_placed_list = placed_tiles_list + [(current_r, current_c, actual_letter, is_blank, True)]
                        if next_gaddag_node.is_end:
                            _record_move(up_part_str + "".join(p[2] for p in new_placed_list), new_placed_list, anchor_r - len(up_part_str), anchor_c, "down",
                                         new_rack_counts, board_colors, tiles, is_first_play, original_tiles_state, full_rack_size, moves)
                        _go_down(anchor_r, anchor_c, up_part_str, new_rack_counts, next_gaddag_node,
                                 tiles, board_colors, cross_checks, gaddag_root, moves, is_first_play, original_tiles_state, full_rack_size,
                                 current_r + 1, current_c, new_placed_list)
    else:
        actual_letter = existing_tile
        if actual_letter in current_gaddag_node.children:
            next_gaddag_node = current_gaddag_node.children[actual_letter]
            new_placed_list = placed_tiles_list + [(current_r, current_c, actual_letter, False, False)]
            if next_gaddag_node.is_end:
                _record_move(up_part_str + "".join(p[2] for p in new_placed_list), new_placed_list, anchor_r - len(up_part_str), anchor_c, "down",
                             current_rack_counts, board_colors, tiles, is_first_play, original_tiles_state, full_rack_size, moves)
            _go_down(anchor_r, anchor_c, up_part_str, current_rack_counts, next_gaddag_node,
                     tiles, board_colors, cross_checks, gaddag_root, moves, is_first_play, original_tiles_state, full_rack_size,
                     current_r + 1, current_c, new_placed_list)


def _record_move(word_str, placed_tiles_list, start_r, start_c, direction, final_rack_counts, board_colors, tiles, is_first_play, original_tiles_state, full_rack_size, moves):
    """Helper to validate and record a completed move."""
    newly_placed_details = [(r, c, l) for r, c, l, _, new in placed_tiles_list if new]
    if not newly_placed_details: return # Must place at least one tile

    # Create temporary board state for validation
    temp_tiles = [row[:] for row in original_tiles_state]
    temp_blanks = set() # Blanks placed in *this specific move*
    move_blanks_coords = set()
    for r_p, c_p, l_p, is_b, is_n in placed_tiles_list:
        if 0 <= r_p < GRID_SIZE and 0 <= c_p < GRID_SIZE:
            temp_tiles[r_p][c_p] = l_p # Update temp board
            if is_n and is_b:
                temp_blanks.add((r_p, c_p))
                move_blanks_coords.add((r_p, c_p))

    # Final validation using is_valid_play
    is_valid, is_bingo = is_valid_play(newly_placed_details, temp_tiles, is_first_play, full_rack_size, original_tiles_state, final_rack_counts)

    if is_valid:
        score = calculate_score(newly_placed_details, board_colors, temp_tiles, temp_blanks)

        # Reconstruct the primary word from the temp board for accuracy
        main_word_tiles, orientation = find_main_word(newly_placed_details, temp_tiles)
        if not main_word_tiles:
             # This shouldn't happen if is_valid is True, but handle defensively
             print(f"Warning: is_valid=True but find_main_word failed for {newly_placed_details}")
             return

        full_word_str_main = "".join(t[2] for t in main_word_tiles)
        start_r_main, start_c_main = main_word_tiles[0][0], main_word_tiles[0][1]

        # Create word_with_blanks based on the main word tiles
        word_with_blanks_list = []
        new_pos_set = set((d[0], d[1]) for d in newly_placed_details)
        for wr, wc, w_letter in main_word_tiles:
            is_blank_in_word = (wr, wc) in new_pos_set and (wr, wc) in move_blanks_coords
            word_with_blanks_list.append(w_letter.lower() if is_blank_in_word else w_letter.upper())
        word_with_blanks = "".join(word_with_blanks_list)

        leave = list(final_rack_counts.elements())
        move_details_dict = {
            'positions': [(t[0], t[1], t[2]) for t in main_word_tiles], # Use main word tiles
            'blanks': move_blanks_coords,
            'word': full_word_str_main, # Use main word string
            'score': score,
            'start': (start_r_main, start_c_main), # Use main word start
            'direction': orientation, # Use main word orientation
            'leave': leave,
            'is_bingo': is_bingo,
            'word_with_blanks': word_with_blanks,
            'newly_placed': newly_placed_details
        }

        # Avoid duplicates based on placed tiles and score
        sig_tuple = tuple(sorted(newly_placed_details)) + (score,)
        # Use a shared set across calls to avoid duplicates between H and V generation
        if sig_tuple not in _record_move.seen_signatures:
             moves.append(move_details_dict)
             _record_move.seen_signatures.add(sig_tuple)

# Initialize the shared set for _record_move
_record_move.seen_signatures = set()


def generate_moves(rack, tiles, board_colors, blanks, gaddag_root, dawg_obj):
    """
    Generates ALL valid Scrabble moves using the anchor-based algorithm.
    Replaces the previous GADDAG-specific traversal.
    Uses the GADDAG for efficient prefix/word checking during extension.
    Uses the DAWG for cross-check generation.
    """
    print(f"--- generate_moves called. Rack: {''.join(rack)} ---")
    if not gaddag_root:
        print("ERROR: GADDAG structure root not provided.")
        return []
    if not dawg_obj:
        print("ERROR: DAWG object not provided for cross-checks.")
        return []

    all_found_moves = []
    _record_move.seen_signatures = set() # Reset seen signatures for this run

    rack_counts = Counter(rack)
    is_first_play = sum(1 for row in tiles for t in row if t) == 0
    anchors = get_anchor_points(tiles, is_first_play)
    print(f"--- generate_moves: Found anchors: {anchors} ---")
    original_tiles_state = [row[:] for row in tiles] # For validation checks
    full_rack_size = len(rack) # For bingo checks

    # --- Precompute Cross-Check Sets ---
    print("--- generate_moves: Generating cross-check sets... ---")
    cross_check_sets = _get_cross_check_sets(tiles, dawg_obj) # Pass the DAWG object
    print("--- generate_moves: Cross-check sets generated. ---")

    # --- Initiate Traversal from Anchors ---
    print("--- generate_moves: Starting generation from anchors... ---")
    for r_anchor, c_anchor in anchors:
        # Generate horizontal moves starting/passing through this anchor
        _extend_right(r_anchor, c_anchor, tiles, board_colors, rack_counts, cross_check_sets, gaddag_root, all_found_moves, is_first_play, original_tiles_state, full_rack_size)

        # Generate vertical moves starting/passing through this anchor
        _extend_down(r_anchor, c_anchor, tiles, board_colors, rack_counts, cross_check_sets, gaddag_root, all_found_moves, is_first_play, original_tiles_state, full_rack_size)

    print(f"--- generate_moves: Anchor traversal complete. Found {len(all_found_moves)} potential moves before final sort. ---")

    # --- Final Sorting ---
    # Filtering for duplicates is now handled within _record_move
    all_found_moves.sort(key=lambda m: m['score'], reverse=True)

    print(f"--- generate_moves: Returning {len(all_found_moves)} unique moves. ---")
    return all_found_moves

# Part 7: Hint Dialog, All Words Dialog, Mouse/Tile Interaction

def draw_hint_dialog(moves, selected_index):
    """Draw the hint dialog showing top 5 moves."""
    dialog_width, dialog_height = 400, 250
    dialog_x = (WINDOW_WIDTH - dialog_width) // 2
    dialog_y = (WINDOW_HEIGHT - dialog_height) // 2

    # Dim background
    dim_surface = pygame.Surface(screen.get_size(), pygame.SRCALPHA)
    dim_surface.fill((0, 0, 0, 128))
    screen.blit(dim_surface, (0, 0))

    pygame.draw.rect(screen, DIALOG_COLOR, (dialog_x, dialog_y, dialog_width, dialog_height))
    pygame.draw.rect(screen, BLACK, (dialog_x, dialog_y, dialog_width, dialog_height), 2)

    title_text = dialog_font.render("Top 5 Moves" if moves else "No Moves Available", True, BLACK)
    screen.blit(title_text, (dialog_x + 10, dialog_y + 10))

    hint_rects = []
    y_pos = dialog_y + 40
    item_height = 30 # Height of each hint item

    for i, move in enumerate(moves[:5]): # Show top 5
        color = HINT_SELECTED_COLOR if i == selected_index else HINT_NORMAL_COLOR
        rect = pygame.Rect(dialog_x + 10, y_pos, dialog_width - 20, item_height)
        pygame.draw.rect(screen, color, rect)

        # Extract move details safely using .get()
        word = move.get('word', 'N/A')
        score = move.get('score', 0)
        start_pos = move.get('start', (0,0))
        direction = move.get('direction', 'right')
        leave = move.get('leave', [])
        word_display = move.get('word_with_blanks', word.upper()) # Use formatted word
        coord = get_coord(start_pos, direction)
        leave_str = ''.join(sorted(l if l != ' ' else '?' for l in leave))

        text_str = f"{i+1}. {word_display} ({score} pts) at {coord} ({leave_str})"
        text = ui_font.render(text_str, True, BLACK)

        # Truncate text if too wide for the hint box
        max_text_width = rect.width - 10 # Padding
        if text.get_width() > max_text_width:
             avg_char_width = text.get_width() / len(text_str) if len(text_str) > 0 else 10
             if avg_char_width > 0:
                 max_chars = int(max_text_width / avg_char_width) - 3 # Estimate max chars, leave space for "..."
                 if max_chars < 5: max_chars = 5 # Ensure at least a few chars show
                 text_str = text_str[:max_chars] + "..." # Truncate and add ellipsis
                 text = ui_font.render(text_str, True, BLACK) # Re-render the truncated text

        screen.blit(text, (dialog_x + 15, y_pos + (item_height - text.get_height()) // 2)) # Center text vertically
        hint_rects.append(rect)
        y_pos += item_height # Move to next position

    # Buttons
    button_y = dialog_y + dialog_height - BUTTON_HEIGHT - 10
    total_button_width = 3 * BUTTON_WIDTH + 2 * BUTTON_GAP
    button_start_x = dialog_x + (dialog_width - total_button_width) // 2

    play_button_rect = pygame.Rect(button_start_x, button_y, BUTTON_WIDTH, BUTTON_HEIGHT)
    all_words_button_rect = pygame.Rect(button_start_x + BUTTON_WIDTH + BUTTON_GAP, button_y, BUTTON_WIDTH, BUTTON_HEIGHT)
    ok_button_rect = pygame.Rect(button_start_x + 2 * (BUTTON_WIDTH + BUTTON_GAP), button_y, BUTTON_WIDTH, BUTTON_HEIGHT)

    # Draw buttons with hover
    mouse_pos = pygame.mouse.get_pos()
    pygame.draw.rect(screen, BUTTON_HOVER if play_button_rect.collidepoint(mouse_pos) else BUTTON_COLOR, play_button_rect)
    pygame.draw.rect(screen, BUTTON_HOVER if all_words_button_rect.collidepoint(mouse_pos) else BUTTON_COLOR, all_words_button_rect)
    pygame.draw.rect(screen, BUTTON_HOVER if ok_button_rect.collidepoint(mouse_pos) else BUTTON_COLOR, ok_button_rect)

    play_text = button_font.render("Play", True, BLACK)
    all_words_text = button_font.render("All Words", True, BLACK)
    ok_text = button_font.render("OK", True, BLACK)

    screen.blit(play_text, play_text.get_rect(center=play_button_rect.center))
    screen.blit(all_words_text, all_words_text.get_rect(center=all_words_button_rect.center))
    screen.blit(ok_text, ok_text.get_rect(center=ok_button_rect.center))

    return hint_rects, play_button_rect, ok_button_rect, all_words_button_rect


def draw_all_words_dialog(moves, selected_index, scroll_offset):
    """Draw the dialog showing all valid moves with scrolling."""
    dialog_x = (WINDOW_WIDTH - ALL_WORDS_DIALOG_WIDTH) // 2
    dialog_y = (WINDOW_HEIGHT - ALL_WORDS_DIALOG_HEIGHT) // 2

    # Dim background
    dim_surface = pygame.Surface(screen.get_size(), pygame.SRCALPHA)
    dim_surface.fill((0, 0, 0, 128))
    screen.blit(dim_surface, (0, 0))

    pygame.draw.rect(screen, DIALOG_COLOR, (dialog_x, dialog_y, ALL_WORDS_DIALOG_WIDTH, ALL_WORDS_DIALOG_HEIGHT))
    pygame.draw.rect(screen, BLACK, (dialog_x, dialog_y, ALL_WORDS_DIALOG_WIDTH, ALL_WORDS_DIALOG_HEIGHT), 2)

    # Header
    header_height = 40
    unique_words_count = len(set(move.get('word', '') for move in moves if move.get('word')))
    title_text = dialog_font.render(f"All Valid Moves ({unique_words_count} unique words, {len(moves)} plays)", True, BLACK)
    screen.blit(title_text, (dialog_x + 10, dialog_y + 10))

    # Content Area
    content_area_y = dialog_y + header_height
    button_area_height = BUTTON_HEIGHT + 30 # Space for buttons at bottom
    content_area_height = ALL_WORDS_DIALOG_HEIGHT - header_height - button_area_height
    content_area_rect = pygame.Rect(dialog_x, content_area_y, ALL_WORDS_DIALOG_WIDTH, content_area_height)

    # Scrollable Surface
    content_height = len(moves) * 30 # Total height of all move items
    content_surface_width = max(1, ALL_WORDS_DIALOG_WIDTH - 20) # Width for content, ensure > 0
    # Check if dimensions are valid before creating surface
    if content_surface_width <= 0 or content_height <= 0:
         print(f"Warning: Invalid content surface dimensions ({content_surface_width}x{content_height}). Skipping draw.")
         content_surface = None
    else:
         content_surface = pygame.Surface((content_surface_width, content_height))
         content_surface.fill(DIALOG_COLOR) # Background for the scrollable area

    all_words_rects = [] # Store tuples of (screen_rect, move_index) for visible items
    item_height = 30

    if content_surface: # Only draw if surface was created
        for i, move in enumerate(moves):
            y_pos_on_surface = i * item_height
            # Simple check if the item might be visible
            if y_pos_on_surface >= scroll_offset - item_height and y_pos_on_surface < scroll_offset + content_area_height:
                color = HINT_SELECTED_COLOR if i == selected_index else HINT_NORMAL_COLOR
                rect_on_surface = pygame.Rect(10, y_pos_on_surface, content_surface_width - 20, item_height)
                pygame.draw.rect(content_surface, color, rect_on_surface)

                # Extract move details
                word = move.get('word', 'N/A')
                score = move.get('score', 0)
                start_pos = move.get('start', (0,0))
                direction = move.get('direction', 'right')
                leave = move.get('leave', [])
                word_display = move.get('word_with_blanks', word.upper())
                coord = get_coord(start_pos, direction)
                leave_str = ''.join(sorted(l if l != ' ' else '?' for l in leave))
                text_str = f"{i+1}. {word_display} ({score} pts) at {coord} ({leave_str})"
                text = ui_font.render(text_str, True, BLACK)

                # Truncate text if needed
                max_text_width = rect_on_surface.width - 10
                if text.get_width() > max_text_width:
                    avg_char_width = text.get_width() / len(text_str) if len(text_str) > 0 else 10
                    if avg_char_width > 0:
                        max_chars = int(max_text_width / avg_char_width) - 3
                        if max_chars < 5: max_chars = 5
                        text_str = text_str[:max_chars] + "..."
                        text = ui_font.render(text_str, True, BLACK)

                content_surface.blit(text, (15, y_pos_on_surface + (item_height - text.get_height()) // 2)) # Center vertically

                # Calculate screen rect for click detection (relative to main screen)
                screen_y = content_area_y + y_pos_on_surface - scroll_offset
                screen_rect = pygame.Rect(dialog_x + 10, screen_y, content_surface_width - 20, item_height)

                # Clip the rect to the visible content area for accurate collision
                visible_top = content_area_y
                visible_bottom = content_area_y + content_area_height
                clipped_top = max(visible_top, screen_rect.top)
                clipped_bottom = min(visible_bottom, screen_rect.bottom)

                if clipped_bottom > clipped_top: # If any part is visible
                    clipped_rect = pygame.Rect(screen_rect.left, clipped_top, screen_rect.width, clipped_bottom - clipped_top)
                    all_words_rects.append((clipped_rect, i)) # Store clipped rect and original index

        # Blit the relevant part of the content surface onto the screen
        visible_area_on_surface = pygame.Rect(0, scroll_offset, content_surface_width, content_area_height)
        screen.blit(content_surface, (dialog_x + 10, content_area_y), visible_area_on_surface)

    # Draw border around content area
    pygame.draw.rect(screen, BLACK, (dialog_x + 10, content_area_y, content_surface_width, content_area_height), 1)

    # Buttons
    total_button_width = 2 * BUTTON_WIDTH + BUTTON_GAP
    buttons_x = dialog_x + (ALL_WORDS_DIALOG_WIDTH - total_button_width) // 2
    button_y = dialog_y + ALL_WORDS_DIALOG_HEIGHT - BUTTON_HEIGHT - 20 # Position buttons at bottom

    play_button_rect = pygame.Rect(buttons_x, button_y, BUTTON_WIDTH, BUTTON_HEIGHT)
    ok_button_rect = pygame.Rect(buttons_x + BUTTON_WIDTH + BUTTON_GAP, button_y, BUTTON_WIDTH, BUTTON_HEIGHT)

    # Draw buttons with hover
    mouse_pos = pygame.mouse.get_pos()
    pygame.draw.rect(screen, BUTTON_HOVER if play_button_rect.collidepoint(mouse_pos) else BUTTON_COLOR, play_button_rect)
    pygame.draw.rect(screen, BUTTON_HOVER if ok_button_rect.collidepoint(mouse_pos) else BUTTON_COLOR, ok_button_rect)

    play_text = button_font.render("Play", True, BLACK)
    ok_text = button_font.render("OK", True, BLACK)
    screen.blit(play_text, play_text.get_rect(center=play_button_rect.center))
    screen.blit(ok_text, ok_text.get_rect(center=ok_button_rect.center))

    return all_words_rects, play_button_rect, ok_button_rect


# --- Mouse/Tile Interaction Helpers ---
def get_tile_under_mouse(x, y, rack_start_x, rack_y, rack_len):
    """Determine which tile index (0 to rack_len-1) is under the mouse cursor."""
    for i in range(rack_len):
        tile_x = rack_start_x + i * (TILE_WIDTH + TILE_GAP)
        tile_rect = pygame.Rect(tile_x, rack_y, TILE_WIDTH, TILE_HEIGHT)
        if tile_rect.collidepoint(x, y):
            return i
    return None


def get_insertion_index(x, rack_start_x, rack_len):
    """Determine the insertion index (0 to rack_len) based on mouse x-position."""
    # Check before the center of the first tile
    if x < rack_start_x + TILE_WIDTH // 2:
        return 0
    # Check between tiles
    for i in range(rack_len):
        tile_left = rack_start_x + i * (TILE_WIDTH + TILE_GAP)
        gap_center = tile_left + TILE_WIDTH + TILE_GAP // 2
        if x < gap_center:
            return i + 1
    # If past the center of the last tile
    return rack_len


def count_consecutive_existing(row, col, direction, tiles):
    """Count consecutive existing tiles in a direction (unused currently)."""
    count = 0
    if direction == "right":
        c = col
        while c < GRID_SIZE and tiles[row][c]:
            count += 1
            c += 1
    elif direction == "down": # Added check for 'down'
        r = row
        while r < GRID_SIZE and tiles[r][col]:
            count += 1
            r += 1
    return count

# Part 8: Playing Moves, AI Logic, Replay State

def play_hint_move(move, tiles, racks, blanks, scores, turn, bag, board_colors):
    """
    Plays a move (usually from hint/AI), updates state. Handles practice mode.
    Input: move = dictionary containing move details ('newly_placed', 'blanks', 'score')
           tiles = current board tile grid (will be modified)
           racks = list of player racks (will be modified)
           blanks = set of blank coordinates (will be modified)
           scores = list of player scores (will be modified)
           turn = current player turn (1 or 2)
           bag = list of remaining tiles in bag (will be modified)
           board_colors = grid of board colors (needed for recalculating score if necessary)
    Returns: (next_turn, drawn_tiles, newly_placed_details)
    """
    global practice_mode # Access global practice_mode
    player_idx = turn - 1

    if not (0 <= player_idx < len(racks)):
        print(f"Error: Invalid player index {player_idx} in play_hint_move.")
        return turn, [], [] # Return original turn, no tiles drawn/placed

    current_rack = racks[player_idx]
    # Get details from the move dictionary
    newly_placed_details = move.get('newly_placed', []) # List of (r, c, letter)
    move_blanks_coords = move.get('blanks', set()) # Set of (r, c) for blanks used in this move
    move_score = move.get('score', 0) # Score pre-calculated by generator

    # --- Verification (Optional but recommended) ---
    # Verify the player has the required tiles (including blanks)
    needed_tiles_counter = Counter()
    blanks_needed_count = 0
    for r, c, letter in newly_placed_details:
        if (r, c) in move_blanks_coords:
            blanks_needed_count += 1
        else:
            needed_tiles_counter[letter] += 1

    rack_counter = Counter(current_rack)
    if rack_counter[' '] < blanks_needed_count:
        print(f"Error playing move: Needs {blanks_needed_count} blanks, only {rack_counter[' ']} available.")
        # Attempt to recalculate score/move? For now, just error out.
        return turn, [], []
    for letter, count_needed in needed_tiles_counter.items():
        if rack_counter[letter] < count_needed:
            print(f"Error playing move: Needs {count_needed} '{letter}', only {rack_counter[letter]} available.")
            return turn, [], []
    # --- End Verification ---

    # --- Apply Changes ---
    rack_after_play = current_rack[:] # Work with a copy

    # Place tiles on board and remove from rack copy
    for r, c, letter in newly_placed_details:
        if 0 <= r < GRID_SIZE and 0 <= c < GRID_SIZE:
            tiles[r][c] = letter # Update main board state
            if (r, c) in move_blanks_coords:
                if ' ' in rack_after_play:
                    rack_after_play.remove(' ')
                    blanks.add((r, c)) # Update main blanks set
                else:
                    # This should not happen if verification passed
                    print("Error: Tried to play blank but none in rack_after_play!")
            else: # Regular tile
                if letter in rack_after_play:
                    rack_after_play.remove(letter)
                else:
                    # This should not happen if verification passed
                    print(f"Error: Tried to play '{letter}' but not in rack_after_play!")
        else:
            print(f"Warning: Invalid coordinate ({r},{c}) in play_hint_move.")


    # Update score
    scores[player_idx] += move_score

    # Draw new tiles (Skip in 8-letter practice)
    drawn_tiles = []
    if practice_mode != "eight_letter":
        num_to_draw = len(newly_placed_details)
        drawn_tiles = [bag.pop() for _ in range(num_to_draw) if bag]
        rack_after_play.extend(drawn_tiles)

    # Update the player's actual rack
    racks[player_idx] = rack_after_play

    # Determine next turn (don't switch in 8-letter practice)
    next_turn = turn if practice_mode == "eight_letter" else (turn % 2 + 1) # Toggle between 1 and 2

    return next_turn, drawn_tiles, newly_placed_details


def ai_turn(turn, racks, tiles, board_colors, blanks, scores, bag, first_play, pass_count, exchange_count, consecutive_zero_point_turns, player_names, dropdown_open=False, hinting=False, showing_all_words=False, letter_checks=None):
    """Handles the AI's turn using the anchor-based move generator."""
    global last_word, last_score, last_start, last_direction, move_history, current_replay_turn, practice_mode, GADDAG_STRUCTURE, DAWG # Need DAWG object too

    # Skip AI turn entirely in 8-letter practice mode
    if practice_mode == "eight_letter":
        return turn, first_play, pass_count, exchange_count, consecutive_zero_point_turns, [], dropdown_open, hinting, showing_all_words, False, None

    print(f"AI Player {turn} turn started. Rack: {''.join(racks[turn-1])}")
    paused_for_power_tile = False
    current_power_tile = None # The specific power tile the player must use
    all_moves = [] # Initialize default

    # *** Generate moves using the new anchor-based algorithm ***
    if GADDAG_STRUCTURE and DAWG:
        # Pass GADDAG root for node traversal and DAWG object for cross-checks
        all_moves = generate_moves(racks[turn-1], tiles, board_colors, blanks, GADDAG_STRUCTURE.root, DAWG)
    elif not GADDAG_STRUCTURE:
        print("ERROR: AI cannot generate moves, GADDAG not loaded.")
        all_moves = []
    elif not DAWG:
         print("ERROR: AI cannot generate moves, DAWG object not available.")
         all_moves = []


    if all_moves is None: all_moves = []
    print(f"AI Player {turn} generated {len(all_moves)} moves.")

    # --- Power Tile Practice Pause Check ---
    if practice_mode == "power_tiles" and letter_checks:
        # Determine which power tiles are designated for practice
        checked_power_tiles = {letter for i, letter in enumerate(['J', 'Q', 'X', 'Z']) if letter_checks[i]}
        # Find which of *those* are actually on the current rack
        power_tiles_on_rack = sorted([tile for tile in racks[turn-1] if tile in checked_power_tiles]) # Sort alphabetically

        if power_tiles_on_rack:
            current_power_tile = power_tiles_on_rack[0] # Target the first one alphabetically
            paused_for_power_tile = True
            print(f"AI turn paused for power tile practice. Target: {current_power_tile}")
            # Return the generated moves so 'main' can use them for validation
            return turn, first_play, pass_count, exchange_count, consecutive_zero_point_turns, all_moves, dropdown_open, hinting, showing_all_words, paused_for_power_tile, current_power_tile

    # --- AI Action: Play, Exchange, or Pass (Only if not paused) ---
    move_rack_before = racks[turn-1][:] # Store rack state *before* the move
    exchanged_tiles_for_history = []
    move_type = ''
    score = 0
    word = ''
    positions = [] # For place moves, store the newly placed tiles (r,c,l)
    blanks_used = set() # For place moves, store coords of blanks used {(r,c)}
    drawn_tiles = []
    coord = ''
    word_with_blanks = ''
    is_bingo = False
    newly_placed_details_hist = [] # Store (r,c,l) of newly placed for history

    if not racks[turn-1] and not bag: # Out of tiles and bag empty
        print(f"AI {turn} passing (empty rack/bag).")
        move_type = 'pass'
        consecutive_zero_point_turns += 1
        pass_count += 1
        exchange_count = 0
        next_turn = turn % 2 + 1 # Toggle turn

    elif all_moves: # Play best move
        best_move = all_moves[0]
        print(f"AI {turn} playing best move: {best_move.get('word','N/A')} for {best_move.get('score',0)} points.")
        # Use play_hint_move to apply the move to the board state
        next_turn, drawn_tiles, newly_placed_details_hist = play_hint_move(best_move, tiles, racks, blanks, scores, turn, bag, board_colors)

        # Extract details for history record
        move_type = 'place'
        score = best_move.get('score', 0)
        word = best_move.get('word', 'N/A')
        # History 'positions' should reflect only newly placed tiles
        positions = newly_placed_details_hist # Use the list returned by play_hint_move
        blanks_used = best_move.get('blanks', set())
        start = best_move.get('start', (0,0))
        direction = best_move.get('direction', 'right')
        coord = get_coord(start, direction)
        word_with_blanks = best_move.get('word_with_blanks', '')
        is_bingo = best_move.get('is_bingo', False)

        first_play = False # A move was made
        consecutive_zero_point_turns = 0
        pass_count = 0
        exchange_count = 0
        # next_turn is already set by play_hint_move

    elif len(bag) >= 7: # Exchange if possible and no moves found
        print(f"AI {turn} exchanging tiles.")
        move_type = 'exchange'
        # Simple exchange strategy: exchange first few tiles (e.g., up to 3)
        num_to_exchange = min(len(racks[turn-1]), 3)
        tiles_to_exchange = racks[turn-1][:num_to_exchange]
        exchanged_tiles_for_history = tiles_to_exchange[:] # For history record

        # Perform exchange
        temp_rack = racks[turn-1][num_to_exchange:] # Keep remaining tiles
        drawn_tiles = [bag.pop() for _ in range(num_to_exchange) if bag]
        temp_rack.extend(drawn_tiles)
        racks[turn-1] = temp_rack # Update AI rack
        bag.extend(tiles_to_exchange) # Return exchanged tiles to bag
        random.shuffle(bag)

        score = 0 # Exchange scores 0
        consecutive_zero_point_turns += 1
        exchange_count += 1
        pass_count = 0
        next_turn = turn % 2 + 1 # Toggle turn

    else: # Pass if no moves and cannot exchange
        print(f"AI {turn} passing.")
        move_type = 'pass'
        score = 0
        consecutive_zero_point_turns += 1
        pass_count += 1
        exchange_count = 0
        next_turn = turn % 2 + 1 # Toggle turn

    # --- Record Move ---
    move_data = {
        'player': turn,
        'move_type': move_type,
        'rack': move_rack_before, # Rack state *before* the move
        'score': score,
        'word': word,
        'positions': positions, # Newly placed tiles for 'place' moves
        'blanks': blanks_used, # Blanks used in 'place' moves
        'drawn': drawn_tiles,
        'coord': coord,
        'word_with_blanks': word_with_blanks,
        'is_bingo': is_bingo
    }
    if move_type == 'exchange':
        move_data['exchanged_tiles'] = exchanged_tiles_for_history

    move_history.append(move_data)
    current_replay_turn = len(move_history) # Update replay pointer

    # Return updated state (return empty list for all_moves as AI turn consumed them if it played)
    return next_turn, first_play, pass_count, exchange_count, consecutive_zero_point_turns, [], dropdown_open, hinting, showing_all_words, paused_for_power_tile, current_power_tile


def get_replay_state(turn_idx, initial_racks_replay):
    """
    Recreate the game state up to turn_idx ITERATIVELY for replay.
    Sorts the racks alphabetically before returning.
    """
    # Start with initial state (ensure deep copies)
    tiles_state = [['' for _ in range(GRID_SIZE)] for _ in range(GRID_SIZE)]
    blanks_state = set()
    scores_state = [0, 0]

    # Validate initial_racks_replay format
    if not isinstance(initial_racks_replay, list) or len(initial_racks_replay) != 2 or \
       not all(isinstance(r, list) for r in initial_racks_replay):
        print(f"Error: Invalid initial_racks format in get_replay_state: {initial_racks_replay}")
        # Return a default empty state
        return tiles_state, blanks_state, scores_state, [[], []]

    racks_state = [initial_racks_replay[0][:], initial_racks_replay[1][:]]

    # Apply moves sequentially up to (but not including) turn_idx
    for i in range(turn_idx):
        if i >= len(move_history):
             print(f"Warning: Replay index {i} out of bounds for move_history (len {len(move_history)})")
             break # Stop applying moves if index is invalid

        move = move_history[i]
        player_idx = move['player'] - 1

        # Ensure player index is valid
        if not (0 <= player_idx < len(racks_state)):
            print(f"Warning: Invalid player index {player_idx+1} in move history at index {i}. Skipping move.")
            continue

        # Get the rack state *before* applying this move's changes
        # Note: move['rack'] already stores the rack *before* the move
        # We need to simulate the rack *after* the move is applied
        rack_after_move = move['rack'][:] # Start with rack before the move

        if move['move_type'] == 'place':
            # Apply board changes based on 'positions' which are newly placed tiles
            positions = move.get('positions', [])
            blanks_in_move = move.get('blanks', set()) # Blanks placed in this move

            tiles_removed_from_rack = []
            for r, c, letter in positions:
                if 0 <= r < GRID_SIZE and 0 <= c < GRID_SIZE:
                    # Place tile on board state for replay display
                    tiles_state[r][c] = letter
                    if (r, c) in blanks_in_move:
                        blanks_state.add((r, c))
                        tiles_removed_from_rack.append(' ') # A blank was used
                    else:
                        tiles_removed_from_rack.append(letter) # A letter tile was used
                else:
                    print(f"Replay Warning: Invalid position ({r},{c}) in move {i}")

            # Update score
            scores_state[player_idx] += move.get('score', 0)

            # Update rack state: remove placed tiles, add drawn tiles
            temp_rack = rack_after_move[:] # Work with copy
            for tile_removed in tiles_removed_from_rack:
                 if tile_removed in temp_rack:
                      temp_rack.remove(tile_removed)
                 else:
                      print(f"Replay Warning: Tried to remove '{tile_removed}' from rack for move {i}, but not found in history rack state.")
            temp_rack.extend(move.get('drawn', [])) # Add tiles drawn after the move
            racks_state[player_idx] = temp_rack # Update the persistent rack state

        elif move['move_type'] == 'exchange':
            # Update rack state: remove exchanged, add drawn
            exchanged = move.get('exchanged_tiles', [])
            drawn = move.get('drawn', [])
            temp_rack = rack_after_move[:] # Work with copy
            for tile in exchanged:
                 if tile in temp_rack: temp_rack.remove(tile)
                 else: print(f"Replay Warning: Tried to remove exchanged tile '{tile}' from rack for move {i}, but not found.")
            temp_rack.extend(drawn)
            racks_state[player_idx] = temp_rack
            # Score doesn't change

        elif move['move_type'] == 'pass':
            # No change to board, score, or rack content needed for the state
            # Rack state carries over, already handled by starting with rack_after_move
            racks_state[player_idx] = rack_after_move

    # Sort racks alphabetically before returning for replay display
    for rack in racks_state:
        rack.sort() # In-place sort

    # Return the state *after* turn_idx moves have been applied
    return tiles_state, blanks_state, scores_state, racks_state

# Part 9: Main Game Loop and Entry Point

def main():
    # Make DAWG and GADDAG global, needed by generate_moves and ai_turn
    global bag, last_word, last_score, last_start, last_direction, move_history, replay_mode, current_replay_turn, game_mode, is_ai, practice_mode, board, tiles, racks, blanks, main_called, scores, GADDAG_STRUCTURE, DAWG, initial_racks # Add initial_racks
    print("--- main() function entered ---")

    # Ensure DAWG is loaded (should happen at import time now)
    if not DAWG:
        print("CRITICAL ERROR: DAWG dictionary not loaded. Exiting.")
        pygame.quit()
        sys.exit()

    if not main_called:
        print("--- main(): 'if not main_called' block entered ---")
        main_called = True # Set flag immediately
        print("--- main(): Calling mode_selection_screen()... ---")
        mode_selection_result = mode_selection_screen()
        # Check if mode selection was cancelled (returned None or fewer values)
        if mode_selection_result is None or len(mode_selection_result) != 6:
             print("--- main(): Mode selection cancelled or failed. Exiting. ---")
             pygame.quit()
             sys.exit()

        game_mode, player_names, human_player, practice_mode, letter_checks, practice_state = mode_selection_result
        print(f"--- main(): mode_selection_screen() returned: mode={game_mode}, practice={practice_mode}, human_player={human_player} ---")

        # --- Load GADDAG Structure ---
        # GADDAG loading remains the same
        try:
            print("Attempting to load GADDAG structure from gaddag.pkl...")
            load_start = time.time()
            with open("gaddag.pkl", 'rb') as f_load:
                print("  File gaddag.pkl opened for reading...")
                GADDAG_STRUCTURE = pickle.load(f_load)
                print("  pickle.load() completed...")
            print(f"GADDAG loaded in {time.time() - load_start:.2f} seconds.")
            print("  Validating loaded GADDAG structure...")
            if not GADDAG_STRUCTURE: raise TypeError("Loaded object is None.")
            if not hasattr(GADDAG_STRUCTURE, 'root'): raise TypeError("Loaded object missing 'root'.")
            if not isinstance(GADDAG_STRUCTURE.root, GaddagNode): raise TypeError("Loaded object's root is not a GaddagNode.")
            print("  GADDAG structure validated successfully.")
        except FileNotFoundError:
            print("\n--- ERROR ---"); print("gaddag.pkl not found..."); print("-------------"); pygame.quit(); sys.exit()
        except (pickle.UnpicklingError, TypeError, AttributeError, EOFError) as e:
            print(f"\n--- ERROR ---"); print(f"Failed to load or validate gaddag.pkl: {e}"); print("-------------"); pygame.quit(); sys.exit()
        except MemoryError:
             print(f"\n--- ERROR ---"); print(f"MemoryError loading gaddag.pkl."); print("-------------"); pygame.quit(); sys.exit()
        except Exception as e:
             print(f"\n--- UNEXPECTED ERROR loading GADDAG ---"); print(f"{type(e).__name__}: {e}"); print("-------------"); pygame.quit(); sys.exit()
        print("GADDAG loading and validation block finished.")


        # --- Game State Initialization ---
        print("--- main(): Starting game state initialization... ---")
        if practice_state and practice_mode == "eight_letter":
            print("Loading state from 8-letter practice...")
            # Unpack state carefully
            board, tiles, racks, blanks, bag, scores, turn, first_play = practice_state["board"], practice_state["tiles"], practice_state["racks"], practice_state["blanks"], practice_state["bag"], practice_state["scores"], practice_state["turn"], practice_state["first_play"]
            is_ai = [False, False] # Human plays practice
            print("--- main(): Loaded state from 8-letter practice. ---")
        # elif practice_state: # Other practice modes (Currently only power tiles handled via AvA)
        #     print("Loading state from other practice mode...")
        #     board, tiles, racks, blanks, bag, scores, turn, first_play = practice_state["board"], practice_state["tiles"], practice_state["racks"], practice_state["blanks"], practice_state["bag"], practice_state["scores"], practice_state["turn"], practice_state["first_play"]
        #     is_ai = [False, False];
        #     if game_mode == MODE_HVA: is_ai[2 - human_player] = True
        #     elif game_mode == MODE_AVA or practice_mode == "power_tiles": is_ai = [True, True]
        #     print(f"--- main(): Loaded state from other practice mode. is_ai: {is_ai} ---")
        else: # Standard game initialization (or Power Tile which starts standard)
            print("Performing standard game initialization...")
            board, tiles = create_board() # Get board colors and empty tile grid
            bag = [letter for letter, (count, _) in TILE_DISTRIBUTION.items() for _ in range(count)]
            random.shuffle(bag)
            racks = [[], []]
            try:
                racks[0] = [bag.pop() for _ in range(7)]
                racks[1] = [bag.pop() for _ in range(7)]
            except IndexError:
                print("Error: Not enough tiles in bag for initial draw."); pygame.quit(); sys.exit()
            for rack in racks: rack.sort() # Sort initial racks
            scores = [0, 0]
            turn = 1
            blanks = set()
            first_play = True
            is_ai = [False, False]
            if game_mode == MODE_HVA:
                is_ai[1 if human_player == 1 else 0] = True # Set AI player correctly
            elif game_mode == MODE_AVA:
                is_ai = [True, True]
            print(f"--- main(): Performed standard game initialization. is_ai: {is_ai} ---")

        # --- Common Initializations & Resets ---
        initial_racks = [rack[:] for rack in racks] # Store initial racks *after* potential practice setup
        word_positions = [] # Tiles placed during typing
        running = True
        dropdown_open = False
        return_to_mode_selection = False
        # Dialog/UI state flags
        exchanging = False
        hinting = False
        showing_all_words = False
        showing_stats = False
        game_over_state = False
        paused_for_power_tile = False
        power_tile_message_shown = False
        # Button/Rects (initialized as needed or None)
        all_words_ok_rect = None; all_words_play_rect = None
        hint_rects = []; hint_rect = None; play_button_rect = None; ok_button_rect = None; all_words_button_rect = None
        tile_rects = []; exchange_button_rect = None; cancel_button_rect = None
        # Game state tracking
        pass_count = 0; exchange_count = 0; consecutive_zero_point_turns = 0
        # Typing state
        typing = False; typing_start = None; typing_direction = None; current_r = None; current_c = None; original_selected_square = None
        # Click/Drag state
        last_left_click_time = 0; last_left_click_pos = None
        dragged_tile = None; drag_pos = None; dragging = False; drag_offset = (0, 0)
        selected_square = None # For arrow placement before typing
        # Move/Replay state
        move_history = [] # Reset move history for new game
        replay_mode = False # Ensure replay mode is off initially
        current_replay_turn = 0
        previous_turn = 0 # Track turn changes for move generation
        human_played = False # Flag to prevent AI playing immediately after human action
        # Hint/All Words state
        all_moves = [] # Store generated moves for the current turn
        hint_moves = []
        selected_hint_index = None
        scroll_offset = 0
        # Backup state for typing cancellation
        original_tiles = None; original_rack = None
        # Game Over state
        final_scores = None; reason = ""
        # Dialog position
        dialog_x = (WINDOW_WIDTH - DIALOG_WIDTH) // 2; dialog_y = (WINDOW_HEIGHT - DIALOG_HEIGHT) // 2
        # Power Tile Practice state
        current_power_tile = None

        print("--- main(): Performed common variable resets. ---")

        # --- 8-Letter Practice Specific Initialization ---
        practice_target_moves = []
        practice_best_move = None
        practice_solved = False
        showing_practice_end_dialog = False
        practice_end_message = ""
        practice_play_again_rect = None
        practice_main_menu_rect = None
        practice_quit_rect = None

        if practice_mode == "eight_letter":
            print("--- main(): Performing 8-letter practice specific init... ---")
            print("Generating target moves for 8-letter practice...")
            # Use the new generate_moves function
            if racks and len(racks) > 0 and racks[0] is not None and GADDAG_STRUCTURE and DAWG:
                practice_target_moves = generate_moves(racks[0], tiles, board, blanks, GADDAG_STRUCTURE.root, DAWG)
                if practice_target_moves:
                    practice_best_move = practice_target_moves[0]
                    print(f"Best move found: {practice_best_move['word']} ({practice_best_move['score']} pts)")
                    all_moves = practice_target_moves # Store for potential display/validation
                else:
                    print("Error: No valid moves found for 8-letter practice setup!")
                    show_message_dialog("Error: No possible moves found for this setup.", "Practice Error")
                    return_to_mode_selection = True; running = False # Go back if setup fails
            elif not GADDAG_STRUCTURE: print("Error: Cannot generate practice moves, GADDAG not loaded."); return_to_mode_selection = True; running = False
            elif not DAWG: print("Error: Cannot generate practice moves, DAWG not loaded."); return_to_mode_selection = True; running = False
            else: print("Error: Invalid rack state for Player 1 in 8-letter practice."); return_to_mode_selection = True; running = False

        print("--- main(): Entering main game loop (while running:)... ---")
        # --- Main Game Loop ---
        while running:
            # Generate moves at start of turn (unless practice mode or paused)
            # Also generate if it's human turn and moves haven't been generated yet (e.g., after AI pause)
            is_human_turn = not replay_mode and not is_ai[turn-1]
            needs_move_gen = (turn != previous_turn or (is_human_turn and not all_moves and not paused_for_power_tile))

            if needs_move_gen and not replay_mode and not game_over_state and not paused_for_power_tile and practice_mode != "eight_letter":
                if racks and len(racks) > turn-1 and racks[turn-1] is not None and GADDAG_STRUCTURE and DAWG:
                    print(f"Generating moves for Player {turn}. Rack: {''.join(racks[turn-1])}")
                    # Use the new generate_moves function
                    all_moves = generate_moves(racks[turn-1], tiles, board, blanks, GADDAG_STRUCTURE.root, DAWG)
                    if all_moves is None: all_moves = []
                    print(f"Generated {len(all_moves)} moves for player {turn}")
                elif not GADDAG_STRUCTURE: print("ERROR: Cannot generate moves, GADDAG not loaded."); all_moves = []
                elif not DAWG: print("ERROR: Cannot generate moves, DAWG not loaded."); all_moves = []
                else: print(f"Error: Invalid rack state for player {turn}. Racks: {racks}"); all_moves = []
                previous_turn = turn # Mark that moves are generated for this turn
                human_played = False # Reset human played flag
                power_tile_message_shown = False # Reset message flag

            # --- AI Turn Trigger ---
            if not game_over_state and not replay_mode and not paused_for_power_tile and \
               practice_mode != "eight_letter" and is_ai[turn-1] and not human_played:
                 print(f"Triggering AI turn for Player {turn}")
                 ai_result = ai_turn(turn, racks, tiles, board, blanks, scores, bag, first_play, pass_count, exchange_count, consecutive_zero_point_turns, player_names, dropdown_open, hinting, showing_all_words, letter_checks)
                 if len(ai_result) == 11:
                      turn, first_play, pass_count, exchange_count, consecutive_zero_point_turns, returned_moves, dropdown_open, hinting, showing_all_words, paused_for_power_tile, current_power_tile = ai_result
                      if paused_for_power_tile:
                           all_moves = returned_moves # Get moves generated by AI before pausing
                           if not power_tile_message_shown:
                                player_name = player_names[turn-1] if player_names[turn-1] else f"Player {turn}"
                                show_message_dialog(f"A {current_power_tile} is on {player_name}'s rack. Find the highest scoring play using {current_power_tile}.", "Power Tile Practice")
                                power_tile_message_shown = True
                 else: print(f"Error: AI turn returned unexpected number of values: {len(ai_result)}")


            # --- Event Handling ---
            # [ Event handling loop remains largely the same as previous version ]
            # [ It uses `all_moves` which is now generated by the new function ]
            # [ Typing validation uses `is_valid_play` which is independent ]
            # [ Hinting uses `all_moves` ]
            # [ Practice mode checks use `all_moves` and `practice_best_move` ]
            # [ GCG saving uses `initial_racks` global ]
            # [ Replay uses `initial_racks` global ]
            for event in pygame.event.get():
                if event.type == pygame.QUIT: running = False
                # --- Practice End Dialog Handling ---
                elif showing_practice_end_dialog:
                     if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
                         x, y = event.pos
                         if practice_play_again_rect and practice_play_again_rect.collidepoint(x,y): running = False; return_to_mode_selection = True # Restart main
                         elif practice_main_menu_rect and practice_main_menu_rect.collidepoint(x,y): running = False; return_to_mode_selection = True # Restart main
                         elif practice_quit_rect and practice_quit_rect.collidepoint(x,y): running = False
                # --- Game Over Event Handling ---
                elif game_over_state:
                    if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
                        x, y = event.pos
                        # Allow dragging the dialog box
                        if dialog_x <= x < dialog_x + DIALOG_WIDTH and dialog_y <= y < dialog_y + 20: # Click in title bar area
                            dragging = True; drag_offset = (x - dialog_x, y - dialog_y)
                        elif showing_stats: # Handle clicks when stats dialog is open
                            stats_dialog_width, stats_dialog_height = 400, 360
                            # Calculate actual screen position of stats dialog OK button
                            stats_ok_rect_screen = pygame.Rect(dialog_x + 20 + stats_dialog_width - BUTTON_WIDTH - 10, dialog_y + 20 + stats_dialog_height - BUTTON_HEIGHT - 10, BUTTON_WIDTH, BUTTON_HEIGHT)
                            if stats_ok_rect_screen.collidepoint(x, y):
                                showing_stats = False
                        else: # Handle clicks on main game over buttons
                            # Get button rects relative to current dialog position
                            temp_save_rect, temp_quit_rect, temp_replay_rect, temp_play_again_rect, temp_stats_rect = draw_game_over_dialog(dialog_x, dialog_y, final_scores if final_scores else [0,0], reason, player_names)
                            if temp_save_rect.collidepoint(x, y):
                                if final_scores:
                                    # Pass the globally stored initial_racks
                                    gcg_content = save_game_to_gcg(player_names, move_history, initial_racks, final_scores)
                                    try:
                                        # Suggest a filename based on players and date/time
                                        ts = time.strftime("%Y%m%d_%H%M%S")
                                        p1_safe = "".join(c if c.isalnum() else "_" for c in player_names[0])
                                        p2_safe = "".join(c if c.isalnum() else "_" for c in player_names[1])
                                        save_filename = f"scrappy_{p1_safe}_vs_{p2_safe}_{ts}.gcg"
                                        with open(save_filename, "w") as f: f.write(gcg_content)
                                        print(f"Game saved to {save_filename}")
                                        show_message_dialog(f"Game saved as {save_filename}", "Save Successful")
                                    except IOError as e:
                                        print(f"Error saving game: {e}")
                                        show_message_dialog(f"Error saving game: {e}", "Save Error")
                                else:
                                    print("Cannot save game: Final scores not calculated.")
                                    show_message_dialog("Cannot save game - final scores missing.", "Save Error")
                            elif temp_quit_rect.collidepoint(x, y): running = False
                            elif temp_replay_rect.collidepoint(x, y):
                                game_over_state = False; replay_mode = True; current_replay_turn = 0
                                practice_mode = None; paused_for_power_tile = False; showing_stats = False
                                # Reset scroll for replay
                                scroll_offset = 0
                            elif temp_play_again_rect.collidepoint(x, y): running = False; return_to_mode_selection = True # Restart main
                            elif temp_stats_rect.collidepoint(x, y): showing_stats = True
                    elif event.type == pygame.MOUSEMOTION and dragging:
                        x, y = event.pos; dialog_x = x - drag_offset[0]; dialog_y = y - drag_offset[1]
                        # Clamp dialog position to screen bounds
                        dialog_x = max(0, min(dialog_x, WINDOW_WIDTH - DIALOG_WIDTH))
                        dialog_y = max(0, min(dialog_y, WINDOW_HEIGHT - DIALOG_HEIGHT))
                    elif event.type == pygame.MOUSEBUTTONUP and event.button == 1: dragging = False
                    elif event.type == pygame.KEYDOWN: # Keyboard shortcuts for game over
                        if event.key == pygame.K_s:
                             if final_scores:
                                 gcg_content = save_game_to_gcg(player_names, move_history, initial_racks, final_scores)
                                 try:
                                     ts = time.strftime("%Y%m%d_%H%M%S")
                                     p1_safe = "".join(c if c.isalnum() else "_" for c in player_names[0])
                                     p2_safe = "".join(c if c.isalnum() else "_" for c in player_names[1])
                                     save_filename = f"scrappy_{p1_safe}_vs_{p2_safe}_{ts}.gcg"
                                     with open(save_filename, "w") as f: f.write(gcg_content)
                                     print(f"Game saved to {save_filename}")
                                     show_message_dialog(f"Game saved as {save_filename}", "Save Successful")
                                 except IOError as e:
                                     print(f"Error saving game: {e}")
                                     show_message_dialog(f"Error saving game: {e}", "Save Error")
                             else:
                                 print("Cannot save game: Final scores not calculated.")
                                 show_message_dialog("Cannot save game - final scores missing.", "Save Error")
                        elif event.key == pygame.K_q: running = False
                        elif event.key == pygame.K_r:
                             game_over_state = False; replay_mode = True; current_replay_turn = 0
                             practice_mode = None; paused_for_power_tile = False; showing_stats = False
                             scroll_offset = 0
                        elif event.key == pygame.K_p: running = False; return_to_mode_selection = True # Restart main

                # --- Active Game / Replay Event Handling ---
                elif event.type == pygame.MOUSEBUTTONDOWN:
                    x, y = event.pos; current_time = pygame.time.get_ticks()
                    if event.button == 1: # Left Click
                        if replay_mode: # Replay controls
                            if replay_start_rect.collidepoint(x, y): current_replay_turn = 0; scroll_offset = 0
                            elif replay_prev_rect.collidepoint(x, y) and current_replay_turn > 0: current_replay_turn -= 1; scroll_offset = max(0, scroll_offset - 20) # Scroll up slightly
                            elif replay_next_rect.collidepoint(x, y) and current_replay_turn < len(move_history): current_replay_turn += 1; scroll_offset += 20 # Scroll down slightly
                            elif replay_end_rect.collidepoint(x, y): current_replay_turn = len(move_history); scroll_offset = max(0, len(move_history)*20 - scoreboard_height) # Scroll to end
                        elif not replay_mode: # Active game clicks
                            if exchanging: # Exchange Dialog Click Handling
                                clicked_in_dialog = False
                                # Check buttons first
                                if exchange_button_rect and exchange_button_rect.collidepoint(x, y):
                                    if selected_tiles and len(bag) >= len(selected_tiles):
                                        clicked_in_dialog = True
                                        move_rack = racks[turn-1][:] # Rack before exchange
                                        tiles_to_exchange = [racks[turn-1][i] for i in sorted(selected_tiles, reverse=True)]
                                        temp_rack = [tile for i, tile in enumerate(racks[turn-1]) if i not in selected_tiles]
                                        drawn_tiles = [bag.pop() for _ in range(len(tiles_to_exchange)) if bag]
                                        temp_rack.extend(drawn_tiles)
                                        racks[turn-1] = temp_rack # Update player rack
                                        bag.extend(tiles_to_exchange) # Return tiles to bag
                                        random.shuffle(bag)
                                        consecutive_zero_point_turns += 1
                                        print(f"Player {turn} exchanged {len(tiles_to_exchange)} tiles")
                                        exchanging = False; selected_tiles.clear(); human_played = True
                                        exchange_count += 1; pass_count = 0; paused_for_power_tile = False
                                        # Record history
                                        move_history.append({'player': turn, 'move_type': 'exchange', 'rack': move_rack, 'exchanged_tiles': tiles_to_exchange, 'drawn': drawn_tiles, 'score': 0, 'word': '', 'coord': '', 'blanks': set(), 'positions': [], 'is_bingo': False, 'word_with_blanks': ''})
                                        current_replay_turn = len(move_history)
                                        turn = turn % 2 + 1 # Next turn
                                    else: # Cannot exchange (no tiles selected or not enough in bag)
                                         show_message_dialog("Select tiles to exchange (bag must have enough tiles).", "Exchange Error")
                                         clicked_in_dialog = True # Prevent other actions
                                elif cancel_button_rect and cancel_button_rect.collidepoint(x, y):
                                    clicked_in_dialog = True; exchanging = False; selected_tiles.clear()
                                elif tile_rects: # Check tile clicks
                                    for i, rect in enumerate(tile_rects):
                                        if rect.collidepoint(x, y):
                                            clicked_in_dialog = True
                                            selected_tiles.symmetric_difference_update({i}) # Toggle selection
                                            break
                                # Check if click was inside dialog but not on a control
                                dialog_width_ex, dialog_height_ex = 400, 200
                                dialog_rect_exchange = pygame.Rect((WINDOW_WIDTH - dialog_width_ex) // 2, (WINDOW_HEIGHT - dialog_height_ex) // 2, dialog_width_ex, dialog_height_ex)
                                if dialog_rect_exchange.collidepoint(x,y) and not clicked_in_dialog:
                                     pass # Ignore click on dialog background

                            elif hinting: # Hint Dialog Click Handling
                                clicked_in_dialog = False
                                if play_button_rect and play_button_rect.collidepoint(x, y):
                                    if selected_hint_index is not None and selected_hint_index < len(hint_moves):
                                        clicked_in_dialog = True; selected_move = hint_moves[selected_hint_index]; move_rack = racks[turn-1][:]
                                        # --- Practice Mode Checks for Playing Hint ---
                                        play_allowed = True
                                        if paused_for_power_tile: # Check if hint play is valid for power tile practice
                                            power_moves_check = [m for m in all_moves if any(letter == current_power_tile for _, _, letter in m.get('newly_placed',[]))]
                                            max_power_score_check = max(m['score'] for m in power_moves_check) if power_moves_check else 0
                                            uses_power_in_hint = any(letter == current_power_tile for _, _, letter in selected_move.get('newly_placed',[]))
                                            if not uses_power_in_hint or selected_move['score'] < max_power_score_check:
                                                show_message_dialog(f"This is not the highest scoring move with {current_power_tile}!", "Incorrect Move")
                                                play_allowed = False
                                        elif practice_mode == "eight_letter": # Check if hint play is correct for 8-letter
                                            if practice_best_move and selected_move['score'] < practice_best_move['score']:
                                                 show_message_dialog(f"Try again. There is another word that scores {practice_best_move['score']}.", "Incorrect")
                                                 play_allowed = False
                                            elif not practice_best_move:
                                                 show_message_dialog("Error: No best move data available.", "Error")
                                                 play_allowed = False
                                        # --- Play the move if allowed ---
                                        if play_allowed:
                                            next_turn, drawn_tiles, newly_placed = play_hint_move(selected_move, tiles, racks, blanks, scores, turn, bag, board)
                                            human_played = True; hinting = False; paused_for_power_tile = False
                                            consecutive_zero_point_turns = 0; pass_count = 0; exchange_count = 0
                                            if practice_mode != "eight_letter": # Record history and advance turn normally
                                                move_history.append({'player': turn, 'move_type': 'place', 'rack': move_rack, 'positions': newly_placed, 'blanks': selected_move.get('blanks',set()), 'score': selected_move.get('score',0), 'word': selected_move.get('word','N/A'), 'drawn': drawn_tiles, 'coord': get_coord(selected_move.get('start',(0,0)), selected_move.get('direction','right')), 'word_with_blanks': selected_move.get('word_with_blanks',''), 'is_bingo': selected_move.get('is_bingo',False)})
                                                current_replay_turn = len(move_history)
                                                turn = next_turn
                                            else: # 8-letter practice: check if solved
                                                if practice_best_move and selected_move['score'] == practice_best_move['score']:
                                                    practice_end_message = f"Congratulations! Best: {practice_best_move['word_with_blanks']} ({selected_move['score']} pts)"
                                                    practice_solved = True; showing_practice_end_dialog = True
                                                # Turn doesn't advance in 8-letter practice
                                    else: # No hint selected or index out of bounds
                                         clicked_in_dialog = True # Prevent other actions
                                elif ok_button_rect and ok_button_rect.collidepoint(x, y):
                                    clicked_in_dialog = True; hinting = False
                                elif all_words_button_rect and all_words_button_rect.collidepoint(x, y):
                                    clicked_in_dialog = True; hinting = False; showing_all_words = True
                                    moves_for_all = practice_target_moves if practice_mode == "eight_letter" else all_moves
                                    selected_hint_index = 0 if moves_for_all else None; scroll_offset = 0 # Reset scroll for all words
                                elif hint_rects: # Check hint selection clicks
                                    for i, rect in enumerate(hint_rects):
                                        if rect.collidepoint(x, y) and i < len(hint_moves):
                                            clicked_in_dialog = True; selected_hint_index = i; break
                                # Check if click was inside dialog but not on a control
                                dialog_width_h, dialog_height_h = 400, 250
                                dialog_rect_hint = pygame.Rect((WINDOW_WIDTH - dialog_width_h) // 2, (WINDOW_HEIGHT - dialog_height_h) // 2, dialog_width_h, dialog_height_h)
                                if dialog_rect_hint.collidepoint(x,y) and not clicked_in_dialog:
                                     pass # Ignore click on dialog background

                            elif showing_all_words: # All Words Dialog Click Handling
                                clicked_in_dialog = False
                                moves_for_all = practice_target_moves if practice_mode == "eight_letter" else all_moves
                                if all_words_play_rect and all_words_play_rect.collidepoint(x, y):
                                     if selected_hint_index is not None and selected_hint_index < len(moves_for_all):
                                        clicked_in_dialog = True; selected_move = moves_for_all[selected_hint_index]; move_rack = racks[turn-1][:]
                                        # --- Practice Mode Checks for Playing from All Words ---
                                        play_allowed = True
                                        if paused_for_power_tile: # Check power tile practice
                                            power_moves_check = [m for m in all_moves if any(letter == current_power_tile for _, _, letter in m.get('newly_placed',[]))]
                                            max_power_score_check = max(m['score'] for m in power_moves_check) if power_moves_check else 0
                                            uses_power_in_sel = any(letter == current_power_tile for _, _, letter in selected_move.get('newly_placed',[]))
                                            if not uses_power_in_sel or selected_move['score'] < max_power_score_check:
                                                show_message_dialog(f"This is not the highest scoring move with {current_power_tile}!", "Incorrect Move")
                                                play_allowed = False
                                        elif practice_mode == "eight_letter": # Check 8-letter practice
                                            if practice_best_move and selected_move['score'] < practice_best_move['score']:
                                                 show_message_dialog(f"Try again. There is another word that scores {practice_best_move['score']}.", "Incorrect")
                                                 play_allowed = False
                                            elif not practice_best_move:
                                                 show_message_dialog("Error: No best move data available.", "Error")
                                                 play_allowed = False
                                        # --- Play the move if allowed ---
                                        if play_allowed:
                                            next_turn, drawn_tiles, newly_placed = play_hint_move(selected_move, tiles, racks, blanks, scores, turn, bag, board)
                                            human_played = True; showing_all_words = False; paused_for_power_tile = False
                                            consecutive_zero_point_turns = 0; pass_count = 0; exchange_count = 0
                                            if practice_mode != "eight_letter": # Record history and advance turn normally
                                                move_history.append({'player': turn, 'move_type': 'place', 'rack': move_rack, 'positions': newly_placed, 'blanks': selected_move.get('blanks',set()), 'score': selected_move.get('score',0), 'word': selected_move.get('word','N/A'), 'drawn': drawn_tiles, 'coord': get_coord(selected_move.get('start',(0,0)), selected_move.get('direction','right')), 'word_with_blanks': selected_move.get('word_with_blanks',''), 'is_bingo': selected_move.get('is_bingo',False)})
                                                current_replay_turn = len(move_history)
                                                turn = next_turn
                                            else: # 8-letter practice: check if solved
                                                if practice_best_move and selected_move['score'] == practice_best_move['score']:
                                                    practice_end_message = f"Congratulations! Best: {practice_best_move['word_with_blanks']} ({selected_move['score']} pts)"
                                                    practice_solved = True; showing_practice_end_dialog = True
                                                # Turn doesn't advance
                                     else: # No move selected or index invalid
                                          clicked_in_dialog = True # Prevent other actions
                                elif all_words_ok_rect and all_words_ok_rect.collidepoint(x, y):
                                    clicked_in_dialog = True; showing_all_words = False
                                elif all_words_rects: # Check clicks on the move list items
                                    for rect, idx in all_words_rects:
                                        if rect.collidepoint(x, y):
                                            clicked_in_dialog = True; selected_hint_index = idx; break
                                # Check if click was inside dialog but not on a control
                                dialog_rect_all = pygame.Rect((WINDOW_WIDTH - ALL_WORDS_DIALOG_WIDTH) // 2, (WINDOW_HEIGHT - ALL_WORDS_DIALOG_HEIGHT) // 2, ALL_WORDS_DIALOG_WIDTH, ALL_WORDS_DIALOG_HEIGHT)
                                if dialog_rect_all.collidepoint(x,y) and not clicked_in_dialog:
                                     pass # Ignore click on dialog background

                            elif not (exchanging or hinting or showing_all_words): # Clicks outside dialogs
                                # Options Menu Click Handling
                                options_rect, dropdown_rects = draw_options_menu(turn, dropdown_open, len(bag)) # Get current rects
                                if options_rect.collidepoint(x, y):
                                    dropdown_open = not dropdown_open
                                elif dropdown_open: # Check dropdown item clicks
                                    clicked_dropdown = False
                                    current_options = ["Give Up", "Main", "Quit"] if practice_mode == "eight_letter" else ["Pass", "Exchange", "Main", "Quit"]
                                    for i, rect in enumerate(dropdown_rects):
                                        if rect and rect.collidepoint(x, y): # Check if rect exists (not disabled)
                                            clicked_dropdown = True; selected_option = current_options[i]; dropdown_open = False
                                            if selected_option == "Pass":
                                                 if practice_mode == "eight_letter": show_message_dialog("Passing is not allowed in 8-Letter Practice.", "Action Not Allowed")
                                                 else:
                                                      move_rack = racks[turn-1][:]; consecutive_zero_point_turns += 1; pass_count += 1; exchange_count = 0; print(f"Player {turn} passed"); human_played = True; paused_for_power_tile = False
                                                      move_history.append({'player': turn, 'move_type': 'pass', 'rack': move_rack, 'score': 0, 'word': '', 'coord': '', 'blanks': set(), 'positions': [], 'drawn': [], 'is_bingo': False, 'word_with_blanks': ''})
                                                      current_replay_turn = len(move_history); turn = turn % 2 + 1
                                            elif selected_option == "Exchange":
                                                 if practice_mode == "eight_letter": show_message_dialog("Exchanging is not allowed in 8-Letter Practice.", "Action Not Allowed")
                                                 # Check for disabled state already handled by rect being None
                                                 else: exchanging = True; selected_tiles.clear()
                                            elif selected_option == "Give Up": # Only for 8-letter practice
                                                if practice_best_move: practice_end_message = f"Best: {practice_best_move['word_with_blanks']} ({practice_best_move['score']} pts)"
                                                else: practice_end_message = "No best move found."
                                                practice_solved = True; showing_practice_end_dialog = True
                                            elif selected_option == "Main": running = False; return_to_mode_selection = True # Restart main
                                            elif selected_option == "Quit":
                                                if confirm_quit(): running = False
                                            break # Exit dropdown loop
                                    if not clicked_dropdown: dropdown_open = False # Close if clicked outside items
                                elif not options_rect.collidepoint(x,y): dropdown_open = False # Close if clicked outside button

                                # Suggest Button Click Handling
                                suggest_rect = draw_suggest_button() # Get current rect
                                if suggest_rect and suggest_rect.collidepoint(x, y) and (not is_ai[turn-1] or paused_for_power_tile):
                                    moves_to_hint = practice_target_moves if practice_mode == "eight_letter" else all_moves
                                    if paused_for_power_tile: # Filter hints for power tile
                                         power_moves_hint = [m for m in moves_to_hint if any(letter == current_power_tile for _, _, letter in m.get('newly_placed',[]))]
                                         hint_moves = sorted(power_moves_hint, key=lambda m: m['score'], reverse=True)[:5]
                                    else:
                                         hint_moves = moves_to_hint[:5]
                                    hinting = True; selected_hint_index = 0 if hint_moves else None

                                # Rack Buttons (Alphabetize/Randomize) Click Handling
                                current_player_idx = turn - 1
                                if not is_ai[current_player_idx] or paused_for_power_tile:
                                     # Get button rects and rack start_x from draw_rack
                                     alpha_rect, rand_rect, _, rack_start_x = draw_rack(turn, racks[current_player_idx], scores, turn, player_names)
                                     if alpha_rect and alpha_rect.collidepoint(x, y):
                                          racks[current_player_idx].sort()
                                     elif rand_rect and rand_rect.collidepoint(x, y):
                                          random.shuffle(racks[current_player_idx])

                                # Rack Tile Drag Start Click Handling
                                current_player_idx = turn - 1
                                if 0 <= current_player_idx < len(racks):
                                     # Get tile rects and rack_start_x from draw_rack again (needed for accurate positions)
                                     _, _, tile_rects_on_rack, rack_start_x_drag = draw_rack(turn, racks[current_player_idx], scores, turn, player_names)
                                     rack_y_drag = BOARD_SIZE + 80 if turn == 1 else BOARD_SIZE + 150
                                     tile_idx = get_tile_under_mouse(x, y, rack_start_x_drag, rack_y_drag, len(racks[current_player_idx]))
                                     if tile_idx is not None and not dragged_tile and (not is_ai[current_player_idx] or paused_for_power_tile):
                                          dragged_tile = (turn, tile_idx)
                                          drag_pos = (x, y)
                                          # Calculate offset within the clicked tile
                                          tile_abs_x = rack_start_x_drag + tile_idx * (TILE_WIDTH + TILE_GAP)
                                          drag_offset = (x - tile_abs_x, y - rack_y_drag)

                                # Board Click (Typing Start / Arrow Selection)
                                if not dragged_tile and (not is_ai[turn-1] or paused_for_power_tile):
                                    col = (x - 40) // SQUARE_SIZE
                                    row = (y - 40) // SQUARE_SIZE
                                    if 0 <= row < GRID_SIZE and 0 <= col < GRID_SIZE and not tiles[row][col]: # Click on empty board square
                                        is_double_click = (last_left_click_pos == (row, col) and current_time - last_left_click_time < DOUBLE_CLICK_TIME)
                                        if is_double_click: # Double click cancels typing/selection
                                            selected_square = None; typing = False
                                            if word_positions and original_tiles and original_rack: # Revert cancelled typing
                                                 for r_wp, c_wp, _ in word_positions: tiles[r_wp][c_wp] = original_tiles[r_wp][c_wp]
                                                 racks[turn-1] = original_rack[:]; blanks_to_remove = set((r_wp, c_wp) for r_wp, c_wp, _ in word_positions if (r_wp, c_wp) in blanks); blanks.difference_update(blanks_to_remove); word_positions = []
                                                 original_tiles = None; original_rack = None # Clear backup state
                                        elif selected_square is None or selected_square[:2] != (row, col): # First click or click on new square
                                            selected_square = (row, col, "right"); typing = False; word_positions = [] # Reset typing state
                                        elif selected_square[2] == "right": # Second click, change direction
                                            selected_square = (row, col, "down")
                                        elif selected_square[2] == "down": # Third click, deselect
                                            selected_square = None
                                        last_left_click_pos = (row, col); last_left_click_time = current_time
                                    else: # Click outside board or on occupied square
                                         selected_square = None # Deselect arrow
                                         # Don't cancel typing here, allow clicking outside board during typing

                    elif event.button == 3: # Right Click
                        selected_square = None # Deselect typing start/arrow
                        if typing: # Cancel active typing
                            if original_tiles and original_rack:
                                for r_wp, c_wp, _ in word_positions: tiles[r_wp][c_wp] = original_tiles[r_wp][c_wp]
                                racks[turn-1] = original_rack[:]
                                blanks_to_remove = set((r_wp, c_wp) for r_wp, c_wp, _ in word_positions if (r_wp, c_wp) in blanks); blanks.difference_update(blanks_to_remove)
                            typing = False; typing_start = None; typing_direction = None; word_positions = []; original_tiles = None; original_rack = None

                # --- Mouse Motion ---
                elif event.type == pygame.MOUSEMOTION:
                    if dragged_tile and drag_pos: drag_pos = event.pos # Update drag position
                    elif game_over_state and dragging: # Drag game over dialog
                        x, y = event.pos; dialog_x = x - drag_offset[0]; dialog_y = y - drag_offset[1]
                        dialog_x = max(0, min(dialog_x, WINDOW_WIDTH - DIALOG_WIDTH))
                        dialog_y = max(0, min(dialog_y, WINDOW_HEIGHT - DIALOG_HEIGHT))

                # --- Mouse Button Up ---
                elif event.type == pygame.MOUSEBUTTONUP:
                    if event.button == 1: # Left button up
                        if game_over_state and dragging: dragging = False # Stop dragging dialog
                        elif dragged_tile and (not is_ai[dragged_tile[0]-1] or paused_for_power_tile) and not replay_mode:
                            x, y = event.pos; player_idx = dragged_tile[0] - 1
                            # Get rack position info again for drop check
                            _, _, _, rack_start_x_drop = draw_rack(dragged_tile[0], racks[player_idx], scores, turn, player_names)
                            rack_y_drop = BOARD_SIZE + 80 if dragged_tile[0] == 1 else BOARD_SIZE + 150
                            rack_width_drop = 7 * (TILE_WIDTH + TILE_GAP) - TILE_GAP
                            rack_area_rect = pygame.Rect(rack_start_x_drop, rack_y_drop, rack_width_drop, TILE_HEIGHT)

                            if rack_area_rect.collidepoint(x, y): # Dropped on rack (reordering)
                                rack_len = len(racks[player_idx])
                                insert_idx = get_insertion_index(x, rack_start_x_drop, rack_len)
                                original_tile_idx = dragged_tile[1]
                                if 0 <= original_tile_idx < rack_len:
                                    player_rack = racks[player_idx]
                                    tile_to_move = player_rack.pop(original_tile_idx)
                                    # Adjust insertion index if moving tile past its original position
                                    if original_tile_idx < insert_idx: insert_idx -= 1
                                    insert_idx = max(0, min(insert_idx, len(player_rack))) # Clamp index
                                    player_rack.insert(insert_idx, tile_to_move)
                            # If dropped elsewhere (e.g., board), tile placement is handled by typing logic
                            dragged_tile = None; drag_pos = None # End drag

                # --- Mouse Wheel (Scrolling) ---
                elif event.type == pygame.MOUSEWHEEL:
                    mouse_x, mouse_y = pygame.mouse.get_pos()
                    if showing_all_words: # Scroll All Words Dialog
                         dialog_rect_all = pygame.Rect((WINDOW_WIDTH - ALL_WORDS_DIALOG_WIDTH) // 2, (WINDOW_HEIGHT - ALL_WORDS_DIALOG_HEIGHT) // 2, ALL_WORDS_DIALOG_WIDTH, ALL_WORDS_DIALOG_HEIGHT)
                         content_area_y = dialog_rect_all.y + 40 # Header height
                         content_area_height = ALL_WORDS_DIALOG_HEIGHT - 40 - (BUTTON_HEIGHT + 30) # Header and button area
                         content_area_rect = pygame.Rect(dialog_rect_all.x, content_area_y, ALL_WORDS_DIALOG_WIDTH, content_area_height)

                         if content_area_rect.collidepoint(mouse_x, mouse_y): # Check if mouse is over the scrollable area
                              moves_for_scroll = practice_target_moves if practice_mode == "eight_letter" else all_moves
                              content_height = len(moves_for_scroll) * 30
                              max_scroll = max(0, content_height - content_area_height)
                              scroll_offset -= event.y * SCROLL_SPEED
                              scroll_offset = max(0, min(scroll_offset, max_scroll))
                    else: # Scroll Scoreboard
                        sb_x = BOARD_SIZE + 20; sb_y = 40
                        sb_w = WINDOW_WIDTH - sb_x - 20; sb_h = WINDOW_HEIGHT - sb_y - 20
                        sb_w = max(250, sb_w); sb_h = max(200, sb_h)
                        scoreboard_rect = pygame.Rect(sb_x, sb_y, sb_w, sb_h)

                        if scoreboard_rect.collidepoint(mouse_x, mouse_y):
                             history_len = current_replay_turn if replay_mode else len(move_history)
                             total_content_height = history_len * 20 # Approx height
                             if (game_over_state or (replay_mode and current_replay_turn == len(move_history))) and final_scores: total_content_height += 40 # Add space for final score line
                             max_scroll = max(0, total_content_height - scoreboard_height)
                             scroll_offset -= event.y * SCROLL_SPEED
                             scroll_offset = max(0, min(scroll_offset, max_scroll))

                # --- Keydown Handling (Typing & General) ---
                elif event.type == pygame.KEYDOWN:
                    is_human_turn_or_paused = not replay_mode and (not is_ai[turn-1] or paused_for_power_tile)

                    if is_human_turn_or_paused:
                        # --- Start Typing Logic ---
                        if selected_square and not typing and event.unicode.isalpha():
                            typing = True
                            original_tiles = [row[:] for row in tiles] # Backup board state
                            original_rack = racks[turn-1][:]          # Backup rack state
                            typing_start = selected_square[:2]
                            typing_direction = selected_square[2]
                            original_selected_square = selected_square # Remember where arrow was
                            selected_square = None # Hide arrow while typing
                            word_positions = [] # Track tiles placed in this typing sequence: (r, c, letter)
                            current_r, current_c = typing_start
                            letter = event.unicode.upper()
                            # Try placing the first letter
                            if 0 <= current_r < GRID_SIZE and 0 <= current_c < GRID_SIZE and not tiles[current_r][current_c]:
                                placed = False
                                if letter in racks[turn-1]:
                                    tiles[current_r][current_c] = letter
                                    racks[turn-1].remove(letter)
                                    word_positions.append((current_r, current_c, letter))
                                    placed = True
                                elif ' ' in racks[turn-1]: # Use blank
                                    tiles[current_r][current_c] = letter
                                    racks[turn-1].remove(' ')
                                    blanks.add((current_r, current_c)) # Track blank placement
                                    word_positions.append((current_r, current_c, letter))
                                    placed = True

                                if placed: # Advance cursor
                                    if typing_direction == "right":
                                        current_c += 1
                                        # Skip over existing tiles
                                        while current_c < GRID_SIZE and tiles[current_r][current_c]:
                                            current_c += 1
                                    elif typing_direction == "down":
                                        current_r += 1
                                        # Skip over existing tiles
                                        while current_r < GRID_SIZE and tiles[current_r][current_c]:
                                            current_r += 1
                                    # Clamp cursor position
                                    current_r = min(current_r, GRID_SIZE - 1)
                                    current_c = min(current_c, GRID_SIZE - 1)

                        # --- Active Typing Logic ---
                        elif typing:
                            if event.key == pygame.K_RETURN or event.key == pygame.K_KP_ENTER:
                                play_finalized_normally = False # Flag to track if normal play logic should run
                                if word_positions:
                                    # Create temporary board state reflecting the typed word for validation
                                    temp_tiles_val = [row[:] for row in original_tiles] # Start from state *before* typing
                                    for r_wp, c_wp, l_wp in word_positions:
                                        if 0 <= r_wp < GRID_SIZE and 0 <= c_wp < GRID_SIZE:
                                             temp_tiles_val[r_wp][c_wp] = l_wp

                                    # Validate the play using the temporary board
                                    valid, is_bingo = is_valid_play(word_positions, temp_tiles_val, first_play, len(original_rack), original_tiles, Counter(original_rack))

                                    if valid:
                                        # Calculate score based on the *actual* board state after typing
                                        score = calculate_score(word_positions, board, tiles, blanks)
                                        print(f"DEBUG: Valid play typed, score: {score}")

                                        # --- Practice Mode Specific Logic ---
                                        if practice_mode == "eight_letter":
                                            print("DEBUG: Checking 8-letter practice logic...")
                                            if practice_best_move and score == practice_best_move['score']:
                                                practice_end_message = f"Congratulations! Best: {practice_best_move['word_with_blanks']} ({score} pts)"
                                                practice_solved = True; showing_practice_end_dialog = True
                                                # Don't finalize normally, just show dialog
                                            elif practice_best_move:
                                                show_message_dialog(f"Try again. There is another word that scores {practice_best_move['score']}.", "Incorrect")
                                                # Revert board/rack
                                                if original_tiles and original_rack:
                                                    for r_wp, c_wp, _ in word_positions: tiles[r_wp][c_wp] = original_tiles[r_wp][c_wp]
                                                    racks[turn-1] = original_rack[:]
                                                    blanks_to_remove = set((r_wp, c_wp) for r_wp, c_wp, _ in word_positions if (r_wp, c_wp) in blanks); blanks.difference_update(blanks_to_remove)
                                                typing = False; typing_start = None; typing_direction = None; word_positions = []; original_tiles = None; original_rack = None
                                                selected_square = original_selected_square # Restore arrow
                                            else: # Error case
                                                show_message_dialog("Error: No best move data available.", "Error")
                                                return_to_mode_selection = True; running = False
                                                typing = False; typing_start = None; typing_direction = None; word_positions = []; original_tiles = None; original_rack = None

                                        elif practice_mode == "power_tiles" and paused_for_power_tile:
                                            print(f"DEBUG: Checking Power Tile ({current_power_tile}) practice logic...")
                                            uses_power = any(letter == current_power_tile for r_wp, c_wp, letter in word_positions)
                                            # Find max score among valid moves using the power tile
                                            power_moves = [m for m in all_moves if any(pt[2] == current_power_tile for pt in m.get('newly_placed', []))]
                                            max_power_score = max(m['score'] for m in power_moves) if power_moves else 0
                                            print(f"DEBUG: Player used power tile: {uses_power}. Player score: {score}. Max power score: {max_power_score}")

                                            if not uses_power:
                                                show_message_dialog(f"Move must use the {current_power_tile}!", "Incorrect")
                                                # Revert
                                                if original_tiles and original_rack:
                                                    for r_wp, c_wp, _ in word_positions: tiles[r_wp][c_wp] = original_tiles[r_wp][c_wp]
                                                    racks[turn-1] = original_rack[:]
                                                    blanks_to_remove = set((r_wp, c_wp) for r_wp, c_wp, _ in word_positions if (r_wp, c_wp) in blanks); blanks.difference_update(blanks_to_remove)
                                                typing = False; typing_start = None; typing_direction = None; word_positions = []; original_tiles = None; original_rack = None; selected_square = original_selected_square
                                            elif score < max_power_score:
                                                show_message_dialog(f"Try again. There is another word that scores {max_power_score}.", "Higher Score Exists")
                                                # Revert
                                                if original_tiles and original_rack:
                                                    for r_wp, c_wp, _ in word_positions: tiles[r_wp][c_wp] = original_tiles[r_wp][c_wp]
                                                    racks[turn-1] = original_rack[:]
                                                    blanks_to_remove = set((r_wp, c_wp) for r_wp, c_wp, _ in word_positions if (r_wp, c_wp) in blanks); blanks.difference_update(blanks_to_remove)
                                                typing = False; typing_start = None; typing_direction = None; word_positions = []; original_tiles = None; original_rack = None; selected_square = original_selected_square
                                            else: # Correct!
                                                show_message_dialog("That's correct! Great job.", "Correct!")
                                                paused_for_power_tile = False # Unpause
                                                power_tile_message_shown = False
                                                play_finalized_normally = True # Allow normal turn progression

                                        else: # Not a practice mode turn, finalize normally
                                            play_finalized_normally = True

                                    else: # Invalid play typed
                                        print(f"Invalid play typed.")
                                        # Revert board and rack
                                        if original_tiles and original_rack:
                                            for r_wp, c_wp, _ in word_positions: tiles[r_wp][c_wp] = original_tiles[r_wp][c_wp]
                                            racks[turn-1] = original_rack[:]
                                            blanks_to_remove = set((r_wp, c_wp) for r_wp, c_wp, _ in word_positions if (r_wp, c_wp) in blanks); blanks.difference_update(blanks_to_remove)
                                        typing = False; typing_start = None; typing_direction = None; word_positions = []; original_tiles = None; original_rack = None
                                        selected_square = original_selected_square # Restore arrow

                                else: # Enter pressed with no tiles typed
                                     typing = False; selected_square = original_selected_square # Restore arrow

                                # --- Normal Play Finalization (if flagged) ---
                                if play_finalized_normally:
                                    scores[turn-1] += score # Score was calculated above based on final board state
                                    first_play = False
                                    # Draw new tiles
                                    drawn_tiles = [bag.pop() for _ in range(len(word_positions)) if bag]
                                    racks[turn-1].extend(drawn_tiles) # Rack already updated during typing
                                    # Get details for history
                                    final_placed_details = [(p[0], p[1], p[2]) for p in word_positions]
                                    final_main_word_tiles, final_orientation = find_main_word(final_placed_details, tiles)
                                    final_full_word = "".join(t[2] for t in final_main_word_tiles) if final_main_word_tiles else "ERROR"
                                    final_coord = get_coord(typing_start, typing_direction) # Use original start for coord
                                    # Determine word with blanks for history
                                    final_blanks_in_play = set((r,c) for r,c,l in final_placed_details if (r,c) in blanks)
                                    final_word_with_blanks_list = []
                                    if final_main_word_tiles:
                                        for wr, wc, w_letter in final_main_word_tiles:
                                            is_blank_hist = (wr, wc) in final_blanks_in_play
                                            final_word_with_blanks_list.append(w_letter.lower() if is_blank_hist else w_letter.upper())
                                    final_word_with_blanks = "".join(final_word_with_blanks_list)

                                    move_history.append({
                                        'player': turn, 'move_type': 'place', 'rack': original_rack[:], # Rack *before* play
                                        'positions': final_placed_details, # Newly placed tiles only
                                        'blanks': final_blanks_in_play,   # Newly placed blanks only
                                        'score': score, 'word': final_full_word, 'drawn': drawn_tiles,
                                        'coord': final_coord, 'word_with_blanks': final_word_with_blanks, 'is_bingo': is_bingo
                                    })
                                    current_replay_turn = len(move_history)
                                    print(f"Player {turn} played: {final_full_word} at {final_coord} for {score} points")
                                    consecutive_zero_point_turns = 0; pass_count = 0; exchange_count = 0
                                    human_played = True; turn = turn % 2 + 1 # Advance turn
                                    # Reset typing state completely
                                    typing = False; typing_start = None; typing_direction = None; word_positions = []; original_tiles = None; original_rack = None

                            elif event.key == pygame.K_BACKSPACE:
                                if word_positions:
                                    # Remove last placed tile from board and put back on rack
                                    r_rem, c_rem, letter_rem = word_positions.pop()
                                    tiles[r_rem][c_rem] = ''
                                    if (r_rem, c_rem) in blanks: # Was it a blank?
                                        blanks.remove((r_rem, c_rem))
                                        racks[turn-1].append(' ')
                                    else: # It was a regular tile
                                        racks[turn-1].append(letter_rem)
                                    # Move cursor back, skipping over existing tiles
                                    if typing_direction == "right":
                                        current_c = c_rem # Move cursor to the now empty square
                                        # Now check if the square *before* that had an existing tile
                                        while current_c > 0 and original_tiles[current_r][current_c - 1]:
                                            current_c -= 1 # Keep moving back if original was filled
                                    elif typing_direction == "down":
                                        current_r = r_rem # Move cursor to the now empty square
                                        # Now check if the square *above* that had an existing tile
                                        while current_r > 0 and original_tiles[current_r - 1][current_c]:
                                            current_r -= 1 # Keep moving back if original was filled
                                    # If backspace removes the very first typed letter, reset cursor to start
                                    if not word_positions:
                                         current_r, current_c = typing_start
                                else: # Backspace when no letters typed yet - cancel typing
                                     typing = False; selected_square = original_selected_square; original_tiles = None; original_rack = None
                            elif event.key == pygame.K_ESCAPE: # Cancel typing
                                 if original_tiles and original_rack: # Revert board/rack
                                     for r_wp, c_wp, _ in word_positions: tiles[r_wp][c_wp] = original_tiles[r_wp][c_wp]
                                     racks[turn-1] = original_rack[:]
                                     blanks_to_remove = set((r_wp, c_wp) for r_wp, c_wp, _ in word_positions if (r_wp, c_wp) in blanks); blanks.difference_update(blanks_to_remove)
                                 typing = False; typing_start = None; typing_direction = None; word_positions = []; original_tiles = None; original_rack = None
                                 selected_square = original_selected_square # Restore arrow
                            elif event.unicode.isalpha(): # Type next letter
                                letter = event.unicode.upper()
                                # Check if cursor is on a valid empty square
                                if 0 <= current_r < GRID_SIZE and 0 <= current_c < GRID_SIZE and not tiles[current_r][current_c]:
                                    placed = False
                                    if letter in racks[turn-1]:
                                        tiles[current_r][current_c] = letter
                                        racks[turn-1].remove(letter)
                                        word_positions.append((current_r, current_c, letter))
                                        placed = True
                                    elif ' ' in racks[turn-1]: # Use blank
                                        tiles[current_r][current_c] = letter
                                        racks[turn-1].remove(' ')
                                        blanks.add((current_r, current_c))
                                        word_positions.append((current_r, current_c, letter))
                                        placed = True

                                    if placed: # Advance cursor
                                        if typing_direction == "right":
                                            current_c += 1
                                            while current_c < GRID_SIZE and tiles[current_r][current_c]:
                                                current_c += 1
                                        elif typing_direction == "down":
                                            current_r += 1
                                            while current_r < GRID_SIZE and tiles[current_r][current_c]:
                                                current_r += 1
                                        current_r = min(current_r, GRID_SIZE - 1)
                                        current_c = min(current_c, GRID_SIZE - 1)
                                else:
                                     print("Cannot type here (occupied or off-board).")


            # --- Game Over Check ---
            if not replay_mode and not game_over_state and practice_mode != "eight_letter":
                game_ended = False; reason = ""
                # Condition 1: Bag empty and one player has no tiles
                if not bag and (not racks[0] or not racks[1]):
                    game_ended = True; reason = "Bag empty & rack empty"
                # Condition 2: Six consecutive zero-point turns (3 passes/exchanges by each player)
                elif consecutive_zero_point_turns >= 6:
                    game_ended = True; reason = "Six Consecutive Zero-Point Turns"

                if game_ended:
                    print(f"Game over triggered: {reason}")
                    # Calculate score adjustments
                    rack_values = [sum(TILE_DISTRIBUTION[tile][1] for tile in rack if tile != ' ') for rack in racks]
                    final_scores = list(scores) # Copy current scores
                    p1_out = not racks[0] and not bag
                    p2_out = not racks[1] and not bag

                    if p1_out: # Player 1 went out
                        final_scores[0] += rack_values[1] # Add P2's remaining value to P1
                        final_scores[1] -= rack_values[1] # Subtract P2's remaining value from P2
                    elif p2_out: # Player 2 went out
                        final_scores[1] += rack_values[0] # Add P1's remaining value to P2
                        final_scores[0] -= rack_values[0] # Subtract P1's remaining value from P1
                    else: # Game ended by passes/exchanges, both players lose value of their rack
                        final_scores[0] -= rack_values[0]
                        final_scores[1] -= rack_values[1]

                    game_over_state = True
                    # Reset UI states
                    exchanging = False; hinting = False; showing_all_words = False; dropdown_open = False
                    typing = False; selected_square = None; dragged_tile = None
                    # Center dialog
                    dialog_x = (WINDOW_WIDTH - DIALOG_WIDTH) // 2; dialog_y = (WINDOW_HEIGHT - DIALOG_HEIGHT) // 2


            # --- Drawing Logic ---
            screen.fill(WHITE)
            # Determine state to display (replay vs live)
            if replay_mode:
                if 0 <= current_replay_turn <= len(move_history):
                    # Get state, racks will be sorted by get_replay_state
                    tiles_to_display, blanks_to_display, scores_to_display, racks_to_display = get_replay_state(current_replay_turn, initial_racks)
                    # Determine whose turn it *is* based on the *last* move made
                    turn_to_display = 1 if current_replay_turn == 0 else (move_history[current_replay_turn - 1]['player'] % 2 + 1)
                else: # Should not happen, but default to start
                    tiles_to_display, blanks_to_display, scores_to_display, racks_to_display = get_replay_state(0, initial_racks)
                    turn_to_display = 1
            else: # Live game
                tiles_to_display, blanks_to_display, racks_to_display = tiles, blanks, racks
                scores_to_display = final_scores if game_over_state else scores
                turn_to_display = turn

            # Draw Board and Tiles
            for r in range(GRID_SIZE):
                for c in range(GRID_SIZE):
                    pygame.draw.rect(screen, board[r][c], (40 + c * SQUARE_SIZE, 40 + r * SQUARE_SIZE, SQUARE_SIZE, SQUARE_SIZE)) # Draw board color
                    pygame.draw.rect(screen, BLACK, (40 + c * SQUARE_SIZE, 40 + r * SQUARE_SIZE, SQUARE_SIZE, SQUARE_SIZE), 1) # Draw grid line
                    if tiles_to_display[r][c]: # If there's a tile
                        tile_char = tiles_to_display[r][c]
                        is_blank_on_board = (r, c) in blanks_to_display
                        if is_blank_on_board: # Draw blank as black circle with letter
                            center = (40 + c * SQUARE_SIZE + SQUARE_SIZE // 2, 40 + r * SQUARE_SIZE + SQUARE_SIZE // 2)
                            radius = SQUARE_SIZE // 2 - 3
                            pygame.draw.circle(screen, BLACK, center, radius)
                            text_surf = font.render(tile_char, True, WHITE) # White letter on black
                            text_rect = text_surf.get_rect(center=center)
                            screen.blit(text_surf, text_rect)
                        else: # Draw regular tile
                            tile_rect = pygame.Rect(40 + c * SQUARE_SIZE + 2, 40 + r * SQUARE_SIZE + 2, SQUARE_SIZE - 4, SQUARE_SIZE - 4)
                            pygame.draw.rect(screen, GREEN, tile_rect)
                            text_surf = font.render(tile_char, True, BLACK)
                            text_rect = text_surf.get_rect(center=tile_rect.center)
                            screen.blit(text_surf, text_rect)

            # Highlight last played tiles in replay
            if replay_mode and current_replay_turn > 0:
                 last_move_data = move_history[current_replay_turn - 1]
                 if last_move_data['move_type'] == 'place':
                    # Highlight the squares corresponding to 'positions' in the move data
                    for r_hist, c_hist, _ in last_move_data.get('positions', []):
                        if 0 <= r_hist < GRID_SIZE and 0 <= c_hist < GRID_SIZE:
                             pygame.draw.rect(screen, YELLOW, (40 + c_hist * SQUARE_SIZE, 40 + r_hist * SQUARE_SIZE, SQUARE_SIZE, SQUARE_SIZE), 3) # Highlight border

            # Draw Labels
            for r in range(GRID_SIZE): row_label = ui_font.render(str(r + 1), True, BLACK); screen.blit(row_label, (10, 40 + r * SQUARE_SIZE + (SQUARE_SIZE // 2 - row_label.get_height() // 2)))
            for c in range(GRID_SIZE): col_label = ui_font.render(LETTERS[c], True, BLACK); screen.blit(col_label, (40 + c * SQUARE_SIZE + (SQUARE_SIZE // 2 - col_label.get_width() // 2), 10))

            # Draw Racks (racks_to_display are already sorted in replay mode by get_replay_state)
            p1_rack_to_draw = racks_to_display[0] if len(racks_to_display) > 0 else []
            p1_alpha_rect, p1_rand_rect, _, _ = draw_rack(1, p1_rack_to_draw, scores_to_display, turn_to_display, player_names, dragged_tile if dragged_tile and dragged_tile[0] == 1 else None, drag_pos)
            p2_alpha_rect, p2_rand_rect = None, None
            if practice_mode != "eight_letter":
                 p2_rack_to_draw = racks_to_display[1] if len(racks_to_display) > 1 else []
                 p2_alpha_rect, p2_rand_rect, _, _ = draw_rack(2, p2_rack_to_draw, scores_to_display, turn_to_display, player_names, dragged_tile if dragged_tile and dragged_tile[0] == 2 else None, drag_pos)

            # Draw Remaining Tiles (skip in 8-letter practice)
            if practice_mode != "eight_letter":
                current_player_index = turn_to_display - 1
                if 0 <= current_player_index < len(racks_to_display):
                    # Show remaining tiles based on current state if not replay
                    if not replay_mode:
                         remaining = get_remaining_tiles(racks_to_display[current_player_index], tiles_to_display, blanks_to_display)
                         draw_remaining_tiles(remaining, turn_to_display)
                    # else: Consider showing full initial bag count or skipping in replay?

            # Draw UI Elements (Options, Suggest, etc.)
            options_rect, dropdown_rects = draw_options_menu(turn_to_display, dropdown_open, len(bag))
            suggest_rect = None; hint_rect = None # Reset rects
            if not replay_mode:
                 suggest_rect = draw_suggest_button()
                 # Draw Hint button only if paused for power tile practice
                 if paused_for_power_tile and suggest_rect:
                      hint_x = suggest_rect.x
                      hint_y = suggest_rect.y + suggest_rect.height + BUTTON_GAP
                      hint_rect = pygame.Rect(hint_x, hint_y, OPTIONS_WIDTH, OPTIONS_HEIGHT)
                      hover = hint_rect.collidepoint(pygame.mouse.get_pos())
                      color = BUTTON_HOVER if hover else BUTTON_COLOR
                      pygame.draw.rect(screen, color, hint_rect)
                      hint_text = button_font.render("Hint", True, BLACK)
                      hint_text_rect = hint_text.get_rect(center=hint_rect.center)
                      screen.blit(hint_text, hint_text_rect)

            # Draw Scoreboard
            history_to_draw = move_history[:current_replay_turn] if replay_mode else move_history
            is_final_turn_in_replay = replay_mode and current_replay_turn == len(move_history)
            draw_scoreboard(screen, history_to_draw, scroll_offset, scores_to_display, is_ai, final_scores=final_scores, game_over_state=game_over_state or is_final_turn_in_replay)

            # Draw Typing Arrow or Cursor
            if selected_square and not typing: draw_arrow(selected_square[0], selected_square[1], selected_square[2])
            elif typing:
                 if current_r is not None and current_c is not None:
                     # Draw blinking cursor at the next typing position
                     cursor_x = 40 + current_c * SQUARE_SIZE + SQUARE_SIZE // 2
                     cursor_y = 40 + current_r * SQUARE_SIZE + SQUARE_SIZE - 5 # Bottom of square
                     if int(time.time() * 2) % 2 == 0: # Blink effect
                          pygame.draw.line(screen, BLACK, (cursor_x - 5, cursor_y), (cursor_x + 5, cursor_y), 2)

            # Draw Dialogs (Exchange, Hint, All Words, Practice End)
            if exchanging: tile_rects, exchange_button_rect, cancel_button_rect = draw_exchange_dialog(racks[turn-1], selected_tiles)
            elif hinting: hint_rects, play_button_rect, ok_button_rect, all_words_button_rect = draw_hint_dialog(hint_moves, selected_hint_index)
            elif showing_all_words:
                 moves_for_all = practice_target_moves if practice_mode == "eight_letter" else all_moves
                 all_words_rects, all_words_play_rect, all_words_ok_rect = draw_all_words_dialog(moves_for_all, selected_hint_index, scroll_offset)
            elif showing_practice_end_dialog: practice_play_again_rect, practice_main_menu_rect, practice_quit_rect = draw_practice_end_dialog(practice_end_message)

            # Draw Replay Controls
            if replay_mode:
                replay_controls = [(replay_start_rect, "start"), (replay_prev_rect, "prev"), (replay_next_rect, "next"), (replay_end_rect, "end")]
                for rect, icon_type in replay_controls:
                    hover = rect.collidepoint(pygame.mouse.get_pos())
                    color = BUTTON_HOVER if hover else BUTTON_COLOR
                    pygame.draw.rect(screen, color, rect)
                    draw_replay_icon(screen, rect, icon_type)

            # Draw Game Over Dialog / Stats
            if game_over_state:
                if final_scores is not None: save_rect, quit_rect, replay_rect, play_again_rect, stats_rect = draw_game_over_dialog(dialog_x, dialog_y, final_scores, reason, player_names)
                if showing_stats and final_scores:
                     # Draw stats dialog slightly offset from game over dialog
                     stats_ok_button_rect = draw_stats_dialog(dialog_x + 20, dialog_y + 20, player_names, final_scores, tiles)

            pygame.display.flip() # Update the full display


        # --- End of Main Game Loop ---
        print("--- main(): Exited main game loop. ---")
        if return_to_mode_selection:
            print("--- main(): Returning to mode selection... ---")
            main_called = False # Reset flag to allow re-initialization
            # Reset key global states before restarting main
            GADDAG_STRUCTURE = None # Force reload if needed
            # DAWG should persist
            bag = []
            move_history = []
            initial_racks = []
            main() # Call main again
        else:
            print("--- main(): Quitting pygame and exiting. ---")
            pygame.quit(); sys.exit()

# --- Program Entry Point ---
if __name__ == "__main__":
    print("--- Script execution started (__name__ == '__main__') ---")
    main_called = False # Ensure flag is reset before first call
    main()
