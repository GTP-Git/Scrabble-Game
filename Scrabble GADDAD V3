

# python
#Stable 13APR24

# Part 1


import pygame
import random
import math
import sys
import time
import pickle
import os
import datetime 
from itertools import permutations, product
from collections import Counter

# --- GADDAG Node Definition (Add this to Scrabble Game.py) ---
class GaddagNode:
    """Represents a node in the GADDAG."""
    __slots__ = ['children', 'is_terminal'] # Memory optimization

    def __init__(self):
        self.children = {}  # Dictionary mapping letter -> GaddagNode
        self.is_terminal = False # True if a path ending here is a valid word/subword

# --- GADDAG Class Definition (Add this to Scrabble Game.py) ---
class Gaddag:
    """
    Represents the GADDAG data structure.
    This class definition is needed to correctly unpickle the object.
    The actual building happens in gaddag_builder.py.
    """
    SEPARATOR = '>' # Special character used in GADDAG paths

    def __init__(self):
        # The root node will be populated when loading from pickle
        self.root = GaddagNode()

    # No insert method needed here, as we load a pre-built structure.

# Initialize Pygame
pygame.init()
main_called = False # Flag to track if main() has been entered

# Constants
GADDAG_STRUCTURE = None
GRID_SIZE = 15
SQUARE_SIZE = 40
BOARD_SIZE = GRID_SIZE * SQUARE_SIZE
FONT_SIZE = SQUARE_SIZE // 2
TILE_WIDTH = 35
TILE_HEIGHT = 35
TILE_GAP = 5
BUTTON_WIDTH = 100
BUTTON_HEIGHT = 30
BUTTON_GAP = 10
CENTER_SQUARE = (7, 7)
OPTIONS_WIDTH = 100
OPTIONS_HEIGHT = 30
DROPDOWN_HEIGHT = 90
OPTIONS_Y = BOARD_SIZE + 60  # Adjusted from +40 to align with shifted UI
DOUBLE_CLICK_TIME = 300
SECOND_CLICK_TIME = 500  # Time window for second click
ALL_WORDS_DIALOG_WIDTH = 750
ALL_WORDS_DIALOG_HEIGHT = 600
SCROLL_SPEED = 20

# Dialog dimensions for game over dialog
DIALOG_WIDTH = 480
DIALOG_HEIGHT = 250
LETTERS = "ABCDEFGHIJKLMNO"  # For column labels

# Get screen resolution
display_info = pygame.display.Info()
# Set window size to fit within screen resolution (with padding for borders)
WINDOW_WIDTH = min(1400, display_info.current_w - 50)  # 50 pixels padding
WINDOW_HEIGHT = min(900, display_info.current_h - 50)  # 50 pixels padding

# Colors
WHITE = (255, 255, 255)
BLACK = (0, 0, 0)
RED = (255, 100, 100)
PINK = (255, 182, 193)
BLUE = (0, 102, 204)  # Darkened from (173, 216, 230) for TL
LIGHT_BLUE = (135, 206, 250)
HIGHLIGHT_BLUE = (191, 238, 255)
YELLOW = (255, 255, 153)
GRAY = (200, 200, 200)
GREEN = (144, 238, 144)
DARK_GREEN = (100, 200, 100)
BUTTON_COLOR = (180, 180, 180)
BUTTON_HOVER = (220, 220, 220)
TURN_INDICATOR_COLOR = (255, 215, 0)
DIALOG_COLOR = (150, 150, 150)
DROPDOWN_COLOR = (200, 200, 200)
SELECTED_TILE_COLOR = (255, 165, 0)
GRAYED_OUT_COLOR = (100, 100, 100)
ARROW_COLOR = (0, 0, 255)
HINT_NORMAL_COLOR = (220, 220, 220)
HINT_SELECTED_COLOR = (180, 180, 255)

# Setup display and font
screen = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))
pygame.display.set_caption("Scrabble Game")
font = pygame.font.SysFont("Arial", FONT_SIZE, bold=True)
ui_font = pygame.font.SysFont("Arial", 20)
button_font = pygame.font.SysFont("Arial", 16)
tile_count_font = pygame.font.SysFont("Arial", 14)
dialog_font = pygame.font.SysFont("Arial", 24)

# Tile bag and values (moved up to be defined before trie)
TILE_DISTRIBUTION = {
    'A': (9, 1), 'B': (2, 3), 'C': (2, 3), 'D': (4, 2), 'E': (12, 1), 'F': (2, 4),
    'G': (3, 2), 'H': (2, 4), 'I': (9, 1), 'J': (1, 8), 'K': (1, 5), 'L': (4, 1),
    'M': (2, 3), 'N': (6, 1), 'O': (8, 1), 'P': (2, 3), 'Q': (1, 10), 'R': (6, 1),
    'S': (4, 1), 'T': (6, 1), 'U': (4, 1), 'V': (2, 4), 'W': (2, 4), 'X': (1, 8),
    'Y': (2, 4), 'Z': (1, 10), ' ': (2, 0)
}
# Global bag - initialized properly in main() or practice setup
bag = []

POWER_TILES = {'J', 'Q', 'X', 'Z'}

# Global game state variables (will be initialized/reset in main)
board = None
tiles = None
racks = None
blanks = None
scores = None
turn = 1
first_play = True
game_mode = None
is_ai = None
practice_mode = None # Added to track practice modes like "eight_letter", "power_tiles"
move_history = []
replay_mode = False
current_replay_turn = 0
last_word = ""
last_score = 0
last_start = None
last_direction = None

def draw_checkbox(screen, x, y, checked):
    pygame.draw.rect(screen, BLACK, (x, y, 20, 20), 1)
    if checked:
        pygame.draw.line(screen, BLACK, (x+2, y+2), (x+18, y+18), 2)
        pygame.draw.line(screen, BLACK, (x+18, y+2), (x+2, y+18), 2)


# --- GCG Handling ---
def save_game_to_gcg(player_names, move_history, initial_racks, final_scores):
    """Save the game to GCG format using move_history directly."""
    gcg_lines = [
        "#",
        f"#player1 {player_names[0]}",
        f"#player2 {player_names[1]}"
    ]
    cumulative_scores = [0, 0]

    for move in move_history:
        player = move['player'] - 1  # 0-based index
        rack = ''.join(sorted(tile if tile != ' ' else '?' for tile in move['rack']))

        if move['move_type'] == 'place':
            # Use the stored full word with blanks
            word_with_blanks = move.get('word_with_blanks', move.get('word','').upper()) # Use getter for safety
            score = move['score']
            cumulative_scores[player] += score
            gcg_lines.append(
                f">{player_names[player]}: {rack} {move['coord']} {word_with_blanks} +{score} {cumulative_scores[player]}"
            )
        elif move['move_type'] == 'exchange':
            exchanged = ''.join(sorted(tile if tile != ' ' else '?' for tile in move.get('exchanged_tiles',[]))) # Use getter
            gcg_lines.append(
                f">{player_names[player]}: {rack} ({exchanged}) +0 {cumulative_scores[player]}"
            )
        elif move['move_type'] == 'pass':
            gcg_lines.append(
                f">{player_names[player]}: {rack} -- +0 {cumulative_scores[player]}"
            )

    gcg_lines.append(f"Final score: {player_names[0]} {final_scores[0]}, {player_names[1]} {final_scores[1]}")

    return '\n'.join(gcg_lines)

# Function to Modify: load_game_from_gcg
# REASON: Added specific try...except blocks around parsing steps
#         to provide more detailed error messages if loading fails.

# Function to Modify: load_game_from_gcg
# REASON: Changed line.split() method and adjusted part indices
#         to correctly parse standard GCG move lines.

# Function to Modify: load_game_from_gcg
# REASON: Implement more robust parsing to handle player names with spaces
#         and correctly identify score/cumulative score from the end.

# Function to Modify: load_game_from_gcg
# REASON: Implement more robust parsing to handle player names with spaces
#         and correctly identify score/cumulative score from the end.

# Function to Modify: load_game_from_gcg
# REASON: Implement more robust parsing by identifying components
#         from the end of the line first, handling player names with spaces.

def load_game_from_gcg(filename):
    """Load a game from a GCG file, returning data to enter replay mode."""
    move_history = []
    player_names = ["Player1", "Player2"]
    final_scores = [0, 0]
    line_num = 0

    try:
        with open(filename, "r") as f:
            for line in f:
                line_num += 1
                line = line.strip()
                if not line or line.startswith("#"): # Skip empty/comments
                    if line.startswith("#player1"):
                        try: player_names[0] = line.split(maxsplit=1)[1]
                        except IndexError: print(f"GCG Load Warning (Line {line_num}): Malformed #player1 line.")
                    elif line.startswith("#player2"):
                        try: player_names[1] = line.split(maxsplit=1)[1]
                        except IndexError: print(f"GCG Load Warning (Line {line_num}): Malformed #player2 line.")
                    continue

                if line.startswith("Final score:"):
                    try:
                        parts = line.split();
                        if len(parts) >= 6: final_scores[0] = int(parts[3].strip(',')); final_scores[1] = int(parts[5])
                        else: raise ValueError("Incorrect number of parts for Final score line")
                    except (IndexError, ValueError) as e: print(f"GCG Load Warning (Line {line_num}): Error parsing final score line: {e}")
                    continue

                if line.startswith(">"):
                    try:
                        parts = line.split() # Split by whitespace
                        if len(parts) < 5: # Minimum parts: >Name: Rack -- +Score CumScore
                            raise ValueError(f"Insufficient parts on move line ({len(parts)})")

                        # --- Robust Parsing Logic ---
                        # 1. Identify parts from the end
                        cumulative_score_str = parts[-1]
                        score_str = parts[-2]
                        # Part before score could be Word, (Exchange), or --
                        third_last_part = parts[-3]

                        # 2. Safely parse scores first
                        try: score = int(score_str[1:]) # Remove initial '+' or '-'
                        except (ValueError, IndexError): raise ValueError(f"Invalid score format '{score_str}'")
                        try: cumulative_score = int(cumulative_score_str)
                        except ValueError: raise ValueError(f"Invalid cumulative score format '{cumulative_score_str}'")

                        # 3. Determine Move Type based on third_last_part
                        move_type = None
                        player_name_parts = []
                        rack_str = ""
                        exchanged_list = []
                        position_str = ""
                        word_played_gcg = ""

                        if third_last_part == "--": # Pass
                            move_type = 'pass'
                            # Structure: > Name(s) : Rack -- +Score CumScore
                            if len(parts) < 5: raise ValueError("Incorrect part count for Pass")
                            rack_str = parts[-4] # Part before -- is Rack
                            player_name_parts = parts[:-4] # All parts before Rack
                        elif third_last_part.startswith("(") and third_last_part.endswith(")"): # Exchange
                            move_type = 'exchange'
                            # Structure: > Name(s) : Rack (Exch) +Score CumScore
                            if len(parts) < 5: raise ValueError("Incorrect part count for Exchange")
                            rack_str = parts[-4] # Part before (Exch) is Rack
                            player_name_parts = parts[:-4] # All parts before Rack
                            exchanged_gcg = third_last_part[1:-1]
                            exchanged_list = [(' ' if char == '?' else char.upper()) for char in exchanged_gcg]
                        else: # Place
                            move_type = 'place'
                            # Structure: > Name(s) : Rack Coord Word +Score CumScore
                            if len(parts) < 6: raise ValueError("Incorrect part count for Place")
                            word_played_gcg = third_last_part # Part before score is Word
                            position_str = parts[-4] # Part before Word is Coord
                            rack_str = parts[-5] # Part before Coord is Rack
                            player_name_parts = parts[:-5] # All parts before Rack

                        # 4. Reconstruct Player Name
                        if not player_name_parts or not player_name_parts[0].startswith(">") or not player_name_parts[-1].endswith(":"):
                            raise ValueError(f"Could not reconstruct player name from parts: {player_name_parts}")
                        player_name_full = " ".join(player_name_parts)
                        player_name = player_name_full[1:-1] # Remove '>' and ':'
                        player = 1 if player_name == player_names[0] else 2
                        # --- End Robust Parsing Logic ---

                        # Append to move_history based on type
                        if move_type == 'pass':
                            move_history.append({
                                'player': player, 'move_type': 'pass', 'score': score,
                                'word': '', 'coord': ''
                            })
                        elif move_type == 'exchange':
                            move_history.append({
                                'player': player, 'move_type': 'exchange', 'exchanged_tiles': exchanged_list,
                                'score': score, 'word': '', 'coord': ''
                            })
                        elif move_type == 'place':
                            # Parse coordinate
                            coord_parse_result = parse_coord(position_str)
                            if coord_parse_result is None or coord_parse_result[0] is None:
                                raise ValueError(f"Invalid coordinate format '{position_str}'")
                            (row, col), direction = coord_parse_result

                            # Reconstruct positions and blanks from the GCG word
                            positions = []; blanks = set()
                            current_r_gcg, current_c_gcg = row, col
                            for i, letter_gcg in enumerate(word_played_gcg):
                                r_place = current_r_gcg if direction == "right" else current_r_gcg + i
                                c_place = current_c_gcg + i if direction == "right" else current_c_gcg
                                if not (0 <= r_place < GRID_SIZE and 0 <= c_place < GRID_SIZE):
                                    raise ValueError(f"Word placement out of bounds: '{word_played_gcg}' at {position_str}")
                                letter_upper = letter_gcg.upper()
                                positions.append((r_place, c_place, letter_upper))
                                if letter_gcg.islower(): blanks.add((r_place, c_place))

                            move_history.append({
                                'player': player, 'move_type': 'place', 'positions': positions,
                                'blanks': blanks, 'score': score, 'word': word_played_gcg.upper(),
                                'start': (row, col), 'direction': direction, 'coord': position_str
                            })

                    except Exception as e:
                        print(f"GCG Load Error (Line {line_num}): Failed to parse move line.")
                        print(f"  Line content: '{line}'")
                        print(f"  Error details: {type(e).__name__}: {e}")
                        raise ValueError(f"Error parsing GCG line {line_num}: {e}") from e

                else:
                    print(f"GCG Load Warning (Line {line_num}): Skipping unrecognized line format: '{line}'")

    except FileNotFoundError:
        print(f"GCG Load Error: File not found '{filename}'")
        raise
    except Exception as e:
        print(f"GCG Load Error: An unexpected error occurred reading file '{filename}' near line {line_num}.")
        print(f"  Error details: {type(e).__name__}: {e}")
        raise

    return player_names, move_history, final_scores



# New helper function to create a standard Scrabble bag
def create_standard_bag():
    """Creates and returns a standard Scrabble tile bag list."""
    bag = [letter for letter, (count, _) in TILE_DISTRIBUTION.items() for _ in range(count)]
    return bag

# New function to simulate game state for replay from GCG history
def simulate_game_up_to(target_turn_idx, move_history_loaded, initial_shuffled_bag):
    """
    Simulates a game turn-by-turn up to a target index using loaded move history
    (which lacks 'drawn' info) and an initial shuffled bag state. Handles initial draws.

    Args:
        target_turn_idx (int): The 0-based index of the turn *after* which the state is needed
                               (e.g., 0 for initial state, 1 for state after move 0).
        move_history_loaded (list): The move history loaded from GCG (lacks 'drawn').
        initial_shuffled_bag (list): A list representing the shuffled bag at the very start of the game.

    Returns:
        tuple: (tiles_state, blanks_state, scores_state, racks_state) representing the
               game state after target_turn_idx-1 moves have been applied.
               Racks are sorted alphabetically before returning for display.
    """
    # Initialize game state variables
    tiles_state = [['' for _ in range(GRID_SIZE)] for _ in range(GRID_SIZE)]
    blanks_state = set()
    scores_state = [0, 0]
    racks_state = [[], []]
    # IMPORTANT: Use a copy of the initial bag for the simulation run to avoid modifying the original
    bag_state = initial_shuffled_bag[:]

    # --- Simulate Drawing Initial Racks ---
    # GCG doesn't store initial racks, so simulate drawing them from the shuffled bag.
    try:
        for _ in range(7):
            if bag_state: racks_state[0].append(bag_state.pop())
            else: raise IndexError("Bag empty during initial draw for P1")
        for _ in range(7):
            if bag_state: racks_state[1].append(bag_state.pop())
            else: raise IndexError("Bag empty during initial draw for P2")
    except IndexError as e:
        print(f"Replay Simulation Error: {e}")
        # Return initial empty state as fallback if bag runs out unexpectedly
        return tiles_state, blanks_state, scores_state, racks_state

    # Apply moves sequentially up to the target turn index (0 to target_turn_idx-1)
    for i in range(target_turn_idx):
        if i >= len(move_history_loaded):
            # Target turn index is beyond the loaded history length
            print(f"Replay Sim Info: Reached end of available history at move index {i} before target index {target_turn_idx}.")
            break

        move = move_history_loaded[i]
        player_idx = move.get('player')
        if player_idx not in [1, 2]:
            print(f"Replay Sim Warning: Invalid player index {player_idx} in loaded move {i}. Skipping move.")
            continue
        player_idx -= 1 # Convert to 0-based index

        # Get a copy of the current rack state for modification
        rack_after_move = racks_state[player_idx][:]

        tiles_removed_count = 0 # Track tiles removed in this turn to know how many to draw

        move_type = move.get('move_type')

        if move_type == 'place':
            # Retrieve necessary info from the loaded move dictionary
            positions = move.get('positions', []) # These are the primary word tiles from GCG
            blanks_in_move = move.get('blanks', set()) # Blanks placed in *this* specific move

            # Identify newly placed tiles on the board based on GCG positions vs current board state
            for r, c, letter in positions:
                 # Check if the square was empty *before* this simulated move
                 is_newly_placed_sim = (0 <= r < GRID_SIZE and 0 <= c < GRID_SIZE and not tiles_state[r][c])

                 # Place tile on simulated board state
                 if 0 <= r < GRID_SIZE and 0 <= c < GRID_SIZE:
                     tiles_state[r][c] = letter
                     if (r, c) in blanks_in_move:
                         blanks_state.add((r, c))
                 else:
                     # Log warning but continue simulation if possible
                     print(f"Replay Sim Warning: Invalid position ({r},{c}) in loaded move {i}")
                     continue

                 # If it was newly placed in this simulation step, remove from simulated rack
                 if is_newly_placed_sim:
                     tiles_removed_count += 1
                     if (r,c) in blanks_in_move: # If this placement used a blank
                         if ' ' in rack_after_move:
                             rack_after_move.remove(' ')
                         else:
                             # Log warning if blank wasn't found (state inconsistency)
                             print(f"Replay Sim Warning: Tried to remove blank from simulated rack for move {i} ({r},{c}), but not found.")
                     else: # If this placement used a regular tile
                         if letter in rack_after_move:
                             rack_after_move.remove(letter)
                         else:
                             # Log warning if tile wasn't found (state inconsistency)
                             print(f"Replay Sim Warning: Tried to remove tile '{letter}' from simulated rack for move {i} ({r},{c}), but not found.")

            # Update score based on the score recorded in the GCG move
            scores_state[player_idx] += move.get('score', 0)

        elif move_type == 'exchange':
            exchanged_gcg = move.get('exchanged_tiles', []) # Tiles recorded in GCG (using '?')
            for tile_gcg in exchanged_gcg:
                 if tile_gcg == '?': # GCG standard for blank
                      tile_to_remove = ' '
                 else:
                      tile_to_remove = tile_gcg.upper() # Ensure consistency

                 if tile_to_remove in rack_after_move:
                      rack_after_move.remove(tile_to_remove)
                      tiles_removed_count += 1
                 else:
                      # Log warning if tile/blank wasn't found (state inconsistency)
                      print(f"Replay Sim Warning: Tried to remove exchanged GCG tile '{tile_gcg}' (as '{tile_to_remove}') from simulated rack for move {i}, but not found.")
            # Score doesn't change for exchange

        elif move_type == 'pass':
            # No change to board, score, or rack content needed for simulation state
            tiles_removed_count = 0
            # Score doesn't change for pass

        else:
             print(f"Replay Sim Warning: Unknown move_type '{move_type}' in loaded move {i}. Skipping state update for move.")
             continue # Skip draw calculation if move type is unknown

        # --- Simulate Drawing New Tiles ---
        # Draw tiles from the simulated bag based on how many were removed/exchanged
        num_to_draw = tiles_removed_count
        drawn_simulated = []
        for _ in range(num_to_draw):
             if bag_state: # Check if bag is not empty
                 drawn_simulated.append(bag_state.pop())
             else:
                 # Bag ran out during simulated draw
                 print(f"Replay Sim Info: Simulated bag ran out while drawing for move {i}.")
                 break # Stop drawing if bag runs out
        rack_after_move.extend(drawn_simulated) # Add the simulated drawn tiles
        racks_state[player_idx] = rack_after_move # Update the persistent rack state

    # Sort final racks alphabetically before returning for display consistency
    for rack in racks_state:
        rack.sort()

    # Return the simulated state *after* target_turn_idx-1 moves have been applied
    return tiles_state, blanks_state, scores_state, racks_state


# --- Trie/DAWG Setup ---
class TrieNode: # Keeping simple Trie for now, can replace with minimized DAWG later
    def __init__(self):
        self.children = {}
        self.is_end = False

class Dawg: # Renaming our existing Trie to Dawg for conceptual clarity
    def __init__(self):
        self.root = TrieNode()

    def insert(self, word):
        node = self.root
        for char in word:
            if char not in node.children:
                node.children[char] = TrieNode()
            node = node.children[char]
        node.is_end = True

    def search(self, word):
        """Check if a word exists in the DAWG."""
        node = self.root
        for char in word:
            if char not in node.children:
                return False
            node = node.children[char]
        return node.is_end

# Load the DAWG with words from "All Words 2023.txt"
DAWG = Dawg()
try:
    # Ensure the path is correct or adjust as needed
    with open("All Words 2023.txt", "r") as f:
        for word in (w.strip().upper() for w in f):
            if len(word) > 1: # Optionally filter out single-letter words if not needed
                DAWG.insert(word)
    print("DAWG loaded successfully.")
except FileNotFoundError:
    print("Error: 'All Words 2023.txt' not found. Word validation will not work.")


# --- Mode Selection Constants ---
MODE_HVH = "Human vs Human"
MODE_HVA = "Human vs AI"
MODE_AVA = "AI vs AI"

# --- Replay Button Positions ---
REPLAY_BUTTON_Y = OPTIONS_Y + OPTIONS_HEIGHT + 10
REPLAY_BUTTON_WIDTH = 50
REPLAY_BUTTON_HEIGHT = 30
REPLAY_BUTTON_GAP = 10
replay_start_rect = pygame.Rect(10, REPLAY_BUTTON_Y, REPLAY_BUTTON_WIDTH, REPLAY_BUTTON_HEIGHT)
replay_prev_rect = pygame.Rect(10 + REPLAY_BUTTON_WIDTH + REPLAY_BUTTON_GAP, REPLAY_BUTTON_Y, REPLAY_BUTTON_WIDTH, REPLAY_BUTTON_HEIGHT)
replay_next_rect = pygame.Rect(10 + 2 * (REPLAY_BUTTON_WIDTH + REPLAY_BUTTON_GAP), REPLAY_BUTTON_Y, REPLAY_BUTTON_WIDTH, REPLAY_BUTTON_HEIGHT)
replay_end_rect = pygame.Rect(10 + 3 * (REPLAY_BUTTON_WIDTH + REPLAY_BUTTON_GAP), REPLAY_BUTTON_Y, REPLAY_BUTTON_WIDTH, REPLAY_BUTTON_HEIGHT)


# --- Coordinate Handling ---
def get_coord(start, direction):
    row, col = start
    if direction == "right":
        return f"{row + 1}{LETTERS[col]}"
    else:  # "down"
        return f"{LETTERS[col]}{row + 1}"

def parse_coord(coord):
    """Parse a GCG coordinate (e.g., '8H' or 'H8') into (row, col) and direction."""
    if not coord: return None, None # Handle empty coord
    if coord[0].isalpha():  # Vertical: e.g., H8 or H10
        col_char = coord[0]
        row_str = coord[1:]
        if col_char not in LETTERS or not row_str.isdigit(): return None, None
        col = LETTERS.index(col_char)
        row = int(row_str) - 1
        direction = "down"
    else:  # Horizontal: e.g., 8H or 10A
        i = 0
        while i < len(coord) and coord[i].isdigit(): i += 1
        row_str = coord[:i]
        col_char = coord[i:]
        if not row_str.isdigit() or len(col_char) != 1 or col_char not in LETTERS: return None, None
        row = int(row_str) - 1
        col = LETTERS.index(col_char)
        direction = "right"

    if not (0 <= row < GRID_SIZE and 0 <= col < GRID_SIZE): return None, None # Bounds check
    return (row, col), direction

# --- Board Creation ---
def create_board():
    """Initialize the Scrabble board with special squares and labels."""
    board = [[WHITE for _ in range(GRID_SIZE)] for _ in range(GRID_SIZE)]
    labels = [['' for _ in range(GRID_SIZE)] for _ in range(GRID_SIZE)]
    tiles = [['' for _ in range(GRID_SIZE)] for _ in range(GRID_SIZE)]

    tw = [(0, 0), (0, 7), (0, 14), (7, 0), (7, 14), (14, 0), (14, 7), (14, 14)]
    dw = [(1, 1), (2, 2), (3, 3), (4, 4), (10, 10), (11, 11), (12, 12), (13, 13),
          (1, 13), (2, 12), (3, 11), (4, 10), (10, 4), (11, 3), (12, 2), (13, 1)]
    tl = [(1, 5), (1, 9), (5, 1), (5, 5), (5, 9), (5, 13), (9, 1), (9, 5),
          (9, 9), (9, 13), (13, 5), (13, 9)]
    dl = [(0, 3), (0, 11), (2, 6), (2, 8), (3, 0), (3, 7), (3, 14), (6, 2),
          (6, 6), (6, 8), (6, 12), (7, 3), (7, 11), (8, 2), (8, 6), (8, 8),
          (8, 12), (11, 0), (11, 7), (11, 14), (12, 6), (12, 8), (14, 3), (14, 11)]

    for r, c in tw: board[r][c] = RED
    for r, c in dw: board[r][c] = PINK
    for r, c in tl: board[r][c] = BLUE
    for r, c in dl: board[r][c] = LIGHT_BLUE
    board[7][7] = PINK # Center square

    return board, labels, tiles

# --- Drawing Functions ---
def draw_rack(player, rack, scores, turn, player_names, dragged_tile=None, drag_pos=None, display_scores=None):
    """Draw a player's rack with tiles, scores, and buttons."""
    global practice_mode # Access global practice_mode
    if not rack: return None, None
    if display_scores is None: display_scores = scores
    if practice_mode == "eight_letter" and player == 2: return None, None # Don't draw P2 rack

    rack_width = 7 * (TILE_WIDTH + TILE_GAP) - TILE_GAP
    # Calculate the rightmost extent of the replay buttons area
    # Replay buttons start at x=10, width=50, gap=10. 4 buttons total.
    replay_area_end_x = 10 + 4 * (REPLAY_BUTTON_WIDTH + REPLAY_BUTTON_GAP) # 10 + 4*(50+10) = 250
    # Minimum start x for the rack, considering replay buttons and star indicator offset (star is at start_x - 20)
    min_rack_start_x = replay_area_end_x + BUTTON_GAP + 20 # 250 + 10 + 20 = 280
    # Try to center the rack, but ensure it starts after the minimum x to avoid overlap
    start_x = max(min_rack_start_x, (BOARD_SIZE - rack_width) // 2)

    rack_y = BOARD_SIZE + 80 if player == 1 else BOARD_SIZE + 150

    if turn == player and (practice_mode != "eight_letter" or player == 1): # Draw turn indicator
        # Star indicator position depends on the calculated start_x
        center_x = start_x - 20; center_y = rack_y + TILE_HEIGHT // 2; radius = 10; points = []
        for i in range(10): angle = i * math.pi / 5; r = radius if i % 2 == 0 else radius / 2; x = center_x + r * math.cos(angle); y = center_y + r * math.sin(angle); points.append((x, y))
        pygame.draw.polygon(screen, TURN_INDICATOR_COLOR, points)

    for i, tile in enumerate(rack): # Draw tiles
        tile_x = start_x + i * (TILE_WIDTH + TILE_GAP)
        if dragged_tile == (player, i) and drag_pos: continue
        if tile == ' ':
            center = (tile_x + TILE_WIDTH // 2, rack_y + TILE_HEIGHT // 2); radius = TILE_WIDTH // 2 - 2
            pygame.draw.circle(screen, BLACK, center, radius); text = font.render('?', True, WHITE)
            text_rect = text.get_rect(center=center); screen.blit(text, text_rect)
        else:
            pygame.draw.rect(screen, GREEN, (tile_x, rack_y, TILE_WIDTH, TILE_HEIGHT)); text = font.render(tile, True, BLACK)
            screen.blit(text, (tile_x + 5, rack_y + 5))

    if dragged_tile and dragged_tile[0] == player and drag_pos: # Draw dragged tile
        tile_x, tile_y = drag_pos
        if 0 <= dragged_tile[1] < len(rack):
            tile = rack[dragged_tile[1]]
            if tile == ' ':
                center = (tile_x, tile_y); radius = TILE_WIDTH // 2 - 2; pygame.draw.circle(screen, BLACK, center, radius)
                text = font.render('?', True, WHITE); text_rect = text.get_rect(center=center); screen.blit(text, text_rect)
            else:
                pygame.draw.rect(screen, GREEN, (tile_x - TILE_WIDTH // 2, tile_y - TILE_HEIGHT // 2, TILE_WIDTH, TILE_HEIGHT))
                text = font.render(tile, True, BLACK); screen.blit(text, (tile_x - TILE_WIDTH // 2 + 5, tile_y - TILE_HEIGHT // 2 + 5))

    button_x = start_x + rack_width + BUTTON_GAP # Draw buttons
    alpha_button_rect = pygame.draw.rect(screen, BUTTON_COLOR, (button_x, rack_y, BUTTON_WIDTH, BUTTON_HEIGHT))
    rand_button_rect = pygame.draw.rect(screen, BUTTON_COLOR, (button_x + BUTTON_WIDTH + BUTTON_GAP, rack_y, BUTTON_WIDTH, BUTTON_HEIGHT))
    alpha_text = button_font.render("Alphabetize", True, BLACK); alpha_rect = alpha_text.get_rect(center=alpha_button_rect.center); screen.blit(alpha_text, alpha_rect)
    rand_text = button_font.render("Randomize", True, BLACK); rand_rect = rand_text.get_rect(center=rand_button_rect.center); screen.blit(rand_text, rand_rect)

    player_idx = player - 1 # Draw score
    if 0 <= player_idx < len(player_names) and 0 <= player_idx < len(display_scores):
        player_name_display = player_names[player_idx] if player_names[player_idx] else f"Player {player}"
        score_text = ui_font.render(f"{player_name_display} Score: {display_scores[player_idx]}", True, BLACK)
        screen.blit(score_text, (start_x, rack_y - 20))
    else: print(f"Warning: Invalid player index {player} for score display.")
    return alpha_button_rect, rand_button_rect

def draw_replay_icon(screen, rect, icon_type):
    """Draw centered replay control icons (arrows) on the buttons."""
    center_x, center_y = rect.center; arrow_size = 8
    if icon_type == "start": pygame.draw.polygon(screen, BLACK, [(center_x + 6, center_y - arrow_size), (center_x - 2, center_y), (center_x + 6, center_y + arrow_size)]); pygame.draw.polygon(screen, BLACK, [(center_x - 2, center_y - arrow_size), (center_x - 10, center_y), (center_x - 2, center_y + arrow_size)])
    elif icon_type == "prev": pygame.draw.polygon(screen, BLACK, [(center_x + 6, center_y - arrow_size), (center_x - 6, center_y), (center_x + 6, center_y + arrow_size)])
    elif icon_type == "next": pygame.draw.polygon(screen, BLACK, [(center_x - 6, center_y - arrow_size), (center_x + 6, center_y), (center_x - 6, center_y + arrow_size)])
    elif icon_type == "end": pygame.draw.polygon(screen, BLACK, [(center_x - 6, center_y - arrow_size), (center_x + 2, center_y), (center_x - 6, center_y + arrow_size)]); pygame.draw.polygon(screen, BLACK, [(center_x + 2, center_y - arrow_size), (center_x + 10, center_y), (center_x + 2, center_y + arrow_size)])

def draw_scoreboard(screen, move_history, scroll_offset, scores, is_ai, final_scores=None, game_over_state=False):
    """Draws the scrollable scoreboard."""
    scoreboard_x = BOARD_SIZE + 275; scoreboard_y = 40; scoreboard_width = max(200, WINDOW_WIDTH - BOARD_SIZE - 20); scoreboard_height = WINDOW_HEIGHT - 80
    if scoreboard_x + scoreboard_width > WINDOW_WIDTH - 10: scoreboard_width = WINDOW_WIDTH - scoreboard_x - 10
    if scoreboard_width < 200: scoreboard_x = WINDOW_WIDTH - 210; scoreboard_width = 200
    scoreboard_surface = pygame.Surface((scoreboard_width, scoreboard_height)); scoreboard_surface.fill(WHITE)
    running_scores = [0, 0]; y_pos = 10 - scroll_offset
    for i, move in enumerate(move_history):
        player_idx = move['player'] - 1; running_scores[player_idx] += move['score']
        player_label = "AI" if 0 <= player_idx < len(is_ai) and is_ai[player_idx] else f"P{move['player']}"
        display_score = running_scores[player_idx]
        if move['move_type'] == 'place': word = move.get('word', 'N/A'); coord = move.get('coord', 'N/A'); text = f"{i+1}: {player_label} - {word} at {coord} (+{move['score']}) Total: {display_score}"
        elif move['move_type'] == 'pass': text = f"{i+1}: {player_label} - Pass (+0) Total: {display_score}"
        elif move['move_type'] == 'exchange': text = f"{i+1}: {player_label} - Exchange (+0) Total: {display_score}"
        else: text = f"{i+1}: {player_label} - Unknown Move Type"
        text_surface = ui_font.render(text, True, BLACK)
        if y_pos < scoreboard_height and y_pos + 20 > 0:
            if (i // 2) % 2 == 0: rect_width = 10 + text_surface.get_width() + 10; highlight_rect = pygame.Rect(0, y_pos, rect_width, 20); pygame.draw.rect(scoreboard_surface, HIGHLIGHT_BLUE, highlight_rect)
            scoreboard_surface.blit(text_surface, (10, y_pos))
        y_pos += 20
    if game_over_state and final_scores is not None:
        y_pos += 20; final_text = f"Final Scores: P1: {final_scores[0]}, P2: {final_scores[1]}"; final_surface = ui_font.render(final_text, True, BLACK)
        if y_pos < scoreboard_height and y_pos + 20 > 0: scoreboard_surface.blit(final_surface, (10, y_pos))
    screen.blit(scoreboard_surface, (scoreboard_x, scoreboard_y))

# End of Part 1 (Includes basic drawing functions)

# Part 2 (Includes word finding, scoring, practice setup, mode selection, options menu)
# find_main_word, find_cross_word, find_all_words_formed (Unchanged from Part 2 provided previously)
def find_main_word(new_tiles, tiles):
    """Finds the primary word formed by newly placed tiles."""
    if not new_tiles: return [], None
    rows = set(r for r, c, _ in new_tiles); cols = set(c for r, c, _ in new_tiles)
    if len(rows) == 1: # Potential horizontal word
        orientation = "horizontal"; row = rows.pop(); min_col = min(c for r, c, _ in new_tiles if r == row); max_col = max(c for r, c, _ in new_tiles if r == row)
        while min_col > 0 and tiles[row][min_col - 1]: min_col -= 1
        while max_col < GRID_SIZE - 1 and tiles[row][max_col + 1]: max_col += 1
        main_word = [(row, c, tiles[row][c]) for c in range(min_col, max_col + 1) if tiles[row][c]]
        return (main_word, orientation) if len(main_word) > 1 else ([], None)
    elif len(cols) == 1: # Potential vertical word
        orientation = "vertical"; col = cols.pop(); min_row = min(r for r, c, _ in new_tiles if c == col); max_row = max(r for r, c, _ in new_tiles if c == col)
        while min_row > 0 and tiles[min_row - 1][col]: min_row -= 1
        while max_row < GRID_SIZE - 1 and tiles[max_row + 1][col]: max_row += 1
        main_word = [(r, col, tiles[r][col]) for r in range(min_row, max_row + 1) if tiles[r][col]]
        return (main_word, orientation) if len(main_word) > 1 else ([], None)
    else: return [], None

def find_cross_word(tile, tiles, main_orientation):
    """Finds a cross word formed by a single tile perpendicular to the main word."""
    r, c, _ = tile; cross_word = []
    if main_orientation == "horizontal": # Check vertically
        min_row = r;
        while min_row > 0 and tiles[min_row - 1][c]: min_row -= 1
        max_row = r;
        while max_row < GRID_SIZE - 1 and tiles[max_row + 1][c]: max_row += 1
        if max_row > min_row: cross_word = [(rr, c, tiles[rr][c]) for rr in range(min_row, max_row + 1) if tiles[rr][c]]
    elif main_orientation == "vertical": # Check horizontally
        min_col = c;
        while min_col > 0 and tiles[r][min_col - 1]: min_col -= 1
        max_col = c;
        while max_col < GRID_SIZE - 1 and tiles[r][max_col + 1]: max_col += 1
        if max_col > min_col: cross_word = [(r, cc, tiles[r][cc]) for cc in range(min_col, max_col + 1) if tiles[r][cc]]
    return cross_word if len(cross_word) > 1 else []

def find_all_words_formed(new_tiles, tiles):
    """Finds all words (main and cross) formed by a play."""
    words = [];
    if not new_tiles: return words
    new_positions_set = set((r, c) for r, c, _ in new_tiles)
    main_word_tiles, orientation = find_main_word(new_tiles, tiles)
    if main_word_tiles:
        words.append(main_word_tiles)
        for tile in new_tiles:
            if (tile[0], tile[1]) in new_positions_set:
                cross_word = find_cross_word(tile, tiles, orientation)
                if cross_word: words.append(cross_word)
    elif len(new_tiles) == 1: # Single tile placement check
        tile = new_tiles[0]
        cross_h = find_cross_word(tile, tiles, "vertical");   # Check H
        if cross_h: words.append(cross_h)
        cross_v = find_cross_word(tile, tiles, "horizontal"); # Check V
        if cross_v: words.append(cross_v)
    unique_word_tile_lists = []; seen_signatures = set()
    for word_tile_list in words:
        signature = tuple(sorted((r, c, l) for r, c, l in word_tile_list))
        if signature not in seen_signatures: unique_word_tile_lists.append(word_tile_list); seen_signatures.add(signature)
    return unique_word_tile_lists

# calculate_score (Unchanged from Part 2 provided previously)
def calculate_score(new_tiles, board, tiles, blanks):
    """Calculates the score for a play based on newly placed tiles."""
    total_score = 0; new_positions = set((r, c) for r, c, _ in new_tiles)
    words_formed_details = find_all_words_formed(new_tiles, tiles)
    for word_tiles in words_formed_details:
        word_score = 0; word_multiplier = 1
        for r, c, letter in word_tiles:
            if letter not in TILE_DISTRIBUTION: print(f"Warning: Invalid letter '{letter}' found in word during scoring at ({r},{c}). Skipping."); continue
            is_blank = (r, c) in blanks; letter_value = 0 if is_blank else TILE_DISTRIBUTION[letter][1]; letter_multiplier = 1
            if (r, c) in new_positions:
                square_color = board[r][c]
                if square_color == LIGHT_BLUE: letter_multiplier = 2 # DL
                elif square_color == BLUE: letter_multiplier = 3 # TL
                elif square_color == PINK: word_multiplier *= 2 # DW (Center is also Pink)
                elif square_color == RED: word_multiplier *= 3 # TW
            word_score += letter_value * letter_multiplier
        total_score += word_score * word_multiplier
    if len(new_tiles) == 7: total_score += 50 # Bingo bonus
    return total_score

# select_seven_letter_word, eight_letter_practice, mode_selection_screen, draw_options_menu (Unchanged from Part 2 provided previously)
def select_seven_letter_word(removed_letter, seven_letter_words):
    """Selects a random 7-letter word containing the removed letter."""
    candidates = [word for word in seven_letter_words if removed_letter in word]
    if not candidates: print(f"Warning: No 7-letter words contain '{removed_letter}'. Choosing random 7-letter word."); return random.choice(seven_letter_words) if seven_letter_words else None
    return random.choice(candidates)

def eight_letter_practice():
    """Handles the setup dialog and initialization for 8-Letter Bingo practice."""
    try:
        with open("7-letter-list.txt", "r") as seven_file, open("8-letter-list.txt", "r") as eight_file:
            seven_letter_words = [line.strip().upper() for line in seven_file.readlines()]; eight_letter_words = [line.strip().upper() for line in eight_file.readlines()]
    except FileNotFoundError: print("Error: Could not find 7-letter-list.txt or 8-letter-list.txt"); return False, None, None, None, None, None
    if not seven_letter_words or not eight_letter_words: print("Error: Word list files are empty."); return False, None, None, None, None, None
    dialog_width, dialog_height = 300, 150; dialog_x = (WINDOW_WIDTH - dialog_width) // 2; dialog_y = (WINDOW_HEIGHT - dialog_height) // 2
    proceed = False; text_box_active = False; probability_input = ""
    while True: # Dialog loop
        screen.fill(WHITE); pygame.draw.rect(screen, DIALOG_COLOR, (dialog_x, dialog_y, dialog_width, dialog_height)); pygame.draw.rect(screen, BLACK, (dialog_x, dialog_y, dialog_width, dialog_height), 2)
        title_text = dialog_font.render("8-Letter Bingo Options", True, BLACK); screen.blit(title_text, (dialog_x + 10, dialog_y + 10))
        prob_text = ui_font.render("Probability", True, BLACK); screen.blit(prob_text, (dialog_x + 20, dialog_y + 50))
        text_box_rect = pygame.Rect(dialog_x + 120, dialog_y + 45, 150, 30); pygame.draw.rect(screen, WHITE, text_box_rect); pygame.draw.rect(screen, BLACK, text_box_rect, 1)
        input_text = ui_font.render(probability_input, True, BLACK); screen.blit(input_text, (text_box_rect.x + 5, text_box_rect.y + 5))
        go_rect = pygame.Rect(dialog_x + 50, dialog_y + 100, 100, 30); cancel_rect = pygame.Rect(dialog_x + 160, dialog_y + 100, 100, 30)
        pygame.draw.rect(screen, BUTTON_COLOR, go_rect); pygame.draw.rect(screen, BUTTON_COLOR, cancel_rect)
        go_text = button_font.render("Go", True, BLACK); cancel_text = button_font.render("Cancel", True, BLACK)
        screen.blit(go_text, go_text.get_rect(center=go_rect.center)); screen.blit(cancel_text, cancel_text.get_rect(center=cancel_rect.center))
        for event in pygame.event.get():
            if event.type == pygame.QUIT: pygame.quit(); sys.exit()
            elif event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
                x, y = event.pos; text_box_active = text_box_rect.collidepoint(x, y)
                if go_rect.collidepoint(x, y):
                    max_index = len(eight_letter_words);
                    if probability_input.isdigit(): prob_val = int(probability_input); max_index = min(max(1, prob_val), len(eight_letter_words))
                    selected_eight = random.choice(eight_letter_words[:max_index]); print("Selected 8-letter word:", selected_eight)
                    remove_idx = random.randint(0, 7); removed_letter = selected_eight[remove_idx]; removed_eight = selected_eight[:remove_idx] + selected_eight[remove_idx + 1:]
                    print("Player 1 rack (7 letters):", removed_eight); print("Removed letter:", removed_letter)
                    selected_seven = select_seven_letter_word(removed_letter, seven_letter_words)
                    if selected_seven is None: print("Error: Could not find a suitable 7-letter word."); return False, None, None, None, None, None
                    print("Selected 7-letter word for board:", selected_seven)
                    board, _, tiles = create_board(); local_racks = [[], []]; local_blanks = set(); local_racks[0] = sorted(list(removed_eight)); local_racks[1] = []
                    center_r, center_c = CENTER_SQUARE; word_len = len(selected_seven); start_offset = word_len // 2; place_horizontally = random.choice([True, False]); placement_successful = False
                    if place_horizontally:
                        start_c_place = center_c - start_offset
                        if 0 <= start_c_place and start_c_place + word_len <= GRID_SIZE:
                            for i, letter in enumerate(selected_seven): tiles[center_r][start_c_place + i] = letter
                            placement_successful = True; print(f"Placed '{selected_seven}' horizontally at ({center_r},{start_c_place})")
                    if not placement_successful: # Try vertically
                        start_r_place = center_r - start_offset
                        if 0 <= start_r_place and start_r_place + word_len <= GRID_SIZE:
                            for i, letter in enumerate(selected_seven): tiles[start_r_place + i][center_c] = letter
                            placement_successful = True; print(f"Placed '{selected_seven}' vertically at ({start_r_place},{center_c})")
                    if not placement_successful: print("Error: Could not place 7-letter word centered H or V."); return False, None, None, None, None, None
                    local_bag = []; return True, board, tiles, local_racks, local_blanks, local_bag
                elif cancel_rect.collidepoint(x, y): return False, None, None, None, None, None
            elif event.type == pygame.KEYDOWN and text_box_active:
                if event.key == pygame.K_BACKSPACE: probability_input = probability_input[:-1]
                elif event.unicode.isdigit(): probability_input += event.unicode
        pygame.display.flip()
    return False, None, None, None, None, None # Should not be reached




# Function to Modify: mode_selection_screen
# REASON: Added "Load Game" button, file dialog logic using tkinter,
#         and modified return values to signal successful load.

# Function to Modify: mode_selection_screen
# REASON: Replaced tkinter file dialog with an in-Pygame text input
#         field to avoid toolkit conflicts and crashes.

# --- Need Imports for this function ---
import pygame
import sys
# import tkinter as tk             # REMOVED for file dialog
# from tkinter import filedialog   # REMOVED for file dialog

# (Make sure other necessary imports like MODE_ constants are available)

# Function to Modify: mode_selection_screen
# REASON: Moved calculation of load input rects before event handling
#         to ensure they are defined before being potentially used.

# --- Need Imports for this function ---
import pygame
import sys
# import tkinter as tk             # REMOVED for file dialog
# from tkinter import filedialog   # REMOVED for file dialog

# (Make sure other necessary imports like MODE_ constants are available)

def mode_selection_screen():
    """Display and handle the game mode selection screen, including Load Game via text input."""
    print("--- mode_selection_screen() entered ---")
    global main_called
    try:
        print("--- mode_selection_screen(): Attempting to load background image... ---")
        image = pygame.image.load("Scrabble_S.png").convert_alpha(); content_width = WINDOW_WIDTH - 200; image = pygame.transform.scale(image, (content_width, WINDOW_HEIGHT)); image.set_alpha(128); content_left = (WINDOW_WIDTH - content_width) // 2
        print("--- mode_selection_screen(): Background image loaded and processed. ---")
    except pygame.error as e:
        print(f"--- mode_selection_screen(): WARNING - Could not load background image 'Scrabble_S.png': {e} ---")
        image = None; content_width = WINDOW_WIDTH; content_left = 0

    modes = [MODE_HVH, MODE_HVA, MODE_AVA]; selected_mode = None; player_names = ["Player 1", "Player 2"]; human_player = 1; input_active = [False, False]; current_input = 0
    practice_mode = None; dropdown_open = False; showing_power_tiles_dialog = False; letter_checks = [True, True, True, True]; number_checks = [True, True, True, True, False, False]; practice_state = None
    loaded_game_data = None

    # State for Load Game Text Input
    showing_load_input = False
    load_filename_input = ""
    load_input_active = False
    load_confirm_button_rect = None
    load_input_rect = None
    load_cancel_button_rect = None

    print("--- mode_selection_screen(): Entering main loop (while selected_mode is None:)... ---")
    loop_count = 0
    while selected_mode is None:
        loop_count += 1
        if loop_count % 15000 == 0: print(f"--- mode_selection_screen(): Loop iteration {loop_count} ---")

        pygame.event.pump()

        # --- Define positions INSIDE the loop ---
        option_rects = []
        name_rect_x = content_left + (content_width - 200) // 2
        p2_y_pos = 300 + 60

        # Button Positions (Mode buttons drawn later)
        play_later_rect = pygame.Rect(WINDOW_WIDTH - BUTTON_WIDTH - 10, WINDOW_HEIGHT - BUTTON_HEIGHT - 10, BUTTON_WIDTH, BUTTON_HEIGHT)
        load_game_button_rect = pygame.Rect(play_later_rect.left - BUTTON_GAP - BUTTON_WIDTH, play_later_rect.top, BUTTON_WIDTH, BUTTON_HEIGHT)

        # --- MOVED RECT CALCULATION ---
        # Calculate Load Input Field/Button Positions unconditionally,
        # they will only be used for drawing/collision if showing_load_input is True.
        load_input_width = 300
        load_input_x = load_game_button_rect.left # Align with Load Game button
        load_input_y = load_game_button_rect.top - BUTTON_GAP - BUTTON_HEIGHT # Position above Load Game button
        load_input_rect = pygame.Rect(load_input_x, load_input_y, load_input_width, BUTTON_HEIGHT)
        load_confirm_button_rect = pygame.Rect(load_input_x + load_input_width + BUTTON_GAP, load_input_y, BUTTON_WIDTH, BUTTON_HEIGHT)
        load_cancel_button_rect = pygame.Rect(load_confirm_button_rect.right + BUTTON_GAP, load_input_y, BUTTON_WIDTH, BUTTON_HEIGHT)
        # --- END MOVED RECT CALCULATION ---

        # Dropdown positioning
        if modes[current_input] == MODE_HVH and dropdown_open:
            dropdown_x = name_rect_x; dropdown_button_y = p2_y_pos + BUTTON_HEIGHT + 10; dropdown_y = dropdown_button_y + 30
            options = ["Power Tiles", "8-Letter Bingos", "End Game"]
            for i, option in enumerate(options): option_rect = pygame.Rect(dropdown_x, dropdown_y + 30 * i, 200, 30); option_rects.append(option_rect)


        # --- Event Handling ---
        for event in pygame.event.get():
            if event.type == pygame.QUIT: pygame.quit(); sys.exit()

            # Handle Load Game Input FIRST if active
            if showing_load_input:
                if event.type == pygame.MOUSEBUTTONDOWN:
                    x, y = event.pos
                    # Activate/Deactivate load input box
                    # Use the pre-calculated load_input_rect
                    if load_input_rect.collidepoint(x, y):
                        load_input_active = True
                    else:
                        load_input_active = False

                    # Check Load Confirm Button (use pre-calculated rect)
                    if load_confirm_button_rect.collidepoint(x, y):
                        filepath = load_filename_input.strip()
                        if filepath:
                             print(f"--- mode_selection_screen(): Attempting to load typed file: {filepath} ---")
                             try:
                                 loaded_p_names, loaded_hist, loaded_f_scores = load_game_from_gcg(filepath)
                                 print(f"--- mode_selection_screen(): GCG loaded successfully. Moves: {len(loaded_hist)} ---")
                                 selected_mode = "LOADED_GAME"
                                 loaded_game_data = (loaded_p_names, loaded_hist, loaded_f_scores)
                                 showing_load_input = False; load_input_active = False
                                 break
                             except FileNotFoundError:
                                 print(f"--- mode_selection_screen(): Error: File not found '{filepath}' ---"); show_message_dialog(f"Error: File not found:\n{filepath}", "Load Error"); load_input_active = True
                             except Exception as e:
                                 print(f"--- mode_selection_screen(): Error loading GCG file '{filepath}': {e} ---"); show_message_dialog(f"Error loading file:\n{e}", "Load Error"); load_input_active = True
                        else: show_message_dialog("Please enter a filename.", "Load Error"); load_input_active = True

                    # Check Load Cancel Button (use pre-calculated rect)
                    elif load_cancel_button_rect.collidepoint(x,y):
                         showing_load_input = False; load_input_active = False; load_filename_input = ""

                    # Deactivate name input if clicking elsewhere while load input showing
                    if not load_input_rect.collidepoint(x,y): input_active = [False, False]

                elif event.type == pygame.KEYDOWN and load_input_active:
                    if event.key == pygame.K_RETURN or event.key == pygame.K_KP_ENTER:
                         if load_confirm_button_rect: pygame.event.post(pygame.event.Event(pygame.MOUSEBUTTONDOWN, {'pos': load_confirm_button_rect.center, 'button': 1}))
                    elif event.key == pygame.K_BACKSPACE: load_filename_input = load_filename_input[:-1]
                    elif event.unicode.isprintable(): load_filename_input += event.unicode

                continue # Skip rest of event handling if load input was active

            # Handle other events if load input wasn't active
            elif event.type == pygame.MOUSEBUTTONDOWN:
                x, y = event.pos
                if showing_power_tiles_dialog: # Power Tiles Dialog ...
                    # (No changes needed here)
                    dialog_x = (WINDOW_WIDTH - 300) // 2; dialog_y = (WINDOW_HEIGHT - 250) // 2; letter_rects = [pygame.Rect(dialog_x + 20, dialog_y + 40 + i*30, 20, 20) for i in range(4)]; number_rects = [pygame.Rect(dialog_x + 150, dialog_y + 40 + i*30, 20, 20) for i in range(6)]
                    go_rect = pygame.Rect(dialog_x + 50, dialog_y + 220, 100, 30); cancel_rect = pygame.Rect(dialog_x + 160, dialog_y + 220, 100, 30)
                    for i, rect in enumerate(letter_rects):
                        if rect.collidepoint(x, y): letter_checks[i] = not letter_checks[i]
                    for i, rect in enumerate(number_rects):
                        if rect.collidepoint(x, y): number_checks[i] = not number_checks[i]
                    if go_rect.collidepoint(x, y): practice_mode = "power_tiles"; selected_mode = MODE_AVA; showing_power_tiles_dialog = False; print(f"--- mode_selection_screen(): Mode selected via Power Tiles Go: {selected_mode} ---"); break
                    elif cancel_rect.collidepoint(x, y): showing_power_tiles_dialog = False
                else: # Main Selection Screen ...
                    # Must define mode_rects before checking collision
                    mode_rects = []
                    for i, mode in enumerate(modes):
                        y_pos = 100 + i * 60; rect = pygame.Rect(content_left + (content_width - (BUTTON_WIDTH * 2 + 20)) // 2, y_pos, BUTTON_WIDTH * 2 + 20, BUTTON_HEIGHT); mode_rects.append(rect)
                    # Now check mode buttons
                    for i, rect in enumerate(mode_rects):
                        if rect.collidepoint(x, y):
                            current_input = i; dropdown_open = False
                            if i == 0: player_names = ["Player 1", "Player 2"]; input_active = [False, False]
                            elif i == 1: player_names = ["Player 1", "AI"] if human_player == 1 else ["AI", "Player 2"]; input_active = [True, False] if human_player == 1 else [False, True]
                            elif i == 2: player_names = ["AI 1", "AI 2"]; input_active = [False, False]
                            if modes[current_input] in [MODE_HVH, MODE_AVA]:
                                selected_mode = modes[current_input]; print(f"--- mode_selection_screen(): Mode selected via click: {selected_mode} ---"); break
                    if selected_mode: break

                    # Check Load Game Button
                    if load_game_button_rect.collidepoint(x, y):
                        print("--- mode_selection_screen(): Load Game button clicked, showing input ---")
                        showing_load_input = True; load_input_active = True; load_filename_input = ""
                        continue # Skip rest

                    # Check Other Buttons
                    if play_later_rect.collidepoint(x, y): print("--- mode_selection_screen(): Play Later clicked. Exiting. ---"); pygame.quit(); sys.exit()
                    clicked_name_input = False
                    p1_name_rect = pygame.Rect(name_rect_x, 300, 200, BUTTON_HEIGHT)
                    p2_name_rect = pygame.Rect(name_rect_x, p2_y_pos, 200, BUTTON_HEIGHT) if modes[current_input] == MODE_HVH else None
                    if modes[current_input] == MODE_HVH:
                        if p1_name_rect.collidepoint(x, y): input_active = [True, False]; clicked_name_input = True
                        elif p2_name_rect and p2_name_rect.collidepoint(x, y): input_active = [False, True]; clicked_name_input = True
                    elif modes[current_input] == MODE_HVA:
                        if human_player == 1 and p1_name_rect.collidepoint(x, y): input_active = [True, False]; clicked_name_input = True
                        elif human_player == 2:
                            p2_name_rect_hva = pygame.Rect(name_rect_x, p2_y_pos, 200, BUTTON_HEIGHT)
                            if p2_name_rect_hva.collidepoint(x,y): input_active = [False, True]; clicked_name_input = True
                    if modes[current_input] == MODE_HVA: # HVA Play As buttons
                        button_row_y = p2_y_pos + BUTTON_HEIGHT + 10; p1_rect_hva = pygame.Rect(content_left + (content_width - (BUTTON_WIDTH * 2 + 20)) // 2, button_row_y, BUTTON_WIDTH, BUTTON_HEIGHT); p2_rect_hva = pygame.Rect(content_left + (content_width - (BUTTON_WIDTH * 2 + 20)) // 2 + BUTTON_WIDTH + 20, button_row_y, BUTTON_WIDTH, BUTTON_HEIGHT)
                        if p1_rect_hva.collidepoint(x, y): human_player = 1; player_names = ["Player 1", "AI"]; input_active = [True, False]; selected_mode = MODE_HVA; print(f"--- mode_selection_screen(): Mode selected via click: {selected_mode} (Play as P1) ---"); break
                        elif p2_rect_hva.collidepoint(x, y): human_player = 2; player_names = ["AI", "Player 2"]; input_active = [False, True]; selected_mode = MODE_HVA; print(f"--- mode_selection_screen(): Mode selected via click: {selected_mode} (Play as P2) ---"); break
                    if modes[current_input] == MODE_HVH: # Practice Dropdown
                        dropdown_button_y = p2_y_pos + BUTTON_HEIGHT + 10; dropdown_rect = pygame.Rect(name_rect_x, dropdown_button_y, 200, 30)
                        if dropdown_rect.collidepoint(x, y): dropdown_open = not dropdown_open
                        elif dropdown_open:
                            clicked_option = False
                            for i, option_rect in enumerate(option_rects):
                                if option_rect.collidepoint(x, y):
                                    clicked_option = True; dropdown_open = False
                                    if i == 0: showing_power_tiles_dialog = True
                                    elif i == 1: # 8-Letter Bingos
                                        print("--- mode_selection_screen(): 8-Letter Bingo practice selected. Calling eight_letter_practice()... ---")
                                        proceed, p_board, p_tiles, p_racks, p_blanks, p_bag = eight_letter_practice()
                                        if proceed:
                                            practice_mode = "eight_letter"; selected_mode = MODE_HVH; player_names = ["Player 1", ""]; human_player = 1
                                            practice_state = {"board": p_board, "tiles": p_tiles, "racks": p_racks, "blanks": p_blanks, "bag": p_bag, "first_play": False, "scores": [0, 0], "turn": 1}
                                            print(f"--- mode_selection_screen(): 8-Letter practice setup successful. Selected mode: {selected_mode} ---"); break
                                        else: print("--- mode_selection_screen(): 8-Letter practice setup cancelled or failed. ---")
                                    elif i == 2: print("End Game practice selected - Not implemented yet")
                                    break # Exit options loop
                            if not clicked_option and not dropdown_rect.collidepoint(x,y): dropdown_open = False
                        elif not dropdown_rect.collidepoint(x,y): dropdown_open = False
                    if selected_mode: break
                    dropdown_button_y = p2_y_pos + BUTTON_HEIGHT + 10; dropdown_rect_check = pygame.Rect(name_rect_x, dropdown_button_y, 200, 30) if modes[current_input] == MODE_HVH else None
                    if not clicked_name_input and not (dropdown_open and any(r.collidepoint(x,y) for r in option_rects)) and not p1_name_rect.collidepoint(x,y) and not (p2_name_rect and p2_name_rect.collidepoint(x,y)) and not (dropdown_rect_check and dropdown_rect_check.collidepoint(x,y)): input_active = [False, False]

            elif event.type == pygame.KEYDOWN: # Keyboard Input (Names only now)
                if not showing_load_input: # Only handle name input if load input isn't showing
                     active_idx = -1
                     if input_active[0]: active_idx = 0
                     elif input_active[1] and modes[current_input] == MODE_HVH: active_idx = 1
                     elif input_active[1] and modes[current_input] == MODE_HVA and human_player == 2: active_idx = 1
                     if active_idx != -1:
                        if event.key == pygame.K_BACKSPACE: player_names[active_idx] = player_names[active_idx][:-1]
                        elif event.key == pygame.K_RETURN: input_active[active_idx] = False
                        elif event.unicode.isalnum() or event.unicode == ' ':
                            if len(player_names[active_idx]) < 15: player_names[active_idx] += event.unicode

        # --- Drawing Logic ---
        screen.fill(WHITE);
        if image: screen.blit(image, (content_left, 0))
        title_text = dialog_font.render("Select Game Mode", True, BLACK); title_x = content_left + (content_width - title_text.get_width()) // 2; screen.blit(title_text, (title_x, 50))
        mode_rects = [] # Draw Mode Buttons ...
        for i, mode in enumerate(modes):
            y_pos = 100 + i * 60; rect = pygame.Rect(content_left + (content_width - (BUTTON_WIDTH * 2 + 20)) // 2, y_pos, BUTTON_WIDTH * 2 + 20, BUTTON_HEIGHT); hover = rect.collidepoint(pygame.mouse.get_pos())
            color = BUTTON_HOVER if i == current_input or hover else BUTTON_COLOR; pygame.draw.rect(screen, color, rect)
            if i == current_input: pygame.draw.rect(screen, BLACK, rect, 2)
            text = button_font.render(mode, True, BLACK); text_rect = text.get_rect(center=rect.center); screen.blit(text, text_rect); mode_rects.append(rect)

        # Draw Play Later Button ...
        hover = play_later_rect.collidepoint(pygame.mouse.get_pos()); color = BUTTON_HOVER if hover else BUTTON_COLOR; pygame.draw.rect(screen, color, play_later_rect)
        play_later_text = button_font.render("Play Later", True, BLACK); play_later_text_rect = play_later_text.get_rect(center=play_later_rect.center); screen.blit(play_later_text, play_later_text_rect)

        # Draw Load Game Button ...
        hover = load_game_button_rect.collidepoint(pygame.mouse.get_pos()); color = BUTTON_HOVER if hover else BUTTON_COLOR; pygame.draw.rect(screen, color, load_game_button_rect)
        load_game_text = button_font.render("Load Game", True, BLACK); load_game_text_rect = load_game_text.get_rect(center=load_game_button_rect.center); screen.blit(load_game_text, load_game_text_rect)

        # Draw Load Game Input Field (if active)
        if showing_load_input:
             # Use the pre-calculated rects
             pygame.draw.rect(screen, WHITE, load_input_rect)
             pygame.draw.rect(screen, BLACK, load_input_rect, 1 if not load_input_active else 2)
             input_surf = ui_font.render(load_filename_input, True, BLACK)
             screen.blit(input_surf, (load_input_rect.x + 5, load_input_rect.y + 5))
             if load_input_active and int(time.time() * 2) % 2 == 0: # Blinking cursor
                  cursor_x = load_input_rect.x + 5 + input_surf.get_width()
                  cursor_y1 = load_input_rect.y + 5; cursor_y2 = load_input_rect.y + load_input_rect.height - 5
                  pygame.draw.line(screen, BLACK, (cursor_x, cursor_y1), (cursor_x, cursor_y2), 1)
             # Confirm Button
             hover = load_confirm_button_rect.collidepoint(pygame.mouse.get_pos()); color = BUTTON_HOVER if hover else BUTTON_COLOR
             pygame.draw.rect(screen, color, load_confirm_button_rect)
             text = button_font.render("Load File", True, BLACK); text_rect = text.get_rect(center=load_confirm_button_rect.center); screen.blit(text, text_rect)
             # Cancel Button
             hover = load_cancel_button_rect.collidepoint(pygame.mouse.get_pos()); color = BUTTON_HOVER if hover else BUTTON_COLOR
             pygame.draw.rect(screen, color, load_cancel_button_rect)
             text = button_font.render("Cancel", True, BLACK); text_rect = text.get_rect(center=load_cancel_button_rect.center); screen.blit(text, text_rect)

        # Name Input / Practice Dropdown / HVA Selection Drawing ...
        # (No changes needed here)
        name_y_start = 300; name_rect_width = 200; p1_y_pos = name_y_start; p1_label_text = "Player 1 Name:"; p1_label = ui_font.render(p1_label_text, True, BLACK);
        p1_name_rect = pygame.Rect(name_rect_x, p1_y_pos, name_rect_width, BUTTON_HEIGHT) # Define for drawing
        p1_label_x = name_rect_x - p1_label.get_width() - 10; screen.blit(p1_label, (p1_label_x, p1_y_pos + 5)); p1_bg_color = LIGHT_BLUE if input_active[0] else (GRAY if modes[current_input] == MODE_AVA else WHITE); pygame.draw.rect(screen, p1_bg_color, p1_name_rect); pygame.draw.rect(screen, BLACK, p1_name_rect, 1)
        p1_name_text = ui_font.render(player_names[0], True, BLACK); screen.blit(p1_name_text, (p1_name_rect.x + 5, p1_name_rect.y + 5))
        if modes[current_input] == MODE_HVH:
            p2_label_text = "Player 2 Name:"; p2_label = ui_font.render(p2_label_text, True, BLACK); p2_name_rect = pygame.Rect(name_rect_x, p2_y_pos, name_rect_width, BUTTON_HEIGHT) # Define for drawing
            p2_label_x = name_rect_x - p2_label.get_width() - 10; screen.blit(p2_label, (p2_label_x, p2_y_pos + 5))
            pygame.draw.rect(screen, WHITE if not input_active[1] else LIGHT_BLUE, p2_name_rect); pygame.draw.rect(screen, BLACK, p2_name_rect, 1); p2_name_text = ui_font.render(player_names[1], True, BLACK); screen.blit(p2_name_text, (p2_name_rect.x + 5, p2_name_rect.y + 5))
            dropdown_button_y = p2_y_pos + BUTTON_HEIGHT + 10; dropdown_rect = pygame.Rect(name_rect_x, dropdown_button_y, 200, 30); hover = dropdown_rect.collidepoint(pygame.mouse.get_pos()); color = BUTTON_HOVER if hover else BUTTON_COLOR; pygame.draw.rect(screen, color, dropdown_rect)
            text = button_font.render("Practice", True, BLACK); text_rect = text.get_rect(center=dropdown_rect.center); screen.blit(text, text_rect)
            if dropdown_open:
                for i, option_rect in enumerate(option_rects): hover = option_rect.collidepoint(pygame.mouse.get_pos()); color = BUTTON_HOVER if hover else DROPDOWN_COLOR; pygame.draw.rect(screen, color, option_rect); text = button_font.render(options[i], True, BLACK); text_rect = text.get_rect(center=option_rect.center); screen.blit(text, text_rect)
        elif modes[current_input] == MODE_HVA:
            p2_label_text = "AI Name:"; p2_label = ui_font.render(p2_label_text, True, BLACK); p2_name_rect = pygame.Rect(name_rect_x, p2_y_pos, name_rect_width, BUTTON_HEIGHT) # Define for drawing
            p2_label_x = name_rect_x - p2_label.get_width() - 10; screen.blit(p2_label, (p2_label_x, p2_y_pos + 5))
            pygame.draw.rect(screen, GRAY, p2_name_rect); pygame.draw.rect(screen, BLACK, p2_name_rect, 1); p2_name_text = ui_font.render(player_names[1], True, BLACK); screen.blit(p2_name_text, (p2_name_rect.x + 5, p2_name_rect.y + 5))
            button_row_y = p2_y_pos + BUTTON_HEIGHT + 10; p1_rect = pygame.Rect(content_left + (content_width - (BUTTON_WIDTH * 2 + 20)) // 2, button_row_y, BUTTON_WIDTH, BUTTON_HEIGHT); p2_rect = pygame.Rect(content_left + (content_width - (BUTTON_WIDTH * 2 + 20)) // 2 + BUTTON_WIDTH + 20, button_row_y, BUTTON_WIDTH, BUTTON_HEIGHT)
            p1_hover = p1_rect.collidepoint(pygame.mouse.get_pos()); p2_hover = p2_rect.collidepoint(pygame.mouse.get_pos()); pygame.draw.rect(screen, BUTTON_HOVER if p1_hover else BUTTON_COLOR, p1_rect);
            if human_player == 1: pygame.draw.rect(screen, BLACK, p1_rect, 2)
            pygame.draw.rect(screen, BUTTON_HOVER if p2_hover else BUTTON_COLOR, p2_rect);
            if human_player == 2: pygame.draw.rect(screen, BLACK, p2_rect, 2)
            p1_text = button_font.render("Play as P1", True, BLACK); p2_text = button_font.render("Play as P2", True, BLACK); p1_text_rect = p1_text.get_rect(center=p1_rect.center); p2_text_rect = p2_text.get_rect(center=p2_rect.center); screen.blit(p1_text, p1_text_rect); screen.blit(p2_text, p2_text_rect)
        elif modes[current_input] == MODE_AVA:
            p2_label_text = "AI 2 Name:"; p2_label = ui_font.render(p2_label_text, True, BLACK); p2_name_rect = pygame.Rect(name_rect_x, p2_y_pos, name_rect_width, BUTTON_HEIGHT) # Define for drawing
            p2_label_x = name_rect_x - p2_label.get_width() - 10; screen.blit(p2_label, (p2_label_x, p2_y_pos + 5))
            pygame.draw.rect(screen, GRAY, p2_name_rect); pygame.draw.rect(screen, BLACK, p2_name_rect, 1); p2_name_text = ui_font.render(player_names[1], True, BLACK); screen.blit(p2_name_text, (p2_name_rect.x + 5, p2_name_rect.y + 5))
            pygame.draw.rect(screen, GRAY, p1_name_rect); pygame.draw.rect(screen, BLACK, p1_name_rect, 1); p1_name_text = ui_font.render(player_names[0], True, BLACK); screen.blit(p1_name_text, (p1_name_rect.x + 5, p1_name_rect.y + 5))

        # Draw Power Tiles Dialog if active ...
        if showing_power_tiles_dialog:
             # (No changes needed here)
            dialog_width, dialog_height = 300, 250; dialog_x = (WINDOW_WIDTH - dialog_width) // 2; dialog_y = (WINDOW_HEIGHT - dialog_height) // 2; pygame.draw.rect(screen, DIALOG_COLOR, (dialog_x, dialog_y, dialog_width, dialog_height)); pygame.draw.rect(screen, BLACK, (dialog_x, dialog_y, dialog_width, dialog_height), 2)
            title_text = dialog_font.render("Power Tiles Options", True, BLACK); screen.blit(title_text, (dialog_x + 10, dialog_y + 10)); letters = ['J', 'Q', 'X', 'Z']
            for i, letter in enumerate(letters): draw_checkbox(screen, dialog_x + 20, dialog_y + 40 + i*30, letter_checks[i]); text = ui_font.render(letter, True, BLACK); screen.blit(text, (dialog_x + 50, dialog_y + 40 + i*30))
            numbers = ['2', '3', '4', '5', '6', '7+']
            for i, num in enumerate(numbers): draw_checkbox(screen, dialog_x + 150, dialog_y + 40 + i*30, number_checks[i]); text = ui_font.render(num, True, BLACK); screen.blit(text, (dialog_x + 180, dialog_y + 40 + i*30))
            go_rect = pygame.Rect(dialog_x + 50, dialog_y + 220, 100, 30); cancel_rect = pygame.Rect(dialog_x + 160, dialog_y + 220, 100, 30); pygame.draw.rect(screen, BUTTON_COLOR, go_rect); pygame.draw.rect(screen, BUTTON_COLOR, cancel_rect)
            go_text = button_font.render("Go", True, BLACK); cancel_text = button_font.render("Cancel", True, BLACK); screen.blit(go_text, go_text.get_rect(center=go_rect.center)); screen.blit(cancel_text, cancel_text.get_rect(center=cancel_rect.center))


        # --- Display Update ---
        pygame.display.flip()

        # --- Exit Condition Check ---
        if selected_mode: break

    print(f"--- mode_selection_screen(): Exiting loop. Returning mode={selected_mode} ---")
    # Return loaded game data or new game setup data
    if selected_mode == "LOADED_GAME":
        return selected_mode, loaded_game_data
    else:
        return selected_mode, (player_names, human_player, practice_mode, letter_checks, practice_state)



def draw_options_menu(turn, dropdown_open, bag_count):
    """Draw the options menu with dropdown functionality."""
    global practice_mode # Access practice_mode
    options_x = 10; options_rect = pygame.Rect(options_x, OPTIONS_Y, OPTIONS_WIDTH, OPTIONS_HEIGHT)
    hover = options_rect.collidepoint(pygame.mouse.get_pos()); color = BUTTON_HOVER if hover else BUTTON_COLOR; pygame.draw.rect(screen, color, options_rect)
    options_text = button_font.render("Options", True, BLACK); options_text_rect = options_text.get_rect(center=(options_x + OPTIONS_WIDTH // 2, OPTIONS_Y + OPTIONS_HEIGHT // 2)); screen.blit(options_text, options_text_rect)
    dropdown_rects = []
    if dropdown_open:
        dropdown_y = OPTIONS_Y + OPTIONS_HEIGHT
        if practice_mode == "eight_letter": options = ["Give Up", "Main", "Quit"]
        else: options = ["Pass", "Exchange", "Main", "Quit"]
        for i, option in enumerate(options):
            rect = pygame.Rect(options_x, dropdown_y + i * OPTIONS_HEIGHT, OPTIONS_WIDTH, OPTIONS_HEIGHT)
            is_disabled = (practice_mode != "eight_letter" and option == "Exchange" and bag_count < 7)
            if is_disabled: pygame.draw.rect(screen, GRAYED_OUT_COLOR, rect); text = button_font.render(option, True, BLACK); dropdown_rects.append(None)
            else: hover = rect.collidepoint(pygame.mouse.get_pos()); color = BUTTON_HOVER if hover else DROPDOWN_COLOR; pygame.draw.rect(screen, color, rect); text = button_font.render(option, True, BLACK); dropdown_rects.append(rect)
            text_rect = text.get_rect(center=(options_x + OPTIONS_WIDTH // 2, dropdown_y + i * OPTIONS_HEIGHT + OPTIONS_HEIGHT // 2)); screen.blit(text, text_rect)
    return options_rect, dropdown_rects

# End of Part 2

# Part 3 (Includes dialogs, stats, message boxes)
# draw_suggest_button, draw_exchange_dialog, confirm_quit, draw_game_over_dialog, draw_score_row, calculate_moves_per_player, calculate_bingos_per_player, calculate_bingo_avg_per_player, draw_moves_row, draw_avg_score_row, draw_bingos_row, draw_bingo_avg_row, calculate_blanks_per_player, draw_blanks_row, draw_stats_dialog, show_message_dialog, draw_practice_end_dialog (Unchanged from Part 3 provided previously)
def draw_suggest_button():
    """Draw the suggest button."""
    suggest_x = 10 + OPTIONS_WIDTH + BUTTON_GAP; suggest_rect = pygame.Rect(suggest_x, OPTIONS_Y, OPTIONS_WIDTH, OPTIONS_HEIGHT)
    hover = suggest_rect.collidepoint(pygame.mouse.get_pos()); color = BUTTON_HOVER if hover else BUTTON_COLOR; pygame.draw.rect(screen, color, suggest_rect)
    suggest_text = button_font.render("Suggest", True, BLACK); suggest_text_rect = suggest_text.get_rect(center=(suggest_x + OPTIONS_WIDTH // 2, OPTIONS_Y + OPTIONS_HEIGHT // 2)); screen.blit(suggest_text, suggest_text_rect)
    return suggest_rect

def draw_exchange_dialog(rack, selected_tiles):
    """Draw the tile exchange dialog."""
    dialog_width, dialog_height = 400, 200; dialog_x = (WINDOW_WIDTH - dialog_width) // 2; dialog_y = (WINDOW_HEIGHT - dialog_height) // 2
    pygame.draw.rect(screen, DIALOG_COLOR, (dialog_x, dialog_y, dialog_width, dialog_height)); pygame.draw.rect(screen, BLACK, (dialog_x, dialog_y, dialog_width, dialog_height), 2)
    prompt_text = dialog_font.render("Select tiles to exchange:", True, BLACK); screen.blit(prompt_text, (dialog_x + 10, dialog_y + 10))
    tile_rects = []; rack_display_width = len(rack) * (TILE_WIDTH + TILE_GAP) - TILE_GAP; start_tile_x = dialog_x + (dialog_width - rack_display_width) // 2
    for i, tile in enumerate(rack):
        tile_x = start_tile_x + i * (TILE_WIDTH + TILE_GAP); tile_y = dialog_y + 50; rect = pygame.Rect(tile_x, tile_y, TILE_WIDTH, TILE_HEIGHT); tile_rects.append(rect)
        if tile == ' ':
            center = rect.center; radius = TILE_WIDTH // 2 - 2; pygame.draw.circle(screen, BLACK, center, radius)
            if i in selected_tiles: pygame.draw.circle(screen, SELECTED_TILE_COLOR, center, radius + 2, 2)
            text = font.render('?', True, WHITE); text_rect = text.get_rect(center=center); screen.blit(text, text_rect)
        else: color = SELECTED_TILE_COLOR if i in selected_tiles else GREEN; pygame.draw.rect(screen, color, rect); text = font.render(tile, True, BLACK); screen.blit(text, (tile_x + 5, tile_y + 5))
    total_button_width = BUTTON_WIDTH * 2 + BUTTON_GAP; button_start_x = dialog_x + (dialog_width - total_button_width) // 2; button_y = dialog_y + dialog_height - BUTTON_HEIGHT - 10
    exchange_button_rect = pygame.Rect(button_start_x, button_y, BUTTON_WIDTH, BUTTON_HEIGHT); cancel_button_rect = pygame.Rect(button_start_x + BUTTON_WIDTH + BUTTON_GAP, button_y, BUTTON_WIDTH, BUTTON_HEIGHT)
    hover = exchange_button_rect.collidepoint(pygame.mouse.get_pos()); color = BUTTON_HOVER if hover else BUTTON_COLOR; pygame.draw.rect(screen, color, exchange_button_rect)
    exchange_text = button_font.render("Exchange", True, BLACK); exchange_text_rect = exchange_text.get_rect(center=exchange_button_rect.center); screen.blit(exchange_text, exchange_text_rect)
    hover = cancel_button_rect.collidepoint(pygame.mouse.get_pos()); color = BUTTON_HOVER if hover else BUTTON_COLOR; pygame.draw.rect(screen, color, cancel_button_rect)
    cancel_text = button_font.render("Cancel", True, BLACK); cancel_text_rect = cancel_text.get_rect(center=cancel_button_rect.center); screen.blit(cancel_text, cancel_text_rect)
    return tile_rects, exchange_button_rect, cancel_button_rect

def confirm_quit():
    """Prompt the user to confirm quitting the game."""
    dialog_width, dialog_height = 300, 100; dialog_x = (WINDOW_WIDTH - dialog_width) // 2; dialog_y = (WINDOW_HEIGHT - dialog_height) // 2
    pygame.draw.rect(screen, DIALOG_COLOR, (dialog_x, dialog_y, dialog_width, dialog_height)); pygame.draw.rect(screen, BLACK, (dialog_x, dialog_y, dialog_width, dialog_height), 2)
    prompt_text = dialog_font.render("Quit game? (Y/N)", True, BLACK); screen.blit(prompt_text, (dialog_x + (dialog_width - prompt_text.get_width()) // 2, dialog_y + 30)); pygame.display.flip()
    while True:
        for event in pygame.event.get():
            if event.type == pygame.QUIT: pygame.quit(); sys.exit()
            elif event.type == pygame.KEYDOWN:
                if event.key == pygame.K_y: return True
                elif event.key == pygame.K_n: return False

def draw_game_over_dialog(dialog_x, dialog_y, final_scores, reason, player_names):
    """Draw the game over dialog and return button rectangles."""
    pygame.draw.rect(screen, DIALOG_COLOR, (dialog_x, dialog_y, DIALOG_WIDTH, DIALOG_HEIGHT)); pygame.draw.rect(screen, BLACK, (dialog_x, dialog_y, DIALOG_WIDTH, DIALOG_HEIGHT), 2)
    title_text = dialog_font.render(f"Game Over - {reason}", True, BLACK); p1_score_text = ui_font.render(f"{player_names[0]} Score: {final_scores[0]}", True, BLACK)
    p2_name_display = player_names[1] if player_names[1] else "Player 2"; p2_score_text = ui_font.render(f"{p2_name_display} Score: {final_scores[1]}", True, BLACK)
    save_text = button_font.render("Save (S)", True, BLACK); quit_text = button_font.render("Quit (Q)", True, BLACK); replay_text = button_font.render("Replay (R)", True, BLACK); play_again_text = button_font.render("Play Again (P)", True, BLACK); stats_text = button_font.render("Statistics", True, BLACK)
    screen.blit(title_text, (dialog_x + 10, dialog_y + 20)); screen.blit(p1_score_text, (dialog_x + 10, dialog_y + 60)); screen.blit(p2_score_text, (dialog_x + 10, dialog_y + 90))
    first_row_width = 3 * BUTTON_WIDTH + 2 * BUTTON_GAP; first_row_start_x = dialog_x + (DIALOG_WIDTH - first_row_width) // 2; second_row_width = 2 * BUTTON_WIDTH + BUTTON_GAP; second_row_start_x = dialog_x + (DIALOG_WIDTH - second_row_width) // 2
    save_rect = pygame.Rect(first_row_start_x, dialog_y + 150, BUTTON_WIDTH, BUTTON_HEIGHT); quit_rect = pygame.Rect(first_row_start_x + BUTTON_WIDTH + BUTTON_GAP, dialog_y + 150, BUTTON_WIDTH, BUTTON_HEIGHT); replay_rect = pygame.Rect(first_row_start_x + 2 * (BUTTON_WIDTH + BUTTON_GAP), dialog_y + 150, BUTTON_WIDTH, BUTTON_HEIGHT)
    play_again_rect = pygame.Rect(second_row_start_x, dialog_y + 190, BUTTON_WIDTH, BUTTON_HEIGHT); stats_rect = pygame.Rect(second_row_start_x + BUTTON_WIDTH + BUTTON_GAP, dialog_y + 190, BUTTON_WIDTH, BUTTON_HEIGHT)
    pygame.draw.rect(screen, BUTTON_COLOR, save_rect); pygame.draw.rect(screen, BUTTON_COLOR, quit_rect); pygame.draw.rect(screen, BUTTON_COLOR, replay_rect); pygame.draw.rect(screen, BUTTON_COLOR, play_again_rect); pygame.draw.rect(screen, BUTTON_COLOR, stats_rect)
    screen.blit(save_text, save_text.get_rect(center=save_rect.center)); screen.blit(quit_text, quit_text.get_rect(center=quit_rect.center)); screen.blit(replay_text, replay_text.get_rect(center=replay_rect.center)); screen.blit(play_again_text, play_again_text.get_rect(center=play_again_rect.center)); screen.blit(stats_text, stats_text.get_rect(center=stats_rect.center))
    return save_rect, quit_rect, replay_rect, play_again_rect, stats_rect

def draw_score_row(screen, dialog_x, y_pos, final_scores):
    """Draw the score row for the statistics dialog."""
    score_label = ui_font.render("Score:", True, BLACK); p1_score_text = ui_font.render(str(final_scores[0]), True, BLACK); p2_score_text = ui_font.render(str(final_scores[1]), True, BLACK)
    screen.blit(score_label, (dialog_x + 10, y_pos)); screen.blit(p1_score_text, (dialog_x + 120, y_pos)); screen.blit(p2_score_text, (dialog_x + 230, y_pos))

def calculate_moves_per_player(move_history):
    """Calculate the number of moves made by each player from move_history."""
    moves_count = {1: 0, 2: 0}
    for move in move_history:
        player = move['player']
        # --- CORRECTED INDENTATION START ---
        if move['move_type'] in ['place', 'pass', 'exchange']:
            moves_count[player] += 1
        # --- CORRECTED INDENTATION END ---
    return moves_count[1], moves_count[2]

def calculate_bingos_per_player(move_history):
    """Calculate the number of bingos played by each player."""
    bingo_count = {1: 0, 2: 0}
    for move in move_history:
        if move['move_type'] == 'place' and move.get('is_bingo', False): player = move['player']; bingo_count[player] += 1
    return bingo_count[1], bingo_count[2]

def calculate_bingo_avg_per_player(move_history):
    """Calculate the average score of bingos for each player."""
    bingo_scores = {1: [], 2: []}
    for move in move_history:
        if move['move_type'] == 'place' and move.get('is_bingo', False): player = move['player']; bingo_scores[player].append(move['score'])
    avg_p1 = sum(bingo_scores[1]) / len(bingo_scores[1]) if bingo_scores[1] else 0.0; avg_p2 = sum(bingo_scores[2]) / len(bingo_scores[2]) if bingo_scores[2] else 0.0
    return avg_p1, avg_p2

def draw_moves_row(screen, dialog_x, y_pos, moves_p1, moves_p2):
    """Draw the moves row for the statistics dialog."""
    moves_label = ui_font.render("Moves:", True, BLACK); p1_moves_text = ui_font.render(str(moves_p1), True, BLACK); p2_moves_text = ui_font.render(str(moves_p2), True, BLACK)
    screen.blit(moves_label, (dialog_x + 10, y_pos)); screen.blit(p1_moves_text, (dialog_x + 120, y_pos)); screen.blit(p2_moves_text, (dialog_x + 230, y_pos))

def draw_avg_score_row(screen, dialog_x, y_pos, avg_p1, avg_p2):
    """Draw the average score per move row for the statistics dialog."""
    avg_label = ui_font.render("Avg Score:", True, BLACK); p1_avg_text = ui_font.render(f"{avg_p1:.2f}", True, BLACK); p2_avg_text = ui_font.render(f"{avg_p2:.2f}", True, BLACK)
    screen.blit(avg_label, (dialog_x + 10, y_pos)); screen.blit(p1_avg_text, (dialog_x + 120, y_pos)); screen.blit(p2_avg_text, (dialog_x + 230, y_pos))

def draw_bingos_row(screen, dialog_x, y_pos, bingos_p1, bingos_p2):
    """Draw the bingos row for the statistics dialog."""
    bingos_label = ui_font.render("Bingos:", True, BLACK); p1_bingos_text = ui_font.render(str(bingos_p1), True, BLACK); p2_bingos_text = ui_font.render(str(bingos_p2), True, BLACK)
    screen.blit(bingos_label, (dialog_x + 10, y_pos)); screen.blit(p1_bingos_text, (dialog_x + 120, y_pos)); screen.blit(p2_bingos_text, (dialog_x + 230, y_pos))

def draw_bingo_avg_row(screen, dialog_x, y_pos, bingo_avg_p1, bingo_avg_p2, bingos_p1, bingos_p2):
    """Draw the average bingo score row."""
    bingo_avg_label = ui_font.render("Bingo Avg:", True, BLACK); p1_text = "N/A" if bingos_p1 == 0 else f"{bingo_avg_p1:.2f}"; p2_text = "N/A" if bingos_p2 == 0 else f"{bingo_avg_p2:.2f}"
    p1_bingo_avg_text = ui_font.render(p1_text, True, BLACK); p2_bingo_avg_text = ui_font.render(p2_text, True, BLACK)
    screen.blit(bingo_avg_label, (dialog_x + 10, y_pos)); screen.blit(p1_bingo_avg_text, (dialog_x + 120, y_pos)); screen.blit(p2_bingo_avg_text, (dialog_x + 230, y_pos))

def calculate_blanks_per_player(move_history):
    """Calculate the number of blanks played by each player."""
    blanks_p1 = 0; blanks_p2 = 0
    for move in move_history:
        if move['move_type'] == 'place': player = move['player']; blanks_count = len(move.get('blanks', set()))
        if player == 1: blanks_p1 += blanks_count
        elif player == 2: blanks_p2 += blanks_count
    return blanks_p1, blanks_p2

def draw_blanks_row(screen, dialog_x, y_pos, blanks_p1, blanks_p2):
    """Draw the blanks played row."""
    blanks_label = ui_font.render("Blanks:", True, BLACK); p1_blanks_text = ui_font.render(str(blanks_p1), True, BLACK); p2_blanks_text = ui_font.render(str(blanks_p2), True, BLACK)
    screen.blit(blanks_label, (dialog_x + 10, y_pos)); screen.blit(p1_blanks_text, (dialog_x + 120, y_pos)); screen.blit(p2_blanks_text, (dialog_x + 230, y_pos))

def draw_stats_dialog(dialog_x, dialog_y, player_names, final_scores, tiles):
    """Draw the complete statistics dialog."""
    stats_dialog_width, stats_dialog_height = 400, 360
    pygame.draw.rect(screen, DIALOG_COLOR, (dialog_x, dialog_y, stats_dialog_width, stats_dialog_height))
    pygame.draw.rect(screen, BLACK, (dialog_x, dialog_y, stats_dialog_width, stats_dialog_height), 2)

    title_text = dialog_font.render("Game Statistics", True, BLACK)
    screen.blit(title_text, (dialog_x + 10, dialog_y + 10))

    # Player Names Header
    p1_name_display = player_names[0] if player_names[0] else "Player 1"
    p2_name_display = player_names[1] if player_names[1] else "Player 2"
    p1_name_text = ui_font.render(p1_name_display, True, BLACK)
    p2_name_text = ui_font.render(p2_name_display, True, BLACK)
    screen.blit(p1_name_text, (dialog_x + 120, dialog_y + 40))
    screen.blit(p2_name_text, (dialog_x + 230, dialog_y + 40))

    # Calculate Stats
    moves_p1, moves_p2 = calculate_moves_per_player(move_history)
    avg_p1 = final_scores[0] / moves_p1 if moves_p1 > 0 else 0.00
    avg_p2 = final_scores[1] / moves_p2 if moves_p2 > 0 else 0.00
    bingos_p1, bingos_p2 = calculate_bingos_per_player(move_history)
    bingo_avg_p1, bingo_avg_p2 = calculate_bingo_avg_per_player(move_history)
    blanks_p1, blanks_p2 = calculate_blanks_per_player(move_history)

    # Draw Rows
    y = dialog_y + 70
    draw_score_row(screen, dialog_x, y, final_scores)
    y += 30
    draw_moves_row(screen, dialog_x, y, moves_p1, moves_p2)
    y += 30
    draw_avg_score_row(screen, dialog_x, y, avg_p1, avg_p2)
    y += 30
    draw_bingos_row(screen, dialog_x, y, bingos_p1, bingos_p2)
    y += 30
    draw_bingo_avg_row(screen, dialog_x, y, bingo_avg_p1, bingo_avg_p2, bingos_p1, bingos_p2)
    y += 30
    draw_blanks_row(screen, dialog_x, y, blanks_p1, blanks_p2)
    y += 30

    # OK Button
    ok_button_rect = pygame.Rect(dialog_x + stats_dialog_width - BUTTON_WIDTH - 10, dialog_y + stats_dialog_height - BUTTON_HEIGHT - 10, BUTTON_WIDTH, BUTTON_HEIGHT)
    hover = ok_button_rect.collidepoint(pygame.mouse.get_pos())
    color = BUTTON_HOVER if hover else BUTTON_COLOR
    pygame.draw.rect(screen, color, ok_button_rect)
    ok_text = button_font.render("OK", True, BLACK)
    ok_text_rect = ok_text.get_rect(center=ok_button_rect.center)
    screen.blit(ok_text, ok_text_rect)

    return ok_button_rect

def show_message_dialog(message, title="Message"):
    """Display a general message dialog with an OK button, wrapping text."""
    dialog_width, dialog_height = 400, 150; dialog_x = (WINDOW_WIDTH - dialog_width) // 2; dialog_y = (WINDOW_HEIGHT - dialog_height) // 2
    words = message.split(' '); lines = []; current_line = ''; max_line_width = dialog_width - 20
    for word in words: test_line = current_line + word + ' ';
    if ui_font.size(test_line)[0] < max_line_width: current_line = test_line
    else: lines.append(current_line.strip()); current_line = word + ' '
    if current_line: lines.append(current_line.strip())
    pygame.draw.rect(screen, DIALOG_COLOR, (dialog_x, dialog_y, dialog_width, dialog_height)); pygame.draw.rect(screen, BLACK, (dialog_x, dialog_y, dialog_width, dialog_height), 2)
    title_surf = dialog_font.render(title, True, BLACK); screen.blit(title_surf, (dialog_x + 10, dialog_y + 5))
    y_offset = 10 + dialog_font.get_linesize()
    for line in lines: text = ui_font.render(line, True, BLACK); screen.blit(text, (dialog_x + 10, dialog_y + y_offset)); y_offset += ui_font.get_linesize()
    ok_button_rect = pygame.Rect(dialog_x + dialog_width - BUTTON_WIDTH - 10, dialog_y + dialog_height - BUTTON_HEIGHT - 10, BUTTON_WIDTH, BUTTON_HEIGHT)
    hover = ok_button_rect.collidepoint(pygame.mouse.get_pos()); color = BUTTON_HOVER if hover else BUTTON_COLOR; pygame.draw.rect(screen, color, ok_button_rect)
    ok_text = button_font.render("OK", True, BLACK); ok_text_rect = ok_text.get_rect(center=ok_button_rect.center); screen.blit(ok_text, ok_text_rect)
    pygame.display.flip()
    dialog_running = True
    while dialog_running:
        for event in pygame.event.get():
            if event.type == pygame.QUIT: pygame.quit(); sys.exit()
            elif event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
                 if ok_button_rect.collidepoint(event.pos): return
            elif event.type == pygame.KEYDOWN:
                 if event.key == pygame.K_RETURN or event.key == pygame.K_KP_ENTER: return

def draw_practice_end_dialog(message):
    """Draw the dialog shown at the end of a practice puzzle."""
    dialog_width, dialog_height = 400, 180; dialog_x = (WINDOW_WIDTH - dialog_width) // 2; dialog_y = (WINDOW_HEIGHT - dialog_height) // 2
    pygame.draw.rect(screen, DIALOG_COLOR, (dialog_x, dialog_y, dialog_width, dialog_height)); pygame.draw.rect(screen, BLACK, (dialog_x, dialog_y, dialog_width, dialog_height), 2)
    words = message.split(' '); lines = []; current_line = ''; max_line_width = dialog_width - 20
    for word in words: test_line = current_line + word + ' ';
    if ui_font.size(test_line)[0] < max_line_width: current_line = test_line
    else: lines.append(current_line.strip()); current_line = word + ' '
    if current_line: lines.append(current_line.strip())
    y_offset = 15
    for line in lines: text_surf = ui_font.render(line, True, BLACK); screen.blit(text_surf, (dialog_x + 10, dialog_y + y_offset)); y_offset += ui_font.get_linesize()
    button_y = dialog_y + dialog_height - BUTTON_HEIGHT - 15; total_button_width = 3 * BUTTON_WIDTH + 2 * BUTTON_GAP; button_start_x = dialog_x + (dialog_width - total_button_width) // 2
    play_again_rect = pygame.Rect(button_start_x, button_y, BUTTON_WIDTH, BUTTON_HEIGHT); main_menu_rect = pygame.Rect(button_start_x + BUTTON_WIDTH + BUTTON_GAP, button_y, BUTTON_WIDTH, BUTTON_HEIGHT); quit_rect = pygame.Rect(button_start_x + 2 * (BUTTON_WIDTH + BUTTON_GAP), button_y, BUTTON_WIDTH, BUTTON_HEIGHT)
    pygame.draw.rect(screen, BUTTON_COLOR, play_again_rect); pygame.draw.rect(screen, BUTTON_COLOR, main_menu_rect); pygame.draw.rect(screen, BUTTON_COLOR, quit_rect)
    play_again_text = button_font.render("Play Again", True, BLACK); main_menu_text = button_font.render("Main Menu", True, BLACK); quit_text = button_font.render("Quit", True, BLACK)
    screen.blit(play_again_text, play_again_text.get_rect(center=play_again_rect.center)); screen.blit(main_menu_text, main_menu_text.get_rect(center=main_menu_rect.center)); screen.blit(quit_text, quit_text.get_rect(center=quit_rect.center))
    return play_again_rect, main_menu_rect, quit_rect

# End of Part 3

# Part 4 (Includes game logic helpers: get_words_played, remaining tiles, validation, anchors)
# get_words_played, get_remaining_tiles, draw_remaining_tiles, draw_arrow, is_valid_play, get_anchor_points (Unchanged from Part 4 provided previously)
def get_words_played(word_positions, tiles):
    """Get all word strings formed by a play based on tile positions."""
    if not word_positions: return []
    words_found = set(); rows_involved_list = []; cols_involved_list = []; valid_positions = True
    for item in word_positions:
        if isinstance(item, tuple) and len(item) >= 3: rows_involved_list.append(item[0]); cols_involved_list.append(item[1])
        else: print(f"Error in get_words_played: Invalid item format: {item}"); valid_positions = False; break
    if not valid_positions: return []
    rows_involved = set(rows_involved_list); cols_involved = set(cols_involved_list)
    if len(rows_involved) == 1: # Horizontal Check
        r = rows_involved.pop(); min_c = min(cols_involved_list); max_c = max(cols_involved_list)
        while min_c > 0 and tiles[r][min_c - 1]: min_c -= 1
        while max_c < GRID_SIZE - 1 and tiles[r][max_c + 1]: max_c += 1
        word_h = "".join(tiles[r][c] for c in range(min_c, max_c + 1) if tiles[r][c])
        if len(word_h) > 1: words_found.add(word_h)
    if len(cols_involved) == 1: # Vertical Check
        c = cols_involved.pop(); min_r = min(rows_involved_list); max_r = max(rows_involved_list)
        while min_r > 0 and tiles[min_r - 1][c]: min_r -= 1
        while max_r < GRID_SIZE - 1 and tiles[max_r + 1][c]: max_r += 1
        word_v = "".join(tiles[r][c] for r in range(min_r, max_r + 1) if tiles[r][c])
        if len(word_v) > 1: words_found.add(word_v)
    for r_new, c_new, _ in word_positions: # Cross Checks
        if len(rows_involved) == 1: # Vertical Cross
            min_r_cross = r_new; max_r_cross = r_new;
            while min_r_cross > 0 and tiles[min_r_cross - 1][c_new]: min_r_cross -= 1;
            while max_r_cross < GRID_SIZE - 1 and tiles[max_r_cross + 1][c_new]: max_r_cross += 1
            if max_r_cross > min_r_cross: cross_word_v = "".join(tiles[r][c_new] for r in range(min_r_cross, max_r_cross + 1) if tiles[r][c_new]);
            if len(cross_word_v) > 1: words_found.add(cross_word_v)
        if len(cols_involved) == 1: # Horizontal Cross
            min_c_cross = c_new; max_c_cross = c_new;
            while min_c_cross > 0 and tiles[r_new][min_c_cross - 1]: min_c_cross -= 1;
            while max_c_cross < GRID_SIZE - 1 and tiles[r_new][max_c_cross + 1]: max_c_cross += 1
            if max_c_cross > min_c_cross: cross_word_h = "".join(tiles[r_new][c] for c in range(min_c_cross, max_c_cross + 1) if tiles[r_new][c]);
            if len(cross_word_h) > 1: words_found.add(cross_word_h)
    return list(words_found)

def get_remaining_tiles(rack, tiles, blanks):
    """Calculate the remaining tiles (excluding those on board and current player's rack)."""
    remaining = {letter: count for letter, (count, _) in TILE_DISTRIBUTION.items()}
    rack_counter = Counter(rack)
    for tile, count in rack_counter.items():
        if tile in remaining: remaining[tile] -= count
    for r in range(GRID_SIZE):
        for c in range(GRID_SIZE):
            if tiles[r][c]:
                if (r, c) in blanks:
                    if ' ' in remaining: remaining[' '] -= 1
                else:
                    letter = tiles[r][c]
                    if letter in remaining: remaining[letter] -= 1
    for letter in remaining: remaining[letter] = max(0, remaining[letter])
    return remaining

def draw_remaining_tiles(remaining, turn):
    """Draw the list of remaining tiles."""
    global practice_mode
    if practice_mode == "eight_letter": return # Don't draw remaining tiles in this mode
    remaining_x = min(BOARD_SIZE + 70, WINDOW_WIDTH - 200);
    if remaining_x < BOARD_SIZE + 10: remaining_x = BOARD_SIZE + 10
    title_text = ui_font.render(f"P{turn}'s Unseen Tiles:", True, BLACK); screen.blit(title_text, (remaining_x, 10))
    y_pos = 40; col_width = 60; max_y = WINDOW_HEIGHT - 100; sorted_letters = sorted(remaining.keys()); current_col_x = remaining_x; items_in_col = 0; max_items_per_col = (max_y - y_pos) // 20
    if max_items_per_col <= 0: max_items_per_col = 1
    last_drawn_y = 40 # Initialize with starting y_pos in case list is empty
    last_drawn_col_x = remaining_x # Track the column x of the last item

    for letter in sorted_letters:
        count = remaining.get(letter, 0)
        if count > 0:
            display_letter = "?" if letter == " " else letter; text_str = f"{display_letter}: {count}"; text = tile_count_font.render(text_str, True, BLACK)
            if items_in_col >= max_items_per_col:
                y_pos = 40 # Reset y_pos for the new column
                current_col_x += col_width
                items_in_col = 0
            screen.blit(text, (current_col_x, y_pos))
            last_drawn_y = y_pos # Update the last drawn y position in the current column
            last_drawn_col_x = current_col_x # Update the column x
            y_pos += 20; items_in_col += 1

    # Calculate summary position directly below the last drawn item's position
    # Add the height of one line (20) to get the position below it, plus a small gap (e.g., 5)
    summary_y_start = last_drawn_y + 20 + 5
    # Ensure it doesn't go off screen
    summary_y_start = min(summary_y_start, max_y + 40) # Use max_y for clamping

    total_tiles = sum(remaining.values()); vowels = sum(remaining.get(letter, 0) for letter in 'AEIOU'); consonants = sum(remaining.get(letter, 0) for letter in remaining if letter.isalpha() and letter not in 'AEIOU '); blanks_rem = remaining.get(' ', 0)
    text1 = tile_count_font.render(f"Tiles remaining: {total_tiles}", True, BLACK); text2 = tile_count_font.render(f"V: {vowels}  C: {consonants}  B: {blanks_rem}", True, BLACK)

    # Align summary text x-coordinate with the start of the list columns
    summary_x = remaining_x
    screen.blit(text1, (summary_x, summary_y_start));
    screen.blit(text2, (summary_x, summary_y_start + 20)) # Draw second line below first

def draw_arrow(row, col, direction):
    """Draw an arrow indicating play direction."""
    center_x = 40 + col * SQUARE_SIZE + SQUARE_SIZE // 2; center_y = 40 + row * SQUARE_SIZE + SQUARE_SIZE // 2; arrow_length = SQUARE_SIZE * 0.4; arrow_width = SQUARE_SIZE * 0.2
    if direction == "right": pygame.draw.line(screen, ARROW_COLOR, (center_x - arrow_length / 2, center_y), (center_x + arrow_length / 2, center_y), 3); pygame.draw.polygon(screen, ARROW_COLOR, [(center_x + arrow_length / 2, center_y - arrow_width / 2), (center_x + arrow_length / 2, center_y + arrow_width / 2), (center_x + arrow_length / 2 + arrow_width, center_y)])
    elif direction == "down": pygame.draw.line(screen, ARROW_COLOR, (center_x, center_y - arrow_length / 2), (center_x, center_y + arrow_length / 2), 3); pygame.draw.polygon(screen, ARROW_COLOR, [(center_x - arrow_width / 2, center_y + arrow_length / 2), (center_x + arrow_width / 2, center_y + arrow_length / 2), (center_x, center_y + arrow_length / 2 + arrow_width)])

def is_valid_play(word_positions, tiles, is_first_play, initial_rack_size, original_tiles, rack):
    """Validate a potential play against game rules and dictionary."""
    # word_positions here is the list of newly placed tiles: [(r, c, letter), ...]
    if not word_positions:
        # print("DEBUG is_valid_play: No word_positions provided.")
        return False, False

    newly_placed_positions_coords = set((r, c) for r, c, _ in word_positions)
    if not newly_placed_positions_coords:
        # print("DEBUG is_valid_play: No new tiles identified.")
        return False, False # No new tiles placed

    # --- Alignment and Gap Checks (remain the same) ---
    rows = sorted(list(set(r for r, _, _ in word_positions))); cols = sorted(list(set(c for _, c, _ in word_positions)))
    is_horizontal = len(rows) == 1; is_vertical = len(cols) == 1
    if not (is_horizontal or is_vertical):
        # print(f"DEBUG is_valid_play: Not aligned. Rows: {rows}, Cols: {cols}")
        return False, False # Not aligned

    # Check for gaps within the main line of play
    if is_horizontal:
        r = rows[0]; min_col = min(cols); max_col = max(cols)
        # Extend bounds to include adjacent existing tiles
        temp_min_col = min_col; temp_max_col = max_col
        while temp_min_col > 0 and tiles[r][temp_min_col - 1]: temp_min_col -= 1
        while temp_max_col < GRID_SIZE - 1 and tiles[r][temp_max_col + 1]: temp_max_col += 1
        # Check for empty squares within these bounds
        for c in range(temp_min_col, temp_max_col + 1):
            if not tiles[r][c]:
                # print(f"DEBUG is_valid_play: Gap found horizontally at ({r},{c})")
                return False, False # Gap found
    elif is_vertical:
        c = cols[0]; min_row = min(rows); max_row = max(rows)
        # Extend bounds
        temp_min_row = min_row; temp_max_row = max_row
        while temp_min_row > 0 and tiles[temp_min_row - 1][c]: temp_min_row -= 1
        while temp_max_row < GRID_SIZE - 1 and tiles[temp_max_row + 1][c]: temp_max_row += 1
        # Check for gaps
        for r in range(temp_min_row, temp_max_row + 1):
            if not tiles[r][c]:
                # print(f"DEBUG is_valid_play: Gap found vertically at ({r},{c})")
                return False, False # Gap found

    # --- Word Validity Check (Use find_all_words_formed) ---
    # Use the more robust function to find all words based on the newly placed tiles
    # It correctly handles single-tile placements forming cross-words.
    all_words_details = find_all_words_formed(word_positions, tiles)

    if not all_words_details:
         # This might happen if only a single letter was placed and it didn't connect
         # to form any word of length 2+ (already checked by connection rule below)
         # Or if find_all_words_formed has a bug.
         # Let's assume connection rule handles the first case.
         # If this triggers otherwise, it indicates an issue.
         # print(f"DEBUG is_valid_play: find_all_words_formed returned empty list for {word_positions}")
         # We might need a connection check *before* this word check?
         pass # Continue to connection check

    formed_word_strings = ["".join(tile[2] for tile in word_detail) for word_detail in all_words_details]

    if not formed_word_strings and len(word_positions) > 1: # If multiple tiles placed but no words formed -> invalid
         # print(f"DEBUG is_valid_play: Multiple tiles placed but no words formed: {word_positions}")
         return False, False

    # Check each formed word string against the DAWG
    for word in formed_word_strings:
        if not DAWG.search(word):
            # print(f"DEBUG is_valid_play: Word '{word}' not in DAWG.")
            return False, False # Word not in dictionary

    # --- Connection Rules Check (remain the same) ---
    if is_first_play:
        if CENTER_SQUARE not in newly_placed_positions_coords:
            # print("DEBUG is_valid_play: First play not on center square.")
            return False, False
    else:
        connects = False
        for r, c in newly_placed_positions_coords:
            for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < GRID_SIZE and 0 <= nc < GRID_SIZE and original_tiles[nr][nc]:
                    connects = True; break
            if connects: break
        if not connects:
            # print("DEBUG is_valid_play: Play does not connect to existing tiles.")
            return False, False

    # --- Bingo Check (remains the same) ---
    tiles_played_from_rack = len(newly_placed_positions_coords)
    is_bingo = (initial_rack_size == 7 and tiles_played_from_rack == 7)

    # If all checks passed
    return True, is_bingo

def get_anchor_points(tiles, is_first_play):
    """Get anchor points (empty squares adjacent to existing tiles) for valid moves."""
    anchors = set()
    if is_first_play: anchors.add(CENTER_SQUARE); return anchors
    has_tiles = False
    for r in range(GRID_SIZE):
        for c in range(GRID_SIZE):
            if tiles[r][c]: has_tiles = True # Check if board has any tiles
            if not tiles[r][c]: # Must be an empty square
                 is_anchor = False
                 for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
                     nr, nc = r + dr, c + dc
                     if 0 <= nr < GRID_SIZE and 0 <= nc < GRID_SIZE and tiles[nr][nc]: is_anchor = True; break
                 if is_anchor: anchors.add((r, c))
    if not has_tiles and not is_first_play: anchors.add(CENTER_SQUARE) # Fallback if board empty but not first play
    return anchors

# End of Part 4

# python
# MODIFIED: 01APR24 - Implementing 8-Letter Bingo Practice Mode Fixes (Part 5 - Corrected Attribute Name)

# Part 5

# --- NEW Move Generation (Based on kamilmielnik/scrabble-solver principles) ---
# --- NEW Move Generation (Based on kamilmielnik/scrabble-solver principles - REVISED) ---

# --- GADDAG-Based Move Generation (Replaces generate_valid_moves_new) ---

# --- GADDAG-Based Move Generation (Replaces generate_valid_moves_new and its helpers) ---

# --- GADDAG-Based Move Generation (Replaces generate_valid_moves_new and its helpers) ---

# --- GADDAG-Based Move Generation (Replaces generate_valid_moves_new and its helpers) ---

# Function to Modify: _gaddag_traverse (Refined post-separator logic)

def _gaddag_traverse(
    anchor_pos, rack_counts, tiles, board, blanks, cross_check_sets, gaddag_node,
    current_word_tiles, is_reversed, current_axis, all_found_moves, unique_move_signatures,
    original_tiles_state, is_first_play, full_rack_size, max_len=GRID_SIZE,
    depth=0
):
    """ Recursive helper with refined post-separator logic """
    # Limit recursion depth for safety and logging
    if depth > 20: return

    # --- Base Cases and Pruning ---
    if not current_word_tiles: return
    if len(current_word_tiles) > max_len: return

    # Get the last tile added for step calculation (but might need anchor later)
    r_last, c_last, _, _, _ = current_word_tiles[-1]

    # --- Check if current path forms a valid move ---
    # (Validation logic remains the same as previous version with diagnostic prints)
    if gaddag_node.is_terminal and not is_reversed:
        # ... (validation code identical to previous response) ...
        # Find newly placed tiles
        newly_placed_list_details = [(r, c, l) for r, c, l, _, is_new in current_word_tiles if is_new]
        if newly_placed_list_details:
            new_tiles_sig = tuple(sorted(newly_placed_list_details))
            if new_tiles_sig not in unique_move_signatures:
                # Simulate placement for validation
                temp_tiles = [row[:] for row in original_tiles_state]
                temp_blanks = set(blanks); move_blanks_coords = set(); newly_placed_coords = set()
                for r, c, letter, is_blank, is_new in current_word_tiles:
                    if is_new:
                        if 0 <= r < GRID_SIZE and 0 <= c < GRID_SIZE:
                            temp_tiles[r][c] = letter; newly_placed_coords.add((r, c))
                            if is_blank: temp_blanks.add((r, c)); move_blanks_coords.add((r, c))

                # Use the ORIGINAL is_valid_play now (remove diagnostic version)
                is_valid, is_bingo = is_valid_play(newly_placed_list_details, temp_tiles, is_first_play, full_rack_size, original_tiles_state, rack_counts) # Pass original_tiles_state

                if is_valid:
                    unique_move_signatures.add(new_tiles_sig) # Mark as found
                    score = calculate_score(newly_placed_list_details, board, temp_tiles, temp_blanks)
                    all_words_formed_details = find_all_words_formed(newly_placed_list_details, temp_tiles)
                    # ... (rest of move detail extraction identical to previous response) ...
                    primary_word_tiles = []; primary_word_str = ""; start_pos = (0, 0); orientation = current_axis
                    if all_words_formed_details:
                        # ... (primary word finding logic) ...
                         found_primary = False
                         for word_detail in all_words_formed_details:
                             is_along_axis = False
                             if orientation == 'H' and len(set(r for r,c,l in word_detail)) == 1: is_along_axis = True
                             elif orientation == 'V' and len(set(c for r,c,l in word_detail)) == 1: is_along_axis = True
                             if is_along_axis and any((t[0], t[1]) in newly_placed_coords for t in word_detail):
                                 primary_word_tiles = word_detail; found_primary = True; break
                         if not found_primary: # Fallback
                              for word_detail in all_words_formed_details:
                                  if any((t[0], t[1]) in newly_placed_coords for t in word_detail):
                                       primary_word_tiles = word_detail
                                       if len(set(r for r,c,l in primary_word_tiles)) == 1: orientation = 'H'
                                       elif len(set(c for r,c,l in primary_word_tiles)) == 1: orientation = 'V'
                                       break
                         if not primary_word_tiles and all_words_formed_details: # Extreme fallback
                              primary_word_tiles = all_words_formed_details[0]
                              if len(set(r for r,c,l in primary_word_tiles)) == 1: orientation = 'H'
                              elif len(set(c for r,c,l in primary_word_tiles)) == 1: orientation = 'V'

                         if primary_word_tiles: # Check added
                             primary_word_str = "".join(t[2] for t in primary_word_tiles)
                             start_pos = (primary_word_tiles[0][0], primary_word_tiles[0][1])
                    # ... (word_with_blanks formatting) ...
                    word_with_blanks_list = []
                    for wr, wc, w_letter in primary_word_tiles:
                        is_blank_in_word = (wr, wc) in newly_placed_coords and (wr, wc) in move_blanks_coords
                        word_with_blanks_list.append(w_letter.lower() if is_blank_in_word else w_letter.upper())
                    word_with_blanks = "".join(word_with_blanks_list)
                    leave = list(rack_counts.elements()) # Current rack count is the leave
                    # ... (store move details) ...
                    move_details_dict = {
                        'positions': [(t[0], t[1], t[2]) for t in primary_word_tiles], 'blanks': move_blanks_coords,
                        'word': primary_word_str, 'score': score, 'start': start_pos, 'direction': orientation,
                        'leave': leave, 'is_bingo': is_bingo, 'word_with_blanks': word_with_blanks,
                        'newly_placed': newly_placed_list_details
                    }
                    all_found_moves.append(move_details_dict)


    # --- Explore Next Steps ---
    for letter, next_node in gaddag_node.children.items():
        if letter == Gaddag.SEPARATOR:
            if is_reversed:
                # When crossing the separator, the *anchor position* becomes the reference
                # for the next step calculation in the forward direction.
                # We pass the anchor_pos implicitly; the logic needs to use it.
                # We pass current_word_tiles as is, because it contains the history.
                _gaddag_traverse(
                    anchor_pos, rack_counts, tiles, board, blanks, cross_check_sets,
                    next_node, current_word_tiles, False, current_axis, # Switch is_reversed
                    all_found_moves, unique_move_signatures, original_tiles_state,
                    is_first_play, full_rack_size, max_len, depth + 1
                )
            continue # Move to next child

        # Determine next coordinates
        next_r, next_c = -1, -1
        if is_reversed:
             # Moving backward from the last placed tile (r_last, c_last)
            if current_axis == 'H': next_r, next_c = r_last, c_last - 1 # Left
            else:                   next_r, next_c = r_last - 1, c_last # Up
        else: # Moving forward
            # **** CORRECTED LOGIC ****
            # If current_word_tiles only contains the anchor tile (or tiles placed *before* it),
            # the first step *forward* must be relative to the anchor_pos.
            # Otherwise, step forward from the last placed tile (r_last, c_last).

            # Check if the anchor position is the last element added *or* if all tiles were placed before anchor
            # A simple check: is the anchor position the first tile in our list (and maybe the only one)?
            # A better check: find the tile actually placed *on* the anchor square.
            anchor_r, anchor_c = anchor_pos
            tile_on_anchor = None
            for t_r, t_c, t_l, t_b, t_n in current_word_tiles:
                 if t_r == anchor_r and t_c == anchor_c:
                      tile_on_anchor = (t_r, t_c)
                      break

            # If we haven't placed anything *after* the anchor yet, step from the anchor
            # This happens immediately after crossing the separator.
            # How to detect this? If the last tile added IS the tile_on_anchor
            # or if all tiles were added when is_reversed was True?
            # Let's use the anchor_pos directly as the reference point
            # for the first step in the forward direction.

            # Heuristic: If the last tile's coordinates are the same as the anchor,
            # then the next step must be the first step *away* from the anchor.
            # What if multiple tiles were placed reversed? The last tile isn't the anchor.
            # --> Need a robust way to know if we are taking the *first* step forward.

            # Let's track if we JUST crossed the separator. A simple way is if the last tile
            # added was before or at the anchor point based on axis and anchor coords.
            just_crossed_separator = False
            if len(current_word_tiles) > 0:
                if current_axis == 'H':
                    if c_last <= anchor_c: just_crossed_separator = True
                else: # Vertical
                    if r_last <= anchor_r: just_crossed_separator = True

            # Use anchor as reference ONLY if we just crossed separator, otherwise use last tile
            ref_r, ref_c = (anchor_r, anchor_c) if just_crossed_separator else (r_last, c_last)

            if current_axis == 'H': next_r, next_c = ref_r, ref_c + 1 # Move right
            else:                   next_r, next_c = ref_r + 1, ref_c # Move down
            # **** END CORRECTED LOGIC ****


        # Bounds check
        if not (0 <= next_r < GRID_SIZE and 0 <= next_c < GRID_SIZE): continue

        next_pos = (next_r, next_c)
        existing_tile = tiles[next_r][next_c]

        # Case 1: Square is empty
        # (Rest of logic for placing rack/blank or using existing tile remains the same)
        if not existing_tile:
            cross_axis = 'V' if current_axis == 'H' else 'H'
            allowed_letters = cross_check_sets.get(next_pos, {}).get(cross_axis, set())
            # Option 1a: Use regular tile
            if rack_counts[letter] > 0 and letter in allowed_letters:
                new_rack_counts = rack_counts.copy(); new_rack_counts[letter] -= 1
                if new_rack_counts[letter] == 0: del new_rack_counts[letter]
                _gaddag_traverse(
                    anchor_pos, new_rack_counts, tiles, board, blanks, cross_check_sets,
                    next_node, current_word_tiles + [(next_r, next_c, letter, False, True)],
                    is_reversed, current_axis, all_found_moves, unique_move_signatures,
                    original_tiles_state, is_first_play, full_rack_size, max_len, depth + 1
                )
            # Option 1b: Use blank tile
            if rack_counts[' '] > 0 and ' ' in allowed_letters:
                new_rack_counts = rack_counts.copy(); new_rack_counts[' '] -= 1
                if new_rack_counts[' '] == 0: del new_rack_counts[' ']
                _gaddag_traverse(
                    anchor_pos, new_rack_counts, tiles, board, blanks, cross_check_sets,
                    next_node, current_word_tiles + [(next_r, next_c, letter, True, True)],
                    is_reversed, current_axis, all_found_moves, unique_move_signatures,
                    original_tiles_state, is_first_play, full_rack_size, max_len, depth + 1
                )
        # Case 2: Square has matching existing tile
        elif existing_tile == letter:
            _gaddag_traverse(
                anchor_pos, rack_counts, tiles, board, blanks, cross_check_sets,
                next_node, current_word_tiles + [(next_r, next_c, letter, False, False)],
                is_reversed, current_axis, all_found_moves, unique_move_signatures,
                original_tiles_state, is_first_play, full_rack_size, max_len, depth + 1
            )

# Function to Replace: generate_all_moves_gaddag
# REASON: Includes corrected initiation logic for Strategy 2 (essential for general cases)
#         and reviewed logic for Strategy 1 (intended to handle first play).

def generate_all_moves_gaddag(rack, tiles, board, blanks, gaddag_root):
    """
    Generates ALL valid Scrabble moves using GADDAG traversal.
    Initiates the traversal from anchor points and adjacent existing tiles.
    Includes corrected Strategy 2 initiation.
    """
    print(f"--- generate_all_moves_gaddag called. Rack: {''.join(sorted(rack))} ---") # Sort rack for consistent logging
    if not gaddag_root:
        print("ERROR: GADDAG structure not loaded.")
        return []

    all_found_moves = []
    unique_move_signatures = set() # Tracks signatures (new_r, new_c, new_l) to avoid adding identical plays
    rack_counts = Counter(rack)
    is_first_play = sum(1 for row in tiles for t in row if t) == 0
    anchors = get_anchor_points(tiles, is_first_play)
    print(f"--- generate_all_moves_gaddag: Found anchors: {anchors} ---")
    original_tiles_state = [row[:] for row in tiles] # Keep a safe copy
    full_rack_size = len(rack) # Needed for bingo check

    # --- Precompute Cross-Check Sets ---
    print("--- generate_all_moves_gaddag: Generating cross-check sets... ---")
    cross_check_sets = {}
    for r in range(GRID_SIZE):
        for c in range(GRID_SIZE):
            if not tiles[r][c]: # Only needed for empty squares
                # Check Vertical context
                up_word = ""; rr = r - 1
                while rr >= 0 and tiles[rr][c]: up_word = tiles[rr][c] + up_word; rr -= 1
                down_word = ""; rr = r + 1
                while rr < GRID_SIZE and tiles[rr][c]: down_word += tiles[rr][c]; rr += 1
                allowed_letters_v = set()
                if not up_word and not down_word: allowed_letters_v = set('ABCDEFGHIJKLMNOPQRSTUVWXYZ ')
                else:
                    for letter in 'ABCDEFGHIJKLMNOPQRSTUVWXYZ':
                        if DAWG.search(up_word + letter + down_word): allowed_letters_v.add(letter)
                    if allowed_letters_v: allowed_letters_v.add(' ')

                # Check Horizontal context
                left_word = ""; cc = c - 1
                while cc >= 0 and tiles[r][cc]: left_word = tiles[r][cc] + left_word; cc -= 1
                right_word = ""; cc = c + 1
                while cc < GRID_SIZE and tiles[r][cc]: right_word += tiles[r][cc]; cc += 1
                allowed_letters_h = set()
                if not left_word and not right_word: allowed_letters_h = set('ABCDEFGHIJKLMNOPQRSTUVWXYZ ')
                else:
                    for letter in 'ABCDEFGHIJKLMNOPQRSTUVWXYZ':
                        if DAWG.search(left_word + letter + right_word): allowed_letters_h.add(letter)
                    if allowed_letters_h: allowed_letters_h.add(' ')

                cross_check_sets[(r, c)] = {'V': allowed_letters_v, 'H': allowed_letters_h}
    print("--- generate_all_moves_gaddag: Cross-check sets generated. ---")

    # --- Initiate Traversal from Each Anchor ---
    print("--- generate_all_moves_gaddag: Starting traversal... ---")
    processed_adjacent_starts = set() # Prevent redundant starts *from the same adjacent tile* for different anchors

    for r_anchor, c_anchor in anchors:
        anchor_pos = (r_anchor, c_anchor)

        # --- Strategy 1: Place the first letter *on* the anchor square itself ---
        # This is the primary strategy for the first move of the game.
        allowed_h = cross_check_sets.get(anchor_pos, {}).get('H', set())
        allowed_v = cross_check_sets.get(anchor_pos, {}).get('V', set())
        # Try placing regular tiles from rack onto the anchor
        for tile_letter, count in list(rack_counts.items()):
            if count > 0 and tile_letter != ' ':
                if tile_letter in gaddag_root.children:
                    next_node = gaddag_root.children[tile_letter]
                    # Create a fresh copy for each starting path
                    new_rack_counts = rack_counts.copy(); new_rack_counts[tile_letter] -= 1
                    if new_rack_counts[tile_letter] == 0: del new_rack_counts[tile_letter]
                    initial_tiles = [(r_anchor, c_anchor, tile_letter, False, True)]
                    # Initiate HORIZONTAL exploration (checks Vertical cross-check)
                    if tile_letter in allowed_v:
                         # Pass a copy of the rack counter
                         _gaddag_traverse(anchor_pos, new_rack_counts.copy(), tiles, board, blanks, cross_check_sets, next_node, initial_tiles, True, 'H', all_found_moves, unique_move_signatures, original_tiles_state, is_first_play, full_rack_size)
                    # Initiate VERTICAL exploration (checks Horizontal cross-check)
                    if tile_letter in allowed_h:
                         # Pass a copy of the rack counter
                         _gaddag_traverse(anchor_pos, new_rack_counts.copy(), tiles, board, blanks, cross_check_sets, next_node, initial_tiles, True, 'V', all_found_moves, unique_move_signatures, original_tiles_state, is_first_play, full_rack_size)
        # Try placing a blank tile from rack onto the anchor
        if rack_counts[' '] > 0:
            if ' ' in allowed_h and ' ' in allowed_v:
                # Create a base rack count with blank removed
                new_rack_counts_blank_base = rack_counts.copy(); new_rack_counts_blank_base[' '] -= 1
                if new_rack_counts_blank_base[' '] == 0: del new_rack_counts_blank_base[' ']

                for assigned_letter in 'ABCDEFGHIJKLMNOPQRSTUVWXYZ':
                    if assigned_letter in gaddag_root.children:
                        next_node = gaddag_root.children[assigned_letter]
                        initial_tiles = [(r_anchor, c_anchor, assigned_letter, True, True)]
                        # Initiate HORIZONTAL exploration
                        # Pass a copy for this branch
                        _gaddag_traverse(anchor_pos, new_rack_counts_blank_base.copy(), tiles, board, blanks, cross_check_sets, next_node, initial_tiles, True, 'H', all_found_moves, unique_move_signatures, original_tiles_state, is_first_play, full_rack_size)
                        # Initiate VERTICAL exploration
                        # Pass a copy for this branch
                        _gaddag_traverse(anchor_pos, new_rack_counts_blank_base.copy(), tiles, board, blanks, cross_check_sets, next_node, initial_tiles, True, 'V', all_found_moves, unique_move_signatures, original_tiles_state, is_first_play, full_rack_size)


        # --- Strategy 2: Start traversal from an *existing* tile adjacent to the anchor ---
        # This strategy only applies if not the first play (anchors != {(7,7)})
        if not is_first_play:
            for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]: # Check N, S, W, E neighbors
                nr, nc = r_anchor + dr, c_anchor + dc
                adj_pos = (nr, nc) # Position of the adjacent tile

                if 0 <= nr < GRID_SIZE and 0 <= nc < GRID_SIZE:
                    existing_tile_letter = tiles[nr][nc]
                    # Check if it's an existing tile AND we haven't already started traversals from this specific tile position
                    if existing_tile_letter and adj_pos not in processed_adjacent_starts:
                         # Mark this adjacent tile as processed FOR THIS generate_all_moves call
                         # to avoid redundant work if it's adjacent to multiple anchors.
                         processed_adjacent_starts.add(adj_pos)

                         if existing_tile_letter in gaddag_root.children:
                            next_node = gaddag_root.children[existing_tile_letter]
                            initial_tiles = [(nr, nc, existing_tile_letter, False, False)] # Existing tile is not blank, not new

                            # Determine the axis based on the direction *from* the existing tile *to* the anchor
                            start_axis = None
                            if dr != 0: start_axis = 'V' # Moved vertically to anchor, so word axis is Vertical
                            else:       start_axis = 'H' # Moved horizontally to anchor, so word axis is Horizontal

                            # **** Explore both directions from the adjacent tile ****
                            # Explore FORWARDS (away from existing tile, past the anchor)
                            _gaddag_traverse(
                                anchor_pos, rack_counts.copy(), tiles, board, blanks, cross_check_sets, # Pass copy of rack_counts
                                next_node, initial_tiles[:], False, start_axis, # is_reversed = False
                                all_found_moves, unique_move_signatures, original_tiles_state,
                                is_first_play, full_rack_size
                            )
                            # Explore BACKWARDS (towards where the existing tile came from - effectively extending the other way)
                            _gaddag_traverse(
                                anchor_pos, rack_counts.copy(), tiles, board, blanks, cross_check_sets, # Pass copy of rack_counts
                                next_node, initial_tiles[:], True, start_axis, # is_reversed = True
                                all_found_moves, unique_move_signatures, original_tiles_state,
                                is_first_play, full_rack_size
                            )


    print(f"--- generate_all_moves_gaddag: Traversal complete. Found {len(all_found_moves)} potential moves before sorting/final check. ---")

    # --- Post-processing ---
    all_found_moves.sort(key=lambda m: m['score'], reverse=True)
    final_unique_moves = []
    seen_final_signatures = set()
    for move in all_found_moves:
        # Signature includes sorted new tiles tuple + score
        sig_tuple = tuple(sorted(move['newly_placed'])) + (move['score'],)
        if sig_tuple not in seen_final_signatures:
            final_unique_moves.append(move)
            seen_final_signatures.add(sig_tuple)

    print(f"--- generate_all_moves_gaddag: Returning {len(final_unique_moves)} unique moves. ---")
    return final_unique_moves


# Corrected snippet for Part 5 - draw_hint_dialog

# --- Hint Dialog ---
def draw_hint_dialog(moves, selected_index):
    """Draw the hint dialog showing top 5 moves."""
    dialog_width, dialog_height = 400, 250
    dialog_x = (WINDOW_WIDTH - dialog_width) // 2
    dialog_y = (WINDOW_HEIGHT - dialog_height) // 2

    pygame.draw.rect(screen, DIALOG_COLOR, (dialog_x, dialog_y, dialog_width, dialog_height))
    pygame.draw.rect(screen, BLACK, (dialog_x, dialog_y, dialog_width, dialog_height), 2)

    title_text = dialog_font.render("Top 5 Moves" if moves else "No Moves Available", True, BLACK)
    screen.blit(title_text, (dialog_x + 10, dialog_y + 10))

    hint_rects = []
    y_pos = dialog_y + 40
    for i, move in enumerate(moves[:5]):
        color = HINT_SELECTED_COLOR if i == selected_index else HINT_NORMAL_COLOR
        rect = pygame.Rect(dialog_x + 10, y_pos, dialog_width - 20, 30)
        pygame.draw.rect(screen, color, rect)

        word = move.get('word', 'N/A')
        score = move.get('score', 0)
        start_pos = move.get('start', (0,0))
        direction = move.get('direction', 'right')
        leave = move.get('leave', [])
        word_display = move.get('word_with_blanks', word.upper()) # Use formatted word
        coord = get_coord(start_pos, direction)
        leave_str = ''.join(sorted(l if l != ' ' else '?' for l in leave))

        text_str = f"{i+1}. {word_display} ({score} pts) at {coord} ({leave_str})"
        text = ui_font.render(text_str, True, BLACK)

        # Truncate text if too wide
        max_text_width = rect.width - 10
        if text.get_width() > max_text_width:
             avg_char_width = text.get_width() / len(text_str) if len(text_str) > 0 else 10
             # Ensure avg_char_width is not zero to avoid division error
             if avg_char_width > 0:
                 max_chars = int(max_text_width / avg_char_width) - 3 # Calculate max_chars
                 # --- CORRECTED INDENTATION START ---
                 if max_chars < 5: # Check if max_chars is too small
                     max_chars = 5
                 text_str = text_str[:max_chars] + "..." # Truncate and add ellipsis
                 text = ui_font.render(text_str, True, BLACK) # Re-render the truncated text
                 # --- CORRECTED INDENTATION END ---
             # else: # Handle case where avg_char_width is 0 (e.g., empty text_str) - text won't be truncated anyway
             #    pass

        screen.blit(text, (dialog_x + 15, y_pos + 5))
        hint_rects.append(rect)
        y_pos += 30

    # Buttons
    button_y = dialog_y + dialog_height - BUTTON_HEIGHT - 10
    total_button_width = 3 * BUTTON_WIDTH + 2 * BUTTON_GAP
    button_start_x = dialog_x + (dialog_width - total_button_width) // 2

    play_button_rect = pygame.Rect(button_start_x, button_y, BUTTON_WIDTH, BUTTON_HEIGHT)
    all_words_button_rect = pygame.Rect(button_start_x + BUTTON_WIDTH + BUTTON_GAP, button_y, BUTTON_WIDTH, BUTTON_HEIGHT)
    ok_button_rect = pygame.Rect(button_start_x + 2 * (BUTTON_WIDTH + BUTTON_GAP), button_y, BUTTON_WIDTH, BUTTON_HEIGHT)

    # Draw buttons
    pygame.draw.rect(screen, BUTTON_COLOR, play_button_rect)
    pygame.draw.rect(screen, BUTTON_COLOR, all_words_button_rect)
    pygame.draw.rect(screen, BUTTON_COLOR, ok_button_rect)

    play_text = button_font.render("Play", True, BLACK)
    all_words_text = button_font.render("All Words", True, BLACK)
    ok_text = button_font.render("OK", True, BLACK)

    screen.blit(play_text, play_text.get_rect(center=play_button_rect.center))
    screen.blit(all_words_text, all_words_text.get_rect(center=all_words_button_rect.center))
    screen.blit(ok_text, ok_text.get_rect(center=ok_button_rect.center))

    return hint_rects, play_button_rect, ok_button_rect, all_words_button_rect

# End of Part 5

# python
# MODIFIED: 01APR24 - Implementing 8-Letter Bingo Practice Mode Fixes (Part 6)

# python
# MODIFIED: 01APR24 - Implementing 8-Letter Bingo Practice Mode Fixes (Part 6 - Corrected Function Call)

# Part 6

def draw_all_words_dialog(moves, selected_index, scroll_offset):
    """Draw the dialog showing all valid moves with scrolling."""
    dialog_x = (WINDOW_WIDTH - ALL_WORDS_DIALOG_WIDTH) // 2; dialog_y = (WINDOW_HEIGHT - ALL_WORDS_DIALOG_HEIGHT) // 2
    pygame.draw.rect(screen, DIALOG_COLOR, (dialog_x, dialog_y, ALL_WORDS_DIALOG_WIDTH, ALL_WORDS_DIALOG_HEIGHT)); pygame.draw.rect(screen, BLACK, (dialog_x, dialog_y, ALL_WORDS_DIALOG_WIDTH, ALL_WORDS_DIALOG_HEIGHT), 2)
    header_height = 40; unique_words_count = len(set(move.get('word', '') for move in moves if move.get('word'))); title_text = dialog_font.render(f"All Valid Moves ({unique_words_count} unique words, {len(moves)} plays)", True, BLACK); screen.blit(title_text, (dialog_x + 10, dialog_y + 10))
    content_area_y = dialog_y + header_height; button_area_height = BUTTON_HEIGHT + 30; content_area_height = ALL_WORDS_DIALOG_HEIGHT - header_height - button_area_height; content_area_rect = pygame.Rect(dialog_x, content_area_y, ALL_WORDS_DIALOG_WIDTH, content_area_height)
    content_height = len(moves) * 30; content_surface_width = max(1, ALL_WORDS_DIALOG_WIDTH - 20); content_surface = pygame.Surface((content_surface_width, content_height)); content_surface.fill(DIALOG_COLOR)
    all_words_rects = []; item_height = 30
    for i, move in enumerate(moves):
        y_pos_on_surface = i * item_height
        if y_pos_on_surface >= scroll_offset - item_height and y_pos_on_surface < scroll_offset + content_area_height:
            color = HINT_SELECTED_COLOR if i == selected_index else HINT_NORMAL_COLOR; rect_on_surface = pygame.Rect(10, y_pos_on_surface, content_surface_width - 20, item_height); pygame.draw.rect(content_surface, color, rect_on_surface)
            word = move.get('word', 'N/A'); score = move.get('score', 0); start_pos = move.get('start', (0,0)); direction = move.get('direction', 'right'); leave = move.get('leave', []); word_display = move.get('word_with_blanks', word.upper())
            coord = get_coord(start_pos, direction); leave_str = ''.join(sorted(l if l != ' ' else '?' for l in leave)); text_str = f"{i+1}. {word_display} ({score} pts) at {coord} ({leave_str})"; text = ui_font.render(text_str, True, BLACK)
            max_text_width = rect_on_surface.width - 10 # Truncate text

            # --- CORRECTED INDENTATION BLOCK START ---
            if text.get_width() > max_text_width:
                avg_char_width = text.get_width() / len(text_str) if len(text_str) > 0 else 10
                if avg_char_width > 0:
                    max_chars = int(max_text_width / avg_char_width) - 3
                    if max_chars < 5: max_chars = 5 # Ensure at least a few chars show
                    text_str = text_str[:max_chars] + "..."
                    text = ui_font.render(text_str, True, BLACK) # Re-render truncated text
                # else: # Handle case where avg_char_width is 0 (e.g., empty text_str) - text won't be truncated anyway
                #    pass
            # --- CORRECTED INDENTATION BLOCK END ---

            content_surface.blit(text, (15, y_pos_on_surface + 5))
            screen_y = content_area_y + y_pos_on_surface - scroll_offset; screen_rect = pygame.Rect(dialog_x + 10, screen_y, content_surface_width - 20, item_height)
            visible_top = content_area_y; visible_bottom = content_area_y + content_area_height; clipped_top = max(visible_top, screen_rect.top); clipped_bottom = min(visible_bottom, screen_rect.bottom)
            if clipped_bottom > clipped_top: clipped_rect = pygame.Rect(screen_rect.left, clipped_top, screen_rect.width, clipped_bottom - clipped_top); all_words_rects.append((clipped_rect, i))

    visible_area_on_surface = pygame.Rect(0, scroll_offset, content_surface_width, content_area_height); screen.blit(content_surface, (dialog_x + 10, content_area_y), visible_area_on_surface)
    pygame.draw.rect(screen, BLACK, (dialog_x + 10, content_area_y, content_surface_width, content_area_height), 1) # Optional border
    total_button_width = 2 * BUTTON_WIDTH + BUTTON_GAP; buttons_x = dialog_x + (ALL_WORDS_DIALOG_WIDTH - total_button_width) // 2; button_y = dialog_y + ALL_WORDS_DIALOG_HEIGHT - BUTTON_HEIGHT - 20
    play_button_rect = pygame.Rect(buttons_x, button_y, BUTTON_WIDTH, BUTTON_HEIGHT); ok_button_rect = pygame.Rect(buttons_x + BUTTON_WIDTH + BUTTON_GAP, button_y, BUTTON_WIDTH, BUTTON_HEIGHT)
    pygame.draw.rect(screen, BUTTON_COLOR, play_button_rect); pygame.draw.rect(screen, BUTTON_COLOR, ok_button_rect)
    play_text = button_font.render("Play", True, BLACK); ok_text = button_font.render("OK", True, BLACK)
    screen.blit(play_text, play_text.get_rect(center=play_button_rect.center)); screen.blit(ok_text, ok_text.get_rect(center=ok_button_rect.center))
    return all_words_rects, play_button_rect, ok_button_rect

# --- Mouse/Tile Interaction Helpers ---
# get_tile_under_mouse, get_insertion_index, count_consecutive_existing (Unchanged from Part 6 provided previously)
def get_tile_under_mouse(x, y, rack_start_x, rack_y, rack_len):
    """Determine which tile index (0 to rack_len-1) is under the mouse cursor."""
    # Iterate through each potential tile position on the rack
    for i in range(rack_len):
        # Calculate the x-coordinate for the current tile
        tile_x = rack_start_x + i * (TILE_WIDTH + TILE_GAP)
        # Create the rectangle for the current tile *inside* the loop
        tile_rect = pygame.Rect(tile_x, rack_y, TILE_WIDTH, TILE_HEIGHT)
        # Check if the mouse coordinates collide with this specific tile's rectangle *inside* the loop
        if tile_rect.collidepoint(x, y):
            return i # Return the index of the collided tile immediately
    # If the loop finishes without finding any collision (or if rack_len was 0), return None
    return None

def get_insertion_index(x, rack_start_x, rack_len):
    """Determine the insertion index (0 to rack_len) based on mouse x-position."""
    if x < rack_start_x + TILE_WIDTH // 2: return 0
    for i in range(rack_len): tile_left = rack_start_x + i * (TILE_WIDTH + TILE_GAP); gap_center = tile_left + TILE_WIDTH + TILE_GAP // 2;
    if x < gap_center: return i + 1
    return rack_len

def count_consecutive_existing(row, col, direction, tiles):
    """Count consecutive existing tiles in a direction (unused currently)."""
    count = 0
    if direction == "right": c = col;
    while c < GRID_SIZE and tiles[row][c]: count += 1; c += 1
    else: r = row;
    while r < GRID_SIZE and tiles[r][col]: count += 1; r += 1
    return count

# New function to handle end-of-game score adjustments
def calculate_final_scores(current_scores, racks, bag):
    """
    Calculates the final scores based on game end conditions and remaining tiles.

    Args:
        current_scores (list): List containing the scores of [Player1, Player2] before adjustments.
        racks (list): List containing the tile lists for [Player1's rack, Player2's rack].
        bag (list): The list representing the tile bag.

    Returns:
        list: A new list containing the final adjusted scores for [Player1, Player2].
    """
    final_scores = list(current_scores) # Start with a copy of current scores
    rack_values = [0, 0]

    # Calculate the value of tiles left on each rack (blanks count as 0)
    for i in range(2):
        if i < len(racks) and racks[i]: # Check if rack exists and is not None
             rack_values[i] = sum(TILE_DISTRIBUTION[tile][1] for tile in racks[i] if tile != ' ')
        # else: rack_values[i] remains 0

    # Determine if a player went out (must have empty rack AND bag must be empty)
    p1_out = (not racks[0]) and (not bag)
    p2_out = (not racks[1]) and (not bag)

    if p1_out:
        print("Final Score Adjust: P1 went out.")
        # Player 1 went out: Add double Player 2's remaining tile value to P1's score. P2 score unchanged.
        adjustment = 2 * rack_values[1]
        final_scores[0] += adjustment
        # final_scores[1] remains unchanged
        print(f"  P2 tiles value: {rack_values[1]}, P1 adjustment: +{adjustment}")
    elif p2_out:
        print("Final Score Adjust: P2 went out.")
        # Player 2 went out: Add double Player 1's remaining tile value to P2's score. P1 score unchanged.
        adjustment = 2 * rack_values[0]
        final_scores[1] += adjustment
        # final_scores[0] remains unchanged
        print(f"  P1 tiles value: {rack_values[0]}, P2 adjustment: +{adjustment}")
    else:
        # Neither player went out: Subtract each player's own remaining tile value from their score.
        print("Final Score Adjust: Neither player went out.")
        final_scores[0] -= rack_values[0]
        final_scores[1] -= rack_values[1]
        print(f"  P1 adjustment: -{rack_values[0]}, P2 adjustment: -{rack_values[1]}")

    print(f"  Scores before: {current_scores}, Scores after: {final_scores}")
    return final_scores


# --- Playing Moves ---
# Function to Modify: play_hint_move
# REASON: Added sorting of the rack *after* drawing new tiles.

def play_hint_move(move, tiles, racks, blanks, scores, turn, bag, board):
    """Plays a move (usually from hint/AI), updates state. Handles practice mode. Sorts rack."""
    global practice_mode, is_ai # Need is_ai to check if player is human

    player_idx = turn - 1
    if not (0 <= player_idx < len(racks)):
        print(f"Error: Invalid player index {player_idx} in play_hint_move.")
        return turn, [], []

    current_rack = racks[player_idx]
    move_positions = move.get('positions', [])
    move_blanks_coords = move.get('blanks', set())
    newly_placed_details = move.get('newly_placed', [])

    # --- Verification (no changes needed here) ---
    needed_tiles = Counter()
    blanks_needed_count = 0
    for r, c, letter in newly_placed_details:
        if (r, c) in move_blanks_coords: blanks_needed_count += 1
        else: needed_tiles[letter] += 1
    rack_counter = Counter(current_rack)
    if blanks_needed_count > rack_counter.get(' ', 0):
        print(f"Error playing move: Needs {blanks_needed_count} blanks, only {rack_counter.get(' ', 0)} available.")
        return turn, [], []
    for letter, count in needed_tiles.items():
        if rack_counter.get(letter, 0) < count:
            print(f"Error playing move: Needs {count} '{letter}', only {rack_counter.get(letter, 0)} available.")
            return turn, [], []
    # --- End Verification ---

    # Place tiles & update rack
    rack_after_play = current_rack[:] # Work with a copy
    for r, c, letter in newly_placed_details:
        tiles[r][c] = letter
        if (r, c) in move_blanks_coords:
            if ' ' in rack_after_play: rack_after_play.remove(' '); blanks.add((r, c))
            else: print("Error: Tried to play blank but none in rack_after_play!")
        else:
            if letter in rack_after_play: rack_after_play.remove(letter)
            else: print(f"Error: Tried to play '{letter}' but not in rack_after_play!")

    score = move.get('score', 0)
    scores[player_idx] += score # Update score

    # Draw new tiles (Skip in 8-letter practice)
    drawn_tiles = []
    if practice_mode != "eight_letter":
        num_to_draw = len(newly_placed_details)
        drawn_tiles = [bag.pop() for _ in range(num_to_draw) if bag]
        rack_after_play.extend(drawn_tiles)

    # --- ADDED SORTING ---
    # Sort the rack alphabetically if the player is human
    if not is_ai[player_idx]:
        rack_after_play.sort()
    # --- END ADDED SORTING ---

    racks[player_idx] = rack_after_play # Update main rack AFTER potential sort

    next_turn = turn if practice_mode == "eight_letter" else 3 - turn # Determine next turn
    return next_turn, drawn_tiles, newly_placed_details



# --- AI Logic ---
def ai_turn(turn, racks, tiles, board, blanks, scores, bag, first_play, pass_count, exchange_count, consecutive_zero_point_turns, player_names, dropdown_open=False, hinting=False, showing_all_words=False, letter_checks=None):
    """Handles the AI's turn, including pausing for Power Tile practice."""
    global last_word, last_score, last_start, last_direction, move_history, current_replay_turn, practice_mode, GADDAG_STRUCTURE

    # Skip AI turn entirely in 8-letter practice mode
    if practice_mode == "eight_letter":
        return turn, first_play, pass_count, exchange_count, consecutive_zero_point_turns, [], dropdown_open, hinting, showing_all_words, False, None

    print(f"AI Player {turn} turn started. Rack: {''.join(racks[turn-1])}")
    paused_for_power_tile = False
    current_power_tile = None # The specific power tile the player must use
    all_moves = [] # Initialize default

    # *** Generate moves using GADDAG ***
    if GADDAG_STRUCTURE:
        all_moves = generate_all_moves_gaddag(racks[turn-1], tiles, board, blanks, GADDAG_STRUCTURE.root)
    else:
        print("ERROR: AI cannot generate moves, GADDAG not loaded.")
        all_moves = []

    if all_moves is None: all_moves = []
    print(f"AI Player {turn} generated {len(all_moves)} moves.")

    # --- Power Tile Practice Pause Check ---
    if practice_mode == "power_tiles" and letter_checks:
        # Determine which power tiles are designated for practice
        checked_power_tiles = {letter for i, letter in enumerate(['J', 'Q', 'X', 'Z']) if letter_checks[i]}
        # Find which of *those* are actually on the current rack
        power_tiles_on_rack = sorted([tile for tile in racks[turn-1] if tile in checked_power_tiles]) # Sort alphabetically

        if power_tiles_on_rack:
            current_power_tile = power_tiles_on_rack[0] # Target the first one alphabetically
            paused_for_power_tile = True
            print(f"AI turn paused for power tile practice. Target: {current_power_tile}")
            # Return the generated moves so 'main' can use them for validation
            return turn, first_play, pass_count, exchange_count, consecutive_zero_point_turns, all_moves, dropdown_open, hinting, showing_all_words, paused_for_power_tile, current_power_tile

    # --- AI Action: Play, Exchange, or Pass (Only if not paused) ---
    move_rack_before = racks[turn-1][:]; exchanged_tiles_for_history = []
    if not racks[turn-1] and not bag: # Out of tiles
        print(f"AI {turn} passing (empty rack/bag)."); move_type = 'pass'; score = 0; word = ''; positions = []; blanks_used = set(); drawn_tiles = []; coord = ''; word_with_blanks = ''; is_bingo = False
        consecutive_zero_point_turns += 1; pass_count += 1; exchange_count = 0; next_turn = 3 - turn
    elif all_moves: # Play best move
        best_move = all_moves[0]; print(f"AI {turn} playing best move: {best_move.get('word','N/A')} for {best_move.get('score',0)} points.")
        next_turn, drawn_tiles, newly_placed = play_hint_move(best_move, tiles, racks, blanks, scores, turn, bag, board)
        move_type = 'place'; score = best_move.get('score', 0); word = best_move.get('word', 'N/A'); positions = best_move.get('positions', []); blanks_used = best_move.get('blanks', set())
        start = best_move.get('start', (0,0)); direction = best_move.get('direction', 'right'); coord = get_coord(start, direction); word_with_blanks = best_move.get('word_with_blanks', ''); is_bingo = best_move.get('is_bingo', False)
        first_play = False; consecutive_zero_point_turns = 0; pass_count = 0; exchange_count = 0
    elif len(bag) >= 7: # Exchange
        print(f"AI {turn} exchanging tiles."); num_to_exchange = min(len(racks[turn-1]), 3); tiles_to_exchange = racks[turn-1][:num_to_exchange]; exchanged_tiles_for_history = tiles_to_exchange[:]
        drawn_tiles = [bag.pop() for _ in range(num_to_exchange) if bag]; new_rack = racks[turn-1][num_to_exchange:] + drawn_tiles; racks[turn-1] = new_rack; bag.extend(tiles_to_exchange); random.shuffle(bag)
        move_type = 'exchange'; score = 0; word = ''; positions = []; blanks_used = set(); coord = ''; word_with_blanks = ''; is_bingo = False
        consecutive_zero_point_turns += 1; exchange_count += 1; pass_count = 0; next_turn = 3 - turn
    else: # Pass
        print(f"AI {turn} passing."); move_type = 'pass'; score = 0; word = ''; positions = []; blanks_used = set(); drawn_tiles = []; coord = ''; word_with_blanks = ''; is_bingo = False
        consecutive_zero_point_turns += 1; pass_count += 1; exchange_count = 0; next_turn = 3 - turn

    # Record Move
    move_data = {'player': turn, 'move_type': move_type, 'rack': move_rack_before, 'score': score, 'word': word, 'positions': positions, 'blanks': blanks_used, 'drawn': drawn_tiles, 'coord': coord, 'word_with_blanks': word_with_blanks, 'is_bingo': is_bingo}
    if move_type == 'exchange': move_data['exchanged_tiles'] = exchanged_tiles_for_history
    move_history.append(move_data); current_replay_turn = len(move_history)

    # Return updated state (return empty list for all_moves as AI turn consumed them if it played)
    return next_turn, first_play, pass_count, exchange_count, consecutive_zero_point_turns, [], dropdown_open, hinting, showing_all_words, paused_for_power_tile, current_power_tile



def power_tile_practice():
    """Placeholder function, logic moved elsewhere."""
    print("Power tile practice setup (handled by mode selection and AI turn).")

# End of Part 6

# python
# MODIFIED: 01APR24 - Implementing 8-Letter Bingo Practice Mode Fixes (Part 7)

# python
# MODIFIED: 01APR24 - Implementing 8-Letter Bingo Practice Mode Fixes (Part 7 - Corrected Function Call)

# python
# MODIFIED: 01APR24 - Implementing 8-Letter Bingo Practice Mode Fixes (Part 7 - Corrected Indentation)

# Part 7

def get_replay_state(turn_idx, initial_racks):
    """
    Recreate the game state up to turn_idx ITERATIVELY.
    Sorts the racks alphabetically before returning.
    """
    # Start with initial state (ensure deep copies)
    tiles_state = [['' for _ in range(GRID_SIZE)] for _ in range(GRID_SIZE)]
    blanks_state = set()
    scores_state = [0, 0]

    if not isinstance(initial_racks, list) or len(initial_racks) != 2 or \
       not isinstance(initial_racks[0], list) or not isinstance(initial_racks[1], list):
        print(f"Error: Invalid initial_racks format in get_replay_state: {initial_racks}")
        return tiles_state, blanks_state, scores_state, [[], []]

    racks_state = [initial_racks[0][:], initial_racks[1][:]]

    # Apply moves sequentially up to turn_idx
    for i in range(turn_idx):
        if i >= len(move_history):
             print(f"Warning: Replay index {i} out of bounds for move_history (len {len(move_history)})")
             break
        move = move_history[i]
        player_idx = move['player'] - 1

        # Get the rack state *before* applying this move's changes
        current_rack_before_move = racks_state[player_idx][:]
        rack_after_move = current_rack_before_move[:] # Work with a copy for this move

        if move['move_type'] == 'place':
            positions = move.get('positions', [])
            blanks_in_move = move.get('blanks', set())

            # Apply board changes and update rack based on *this* move
            for r, c, letter in positions:
                # Check if this square was empty *before* this move (using current tiles_state)
                is_newly_placed = (0 <= r < GRID_SIZE and 0 <= c < GRID_SIZE and not tiles_state[r][c])

                # Place tile on board state
                if 0 <= r < GRID_SIZE and 0 <= c < GRID_SIZE:
                    tiles_state[r][c] = letter
                    if (r, c) in blanks_in_move:
                        blanks_state.add((r, c))
                else:
                    print(f"Replay Warning: Invalid position ({r},{c}) in move {i}")
                    continue # Skip processing this invalid position

                # If it was newly placed, remove the corresponding tile from the rack_after_move
                if is_newly_placed:
                    if (r,c) in blanks_in_move:
                        if ' ' in rack_after_move: rack_after_move.remove(' ')
                        else: print(f"Replay Warning: Tried to remove blank from rack for move {i}, but not found.")
                    else:
                        if letter in rack_after_move: rack_after_move.remove(letter)
                        else: print(f"Replay Warning: Tried to remove '{letter}' from rack for move {i}, but not found.")

            # Update score
            scores_state[player_idx] += move.get('score', 0)
            # Add drawn tiles to the rack for the *next* turn's state
            rack_after_move.extend(move.get('drawn', []))
            racks_state[player_idx] = rack_after_move

        elif move['move_type'] == 'exchange':
            # Update rack: remove exchanged, add drawn
            exchanged = move.get('exchanged_tiles', [])
            for tile in exchanged:
                 if tile in rack_after_move: rack_after_move.remove(tile)
                 else: print(f"Replay Warning: Tried to remove exchanged tile '{tile}' from rack for move {i}, but not found.")
            rack_after_move.extend(move.get('drawn', []))
            racks_state[player_idx] = rack_after_move
            # Score doesn't change

        elif move['move_type'] == 'pass':
            # No change to board, score, or rack content needed for the state
            racks_state[player_idx] = rack_after_move # Rack state carries over

    # Sort racks alphabetically before returning for replay display
    for rack in racks_state:
        rack.sort() # In-place sort

    # Return the state *after* turn_idx moves have been applied
    return tiles_state, blanks_state, scores_state, racks_state


# Function to Replace: main()
# REASON: Added sorting lines for human player racks after completing
#         a typed play or an exchange.

# Function to Replace: main()
# REASON: Implemented GCG saving with custom filename format (DDMMMYY-HHMM-N.gcg)
#         in the Game Over dialog's Save action (click and keypress).

# Function to Replace: main()
# REASON: Corrected indentation errors in cursor advancement logic
#         within KEYDOWN event handling (both for starting typing and
#         for subsequent letter typing).

# Function to Replace: main()
# REASON: Incorporates all previous fixes (save filename, human rack sort,
#         typing cursor indentation) and reviewed for overall syntax correctness.

# Function to Replace: main()
# REASON: Complete function incorporating all previous fixes and
#         meticulously reviewed for indentation consistency.

def main():
    global bag, last_word, last_score, last_start, last_direction, move_history, replay_mode, current_replay_turn, game_mode, is_ai, practice_mode, board, tiles, racks, blanks, main_called, scores, GADDAG_STRUCTURE
    global is_loaded_game, replay_initial_shuffled_bag # For loaded game replay state

    print("--- main() function entered ---")

    # --- Initialization Block (Runs Once) ---
    if not main_called:
        print("--- main(): 'if not main_called' block entered ---")
        main_called = True

        print("--- main(): Calling mode_selection_screen()... ---")
        selected_mode_result, return_data = mode_selection_screen()
        print(f"--- main(): mode_selection_screen() returned: mode={selected_mode_result} ---")

        # --- Load GADDAG Structure ---
        try:
            print("Attempting to load GADDAG structure from gaddag.pkl...")
            load_start = time.time()
            with open("gaddag.pkl", 'rb') as f_load: GADDAG_STRUCTURE = pickle.load(f_load)
            print(f"GADDAG loaded in {time.time() - load_start:.2f} seconds.")
            # Add GADDAG validation if needed
        except Exception as e:
            print(f"\n--- ERROR Loading GADDAG: {e} ---"); pygame.quit(); sys.exit()
        print("GADDAG loading block finished.")

        # --- Game State Initialization ---
        print("--- main(): Starting game state initialization... ---")

        # Handle LOADED_GAME mode
        if selected_mode_result == "LOADED_GAME":
            print("--- main(): Handling LOADED_GAME setup ---")
            game_mode = "LOADED_GAME"; is_loaded_game = True
            player_names, loaded_history, final_scores_loaded = return_data
            move_history = loaded_history; final_scores = final_scores_loaded
            base_bag = create_standard_bag(); random.shuffle(base_bag)
            replay_initial_shuffled_bag = base_bag[:]
            board, _, tiles = create_board(); scores = [0, 0]; blanks = set()
            racks = [[], []]; bag = [] # Live bag empty
            replay_mode = True; current_replay_turn = 0; practice_mode = None
            is_ai = [False, False]; human_player = 1; first_play = False
            print(f"--- main(): Loaded Game Setup Complete. Players: {player_names}, Moves: {len(move_history)} ---")

        # Handle New Game Modes (Practice or Standard)
        elif selected_mode_result is not None:
            print(f"--- main(): Handling New Game Setup ({selected_mode_result}) ---")
            game_mode = selected_mode_result; is_loaded_game = False; replay_initial_shuffled_bag = None
            player_names, human_player, practice_mode, letter_checks, practice_state = return_data

            if practice_state and practice_mode == "eight_letter": # 8-Letter Practice Setup
                print("Loading state from 8-letter practice...")
                board, tiles, racks, blanks, bag, scores, turn, first_play = practice_state["board"], practice_state["tiles"], practice_state["racks"], practice_state["blanks"], practice_state["bag"], practice_state["scores"], practice_state["turn"], practice_state["first_play"]
                is_ai = [False, False]
                print("--- main(): Loaded state from 8-letter practice. ---")
            elif practice_state: # Other Practice Modes (Power Tiles)
                print("Loading state from other practice mode...")
                board, tiles, racks, blanks, bag, scores, turn, first_play = practice_state["board"], practice_state["tiles"], practice_state["racks"], practice_state["blanks"], practice_state["bag"], practice_state["scores"], practice_state["turn"], practice_state["first_play"]
                is_ai = [False, False];
                if game_mode == MODE_HVA: is_ai[2 - human_player] = True
                elif game_mode == MODE_AVA or practice_mode == "power_tiles": is_ai = [True, True]
                print(f"--- main(): Loaded state from other practice mode. is_ai: {is_ai} ---")
            else: # Standard New Game Setup
                print("Performing standard game initialization...")
                board, _, tiles = create_board()
                bag = create_standard_bag(); random.shuffle(bag)
                racks = [[], []]; scores = [0, 0]; turn = 1; blanks = set(); first_play = True
                try: racks[0] = [bag.pop() for _ in range(7)]; racks[1] = [bag.pop() for _ in range(7)]
                except IndexError: print("Error: Not enough tiles in bag."); pygame.quit(); sys.exit()
                for rack in racks: rack.sort() # Sort initial racks
                is_ai = [False, False]
                if game_mode == MODE_HVA: is_ai[2 - human_player] = True
                elif game_mode == MODE_AVA: is_ai = [True, True]
                print(f"--- main(): Performed standard game initialization. is_ai: {is_ai} ---")
            initial_racks = [rack[:] for rack in racks] # Store initial racks for GCG saving

        else: # Mode selection returned None
             print("--- main(): Mode selection returned None. Exiting. ---"); pygame.quit(); sys.exit()

        # --- Common Initializations & Resets ---
        word_positions = []; running = True; dropdown_open = False; return_to_mode_selection = False; all_words_ok_rect = None; all_words_play_rect = None
        hint_rects = []; hint_rect = None; play_button_rect = None; ok_button_rect = None; all_words_button_rect = None; tile_rects = []; exchange_button_rect = None
        cancel_button_rect = None; pass_count = 0; exchange_count = 0; consecutive_zero_point_turns = 0; exchanging = False; hinting = False
        showing_all_words = False; selected_tiles = set(); typing = False; typing_start = None; typing_direction = None; current_r = None; current_c = None
        last_left_click_time = 0; last_left_click_pos = None; hint_moves = []; all_moves = []; selected_hint_index = None; scroll_offset = 0
        last_clicked_pos = None; last_word = ""; last_score = 0; last_start = None; last_direction = None; human_played = False; dragged_tile = None; drag_pos = None; drag_offset = (0,0)
        selected_square = None; original_tiles = None; original_rack = None;
        if selected_mode_result != "LOADED_GAME": move_history = []
        if selected_mode_result != "LOADED_GAME": replay_mode = False; current_replay_turn = 0
        previous_turn = 0; game_over_state = False; showing_stats = False; dialog_x = (WINDOW_WIDTH - DIALOG_WIDTH) // 2; dialog_y = (WINDOW_HEIGHT - DIALOG_HEIGHT) // 2; dragging = False;
        if selected_mode_result != "LOADED_GAME": final_scores = None
        reason = ""; action = None; scoreboard_height = WINDOW_HEIGHT - 80; paused_for_power_tile = False; current_power_tile = None; power_tile_message_shown = False
        print("--- main(): Performed common variable resets. ---")

        # --- 8-Letter Practice Specific Initialization ---
        practice_target_moves = []; practice_best_move = None; practice_solved = False
        showing_practice_end_dialog = False; practice_end_message = ""; practice_play_again_rect = None
        practice_main_menu_rect = None; practice_quit_rect = None
        if practice_mode == "eight_letter":
            print("--- main(): Performing 8-letter practice specific init... ---")
            if racks and len(racks) > 0 and racks[0] is not None and GADDAG_STRUCTURE:
                practice_target_moves = generate_all_moves_gaddag(racks[0], tiles, board, blanks, GADDAG_STRUCTURE.root)
                if practice_target_moves:
                    practice_best_move = practice_target_moves[0]; print(f"Best move found: {practice_best_move['word']} ({practice_best_move['score']} pts)"); all_moves = practice_target_moves
                else: print("Error: No valid moves found for 8-letter practice setup!"); show_message_dialog("Error: No possible moves found for this setup.", "Practice Error"); return_to_mode_selection = True; running = False
            elif not GADDAG_STRUCTURE: print("Error: Cannot generate practice moves, GADDAG not loaded."); return_to_mode_selection = True; running = False
            else: print("Error: Invalid rack state for Player 1 in 8-letter practice."); return_to_mode_selection = True; running = False
    # --- End of Initialization Block ---

    # --- Main Game Loop ---
    print("--- main(): Entering main game loop (while running:)... ---")
    while running:
        # Generate moves at start of turn (unless practice mode or paused or replay)
        if turn != previous_turn and not replay_mode and not game_over_state and not paused_for_power_tile and practice_mode != "eight_letter":
            if racks and len(racks) > turn-1 and racks[turn-1] is not None and GADDAG_STRUCTURE:
                print(f"Generating moves for Player {turn}. Rack: {''.join(racks[turn-1])}")
                all_moves = generate_all_moves_gaddag(racks[turn-1], tiles, board, blanks, GADDAG_STRUCTURE.root)
                if all_moves is None: all_moves = []
                print(f"Generated {len(all_moves)} moves for player {turn}")
            elif not GADDAG_STRUCTURE: print("ERROR: Cannot generate moves, GADDAG not loaded."); all_moves = []
            else: print(f"Error: Invalid rack state for player {turn}. Racks: {racks}"); all_moves = []
            previous_turn = turn; human_played = False; power_tile_message_shown = False

        # --- AI Turn Trigger ---
        if not game_over_state and not replay_mode and not paused_for_power_tile and \
           practice_mode != "eight_letter" and is_ai[turn-1] and not human_played:
            print(f"Triggering AI turn for Player {turn}")
            ai_result = ai_turn(turn, racks, tiles, board, blanks, scores, bag, first_play, pass_count, exchange_count, consecutive_zero_point_turns, player_names, dropdown_open, hinting, showing_all_words, letter_checks)
            if len(ai_result) == 11:
                turn, first_play, pass_count, exchange_count, consecutive_zero_point_turns, returned_moves, dropdown_open, hinting, showing_all_words, paused_for_power_tile, current_power_tile = ai_result
                if paused_for_power_tile:
                    all_moves = returned_moves
                    if not power_tile_message_shown: player_name = player_names[turn-1] if player_names[turn-1] else f"Player {turn}"; show_message_dialog(f"A {current_power_tile} is on {player_name}'s rack. Find the highest scoring play using {current_power_tile}.", "Power Tile Practice"); power_tile_message_shown = True
            else: print(f"Error: AI turn returned unexpected number of values: {len(ai_result)}")

        # --- Event Handling ---
        for event in pygame.event.get():
            if event.type == pygame.QUIT: running = False
            # --- Practice End Dialog Handling ---
            elif showing_practice_end_dialog:
                if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
                    x, y = event.pos
                    if practice_play_again_rect and practice_play_again_rect.collidepoint(x,y): running = False; return_to_mode_selection = True
                    elif practice_main_menu_rect and practice_main_menu_rect.collidepoint(x,y): running = False; return_to_mode_selection = True
                    elif practice_quit_rect and practice_quit_rect.collidepoint(x,y): running = False
            # --- Game Over Event Handling ---
            elif game_over_state:
                # Define save action nested function (uses local variables like final_scores)
                def perform_save_action():
                    if final_scores:
                        now = datetime.datetime.now(); date_str = now.strftime("%d%b%y").upper(); time_str = now.strftime("%H%M"); seq_num = 1; max_existing_num = 0
                        try:
                            for filename in os.listdir('.'):
                                if filename.startswith(date_str + "-") and filename.endswith(".gcg"):
                                    parts = filename[:-4].split('-');
                                    if len(parts) == 3:
                                        try:
                                            num = int(parts[2])
                                            if num > max_existing_num: max_existing_num = num
                                        except ValueError: continue # Correctly indented except
                            seq_num = max_existing_num + 1
                        except OSError as e: print(f"Error listing directory for sequence number: {e}")
                        save_filename = f"{date_str}-{time_str}-{seq_num}.gcg"; gcg_content = save_game_to_gcg(player_names, move_history, initial_racks, final_scores)
                        try:
                            with open(save_filename, "w") as f: f.write(gcg_content); print(f"Game saved to {save_filename}"); show_message_dialog(f"Game saved as {save_filename}", "Save Successful")
                        except IOError as e: print(f"Error saving game to {save_filename}: {e}"); show_message_dialog(f"Error saving game: {e}", "Save Error")
                    else: print("Cannot save game: Final scores not calculated."); show_message_dialog("Cannot save game - final scores missing.", "Save Error")

                # Handle events in game over state
                if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
                    x, y = event.pos
                    if dialog_x <= x < dialog_x + DIALOG_WIDTH and dialog_y <= y < dialog_y + 20: dragging = True; drag_offset = (x - dialog_x, y - dialog_y) # Dragging
                    elif showing_stats: # Stats dialog OK
                        stats_dialog_width, stats_dialog_height = 400, 360; stats_dialog_actual_x = dialog_x + 20; stats_dialog_actual_y = dialog_y + 20
                        temp_ok_rect = pygame.Rect(stats_dialog_actual_x + stats_dialog_width - BUTTON_WIDTH - 10, stats_dialog_actual_y + stats_dialog_height - BUTTON_HEIGHT - 10, BUTTON_WIDTH, BUTTON_HEIGHT)
                        if temp_ok_rect.collidepoint(x, y): showing_stats = False
                    else: # Game over buttons
                        temp_save_rect, temp_quit_rect, temp_replay_rect, temp_play_again_rect, temp_stats_rect = draw_game_over_dialog(dialog_x, dialog_y, final_scores if final_scores else [0,0], reason, player_names)
                        if temp_save_rect.collidepoint(x, y): perform_save_action()
                        elif temp_quit_rect.collidepoint(x, y): running = False
                        elif temp_replay_rect.collidepoint(x, y): # Prepare for replay
                            if is_loaded_game:
                                if not replay_initial_shuffled_bag: base_bag = create_standard_bag(); random.shuffle(base_bag); replay_initial_shuffled_bag = base_bag[:]
                            else: replay_initial_shuffled_bag = None
                            game_over_state = False; replay_mode = True; current_replay_turn = 0; practice_mode = None; paused_for_power_tile = False; showing_stats = False
                        elif temp_play_again_rect.collidepoint(x, y): running = False; return_to_mode_selection = True
                        elif temp_stats_rect.collidepoint(x, y): showing_stats = True
                elif event.type == pygame.MOUSEMOTION and dragging: x, y = event.pos; dialog_x = x - drag_offset[0]; dialog_y = y - drag_offset[1]; dialog_x = max(0, min(dialog_x, WINDOW_WIDTH - DIALOG_WIDTH)); dialog_y = max(0, min(dialog_y, WINDOW_HEIGHT - DIALOG_HEIGHT))
                elif event.type == pygame.MOUSEBUTTONUP and event.button == 1: dragging = False
                elif event.type == pygame.KEYDOWN: # Keyboard shortcuts
                    if event.key == pygame.K_s: perform_save_action()
                    elif event.key == pygame.K_q: running = False
                    elif event.key == pygame.K_r: # Prepare for replay
                         if is_loaded_game:
                             if not replay_initial_shuffled_bag: base_bag = create_standard_bag(); random.shuffle(base_bag); replay_initial_shuffled_bag = base_bag[:]
                         else: replay_initial_shuffled_bag = None
                         game_over_state = False; replay_mode = True; current_replay_turn = 0; practice_mode = None; paused_for_power_tile = False; showing_stats = False
                    elif event.key == pygame.K_p: running = False; return_to_mode_selection = True
            # --- Active Game / Replay Event Handling ---
            elif event.type == pygame.MOUSEBUTTONDOWN:
                x, y = event.pos; current_time = pygame.time.get_ticks()
                if event.button == 1: # Left Click ...
                    if replay_mode: # Replay controls ...
                        if replay_start_rect.collidepoint(x, y): current_replay_turn = 0
                        elif replay_prev_rect.collidepoint(x, y) and current_replay_turn > 0: current_replay_turn -= 1
                        elif replay_next_rect.collidepoint(x, y) and current_replay_turn < len(move_history): current_replay_turn += 1
                        elif replay_end_rect.collidepoint(x, y): current_replay_turn = len(move_history)
                    elif not replay_mode: # Active game clicks ...
                        if exchanging: # Exchange Dialog ...
                            clicked_in_dialog = False
                            if exchange_button_rect and exchange_button_rect.collidepoint(x, y) and selected_tiles and len(bag) >= len(selected_tiles):
                                clicked_in_dialog = True; move_rack = racks[turn-1][:]; tiles_to_exchange = [racks[turn-1][i] for i in sorted(selected_tiles, reverse=True)]
                                temp_rack = [tile for i, tile in enumerate(racks[turn-1]) if i not in selected_tiles]; drawn_tiles = [bag.pop() for _ in range(len(tiles_to_exchange)) if bag]
                                temp_rack.extend(drawn_tiles); racks[turn-1] = temp_rack
                                if not is_ai[turn-1]: racks[turn-1].sort() # Sort human rack
                                bag.extend(tiles_to_exchange); random.shuffle(bag); consecutive_zero_point_turns += 1; print(f"Player {turn} exchanged {len(tiles_to_exchange)} tiles")
                                exchanging = False; selected_tiles.clear(); human_played = True; exchange_count += 1; pass_count = 0; paused_for_power_tile = False
                                move_history.append({'player': turn, 'move_type': 'exchange', 'rack': move_rack, 'exchanged_tiles': tiles_to_exchange, 'drawn': drawn_tiles, 'score': 0, 'word': '', 'coord': '', 'blanks': set(), 'positions': [], 'is_bingo': False, 'word_with_blanks': ''})
                                current_replay_turn = len(move_history); turn = 3 - turn
                            elif cancel_button_rect and cancel_button_rect.collidepoint(x, y): clicked_in_dialog = True; exchanging = False; selected_tiles.clear()
                            elif tile_rects:
                                for i, rect in enumerate(tile_rects):
                                    if rect.collidepoint(x, y): clicked_in_dialog = True; selected_tiles.symmetric_difference_update({i}); break
                            dialog_width, dialog_height = 400, 200; dialog_rect_exchange = pygame.Rect((WINDOW_WIDTH - dialog_width) // 2, (WINDOW_HEIGHT - dialog_height) // 2, dialog_width, dialog_height)
                            if dialog_rect_exchange.collidepoint(x,y) and not clicked_in_dialog: pass
                        elif hinting: # Hint Dialog ...
                           clicked_in_dialog = False
                           if play_button_rect and play_button_rect.collidepoint(x, y) and selected_hint_index is not None and selected_hint_index < len(hint_moves):
                               clicked_in_dialog = True; selected_move = hint_moves[selected_hint_index]; move_rack = racks[turn-1][:]
                               if paused_for_power_tile:
                                   power_moves_check = [m for m in all_moves if any(letter == current_power_tile for _, _, letter in m.get('newly_placed',[]))]; max_power_score_check = max(m['score'] for m in power_moves_check) if power_moves_check else 0
                                   if selected_move['score'] >= max_power_score_check:
                                       next_turn, drawn_tiles, newly_placed = play_hint_move(selected_move, tiles, racks, blanks, scores, turn, bag, board)
                                       human_played = True; hinting = False; paused_for_power_tile = False; consecutive_zero_point_turns = 0; pass_count = 0; exchange_count = 0
                                       move_history.append({'player': turn, 'move_type': 'place', 'rack': move_rack, 'positions': selected_move.get('positions',[]), 'blanks': selected_move.get('blanks',set()), 'score': selected_move.get('score',0), 'word': selected_move.get('word','N/A'), 'drawn': drawn_tiles, 'coord': get_coord(selected_move.get('start',(0,0)), selected_move.get('direction','right')), 'word_with_blanks': selected_move.get('word_with_blanks',''), 'is_bingo': selected_move.get('is_bingo',False)})
                                       current_replay_turn = len(move_history); turn = next_turn
                                   else: show_message_dialog(f"This is not the highest scoring move with {current_power_tile}!", "Incorrect Move")
                               else: # Normal hint play
                                   next_turn, drawn_tiles, newly_placed = play_hint_move(selected_move, tiles, racks, blanks, scores, turn, bag, board)
                                   human_played = True; hinting = False; paused_for_power_tile = False; consecutive_zero_point_turns = 0; pass_count = 0; exchange_count = 0
                                   if practice_mode != "eight_letter":
                                       move_history.append({'player': turn, 'move_type': 'place', 'rack': move_rack, 'positions': selected_move.get('positions',[]), 'blanks': selected_move.get('blanks',set()), 'score': selected_move.get('score',0), 'word': selected_move.get('word','N/A'), 'drawn': drawn_tiles, 'coord': get_coord(selected_move.get('start',(0,0)), selected_move.get('direction','right')), 'word_with_blanks': selected_move.get('word_with_blanks',''), 'is_bingo': selected_move.get('is_bingo',False)})
                                       current_replay_turn = len(move_history); turn = next_turn
                                   else: print("Hint played visually in 8-letter practice.")
                           elif ok_button_rect and ok_button_rect.collidepoint(x, y): clicked_in_dialog = True; hinting = False
                           elif all_words_button_rect and all_words_button_rect.collidepoint(x, y): clicked_in_dialog = True; hinting = False; showing_all_words = True; moves_for_all = practice_target_moves if practice_mode == "eight_letter" else all_moves; selected_hint_index = 0 if moves_for_all else None; scroll_offset = 0
                           elif hint_rects:
                               for i, rect in enumerate(hint_rects):
                                   if rect.collidepoint(x, y) and i < len(hint_moves): clicked_in_dialog = True; selected_hint_index = i; break
                           dialog_width, dialog_height = 400, 250; dialog_rect_hint = pygame.Rect((WINDOW_WIDTH - dialog_width) // 2, (WINDOW_HEIGHT - dialog_height) // 2, dialog_width, dialog_height)
                           if dialog_rect_hint.collidepoint(x,y) and not clicked_in_dialog: pass
                        elif showing_all_words: # All Words Dialog ...
                           clicked_in_dialog = False; moves_for_all = practice_target_moves if practice_mode == "eight_letter" else all_moves
                           if all_words_play_rect and all_words_play_rect.collidepoint(x, y) and selected_hint_index is not None and selected_hint_index < len(moves_for_all):
                               clicked_in_dialog = True; selected_move = moves_for_all[selected_hint_index]; move_rack = racks[turn-1][:]; next_turn, drawn_tiles, newly_placed = play_hint_move(selected_move, tiles, racks, blanks, scores, turn, bag, board)
                               human_played = True; showing_all_words = False; paused_for_power_tile = False; consecutive_zero_point_turns = 0; pass_count = 0; exchange_count = 0
                               if practice_mode != "eight_letter":
                                   move_history.append({'player': turn, 'move_type': 'place', 'rack': move_rack, 'positions': selected_move.get('positions',[]), 'blanks': selected_move.get('blanks',set()), 'score': selected_move.get('score',0), 'word': selected_move.get('word','N/A'), 'drawn': drawn_tiles, 'coord': get_coord(selected_move.get('start',(0,0)), selected_move.get('direction','right')), 'word_with_blanks': selected_move.get('word_with_blanks',''), 'is_bingo': selected_move.get('is_bingo',False)})
                                   current_replay_turn = len(move_history); turn = next_turn
                               else: print("Move played visually from All Words in 8-letter practice.")
                           elif all_words_ok_rect and all_words_ok_rect.collidepoint(x, y): clicked_in_dialog = True; showing_all_words = False
                           elif all_words_rects:
                               for rect, idx in all_words_rects:
                                   if rect.collidepoint(x, y): clicked_in_dialog = True; selected_hint_index = idx; break
                           dialog_rect_all = pygame.Rect((WINDOW_WIDTH - ALL_WORDS_DIALOG_WIDTH) // 2, (WINDOW_HEIGHT - ALL_WORDS_DIALOG_HEIGHT) // 2, ALL_WORDS_DIALOG_WIDTH, ALL_WORDS_DIALOG_HEIGHT)
                           if dialog_rect_all.collidepoint(x,y) and not clicked_in_dialog: pass
                        elif not (exchanging or hinting or showing_all_words): # Clicks outside dialogs ...
                            options_rect_base, dropdown_rects_base = draw_options_menu(turn, dropdown_open, len(bag)) # Options Menu ...
                            if options_rect_base.collidepoint(x, y): dropdown_open = not dropdown_open
                            elif dropdown_open:
                                clicked_dropdown = False; current_options = ["Give Up", "Main", "Quit"] if practice_mode == "eight_letter" else ["Pass", "Exchange", "Main", "Quit"]
                                for i, rect in enumerate(dropdown_rects_base):
                                    if rect and rect.collidepoint(x, y):
                                        clicked_dropdown = True; selected_option = current_options[i]; dropdown_open = False
                                        if selected_option == "Pass": move_rack = racks[turn-1][:]; consecutive_zero_point_turns += 1; pass_count += 1; exchange_count = 0; print(f"Player {turn} passed"); human_played = True; paused_for_power_tile = False; move_history.append({'player': turn, 'move_type': 'pass', 'rack': move_rack, 'score': 0, 'word': '', 'coord': '', 'blanks': set(), 'positions': [], 'drawn': [], 'is_bingo': False, 'word_with_blanks': ''}); current_replay_turn = len(move_history); turn = 3 - turn
                                        elif selected_option == "Exchange": exchanging = True; selected_tiles.clear()
                                        elif selected_option == "Give Up": practice_end_message = f"Best: {practice_best_move['word_with_blanks']} ({practice_best_move['score']} pts)" if practice_best_move else "No best move found."; practice_solved = True; showing_practice_end_dialog = True
                                        elif selected_option == "Main": running = False; return_to_mode_selection = True
                                        elif selected_option == "Quit":
                                            if confirm_quit(): running = False
                                        break
                                if not clicked_dropdown: dropdown_open = False
                            elif not options_rect_base.collidepoint(x,y): dropdown_open = False
                            suggest_rect_base = draw_suggest_button() # Suggest Button ...
                            if suggest_rect_base and suggest_rect_base.collidepoint(x, y) and (not is_ai[turn-1] or paused_for_power_tile):
                                moves_to_hint = practice_target_moves if practice_mode == "eight_letter" else all_moves
                                if paused_for_power_tile and current_power_tile: power_moves_hint = [m for m in moves_to_hint if any(letter == current_power_tile for _, _, letter in m.get('newly_placed',[]))]; hint_moves = sorted(power_moves_hint, key=lambda m: m['score'], reverse=True)[:5]
                                else: hint_moves = moves_to_hint[:5]
                                hinting = True; selected_hint_index = 0 if hint_moves else None
                            if paused_for_power_tile and hint_rect and hint_rect.collidepoint(x, y): # Hint button (Paused) ...
                                 power_moves_hint = [m for m in all_moves if any(letter == current_power_tile for _, _, letter in m.get('newly_placed',[]))]; hint_moves = sorted(power_moves_hint, key=lambda m: m['score'], reverse=True)[:5]; hinting = True; selected_hint_index = 0 if hint_moves else None
                            current_player_idx = turn - 1 # Rack Buttons ...
                            if not is_ai[current_player_idx] or paused_for_power_tile:
                                 p1_alpha_rect, p1_rand_rect = None, None; p2_alpha_rect, p2_rand_rect = None, None
                                 if len(racks) > 0: p1_alpha_rect, p1_rand_rect = draw_rack(1, racks[0], scores, turn, player_names)
                                 if len(racks) > 1 and practice_mode != "eight_letter": p2_alpha_rect, p2_rand_rect = draw_rack(2, racks[1], scores, turn, player_names)
                                 if turn == 1:
                                      if p1_alpha_rect and p1_alpha_rect.collidepoint(x, y): racks[0].sort()
                                      elif p1_rand_rect and p1_rand_rect.collidepoint(x, y): random.shuffle(racks[0])
                                 elif turn == 2 and practice_mode != "eight_letter":
                                      if p2_alpha_rect and p2_alpha_rect.collidepoint(x, y): racks[1].sort()
                                      elif p2_rand_rect and p2_rand_rect.collidepoint(x, y): random.shuffle(racks[1])
                            # Rack Tile Drag Start ...
                            rack_y = BOARD_SIZE + 80 if turn == 1 else BOARD_SIZE + 150; rack_width_calc = 7 * (TILE_WIDTH + TILE_GAP) - TILE_GAP; replay_area_end_x = 10 + 4 * (REPLAY_BUTTON_WIDTH + REPLAY_BUTTON_GAP); min_rack_start_x = replay_area_end_x + BUTTON_GAP + 20; rack_start_x_calc = max(min_rack_start_x, (BOARD_SIZE - rack_width_calc) // 2)
                            if 0 <= current_player_idx < len(racks):
                                 rack_len = len(racks[current_player_idx]); tile_idx = get_tile_under_mouse(x, y, rack_start_x_calc, rack_y, rack_len)
                                 if tile_idx is not None and not dragged_tile and (not is_ai[current_player_idx] or paused_for_power_tile): dragged_tile = (turn, tile_idx); drag_pos = (x, y); tile_abs_x = rack_start_x_calc + tile_idx * (TILE_WIDTH + TILE_GAP); drag_offset = (x - tile_abs_x, y - rack_y)
                            # Board Click (Typing Start / Arrow) ...
                            if not dragged_tile and (not is_ai[turn-1] or paused_for_power_tile): # Only if not dragging
                                col = (x - 40) // SQUARE_SIZE; row = (y - 40) // SQUARE_SIZE
                                if 0 <= row < GRID_SIZE and 0 <= col < GRID_SIZE and not tiles[row][col]: # Click on empty board square
                                    is_double_click = (last_left_click_pos == (row, col) and current_time - last_left_click_time < DOUBLE_CLICK_TIME)
                                    if is_double_click: # Cancel
                                         selected_square = None; typing = False
                                         if word_positions and original_tiles and original_rack: # Revert
                                              for r_wp, c_wp, _ in word_positions: tiles[r_wp][c_wp] = original_tiles[r_wp][c_wp]
                                              racks[turn-1] = original_rack[:]; blanks_to_remove = set((r_wp, c_wp) for r_wp, c_wp, _ in word_positions if (r_wp, c_wp) in blanks); blanks.difference_update(blanks_to_remove); word_positions = []; original_tiles = None; original_rack = None
                                    elif selected_square is None or selected_square[:2] != (row, col): selected_square = (row, col, "right"); typing = False; word_positions = [] # 1st click
                                    elif selected_square[2] == "right": selected_square = (row, col, "down") # 2nd click
                                    elif selected_square[2] == "down": selected_square = None # 3rd click
                                    last_left_click_pos = (row, col); last_left_click_time = current_time
                                else: selected_square = None # Click outside board or on occupied square

                elif event.button == 3: # Right Click -> Cancel typing/arrow
                    selected_square = None
                    if typing: # Revert typing
                        if original_tiles and original_rack:
                            for r_wp, c_wp, _ in word_positions: tiles[r_wp][c_wp] = original_tiles[r_wp][c_wp]
                            racks[turn-1] = original_rack[:]
                            blanks_to_remove = set((r_wp, c_wp) for r_wp, c_wp, _ in word_positions if (r_wp, c_wp) in blanks)
                            blanks.difference_update(blanks_to_remove)
                        # Reset typing state variables (Correctly indented)
                        typing = False
                        typing_start = None
                        typing_direction = None
                        word_positions = []
                        original_tiles = None
                        original_rack = None

            elif event.type == pygame.MOUSEMOTION: # Mouse Motion ...
                if dragged_tile and drag_pos: drag_pos = event.pos
                elif game_over_state and dragging: x, y = event.pos; dialog_x = x - drag_offset[0]; dialog_y = y - drag_offset[1]; dialog_x = max(0, min(dialog_x, WINDOW_WIDTH - DIALOG_WIDTH)); dialog_y = max(0, min(dialog_y, WINDOW_HEIGHT - DIALOG_HEIGHT))

            elif event.type == pygame.MOUSEBUTTONUP: # Mouse Up ...
                if event.button == 1: # Left button up
                    if game_over_state and dragging: dragging = False
                    elif dragged_tile and (not is_ai[dragged_tile[0]-1] or paused_for_power_tile) and not replay_mode: # Finish dragging a tile
                        x, y = event.pos; player_idx = dragged_tile[0] - 1; rack_y = BOARD_SIZE + 80 if dragged_tile[0] == 1 else BOARD_SIZE + 150
                        rack_width_calc = 7 * (TILE_WIDTH + TILE_GAP) - TILE_GAP; replay_area_end_x = 10 + 4 * (REPLAY_BUTTON_WIDTH + REPLAY_BUTTON_GAP); min_rack_start_x = replay_area_end_x + BUTTON_GAP + 20
                        rack_start_x_calc = max(min_rack_start_x, (BOARD_SIZE - rack_width_calc) // 2); rack_area_rect = pygame.Rect(rack_start_x_calc, rack_y, rack_width_calc, TILE_HEIGHT)
                        if rack_area_rect.collidepoint(x, y): # Dropped back on the rack area
                            rack_len = len(racks[player_idx]); insert_idx = get_insertion_index(x, rack_start_x_calc, rack_len); original_tile_idx = dragged_tile[1]
                            if 0 <= original_tile_idx < rack_len:
                                player_rack = racks[player_idx]; tile_to_move = player_rack.pop(original_tile_idx)
                                if original_tile_idx < insert_idx: insert_idx -= 1
                                insert_idx = max(0, min(insert_idx, len(player_rack))); player_rack.insert(insert_idx, tile_to_move)
                        dragged_tile = None; drag_pos = None # Stop dragging

            elif event.type == pygame.MOUSEWHEEL: # Mouse Wheel ...
                mouse_x, mouse_y = pygame.mouse.get_pos()
                if showing_all_words: # Scroll All Words ...
                     dialog_rect_all = pygame.Rect((WINDOW_WIDTH - ALL_WORDS_DIALOG_WIDTH) // 2, (WINDOW_HEIGHT - ALL_WORDS_DIALOG_HEIGHT) // 2, ALL_WORDS_DIALOG_WIDTH, ALL_WORDS_DIALOG_HEIGHT)
                     if dialog_rect_all.collidepoint(mouse_x, mouse_y):
                          moves_for_scroll = practice_target_moves if practice_mode == "eight_letter" else all_moves; content_height = len(moves_for_scroll) * 30; header_height = 40; button_area_height = BUTTON_HEIGHT + 30
                          visible_content_height = ALL_WORDS_DIALOG_HEIGHT - header_height - button_area_height
                          if content_height > visible_content_height: max_scroll = content_height - visible_content_height; scroll_offset -= event.y * SCROLL_SPEED; scroll_offset = max(0, min(scroll_offset, max_scroll))
                          else: scroll_offset = 0
                else: # Scroll Scoreboard ...
                    sb_x = BOARD_SIZE + 275; sb_y = 40; sb_w = max(200, WINDOW_WIDTH - BOARD_SIZE - 20); sb_h = WINDOW_HEIGHT - 80;
                    if sb_x + sb_w > WINDOW_WIDTH - 10: sb_w = WINDOW_WIDTH - sb_x - 10
                    if sb_w < 200: sb_x = WINDOW_WIDTH - 210; sb_w = 200
                    scoreboard_rect = pygame.Rect(sb_x, sb_y, sb_w, sb_h)
                    if scoreboard_rect.collidepoint(mouse_x, mouse_y):
                         history_len = current_replay_turn if replay_mode else len(move_history); total_content_height = history_len * 20; is_final_turn_in_replay = replay_mode and current_replay_turn == len(move_history)
                         if (game_over_state or is_final_turn_in_replay) and final_scores is not None: total_content_height += 40
                         if total_content_height > scoreboard_height: max_scroll = total_content_height - scoreboard_height; scroll_offset -= event.y * SCROLL_SPEED; scroll_offset = max(0, min(scroll_offset, max_scroll))
                         else: scroll_offset = 0

            elif event.type == pygame.KEYDOWN: # Keydown ...
                is_human_turn_or_paused = not replay_mode and (not is_ai[turn-1] or paused_for_power_tile)
                if is_human_turn_or_paused:
                    # --- Start Typing Logic ---
                    if selected_square and not typing and event.unicode.isalpha():
                        typing = True; original_tiles = [row[:] for row in tiles]; original_rack = racks[turn-1][:]
                        typing_start = selected_square[:2]; typing_direction = selected_square[2]; original_selected_square = selected_square
                        selected_square = None; word_positions = []; current_r, current_c = typing_start
                        letter = event.unicode.upper()
                        if 0 <= current_r < GRID_SIZE and 0 <= current_c < GRID_SIZE and not tiles[current_r][current_c]:
                            placed = False
                            if letter in racks[turn-1]: tiles[current_r][current_c] = letter; racks[turn-1].remove(letter); word_positions.append((current_r, current_c, letter)); placed = True
                            elif ' ' in racks[turn-1]: tiles[current_r][current_c] = letter; racks[turn-1].remove(' '); blanks.add((current_r, current_c)); word_positions.append((current_r, current_c, letter)); placed = True
                            # Corrected Indentation Block 1
                            if placed:
                                if typing_direction == "right":
                                    current_c += 1
                                    while current_c < GRID_SIZE and tiles[current_r][current_c]: current_c += 1
                                elif typing_direction == "down": # Correctly aligned
                                    current_r += 1
                                    while current_r < GRID_SIZE and tiles[current_r][current_c]: current_r += 1 # Correctly indented
                                # Correctly indented
                                current_r = min(current_r, GRID_SIZE - 1)
                                current_c = min(current_c, GRID_SIZE - 1)
                            # End Corrected Block 1
                        else: typing = False; selected_square = original_selected_square
                    # --- Active Typing Logic ---
                    elif typing:
                        if event.key == pygame.K_RETURN or event.key == pygame.K_KP_ENTER: # Finalize Typed Play ...
                                play_finalized_normally = False
                                if word_positions:
                                    temp_tiles_val = [row[:] for row in original_tiles];
                                    for r_wp, c_wp, l_wp in word_positions:
                                        if 0 <= r_wp < GRID_SIZE and 0 <= c_wp < GRID_SIZE: temp_tiles_val[r_wp][c_wp] = l_wp
                                    valid, is_bingo = is_valid_play(word_positions, temp_tiles_val, first_play, len(original_rack), original_tiles, original_rack)
                                    if valid:
                                        score = calculate_score(word_positions, board, tiles, blanks); print(f"DEBUG: Valid play typed, score: {score}")
                                        # ... (Practice mode checks remain the same) ...
                                        if practice_mode == "eight_letter":
                                            print("DEBUG: Checking 8-letter practice logic..."); # ... (8-letter logic) ...
                                            if practice_best_move and score == practice_best_move['score']: practice_end_message = f"Congratulations! Best: {practice_best_move['word_with_blanks']} ({score} pts)"; practice_solved = True; showing_practice_end_dialog = True
                                            elif practice_best_move: show_message_dialog(f"Try again. There is another word that scores {practice_best_move['score']}.", "Incorrect")
                                            else: show_message_dialog("Error: No best move data available.", "Error"); return_to_mode_selection = True; running = False
                                            if not practice_solved: # Revert
                                                if original_tiles and original_rack:
                                                    for r_wp, c_wp, _ in word_positions: tiles[r_wp][c_wp] = original_tiles[r_wp][c_wp]
                                                    racks[turn-1] = original_rack[:]; blanks_to_remove = set((r_wp, c_wp) for r_wp, c_wp, _ in word_positions if (r_wp, c_wp) in blanks); blanks.difference_update(blanks_to_remove)
                                            typing = False; typing_start = None; typing_direction = None; word_positions = []; original_tiles = None; original_rack = None
                                            if not practice_solved and not return_to_mode_selection: selected_square = original_selected_square

                                        elif practice_mode == "power_tiles" and paused_for_power_tile: # ... (Power tile logic) ...
                                             print(f"DEBUG: Checking Power Tile ({current_power_tile}) practice logic...")
                                             uses_power = any(letter == current_power_tile for r_wp, c_wp, letter in word_positions); power_moves = [m for m in all_moves if any(pt[2] == current_power_tile for pt in m.get('newly_placed', []))]
                                             max_power_score = max(m['score'] for m in power_moves) if power_moves else 0; print(f"DEBUG: Player used power tile: {uses_power}. Player score: {score}. Max power score: {max_power_score}")
                                             if not uses_power: show_message_dialog(f"Move must use the {current_power_tile}!", "Incorrect")
                                             elif score < max_power_score: show_message_dialog(f"Try again. There is another word that scores {max_power_score}.", "Higher Score Exists")
                                             else: show_message_dialog("That's correct! Great job.", "Correct!"); paused_for_power_tile = False; power_tile_message_shown = False; play_finalized_normally = True
                                             if not play_finalized_normally: # Revert
                                                  if original_tiles and original_rack:
                                                      for r_wp, c_wp, _ in word_positions: tiles[r_wp][c_wp] = original_tiles[r_wp][c_wp]
                                                      racks[turn-1] = original_rack[:]; blanks_to_remove = set((r_wp, c_wp) for r_wp, c_wp, _ in word_positions if (r_wp, c_wp) in blanks); blanks.difference_update(blanks_to_remove)
                                                  typing = False; typing_start = None; typing_direction = None; word_positions = []; original_tiles = None; original_rack = None; selected_square = original_selected_square
                                        else:
                                            play_finalized_normally = True # Finalize normal play

                                    else: # Invalid play
                                        print(f"Invalid play.");
                                        if original_tiles and original_rack: # Revert
                                            for r_wp, c_wp, _ in word_positions: tiles[r_wp][c_wp] = original_tiles[r_wp][c_wp]
                                            racks[turn-1] = original_rack[:]; blanks_to_remove = set((r_wp, c_wp) for r_wp, c_wp, _ in word_positions if (r_wp, c_wp) in blanks); blanks.difference_update(blanks_to_remove)
                                        typing = False; typing_start = None; typing_direction = None; word_positions = []; original_tiles = None; original_rack = None; selected_square = original_selected_square
                                else:
                                     typing = False; selected_square = original_selected_square # Enter with no tiles

                                # --- Normal Play Finalization ---
                                if play_finalized_normally:
                                    scores[turn-1] += score; first_play = False; drawn_tiles = [bag.pop() for _ in range(len(word_positions)) if bag]; racks[turn-1].extend(drawn_tiles)
                                    if not is_ai[turn-1]: racks[turn-1].sort() # Sort human rack

                                    # Find the full word and its actual start position/direction
                                    full_word_tiles_hist, _ = find_main_word(word_positions, tiles)
                                    full_word_hist = "".join(t[2] for t in full_word_tiles_hist) if full_word_tiles_hist else "ERROR"

                                    # --- CORRECTED: Calculate coord based on actual word start ---
                                    if full_word_tiles_hist:
                                        actual_start_pos = (full_word_tiles_hist[0][0], full_word_tiles_hist[0][1])
                                        # Determine direction based on the full word found
                                        actual_direction = "right" if len(set(r for r,c,l in full_word_tiles_hist)) == 1 else "down"
                                        coord_hist = get_coord(actual_start_pos, actual_direction)
                                    else: # Should not happen if valid play, but fallback
                                        coord_hist = "???" # Indicate error in coord
                                        print("WARNING: Could not determine actual start pos for history coord.")
                                    # ----------------------------------------------------------

                                    # Format word_with_blanks based on full word
                                    word_with_blanks_list_hist = []; placed_pos_set_hist = set((p[0], p[1]) for p in word_positions); blanks_in_play = blanks.copy() & placed_pos_set_hist
                                    for wr, wc, w_letter in full_word_tiles_hist: is_blank_hist = (wr, wc) in blanks_in_play; word_with_blanks_list_hist.append(w_letter.lower() if is_blank_hist else w_letter.upper())
                                    word_with_blanks_hist = "".join(word_with_blanks_list_hist)

                                    # Append correct info to history
                                    move_history.append({
                                        'player': turn, 'move_type': 'place', 'rack': original_rack[:],
                                        'positions': [(p[0], p[1], p[2]) for p in word_positions], # newly placed
                                        'blanks': blanks_in_play, 'score': score, 'word': full_word_hist,
                                        'drawn': drawn_tiles, 'coord': coord_hist, # Use corrected coord
                                        'word_with_blanks': word_with_blanks_hist, 'is_bingo': is_bingo
                                    })
                                    current_replay_turn = len(move_history); print(f"Player {turn} played: {full_word_hist} at {coord_hist} for {score} points")
                                    consecutive_zero_point_turns = 0; pass_count = 0; exchange_count = 0; human_played = True; turn = 3 - turn
                                    typing = False; typing_start = None; typing_direction = None; word_positions = []; original_tiles = None; original_rack = None; selected_square = None


                        elif event.key == pygame.K_BACKSPACE: # Backspace ...
                            if word_positions:
                                r_rem, c_rem, letter_rem = word_positions.pop(); tiles[r_rem][c_rem] = ''
                                if (r_rem, c_rem) in blanks: blanks.remove((r_rem, c_rem)); racks[turn-1].append(' ')
                                else: racks[turn-1].append(letter_rem)
                                current_r, current_c = r_rem, c_rem
                                if typing_direction == "right":
                                     while current_c > typing_start[1] and tiles[current_r][current_c-1]: current_c -=1
                                elif typing_direction == "down":
                                     while current_r > typing_start[0] and tiles[current_r-1][current_c]: current_r -=1
                            else: typing = False; selected_square = original_selected_square; original_tiles = None; original_rack = None
                        elif event.key == pygame.K_ESCAPE: # Cancel typing ...
                             if original_tiles and original_rack:
                                 for r_wp, c_wp, _ in word_positions: tiles[r_wp][c_wp] = original_tiles[r_wp][c_wp]
                                 racks[turn-1] = original_rack[:]; blanks_to_remove = set((r_wp, c_wp) for r_wp, c_wp, _ in word_positions if (r_wp, c_wp) in blanks); blanks.difference_update(blanks_to_remove)
                             typing = False; typing_start = None; typing_direction = None; word_positions = []; original_tiles = None; original_rack = None; selected_square = original_selected_square
                        elif event.unicode.isalpha(): # Typing subsequent letters
                            letter = event.unicode.upper()
                            if 0 <= current_r < GRID_SIZE and 0 <= current_c < GRID_SIZE and not tiles[current_r][current_c]:
                                placed = False
                                if letter in racks[turn-1]: tiles[current_r][current_c] = letter; racks[turn-1].remove(letter); word_positions.append((current_r, current_c, letter)); placed = True
                                elif ' ' in racks[turn-1]: tiles[current_r][current_c] = letter; racks[turn-1].remove(' '); blanks.add((current_r, current_c)); word_positions.append((current_r, current_c, letter)); placed = True
                                # Corrected Indentation Block 2
                                if placed:
                                    if typing_direction == "right":
                                        current_c += 1
                                        while current_c < GRID_SIZE and tiles[current_r][current_c]: current_c += 1
                                    elif typing_direction == "down": # Correctly aligned
                                        current_r += 1
                                        while current_r < GRID_SIZE and tiles[current_r][current_c]: current_r += 1 # Correctly indented
                                    # Correctly indented
                                    current_r = min(current_r, GRID_SIZE - 1)
                                    current_c = min(current_c, GRID_SIZE - 1)
                                # End Corrected Block 2
                            else: print("Cannot type here (occupied or off-board).")


        # --- Game Over Check ---
        if not replay_mode and not game_over_state and practice_mode != "eight_letter":
            game_ended = False; reason = ""
            if not bag and (len(racks) > 0 and not racks[0]) or (len(racks) > 1 and not racks[1]): # Check rack exists before checking length
                game_ended = True; reason = "Bag empty & rack empty"
            elif consecutive_zero_point_turns >= 6:
                game_ended = True; reason = "Six Consecutive Zero-Point Turns"
            if game_ended:
                print(f"Game over triggered: {reason}");
                final_scores = calculate_final_scores(scores, racks, bag)
                game_over_state = True; exchanging = False; hinting = False; showing_all_words = False; dropdown_open = False; dragging = False; typing = False; selected_square = None
                dialog_x = (WINDOW_WIDTH - DIALOG_WIDTH) // 2; dialog_y = (WINDOW_HEIGHT - DIALOG_HEIGHT) // 2

        # --- Drawing Logic ---
        screen.fill(WHITE)
        if replay_mode: # Determine state based on replay method
            if is_loaded_game and replay_initial_shuffled_bag is not None: tiles_to_display, blanks_to_display, scores_to_display, racks_to_display = simulate_game_up_to(current_replay_turn, move_history, replay_initial_shuffled_bag)
            elif not is_loaded_game: tiles_to_display, blanks_to_display, scores_to_display, racks_to_display = get_replay_state(current_replay_turn, initial_racks) # Assumes move_history has 'drawn'
            else: print("Replay Warning: Missing initial bag for loaded game simulation. Displaying initial state."); tiles_to_display, blanks_to_display, scores_to_display, racks_to_display = get_replay_state(0, initial_racks) # Fallback
            turn_to_display = 1 if current_replay_turn == 0 else (3 - move_history[current_replay_turn - 1]['player'])
        else: # Live game
            tiles_to_display, blanks_to_display, racks_to_display = tiles, blanks, racks; scores_to_display = final_scores if game_over_state else scores; turn_to_display = turn
        # Draw Board/Tiles ...
        for r in range(GRID_SIZE):
            for c in range(GRID_SIZE):
                pygame.draw.rect(screen, board[r][c], (40 + c * SQUARE_SIZE, 40 + r * SQUARE_SIZE, SQUARE_SIZE, SQUARE_SIZE)); pygame.draw.rect(screen, BLACK, (40 + c * SQUARE_SIZE, 40 + r * SQUARE_SIZE, SQUARE_SIZE, SQUARE_SIZE), 1)
                if tiles_to_display[r][c]:
                    tile_char = tiles_to_display[r][c]; is_blank_on_board = (r, c) in blanks_to_display
                    if is_blank_on_board: center = (40 + c * SQUARE_SIZE + SQUARE_SIZE // 2, 40 + r * SQUARE_SIZE + SQUARE_SIZE // 2); radius = SQUARE_SIZE // 2 - 3; pygame.draw.circle(screen, BLACK, center, radius); text_surf = font.render(tile_char, True, WHITE); text_rect = text_surf.get_rect(center=center); screen.blit(text_surf, text_rect)
                    else: tile_rect = pygame.Rect(40 + c * SQUARE_SIZE + 2, 40 + r * SQUARE_SIZE + 2, SQUARE_SIZE - 4, SQUARE_SIZE - 4); pygame.draw.rect(screen, GREEN, tile_rect); text_surf = font.render(tile_char, True, BLACK); text_rect = text_surf.get_rect(center=tile_rect.center); screen.blit(text_surf, text_rect)
        # Highlight last play in Replay ...
        if replay_mode and current_replay_turn > 0:
             last_move_data = move_history[current_replay_turn - 1]
             if last_move_data['move_type'] == 'place':
                 placed_coords_in_move = last_move_data.get('newly_placed')
                 if not placed_coords_in_move: # Fallback calculation
                     original_replay_tiles = [['' for _ in range(GRID_SIZE)] for _ in range(GRID_SIZE)];
                     try:
                         if is_loaded_game and replay_initial_shuffled_bag: original_replay_tiles,_,_,_ = simulate_game_up_to(current_replay_turn - 1, move_history, replay_initial_shuffled_bag)
                         elif not is_loaded_game: original_replay_tiles,_,_,_ = get_replay_state(current_replay_turn - 1, initial_racks)
                     except Exception as e: print(f"Error getting prev state for highlight: {e}")
                     placed_coords_in_move = [(p[0], p[1], p[2]) for p in last_move_data.get('positions', []) if 0<=p[0]<GRID_SIZE and 0<=p[1]<GRID_SIZE and not original_replay_tiles[p[0]][p[1]]]
                 for r, c, _ in placed_coords_in_move:
                      if 0 <= r < GRID_SIZE and 0 <= c < GRID_SIZE: pygame.draw.rect(screen, YELLOW, (40 + c * SQUARE_SIZE, 40 + r * SQUARE_SIZE, SQUARE_SIZE, SQUARE_SIZE), 3)
        # Draw Labels ...
        for r in range(GRID_SIZE): row_label = ui_font.render(str(r + 1), True, BLACK); screen.blit(row_label, (10, 40 + r * SQUARE_SIZE + (SQUARE_SIZE // 2 - row_label.get_height() // 2)))
        for c in range(GRID_SIZE): col_label = ui_font.render(LETTERS[c], True, BLACK); screen.blit(col_label, (40 + c * SQUARE_SIZE + (SQUARE_SIZE // 2 - col_label.get_width() // 2), 10))
        # Draw Racks ...
        p1_rack_to_draw = racks_to_display[0] if len(racks_to_display) > 0 else []; p1_drag_info = dragged_tile if dragged_tile and dragged_tile[0] == 1 else None
        p1_alpha_rect, p1_rand_rect = draw_rack(1, p1_rack_to_draw, scores_to_display, turn_to_display, player_names, p1_drag_info, drag_pos)
        p2_alpha_rect, p2_rand_rect = None, None
        if practice_mode != "eight_letter": p2_rack_to_draw = racks_to_display[1] if len(racks_to_display) > 1 else []; p2_drag_info = dragged_tile if dragged_tile and dragged_tile[0] == 2 else None; p2_alpha_rect, p2_rand_rect = draw_rack(2, p2_rack_to_draw, scores_to_display, turn_to_display, player_names, p2_drag_info, drag_pos)
        # Draw Remaining Tiles ...
        if practice_mode != "eight_letter":
            current_player_index = turn_to_display - 1
            if 0 <= current_player_index < len(racks_to_display): remaining = get_remaining_tiles(racks_to_display[current_player_index], tiles_to_display, blanks_to_display); draw_remaining_tiles(remaining, turn_to_display)
            else: draw_remaining_tiles({}, turn_to_display)
        # Draw UI Buttons ...
        options_rect, dropdown_rects = draw_options_menu(turn_to_display, dropdown_open, len(bag))
        suggest_rect = None; hint_rect = None
        if not replay_mode:
             suggest_rect = draw_suggest_button()
             if paused_for_power_tile and suggest_rect: hint_x = suggest_rect.x; hint_y = suggest_rect.y + suggest_rect.height + BUTTON_GAP; hint_rect = pygame.Rect(hint_x, hint_y, OPTIONS_WIDTH, OPTIONS_HEIGHT); hover = hint_rect.collidepoint(pygame.mouse.get_pos()); color = BUTTON_HOVER if hover else BUTTON_COLOR; pygame.draw.rect(screen, color, hint_rect); hint_text = button_font.render("Hint", True, BLACK); hint_text_rect = hint_text.get_rect(center=hint_rect.center); screen.blit(hint_text, hint_text_rect)
        # Draw Scoreboard ...
        history_to_draw = move_history[:current_replay_turn] if replay_mode else move_history; is_final_turn_in_replay = replay_mode and current_replay_turn == len(move_history)
        draw_scoreboard(screen, history_to_draw, scroll_offset, scores_to_display, is_ai, final_scores=final_scores, game_over_state=game_over_state or is_final_turn_in_replay)
        # Draw Typing Arrow / Cursor ...
        if selected_square and not typing: draw_arrow(selected_square[0], selected_square[1], selected_square[2])
        elif typing:
             if current_r is not None and current_c is not None: cursor_x = 40 + current_c * SQUARE_SIZE + SQUARE_SIZE // 2; cursor_y = 40 + current_r * SQUARE_SIZE + SQUARE_SIZE - 5;
             if int(time.time() * 2) % 2 == 0: pygame.draw.line(screen, BLACK, (cursor_x - 5, cursor_y), (cursor_x + 5, cursor_y), 2)
        # Draw Dialogs ...
        if exchanging: tile_rects, exchange_button_rect, cancel_button_rect = draw_exchange_dialog(racks[turn-1], selected_tiles)
        elif hinting: hint_rects, play_button_rect, ok_button_rect, all_words_button_rect = draw_hint_dialog(hint_moves, selected_hint_index)
        elif showing_all_words: moves_for_all = practice_target_moves if practice_mode == "eight_letter" else all_moves; all_words_rects, all_words_play_rect, all_words_ok_rect = draw_all_words_dialog(moves_for_all, selected_hint_index, scroll_offset)
        elif showing_practice_end_dialog: practice_play_again_rect, practice_main_menu_rect, practice_quit_rect = draw_practice_end_dialog(practice_end_message)
        # Draw Replay Controls ...
        if replay_mode:
            replay_controls = [(replay_start_rect, "start"), (replay_prev_rect, "prev"), (replay_next_rect, "next"), (replay_end_rect, "end")]
            for rect, icon_type in replay_controls: hover = rect.collidepoint(pygame.mouse.get_pos()); color = BUTTON_HOVER if hover else BUTTON_COLOR; pygame.draw.rect(screen, color, rect); draw_replay_icon(screen, rect, icon_type)
        # Draw Game Over / Stats Dialog ...
        if game_over_state:
            if final_scores is not None: save_rect, quit_rect, replay_rect, play_again_rect, stats_rect = draw_game_over_dialog(dialog_x, dialog_y, final_scores, reason, player_names)
            if showing_stats and final_scores: ok_button_rect = draw_stats_dialog(dialog_x + 20, dialog_y + 20, player_names, final_scores, tiles)
        # Draw dragged tile last ...
        if dragged_tile and drag_pos:
            player_idx_drag = dragged_tile[0]-1; rack_to_draw_temp = racks[player_idx_drag][:]; tile_val = None
            if 0 <= dragged_tile[1] < len(rack_to_draw_temp): tile_val = rack_to_draw_temp.pop(dragged_tile[1])
            if tile_val:
                tile_x_drag, tile_y_drag = drag_pos
                if tile_val == ' ': center = (tile_x_drag, tile_y_drag); radius = TILE_WIDTH // 2 - 2; pygame.draw.circle(screen, BLACK, center, radius); text = font.render('?', True, WHITE); text_rect = text.get_rect(center=center); screen.blit(text, text_rect)
                else: draw_x = tile_x_drag - drag_offset[0]; draw_y = tile_y_drag - drag_offset[1]; pygame.draw.rect(screen, GREEN, (draw_x, draw_y, TILE_WIDTH, TILE_HEIGHT)); text = font.render(tile_val, True, BLACK); screen.blit(text, (draw_x + 5, draw_y + 5))

        pygame.display.flip() # Update the full display

    # --- End of Main Game Loop ---
    print("--- main(): Exited main game loop. ---")
    if return_to_mode_selection:
        print("--- main(): Returning to mode selection... ---")
        main_called = False # Reset flag to allow re-entry into mode selection
        main() # Call main again to restart the process
    else:
        print("--- main(): Quitting pygame and exiting. ---")
        pygame.quit(); sys.exit()

# --- Program Entry Point ---
if __name__ == "__main__":
    print("--- Script execution started (__name__ == '__main__') ---")
    main_called = False # Ensure flag is reset before first call
    main()
